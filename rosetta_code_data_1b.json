[
    {
        "task_name": "100-doors",
        "task_description": "There are 100 doors in a row that are all initially closed. \n\nYou make 100 [[task feature::Rosetta Code:multiple passes|passes]] by the doors. \n\nThe first time through, visit every door and &nbsp;''toggle''&nbsp; the door &nbsp;(if the door is closed, &nbsp;open it; &nbsp; if it is open,&nbsp; close it). \n\nThe second time, only visit every 2<sup>nd</sup> door &nbsp; (door #2, #4, #6, ...), &nbsp; and toggle it.  \n\nThe third time, visit every 3<sup>rd</sup> door &nbsp; (door #3, #6, #9, ...), etc, &nbsp; until you only visit the 100<sup>th</sup> door.\n\n\n;Task:\nAnswer the question: &nbsp; what state are the doors in after the last pass? &nbsp; Which are open, which are closed?\n\n\n'''[[task feature::Rosetta Code:extra credit|Alternate]]:'''  \nAs noted in this page's &nbsp; [[Talk:100 doors|discussion page]], &nbsp; the only doors that remain open are those whose numbers are perfect squares.\n\nOpening only those doors is an &nbsp; [[task feature::Rosetta Code:optimization|optimization]] &nbsp; that may also be expressed; \nhowever, as should be obvious, this defeats the intent of comparing implementations across programming languages.\n<br><br>\n\n",
        "solution_pairs": [
            [
                {
                    "language": "Raku",
                    "solution": "say 'Door $_ is open' for (1..10)\u00bb\u00b2;\n"
                },
                {
                    "language": "Groovy",
                    "solution": "doors = ['closed'] * 100\n(1..10).each { doors[it**2 - 1] = 'open' }\n(0..99).each {\n   println(\"Door #${it + 1} is ${doors[it]}.\")\n}\n"
                }
            ],
            [
                {
                    "language": "Groovy",
                    "solution": "(1..100).each {\n   println(\"Door #${it} is ${Math.sqrt(it).with{it==(int)it} ? 'open' : 'closed'}.\")\n}\n"
                },
                {
                    "language": "Yabasic",
                    "solution": "n = 100\t// doors\nppa = 1\t// next open door\np2 = 1\n\nfor i = 1 to n\n\tprint \"Door \", i, \" is \";\n\tif i < p2 then\n\t\tprint \"closed.\"\n\telse\n\t\tppa = ppa + 1\n\t\tp2 = ppa^2\n\t\tprint \"OPEN.\"\n\tend if\nnext\n"
                }
            ],
            [
                {
                    "language": "Plain-English",
                    "solution": "To create some doors given a count:\nLoop.\nIf a counter is past the count, exit.\nAllocate memory for a door.\nClear the door's flag.\nAppend the door to the doors.\nRepeat.\n\nA door is a flag thing.\n\nTo go through some doors given a number and some passes:\nPut 0 into a counter.\nLoop.\nAdd the number to the counter.\nIf the counter is greater than the passes, exit.\nPick a door from the doors given the number.\nInvert the door's flag.\nRepeat.\n\nTo output the states of some doors:\nLoop.\nBump a counter.\nGet a door from the doors.\nIf the door is nil, exit.\nIf the door's flag is set, write \"Door \" then the counter then \" is open\" to the output; repeat.\nWrite \"Door \" then the counter then \" is closed\" to the output.\nRepeat.\n\nTo pass doors given a count and some passes:\nCreate some doors given the count.\nLoop.\nIf a counter is past the passes, break.\nGo through the doors given the counter and the passes.\nRepeat.\nOutput the states of the doors.\nDestroy the doors.\n\nA pass is a number.\n\nTo pick a door from some doors given a number:\nLoop.\nIf a counter is past the number, exit.\nGet the door from the doors.\nIf the door is nil, exit.\nRepeat.\n\nTo run:\nStart up.\nPass doors given 100 and 100 passes.\nWait for the escape key.\nShut down.\n"
                },
                {
                    "language": "ACL2",
                    "solution": "(defun rep (n x)\n   (if (zp n)\n       nil\n       (cons x\n             (rep (- n 1) x))))\n\n(defun toggle-every-r (n i bs)\n   (if (endp bs)\n       nil\n       (cons (if (zp i)\n                 (not (first bs))\n                 (first bs))\n             (toggle-every-r n (mod (1- i) n) (rest bs)))))\n\n(defun toggle-every (n bs)\n   (toggle-every-r n (1- n) bs))\n\n(defun 100-doors (i doors)\n   (if (zp i)\n       doors\n       (100-doors (1- i) (toggle-every i doors))))\n"
                }
            ],
            [
                {
                    "language": "Eiffel",
                    "solution": "note\n\tdescription: \"100 Doors problem\"\n\tdate: \"08-JUL-2015\"\n\trevision: \"1.1\"\n\nclass\n\tAPPLICATION\n\ncreate\n\tmake\n\nfeature {NONE} -- Initialization\n\n\tmake\n\t\t\t-- Main application routine.\n\t\tdo\n\t\t\tinitialize_closed_doors\n\t\t\ttoggle_doors\n\t\t\toutput_door_states\n\t\tend\n\nfeature -- Access\n\n\tdoors: ARRAYED_LIST [DOOR]\n\t\t\t-- A set of doors (self-initialized to capacity of `max_door_count').\n\t\tattribute\n\t\t\tcreate Result.make (max_door_count)\n\t\tend\n\nfeature -- Basic Operations\n\n\tinitialize_closed_doors\n\t\t\t-- Initialize all `doors'.\n\t\tdo\n\t\t\tacross min_door_count |..| max_door_count as ic_address_list loop\n\t\t\t\tdoors.extend (create {DOOR}.make_closed (ic_address_list.item))\n\t\t\tend\n\t\tensure\n\t\t\thas_all_closed_doors: across doors as ic_doors_list all not ic_doors_list.item.is_open end\n\t\tend\n\n\ttoggle_doors\n\t\t\t-- Toggle all `doors'.\n\t\tdo\n\t\t\tacross min_door_count |..| max_door_count as ic_addresses_list loop\n\t\t\t\tacross doors as ic_doors_list loop\n\t\t\t\t\tif is_door_to_toggle (ic_doors_list.item.address, ic_addresses_list.item) then\n\t\t\t\t\t\tic_doors_list.item.toggle_door\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\n\toutput_door_states\n\t\t\t-- Output the state of all `doors'.\n\t\tdo\n\t\t\tdoors.do_all (agent door_state_out)\n\t\tend\n\nfeature -- Status Report\n\n\tis_door_to_toggle (a_door_address, a_index_address: like {DOOR}.address): BOOLEAN\n\t\t\t-- Is the door at `a_door_address' needing to be toggled, when compared to `a_index_address'?\n\t\tdo\n\t\t\tResult := a_door_address \\\\ a_index_address = 0\n\t\tensure\n\t\t\tonly_modulus_zero: Result = (a_door_address \\\\ a_index_address = 0)\n\t\tend\n\nfeature -- Outputs\n\n\tdoor_state_out (a_door: DOOR)\n\t\t\t-- Output the state of `a_door'.\n\t\tdo\n\t\t\tprint (\"Door \" + a_door.address.out + \" is \")\n\t\t\tif a_door.is_open then\n\t\t\t\tprint (\"open.\")\n\t\t\telse\n\t\t\t\tprint (\"closed.\")\n\t\t\tend\n\t\t\tio.new_line\n\t\tend\n\nfeature {DOOR} -- Constants\n\n\tmin_door_count: INTEGER = 1\n\t\t\t-- Minimum number of doors.\n\n\tmax_door_count: INTEGER = 100\n\t\t\t-- Maximum number of doors.\n\nend\n"
                },
                {
                    "language": "TXR",
                    "solution": "(defun hyaku-mai-tobira ()\n  (let ((doors (vector 100)))\n    (each ((i (range 0 99)))\n      (each ((j (range i 99 (+ i 1))))\n        (flip [doors j])))\n    doors))\n\n(each ((counter (range 1))\n       (door (hyaku-mai-tobira)))\n  (put-line `door @counter is @(if door \"open\" \"closed\")`))\n"
                }
            ],
            [
                {
                    "language": "Lily",
                    "solution": "var doors = List.fill(100, false)\n\nfor i in 0...99:\n    for j in i...99 by i + 1:\n        doors[j] = !doors[j]\n\n# The type must be specified since the list starts off empty.\nvar open_doors: List[Integer] = []\n\ndoors.each_index{|i|\n    if doors[i]:\n        open_doors.push(i + 1)\n}\n\nprint($\"Open doors: ^(open_doors)\")\n"
                },
                {
                    "language": "Swift",
                    "solution": "/* declare enum to identify the state of a door */\nenum DoorState : String {\n    case Opened = \"Opened\"\n    case Closed = \"Closed\"\n}\n\n/* declare list of doors state and initialize them */\nvar doorsStateList = [DoorState](count: 100, repeatedValue: DoorState.Closed)\n\n/* do the 100 passes */\nfor i in 1...100 {\n    /* map on a strideTo instance to only visit the needed doors on each iteration */\n    map(stride(from: i - 1, to: 100, by: i)) {\n        doorsStateList[$0] = doorsStateList[$0] == .Opened ? .Closed : .Opened\n    }\n}\n\n/* print the results */\nfor (index, item) in enumerate(doorsStateList) {\n    println(\"Door \\(index+1) is \\(item.rawValue)\")\n}\n"
                }
            ]
        ]
    },
    {
        "task_name": "100-prisoners",
        "task_description": ";The Problem:\n* 100 prisoners are individually numbered 1 to 100\n* A room having a cupboard of 100 opaque drawers numbered 1 to 100, that cannot be seen from outside.\n* Cards numbered 1 to 100 are placed randomly, one to a drawer, and the drawers all closed; at the start.\n* Prisoners start outside the room\n:* They can decide some strategy before any enter the room.\n:* Prisoners enter the room one by one, can open a drawer, inspect the card number in the drawer, then close the drawer.\n:* A prisoner can open no more than 50 drawers.\n:* A prisoner tries to find his own number.\n:* A prisoner finding his own number is then held apart from the others.\n* If '''all''' 100 prisoners find their own numbers then they will all be pardoned. If ''any'' don't then ''all'' sentences stand. \n\n\n;The task:\n# Simulate several thousand instances of the game where the prisoners randomly open drawers\n# Simulate several thousand instances of the game where the prisoners use the optimal strategy mentioned in the Wikipedia article, of:\n:* First opening the drawer whose outside number is his prisoner number.\n:* If the card within has his number then he succeeds otherwise he opens the drawer with the same number as that of the revealed card. (until he opens his maximum).\n\n\nShow and compare the computed probabilities of success for the two strategies, here, on this page.<br>\n\n\n;References:\n# [https://www.youtube.com/watch?v=a1DUUnhk3uE The unbelievable solution to the 100 prisoner puzzle] standupmaths (Video).\n# [[wp:100 prisoners problem]]\n# [http://datagenetics.com/blog/december42014/index.html 100 Prisoners Escape Puzzle] DataGenetics.\n# [https://en.wikipedia.org/wiki/Random_permutation_statistics#One_hundred_prisoners Random permutation statistics#One hundred prisoners] on Wikipedia.\n<br><br>\n",
        "solution_pairs": [
            [
                {
                    "language": "Rust",
                    "solution": "[dependencies]\nrand = '0.7.2'\n"
                },
                {
                    "language": "Wren",
                    "solution": "import \"random\" for Random\nimport \"./fmt\" for Fmt\n\nvar rand = Random.new()\n\nvar doTrials = Fn.new{ |trials, np, strategy|\n    var pardoned = 0\n    for (t in 0...trials) {\n        var drawers = List.filled(100, 0)\n        for (i in 0..99) drawers[i] = i\n        rand.shuffle(drawers)\n        var nextTrial = false\n        for (p in 0...np) {\n            var nextPrisoner = false\n            if (strategy == \"optimal\") {\n                var prev = p\n                for (d in 0..49) {\n                    var curr = drawers[prev]\n                    if (curr == p) {\n                        nextPrisoner = true\n                        break\n                    }\n                    prev = curr\n                }\n            } else {\n                var opened = List.filled(100, false)\n                for (d in 0..49) {\n                    var n\n                    while (true) {\n                        n = rand.int(100)\n                        if (!opened[n]) {\n                            opened[n] = true\n                            break\n                        }\n                    }\n                    if (drawers[n] == p) {\n                        nextPrisoner = true\n                        break\n                    }\n                }\n            }\n            if (!nextPrisoner) {\n                nextTrial = true\n                break\n            }\n        }\n        if (!nextTrial) pardoned = pardoned + 1\n    }\n    var rf = pardoned/trials * 100\n    Fmt.print(\"  strategy = $-7s  pardoned = $,6d relative frequency = $5.2f\\%\\n\", strategy, pardoned, rf)\n}\n\nvar trials = 1e5\nfor (np in [10, 100]) {\n    Fmt.print(\"Results from $,d trials with $d prisoners:\\n\", trials, np)\n    for (strategy in [\"random\", \"optimal\"]) doTrials.call(trials, np, strategy)\n}\n"
                }
            ],
            [
                {
                    "language": "J",
                    "solution": "NB. game is solvable by optimal strategy when the length (#) of the\nNB. longest (>./) cycle (C.) is at most 50.\nopt=: 50 >: [: >./ [: > [: #&.> C.\n\nNB. for each prisoner randomly open 50 boxes ((50?100){y) and see if\nNB. the right card is there (p&e.). if not return 0.\nrand=: monad define\nfor_p. i.100 do. if. -.p e.(50?100){y do. 0 return. end.\nend. 1\n)\n\nNB. use both strategies on the same shuffles y times.\nsimulate=: monad define\n'o r'=. y %~ 100 * +/ ((rand,opt)@?~)\"0 y # 100\n('strategy';'win rate'),('random';(\":o),'%'),:'optimal';(\":r),'%'\n)\n"
                },
                {
                    "language": "Gambas",
                    "solution": "' Gambas module file\n\nPublic DrawerArray As Long[]\nPublic NumberFromDrawer As Long\nPublic FoundOwnNumber As Long\n\nPublic Sub Main()\n\n  Dim NumberOfPrisoners As Long\n  Dim Selections As Long\n  Dim Tries As Long\n\n  Print \"Number of prisoners (default, 100)?\"\n  Try Input NumberOfPrisoners\n  If Error Then NumberOfPrisoners = 100\n\n  Print \"Number of selections (default, half of prisoners)?\"\n  Try Input Selections\n  If Error Then Selections = NumberOfPrisoners / 2\n\n  Print \"Number of tries (default, 1000)?\"\n  Try Input Tries\n  If Error Then Tries = 1000\n\n  Dim AllFoundOptimal As Long = 0\n  Dim AllFoundRandom As Long = 0\n  Dim AllFoundRandomMem As Long = 0\n\n  Dim i As Long\n  Dim OptimalCount As Long\n  Dim RandomCount As Long\n  Dim RandomMenCount As Long\n\n  Dim fStart As Float = Timer\n\n  For i = 1 To Tries\n    OptimalCount = HundredPrisoners_Optimal(NumberOfPrisoners, Selections)\n    RandomCount = HundredPrisoners_Random(NumberOfPrisoners, Selections)\n    RandomMenCount = HundredPrisoners_Random_Mem(NumberOfPrisoners, Selections)\n\n    If OptimalCount = NumberOfPrisoners Then AllFoundOptimal += 1\n    If RandomCount = NumberOfPrisoners Then AllFoundRandom += 1\n    If RandomMenCount = NumberOfPrisoners Then AllFoundRandomMem += 1\n  Next\n\n  Dim fTime As Float = Timer - fStart\n  fTime = Round(ftime, -1)\n\n  Print\n  Print \"Result with \" & NumberOfPrisoners & \" prisoners, \" & Selections & \" selections and \" & Tries & \" tries. \"\n  Print\n  Print \"Optimal: \" & AllFoundOptimal & \" of \" & Tries & \": \" & Str(AllFoundOptimal / Tries * 100) & \" %\"\n  Print \"Random: \" & AllFoundRandom & \" of \" & Tries & \": \" & Str(AllFoundRandom / Tries * 100) & \" %\"\n  Print \"RandomMem: \" & AllFoundRandomMem & \" of \" & Tries & \": \" & Str(AllFoundRandomMem / Tries * 100) & \" %\"\n  Print\n  Print \"Elapsed Time: \" & fTime & \" sec\"\n  Print\n  Print \"Trials/sec: \" & Round(Tries / fTime, -1)\n\nEnd\n\nFunction HundredPrisoners_Optimal(NrPrisoners As Long, NrSelections As Long) As Long\n\n  DrawerArray = New Long[NrPrisoners]\n  Dim Counter As Long\n\n  For Counter = 0 To DrawerArray.Max\n    DrawerArray[Counter] = Counter + 1\n  Next\n\n  DrawerArray.Shuffle()\n\n  Dim i As Long\n  Dim j As Long\n  FoundOwnNumber = 0\n\n  For i = 1 To NrPrisoners\n    For j = 1 To NrSelections\n      If j = 1 Then NumberFromDrawer = DrawerArray[i - 1]\n\n      If NumberFromDrawer = i Then\n        FoundOwnNumber += 1\n        Break\n      Endif\n      NumberFromDrawer = DrawerArray[NumberFromDrawer - 1]\n    Next\n  Next\n  Return FoundOwnNumber\n\nEnd\n\nFunction HundredPrisoners_Random(NrPrisoners As Long, NrSelections As Long) As Long\n\n  Dim RandomDrawer As Long\n  Dim Counter As Long\n\n  DrawerArray = New Long[NrPrisoners]\n\n  For Counter = 0 To DrawerArray.Max\n    DrawerArray[Counter] = Counter + 1\n  Next\n\n  DrawerArray.Shuffle()\n\n  Dim i As Long\n  Dim j As Long\n  FoundOwnNumber = 0\n\n  Randomize\n\n  For i = 1 To NrPrisoners\n    For j = 1 To NrSelections\n      RandomDrawer = CLong(Rand(NrPrisoners - 1))\n      NumberFromDrawer = DrawerArray[RandomDrawer]\n      If NumberFromDrawer = i Then\n        FoundOwnNumber += 1\n        Break\n      Endif\n    Next\n  Next\n  Return FoundOwnNumber\n\nEnd\n\nFunction HundredPrisoners_Random_Mem(NrPrisoners As Long, NrSelections As Long) As Long\n\n  Dim SelectionArray As New Long[NrPrisoners]\n  Dim Counter As Long\n\n  DrawerArray = New Long[NrPrisoners]\n\n  For Counter = 0 To DrawerArray.Max\n    DrawerArray[Counter] = Counter + 1\n\n  Next\n\n  For Counter = 0 To SelectionArray.Max\n    SelectionArray[Counter] = Counter + 1\n\n  Next\n\n  DrawerArray.Shuffle()\n\n  Dim i As Long\n  Dim j As Long\n  FoundOwnNumber = 0\n\n  For i = 1 To NrPrisoners\n    SelectionArray.Shuffle()\n    For j = 1 To NrSelections\n      NumberFromDrawer = DrawerArray[SelectionArray[j - 1] - 1]\n      If NumberFromDrawer = i Then\n        FoundOwnNumber += 1\n        Break\n      Endif\n      NumberFromDrawer = DrawerArray[NumberFromDrawer - 1]\n    Next\n  Next\n  Return FoundOwnNumber\n\nEnd\n"
                }
            ],
            [
                {
                    "language": "Yabasic",
                    "solution": "// Rosetta Code problem: http://rosettacode.org/wiki/100_prisoners\n// by Galileo, 05/2022\n\nsub play(prisoners, iterations, optimal)\n    local prisoner, pardoned, found, drawer, drawers(prisoners), i, j, k, p, x\n\n    for i = 1 to prisoners : drawers(i) = i : next\n\n    for i = 1 to iterations\n        for k = 1 to prisoners : x = ran(prisoners) + 1 : p = drawers(x) : drawers(x) = drawers(k) : drawers(k) = p : next\n        for prisoner = 1 to prisoners\n            found = false\n            if optimal then drawer = prisoner else drawer = ran(prisoners) + 1 end if\n            for j = 1 to prisoners / 2\n                drawer = drawers(drawer)\n                if drawer = prisoner found = true : break\n                if not optimal drawer = ran(prisoners) + 1\n            next\n            if not found break\n        next\n        pardoned = pardoned + found\n    next\n\n    return 100 * pardoned / iterations\nend sub\n\niterations = 10000\nprint \"Simulation count: \", iterations\nfor prisoners = 10 to 100 step 90\n    random = play(prisoners, iterations, false)\n    optimal = play(prisoners, iterations, true)\n    print \"Prisoners: \", prisoners, \", random: \", random, \", optimal: \", optimal\nnext\n"
                },
                {
                    "language": "Red",
                    "solution": "Red []\n\nK_runs: 100000\nrepeat n 100 [append rand_arr: []  n]              ;; define array/series with numbers 1..100\n\n;;-------------------------------\nstrat_optimal: function [pris ][\n;;-------------------------------\n  locker: pris                                    ;; start with locker equal to prisoner number\n  loop 50 [\n    if Board/:locker = pris [ return true ]       ;; locker with prisoner number found\n    locker: Board/:locker\n  ]\n  false                                           ;; number not found - fail\n]\n;;-------------------------------\nstrat_rand: function [pris ][\n;;-------------------------------\n  random rand_arr                                                 ;; define set of  random lockers\n  repeat n 50 [ if Board/(rand_arr/:n) = pris [ return true ]  ]  ;; try first 50, found ? then return success\n  false\n]\n\n;;------------------------------\ncheck_board: function [ strat][\n;;------------------------------\nrepeat pris 100 [                                                   ;; for each prisoner\n  either  strat = 'optimal [ unless strat_optimal pris [return false ]  ]\n                            [ unless strat_rand pris [return false ]  ]\n]\n  true                                                  ;; all 100 prisoners passed test\n]\n\nsaved: saved_rand: 0                                    ;; count all saved runs per strategy\nloop K_runs [\n  Board: random copy rand_arr                           ;; new board for every run\n  if  check_board 'optimal [saved: saved + 1]           ;; optimal stategy\n  if  check_board 'rand [saved_rand: saved_rand + 1]  ;; random strategy\n]\n\nprint [\"runs\" k_runs newline  \"Percent saved opt.strategy:\" saved * 100.0 / k_runs ]\nprint [\"Percent saved random strategy:\" saved_rand * 100.0 / k_runs ]\n"
                }
            ],
            [
                {
                    "language": "Maple",
                    "solution": "a:=[seq(max(GroupTheory[PermCycleType](Perm(Statistics[Shuffle]([$1..100])))),i=1..100000)]:\nnops(select(n->n<=50,a))/nops(a);\nevalf(%);\n# 31239/100000\n# 0.3123900000\n"
                },
                {
                    "language": "BCPL",
                    "solution": "get \"libhdr\"\n\nmanifest $(\n    seed = 12345   // for pseudorandom number generator\n    size = 100     // amount of drawers and prisoners\n    tries = 50     // amount of tries each prisoner may make\n    simul = 2000   // amount of simulations to run\n$)\n\nlet randto(n) = valof\n$(  static $( state = seed $)\n    let mask = 1\n    mask := (mask<<1)|1 repeatuntil mask > n\n    state := random(state) repeatuntil ((state >> 8) & mask) < n\n    resultis (state >> 8) & mask\n$)\n\n// initialize drawers\nlet placeCards(d, n) be\n$(  for i=0 to n-1 do d!i := i;\n    for i=0 to n-2 do\n    $(  let j = i+randto(n-i)\n        let k = d!i\n        d!i := d!j\n        d!j := k\n    $)\n$)\n\n// random strategy (prisoner 'p' tries to find his own number)\nlet randoms(d, p, t) = valof\n$(  for n = 1 to t do\n        if d!randto(size) = p then resultis true\n    resultis false\n$)\n\n// optimal strategy\nlet optimal(d, p, t) = valof\n$(  let last = p\n    for n = 1 to t do\n        test d!last = p\n            then resultis true\n            else last := d!last\n    resultis false\n$)\n\n// run a simulation given a strategy\nlet simulate(d, strat, n, t) = valof\n$(  placeCards(d, n)\n    for p = 0 to n-1 do\n        if not strat(d, p, t) then resultis false\n    resultis true\n$)\n\n// run many simulations and count the successes\nlet runSimulations(d, strat, n, amt, t) = valof\n$(  let succ = 0\n    for i = 1 to amt do\n        if simulate(d, strat, n, t) do\n            succ := succ + 1\n    resultis succ\n$)\n\nlet run(d, name, strat, n, amt, t) be\n$(  let s = runSimulations(d, strat, n, amt, t);\n    writef(\"%S: %I5 of %I5, %N percent.*N\", name, s, amt, s*10/(amt/10))\n$)\n\nlet start() be\n$(  let d = vec size-1\n    run(d, \" Random\", randoms, size, simul, tries)\n    run(d, \"Optimal\", optimal, size, simul, tries)\n$)\n"
                }
            ],
            [
                {
                    "language": "Arturo",
                    "solution": "unplanned: function [][\n    drawers: shuffle @1..100\n    every? 1..100 'x -> some? 1..50 => [x = sample drawers]\n]\n\nplanned: function [][\n    drawers: shuffle @1..100\n    every? 1..100 'x [\n        next: x\n        some? 1..50 => [x = next: <= drawers\\[next-1]]\n    ]\n]\n\ntest: function [f][\n    count: enumerate 10000 => [call f []]\n    print [f ~\"|mul fdiv count 10000 100|%\"]\n]\n\ntest 'unplanned\ntest 'planned\n"
                },
                {
                    "language": "Maple",
                    "solution": "p:=simplify(1-product(1-1/(2*n-k),k=0..n-1));\n# p=1/2\n"
                }
            ]
        ]
    },
    {
        "task_name": "15-puzzle-game",
        "task_description": ";Task:\nImplement the [[wp:15_puzzle|Fifteen Puzzle Game]].\n\n\nThe &nbsp; '''15-puzzle''' &nbsp; is also known as: \n:::* &nbsp; '''Fifteen Puzzle'''\n:::* &nbsp; '''Gem Puzzle'''\n:::* &nbsp; '''Boss Puzzle'''\n:::* &nbsp; '''Game of Fifteen'''\n:::* &nbsp; '''Mystic Square'''\n:::* &nbsp; '''14-15 Puzzle'''\n:::* &nbsp; and some others.\n\n\n;Related Tasks:\n:* &nbsp; [[15_puzzle_solver|15 Puzzle Solver]]\n:* &nbsp; [[16 Puzzle Game]]\n<br><br>\n\n",
        "solution_pairs": [
            [
                {
                    "language": "Standard-ML",
                    "solution": "(* Load required Modules for Moscow ML *)\nload \"Int\";\nload \"Random\";\n\n\n(* Mutable Matrix *)\nsignature MATRIX =\nsig\n\ttype 'a matrix\n\tval construct : 'a -> int * int -> 'a matrix\n\tval size : 'a matrix -> int * int\n\tval get : 'a matrix -> int * int -> 'a\n\tval set : 'a matrix -> int * int -> 'a -> unit\nend\n\nstructure Matrix :> MATRIX =\nstruct\n\t(* Array of rows, where the rows are a array of 'a *)\n\ttype 'a matrix = 'a Array.array Array.array\n\n\tfun 'a construct (a : 'a) (width, height) : 'a matrix =\n\t\tif width < 1 orelse height < 1\n\t\t\tthen raise Subscript\n\t\t\telse Array.tabulate (height, fn _ => Array.tabulate (width, fn _ => a))\n\t\n\tfun size b =\n\t\tlet\n\t\t\tval firstrow = Array.sub (b, 0)\n\t\tin\n\t\t\t(Array.length firstrow, Array.length b)\n\t\tend\n\n\t\n\tfun get b (x, y) = Array.sub (Array.sub (b, y), x)\n\n\tfun set b (x, y) v = Array.update (Array.sub (b, y), x, v)\nend\n\nsignature P15BOARD =\nsig\n\ttype board\n\tdatatype direction = North | East | South | West\n\n\tval construct : int * int -> board\n\tval emptyField : board -> int * int\n\tval get : board -> int * int -> int option\n\tval size : board -> int * int\n\n\texception IllegalMove\n\tval moves : board -> int list\n\tval move : board -> int -> unit\n\n\tval issolved : board -> bool\nend\n\n(* Game Logic and data *)\n\nstructure Board :> P15BOARD =\nstruct\n\t(* Matrix + empty Field position *)\n\ttype board = int option Matrix.matrix * (int * int) ref\n\t\n\tdatatype direction = North | East | South | West\n\n\texception IllegalMove\n\n\tfun numberat width (x, y) = (y*width + x + 1)\n\n\tfun construct (width, height) =\n\t\tlet\n\t\t\tval emptyBoard : int option Matrix.matrix = Matrix.construct NONE (width, height)\n\t\tin\n\t\t\t(* Fill the board with numbers *)\n\t\t\tList.tabulate (height, fn y => List.tabulate (width, fn x =>\n\t\t\t\t\tMatrix.set emptyBoard (x, y) (SOME (numberat width (x, y)))));\n\t\t\t(* Clear the last field *)\n\t\t\tMatrix.set emptyBoard (width-1, height-1) NONE;\n\t\t\t(* Return the board *)\n\t\t\t(emptyBoard, ref (width-1, height-1))\n\t\tend\n\n\tfun emptyField (_, rfield) = !rfield\n\n\tfun get (mat, _) (x, y) = Matrix.get mat (x, y)\n\n\tfun size (mat, _) = Matrix.size mat\n\n\t(* toggle the empty field with a given field *)\n\tfun toggle (mat, rpos) pos =\n\t\tlet\n\t\t\tval pos' = !rpos\n\t\t\tval value = Matrix.get mat pos\n\t\tin\n\t\t\tMatrix.set mat pos NONE;\n\t\t\tMatrix.set mat pos' value;\n\t\t\trpos := pos\n\t\tend\n\n\t(* Get list of positions of the neighbors of a given field *)\n\tfun neighbors mat (x, y) : (int * int) list =\n\t\tlet\n\t\t\tval (width, height) = Matrix.size mat\n\t\t\tval directions = [(x, y-1), (x+1, y), (x, y+1), (x-1, y)]\n\t\tin\n\t\t\tList.mapPartial (fn pos => SOME (Matrix.get mat pos; pos) handle Subscript => NONE) directions\n\t\tend\n\t\n\tfun moves (mat, rpos) =\n\t\tlet\n\t\t\tval neighbors = neighbors mat (!rpos)\n\t\tin\n\t\t\tmap (fn pos => valOf (Matrix.get mat pos)) neighbors\n\t\tend\n\t\t\n\tfun move (mat, rpos) m =\n\t\tlet\n\t\t\tval (hx, hy) = !rpos\n\t\t\tval neighbors = neighbors mat (hx, hy)\n\t\t\tval optNeighbor = List.find (fn pos => SOME m = Matrix.get mat pos) neighbors\n\t\tin\n\t\t\tif isSome optNeighbor\n\t\t\tthen\n\t\t\t\ttoggle (mat, rpos) (valOf optNeighbor)\n\t\t\telse\n\t\t\t\traise IllegalMove\n\t\tend\n\n\tfun issolved board =\n\t\tlet\n\t\t\tval (width, height) = size board\n\t\t\tval xs = List.tabulate (width,  fn x => x)\n\t\t\tval ys = List.tabulate (height, fn y => y)\n\t\tin\n\t\t\tList.all (fn x => List.all (fn y => (x + 1 = width andalso y + 1 = height) orelse get board (x, y) = SOME (numberat width (x,y))) ys) xs\n\t\tend\nend\n\n(* Board Shuffle *)\nsignature BOARDSHUFFLE =\nsig\n\tval shuffle : Board.board -> int -> unit\nend\n\nstructure Shuffle :> BOARDSHUFFLE =\nstruct\n\t(*\n\t * Note: Random Number Interfaces are different in SML/NJ and Moscow ML. Comment out the corresponding version:\n\t *)\n\n\t(*\n\t(* SML/NJ - Version *)\n\tval time = Time.now ()\n\tval timeInf = Time.toMicroseconds time\n\tval timens = Int.fromLarge (LargeInt.mod (timeInf, 1073741823));\n\tval rand = Random.rand (timens, timens)\n\n\tfun next n = Random.randRange (0, n) rand\n\t*)\n\n\t(* Moscow ML - Version *)\n\tval generator = Random.newgen ()\n\tfun next n = Random.range (0, n) generator\n\n\n\tfun shuffle board 0 = if (Board.issolved board) then shuffle board 1 else ()\n\t  | shuffle board n =\n\t  \tlet\n\t\t\tval moves = Board.moves board\n\t\t\tval move  = List.nth (moves, next (List.length moves - 1))\n\t\tin\n\t\t\tBoard.move board move;\n\t\t\tshuffle board (n-1)\n\t\tend\nend\n\n\n(* Console interface *)\n\nsignature CONSOLEINTERFACE =\nsig\n\tval start : unit -> unit\n\tval printBoard : Board.board -> unit\nend\n\nstructure Console :> CONSOLEINTERFACE =\nstruct\n\tfun cls () = print \"\\^[[1;1H\\^[[2J\"\n\n\tfun promptNumber prompt =\n\t\tlet\n\t\t\tval () = print prompt\n\t\t\t(* Input + \"\\n\" *)\n\t\t\tval line   = valOf (TextIO.inputLine TextIO.stdIn)\n\t\t\tval length = String.size line\n\t\t\tval input  = String.substring (line, 0, length - 1)\n\t\t\tval optnum = Int.fromString input\n\t\tin\n\t\t\tif isSome optnum\n\t\t\t\tthen valOf optnum\n\t\t\t\telse (print \"Input is not a number.\\n\"; promptNumber prompt)\n\t\tend\n\n\tfun fieldToString (SOME x) = Int.toString x\n\t  | fieldToString (NONE  ) = \"\"\n\n\tfun boardToString board =\n\t\tlet\n\t\t\tval (width, height) = Board.size board\n\t\t\tval xs = List.tabulate (width,  fn x => x)\n\t\t\tval ys = List.tabulate (height, fn y => y)\n\t\tin\n\t\t\tfoldl (fn (y, str) => (foldl (fn (x, str') => str' ^ (fieldToString (Board.get board (x, y))) ^ \"\\t\") str xs) ^ \"\\n\") \"\" ys\n\t\tend\n\t\n\tfun printBoard board = print (boardToString board)\n\n\n\tfun loop board =\n\t\tlet\n\t\t\tval rvalidInput = ref false\n\t\t\tval rinput      = ref 42\n\t\t\tval () = cls ()\n\t\t\tval () = printBoard board\n\t\tin\n\t\t\t(* Ask for a move and repeat until it is a valid move *)\n\t\t\twhile (not (!rvalidInput)) do\n\t\t\t\t(\n\t\t\t\t\trinput := promptNumber \"Input the number to move: \";\n\t\t\t\t\tBoard.move board (!rinput);\n\t\t\t\t\trvalidInput := true\n\t\t\t\t) handle Board.IllegalMove => print \"Illegal move!\\n\"\n\t\tend\n\n\t\n\tfun start () =\n\t\tlet\n\t\t\tval () = cls ()\n\t\t\tval () = print \"Welcome to nxm-Puzzle!\\n\"\n\t\t\tval (width, height) = (promptNumber \"Enter the width: \", promptNumber \"Enter the height: \")\n\t\t\tval diff = (promptNumber \"Enter the difficulty (number of shuffles): \")\n\t\t\tval board = Board.construct (width, height)\n\t\tin\n\t\t\tShuffle.shuffle board diff;\n\t\t\twhile (not (Board.issolved board)) do loop board;\n\t\t\tprint \"Solved!\\n\"\n\t\tend\nend\n\n\nval () = Console.start()\n"
                },
                {
                    "language": "XPL0",
                    "solution": "int Box, Hole, I;\n[Box:= [^ ,^F,^E,^D,    \\starting configuration\n        ^C,^B,^A,^9,    \\slide digits into ascending order\n        ^8,^7,^6,^5,    \\with blank in lower-right corner\n        ^4,^3,^2,^1];\nHole:= 0;               \\index for hole position\nloop    [Clear;         \\erase screen and move to start\n        for I:= 0 to 15 do \\show puzzle\n                [ChOut(0, Box(I));  ChOut(0, ^ );\n                if (I & 3) = 3 then CrLf(0)];\n        case ChIn(1) of                 \\get move\n          $1B:  quit;                   \\Esc\n          $48:  if Hole < 12 then       \\UpArrow scan code\n                        [Box(Hole):= Box(Hole+4);\n                        Hole:= Hole+4;\n                        Box(Hole):= ^ ];\n          $50:  if Hole > 3 then        \\DnArrow\n                        [Box(Hole):= Box(Hole-4);\n                        Hole:= Hole-4;\n                        Box(Hole):= ^ ];\n          $4B:  if (Hole & 3) < 3 then  \\LfArrow\n                        [Box(Hole):= Box(Hole+1);\n                        Hole:= Hole+1;\n                        Box(Hole):= ^ ];\n          $4D:  if (Hole & 3) > 0 then  \\RtArrow\n                        [Box(Hole):= Box(Hole-1);\n                        Hole:= Hole-1;\n                        Box(Hole):= ^ ]\n        other   [];     \\ignore 0 scan code prefix etc.\n        ];\n]\n"
                }
            ],
            [
                {
                    "language": "COBOL",
                    "solution": "         >>SOURCE FORMAT FREE\n*> This code is dedicated to the public domain\n*> This is GNUCOBOL 2.0\nidentification division.\nprogram-id. fifteen.\nenvironment division.\nconfiguration section.\nrepository. function all intrinsic.\ndata division.\nworking-storage section.\n\n01  r pic 9.\n01  r-empty pic 9.\n01  r-to pic 9.\n01  r-from pic 9.\n\n01  c pic 9.\n01  c-empty pic 9.\n01  c-to pic 9.\n01  c-from pic 9.\n\n01  display-table.\n    03  display-row occurs 4.\n        05  display-cell occurs 4 pic 99.\n\n01  tile-number pic 99.\n01  tile-flags pic x(16).\n\n01  display-move value spaces.\n    03  tile-id pic 99.\n\n01  row-separator pic x(21) value all '.'.\n01  column-separator pic x(3) value ' . '.\n\n01  inversions pic 99.\n01  current-tile pic 99.\n\n01  winning-display pic x(32) value\n        '01020304'\n    &   '05060708'\n    &   '09101112'\n    &   '13141500'.\n\nprocedure division.\nstart-fifteen.\n    display 'start fifteen puzzle'\n    display '    enter a two-digit tile number and press <enter> to move'\n    display '    press <enter> only to exit'\n\n    *> tables with an odd number of inversions are not solvable\n    perform initialize-table with test after until inversions = 0\n    perform show-table\n    accept display-move\n    perform until display-move = spaces\n        perform move-tile\n        perform show-table\n        move spaces to display-move\n        accept display-move\n    end-perform\n    stop run\n    .\ninitialize-table.\n    compute tile-number = random(seconds-past-midnight) *> seed only\n    move spaces to tile-flags\n    move 0 to current-tile inversions\n    perform varying r from 1 by 1 until r > 4\n    after c from 1 by 1 until c > 4\n        perform with test after\n        until tile-flags(tile-number + 1:1) = space\n            compute tile-number = random() * 100\n            compute tile-number = mod(tile-number, 16)\n        end-perform\n        move 'x' to tile-flags(tile-number + 1:1)\n        if tile-number > 0 and < current-tile\n            add 1 to inversions\n        end-if\n        move tile-number to display-cell(r,c) current-tile\n    end-perform\n    compute inversions = mod(inversions,2)\n    .\nshow-table.\n    if display-table = winning-display\n        display 'winning'\n    end-if\n    display space row-separator\n    perform varying r from 1 by 1 until r > 4\n        perform varying c from 1 by 1 until c > 4\n            display column-separator with no advancing\n            if display-cell(r,c) = 00\n                display '  ' with no advancing\n                move r to r-empty\n                move c to c-empty\n            else\n                display display-cell(r,c) with no advancing\n            end-if\n        end-perform\n        display column-separator\n    end-perform\n    display space row-separator\n    .\nmove-tile.\n    if not (tile-id numeric and tile-id >= 01 and <= 15)\n        display 'invalid tile number'\n        exit paragraph\n    end-if\n\n    *> find the entered tile-id row and column (r,c)\n    perform varying r from 1 by 1 until r > 4\n    after c from 1 by 1 until c > 4\n        if display-cell(r,c) = tile-id\n            exit perform\n        end-if\n    end-perform\n\n    *> show-table filled (r-empty,c-empty)\n    evaluate true\n    when r = r-empty\n        if c-empty < c\n            *> shift left\n            perform varying c-to from c-empty by 1 until c-to > c\n                compute c-from = c-to + 1\n                move display-cell(r-empty,c-from) to display-cell(r-empty,c-to)\n            end-perform\n        else\n           *> shift right\n           perform varying c-to from c-empty by -1 until c-to < c\n               compute c-from = c-to - 1\n               move display-cell(r-empty,c-from) to display-cell(r-empty,c-to)\n           end-perform\n       end-if\n       move 00 to display-cell(r,c)\n    when c = c-empty\n        if r-empty < r\n            *>shift up\n            perform varying r-to from r-empty by 1 until r-to > r\n                compute r-from = r-to + 1\n                move display-cell(r-from,c-empty) to display-cell(r-to,c-empty)\n            end-perform\n        else\n            *> shift down\n            perform varying r-to from r-empty by -1 until r-to < r\n                compute r-from = r-to - 1\n                move display-cell(r-from,c-empty) to display-cell(r-to,c-empty)\n            end-perform\n        end-if\n        move 00 to display-cell(r,c)\n    when other\n         display 'invalid move'\n    end-evaluate\n    .\nend program fifteen.\n"
                },
                {
                    "language": "C",
                    "solution": "/*\n * RosettaCode: Fifteen puzle game, C89, plain vanillia TTY, MVC\n */\n\n#define _CRT_SECURE_NO_WARNINGS /* unlocks printf etc. in MSVC */\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\nenum Move { MOVE_UP = 0, MOVE_DOWN = 1, MOVE_LEFT = 2, MOVE_RIGHT = 3 };\n\n/* *****************************************************************************\n * Model\n */\n\n#define NROWS     4\n#define NCOLLUMNS 4\nint holeRow;\nint holeCollumn;\nint cells[NROWS][NCOLLUMNS];\nconst int nShuffles = 100;\n\nint Game_update(enum Move move){\n    const int dx[] = {  0,  0, -1, +1 };\n    const int dy[] = { -1, +1,  0,  0 };\n    int i = holeRow     + dy[move];\n    int j = holeCollumn + dx[move];\n    if ( i >= 0 && i < NROWS && j >= 0 && j < NCOLLUMNS ){\n        cells[holeRow][holeCollumn] = cells[i][j];\n        cells[i][j] = 0; holeRow = i; holeCollumn = j;\n        return 1;\n    }\n    return 0;\n}\n\nvoid Game_setup(void){\n    int i,j,k;\n    for ( i = 0; i < NROWS; i++ )\n        for ( j = 0; j < NCOLLUMNS; j++ )\n            cells[i][j] = i * NCOLLUMNS + j + 1;\n    cells[NROWS-1][NCOLLUMNS-1] = 0;\n    holeRow = NROWS - 1;\n    holeCollumn = NCOLLUMNS - 1;\n    k = 0;\n    while ( k < nShuffles )\n        k += Game_update((enum Move)(rand() % 4));\n}\n\nint Game_isFinished(void){\n    int i,j; int k = 1;\n    for ( i = 0; i < NROWS; i++ )\n        for ( j = 0; j < NCOLLUMNS; j++ )\n            if ( (k < NROWS*NCOLLUMNS) && (cells[i][j] != k++ ) )\n                return 0;\n    return 1;\n}\n\n\n/* *****************************************************************************\n * View\n */\n\nvoid View_showBoard(){\n    int i,j;\n    putchar('\\n');\n    for ( i = 0; i < NROWS; i++ )\n        for ( j = 0; j < NCOLLUMNS; j++ ){\n            if ( cells[i][j] )\n                printf(j != NCOLLUMNS-1 ? \" %2d \" : \" %2d \\n\", cells[i][j]);\n            else\n                printf(j != NCOLLUMNS-1 ? \" %2s \" : \" %2s \\n\", \"\");\n        }\n    putchar('\\n');\n}\n\nvoid View_displayMessage(char* text){\n    printf(\"\\n%s\\n\", text);\n}\n\n\n/* *****************************************************************************\n * Controller\n */\n\nenum Move Controller_getMove(void){\n    int c;\n    for(;;){\n        printf(\"%s\", \"enter u/d/l/r : \");\n        c = getchar();\n        while( getchar() != '\\n' )\n            ;\n        switch ( c ){\n            case 27: exit(EXIT_SUCCESS);\n            case 'd' : return MOVE_UP;\n            case 'u' : return MOVE_DOWN;\n            case 'r' : return MOVE_LEFT;\n            case 'l' : return MOVE_RIGHT;\n        }\n    }\n}\n\nvoid Controller_pause(void){\n    getchar();\n}\n\nint main(void){\n\n    srand((unsigned)time(NULL));\n\n    do Game_setup(); while ( Game_isFinished() );\n\n    View_showBoard();\n    while( !Game_isFinished() ){\n        Game_update( Controller_getMove() );\n        View_showBoard();\n    }\n\n    View_displayMessage(\"You win\");\n    Controller_pause();\n\n    return EXIT_SUCCESS;\n}\n"
                }
            ],
            [
                {
                    "language": "APL",
                    "solution": "fpg\u2190{\u2395IO\u21900\n    \u237a\u21904 4\n    (s\u2228.<0)\u22282\u2260\u2374s\u2190\u237a:'invalid shape:'s\n    0\u2260\u2374\u2374\u2375:'invalid shuffle count:'\u2375\n    d\u2190d,-d\u2190\u21932 2\u23743\u21911\n    e\u2190\u00af1+\u2374c\u2190'\u2191\u2193\u2190\u2192\u25cb'\n    b\u2190w\u2190s\u2374w\u21901\u233d\u2373\u00d7/s\n    z\u2190\u2283{\n        z p\u2190\u2375\n        n\u2190(?\u2374p)\u2283p\u2190(p\u2261\u00a8(\u2282s)|p)/p\u2190(d~p)+\u2282z\n        b[z n]\u2190b[n z]\n        -\u2368\\n z\n    }\u2363\u2375\u22a2(s-1)0\n    \u2395\u2190b\n    \u236c{\n        b\u2261w:'win'\n        0=\u2374\u237a:\u235e\u2207 \u2375\n        e=i\u2190c\u2373m\u2190\u2283\u237a:'quit'\n        i>e:\u235e\u2207 \u2375\u22a3\u2395\u2190'invalid direction:'m\n        n\u2262s|n\u2190\u2375+i\u2283d:\u235e\u2207 \u2375\u22a3'out of bounds:'m\n        b[\u2375 n]\u2190b[n \u2375]\n        \u2395\u2190(s\u00d70\u2260\u2374\u237a)\u2374b\n        (1\u2193\u237a)\u2207 n\n    }z\n}\n"
                },
                {
                    "language": "FutureBasic",
                    "solution": "// 15 Puzzle // 26 september 2023 //\n\nbegin globals\nCFMutableStringRef board : board = fn MutableStringNew\nend globals\n\n\nvoid local fn buildUI\n  Long i, j, k = 1 // k is button number\n  window 1, @\"15 Puzzle\", ( 0, 0, 200, 200 ), 3\n  for j = 3 to 0 step -1 : for i = 0 to 3 // Top to bottom, left to right\n    button k, Yes, 1, @\"\",  ( 20 + 40 * i, 20 + 40 * j , 40, 40 ), , NSBezelStyleShadowlessSquare\n    ControlSetFont(k, fn FontSystemFontOfSize( 21 ) )\n    ControlSetAlignment( k, NSTextAlignmentCenter )\n    k ++\n  next : next\n  menu 1, , 1, @\"File\": menu 1, 1, , @\"Close\", @\"w\" : MenuItemSetAction( 1, 1, @\"performClose:\" )\n  editmenu 2 : menu 2, 0, No : menu 3, , , @\"Level\"\n  for i = 1 to 8 : menu 3, i, , str( i ) : next\n  MenuSetOneItemOnState( 3, 3 )\nend fn\n\n\nvoid local fn newGame\n  CFStringRef s\n  Long i, m, n = 16, p = 0 // n is empty starting tile, p holds previous move\n  Bool ok\n  MutableStringSetString (board, @\" 123456789ABCDEF \" )\n  for i = 1 to fn MenuSelectedItem( 3 )^2 // Number of shuffles is square of level\n    do : ok = Yes\n      m = n + int( 2.6 * rnd( 4 ) - 6.5 )       // Choose a random move, but\n      if m < 1 or m > 16 or m == p then ok = No // not of bounds or previous,\n      if n mod 4 = 0 and m = n + 1 then ok = No // and don't exchange eg tile 4 and 5\n      if n mod 4 = 1 and m = n - 1 then ok = No // or 9 and 8\n    until ok = Yes // Found a move, swap in board string\n    s = mid( board, m, 1 ) : mid( board, m, 1 ) = @\" \" : mid( board, n, 1 ) = s\n    p = n : n = m\n  next\n  for i = 1 to 16 // Stamp the buttons, p is unicode of board char, s is button title\n    p = (Long) fn StringCharacterAtIndex( board, i )\n    if p > 64 then s = fn StringWithFormat ( @\"%d\", p - 55 ) else s = mid( board, i, 1 )\n    button i, Yes, 1, s\n    if fn StringIsEqual( s, @\" \") == Yes then button i, No\n  next\nend fn\n\n\nvoid local fn move ( n as Long )\n  CFStringRef s\n  Long i, m, x = -1 // x is empty plot\n  Bool ok\n  for i = 1 to 4 // see if clicked button is next to empty plot\n    m = n + int( 2.6 * i - 6.5 ) // -4. -1, +1, +4\n    ok = Yes\n    if m < 1 or m > 16 then ok = No // Not out of bounds etc\n    if n mod 4 = 0 and m = n + 1 then ok = No\n    if n mod 4 = 1 and m = n - 1 then ok = No\n    if ok == Yes\n      if fn StringIsEqual( mid( board, m, 1 ), @\" \" ) then x = m\n    end if\n  next\n  if x > -1 // Swap places in board string and button titles\n    s = mid( board, n, 1 ) : mid( board, n, 1 ) = @\" \" : mid( board, x, 1 ) = s\n    button x, Yes, 1 , fn ButtonTitle( n ) : button n, No, 1, @\" \"\n  end if\n  if fn StringIsEqual( board, @\" 123456789ABCDEF \" )\n    alert 112, , @\"Well done.\", @\"Another game?\", @\"Yes;No\", Yes\n  end if\nend fn\n\n\nvoid local fn doMenu( mnu as Long, itm as Long )\n  if mnu == 3 then MenuSetOneItemOnState( 3, itm ) : fn newGame\nend fn\n\n\nvoid local fn DoDialog( evt as Long, tag as Long )\n  select evt\n    case _btnClick : fn move( tag )\n    case _alertDidEnd : if tag == NSAlertFirstButtonReturn then fn newGame else end\n  end select\nend fn\n\nfn buildUI\nfn newGame\n\non dialog fn doDialog\non menu fn doMenu\nhandleevents\n"
                }
            ],
            [
                {
                    "language": "68000-Assembly",
                    "solution": ";15 PUZZLE GAME\n;Ram Variables\nCursor_X equ $00FF0000\t\t;Ram for Cursor Xpos\nCursor_Y equ $00FF0000+1\t;Ram for Cursor Ypos\njoypad1 equ $00FF0002\n\nGameRam equ $00FF1000\t\t;Ram for where the pieces are\nGameRam_End equ $00FF100F\t;the last valid slot in the array\n;Video Ports\nVDP_data\tEQU\t$C00000\t; VDP data, R/W word or longword access only\nVDP_ctrl\tEQU\t$C00004\t; VDP control, word or longword writes only\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n; \t\t\t\t\tVECTOR TABLE\n;org $00000000\n\tDC.L\t$00FFFFFE\t\t;SP register value\n\tDC.L\tProgramStart\t;Start of Program Code\n\tDC.L\tIntReturn\t\t; bus err\n\tDC.L\tIntReturn\t\t; addr err\n\tDC.L\tIntReturn\t\t; illegal inst\n\tDC.L\tIntReturn\t\t; divzero\n\tDC.L\tIntReturn\t\t; CHK\n\tDC.L\tIntReturn\t\t; TRAPV\n\tDC.L\tIntReturn\t\t; privilege viol\n\tDC.L\tIntReturn\t\t; TRACE\n\tDC.L\tIntReturn\t\t; Line A (1010) emulator\n\tDC.L\tIntReturn\t\t; Line F (1111) emulator\n\tDC.L\tIntReturn,IntReturn,IntReturn,IntReturn\t\t; Reserved /Coprocessor/Format err/ Uninit Interrupt\n\tDC.L\tIntReturn,IntReturn,IntReturn,IntReturn,IntReturn,IntReturn,IntReturn,IntReturn\n\tDC.L\tIntReturn\t\t; spurious interrupt\n\tDC.L\tIntReturn\t\t; IRQ level 1\n\tDC.L\tIntReturn\t\t; IRQ level 2 EXT\n\tDC.L\tIntReturn\t\t; IRQ level 3\n\tDC.L\tIntReturn\t\t; IRQ level 4 Hsync\n\tDC.L\tIntReturn\t\t; IRQ level 5\n\tDC.L\tIntReturn\t\t; IRQ level 6 Vsync\n\tDC.L\tIntReturn\t\t; IRQ level 7 (NMI)\n;org $00000080\n;TRAPS\n\tDC.L\tIntReturn,IntReturn,IntReturn,IntReturn,IntReturn,IntReturn,IntReturn,IntReturn\n\tDC.L\tIntReturn,IntReturn,IntReturn,IntReturn,IntReturn,IntReturn,IntReturn,IntReturn\n;org $000000C0\n;FP/MMU\n\tDC.L\tIntReturn,IntReturn,IntReturn,IntReturn,IntReturn,IntReturn,IntReturn,IntReturn\n\tDC.L\tIntReturn,IntReturn,IntReturn,IntReturn,IntReturn,IntReturn,IntReturn,IntReturn\n\n\t\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;\t\t\t\t\tHeader\nHEADER:\n\tDC.B\t\"SEGA GENESIS    \"\t        ;System Name\tMUST TAKE UP 16 BYTES, USE PADDING IF NECESSARY\n\tDC.B\t\"(C)PDS  \"\t\t\t;Copyright\tMUST TAKE UP 8 BYTES, USE PADDING IF NECESSARY\n \tDC.B\t\"2022.JUN\"\t\t\t;Date\t\tMUST TAKE UP 8 BYTES, USE PADDING IF NECESSARY\nCARTNAME:\n\tDC.B \t\"15 PUZZLE\"\nCARTNAME_END:\n\tDS.B 48-(CARTNAME_END-CARTNAME)\t;ENSURES PROPER SPACING\nCARTNAMEALT:\n\tDC.B\t\"15 PUZZLE\"\nCARTNAMEALT_END:\n\tDS.B 48-(CARTNAMEALT_END-CARTNAMEALT)\t;ENSURES PROPER SPACING\ngameID:\n\tDC.B\t\"GM PUPPY001-00\"\t        ;TT NNNNNNNN-RR T=Type (GM=Game) N=game Num  R=Revision\n\tDC.W\t$0000\t\t\t\t;16-bit Checksum (Address $000200+)\nCTRLDATA:\n\tDC.B\t\"J               \"\t        ;Control Data (J=3button K=Keyboard 6=6button C=cdrom)\n                                                ;(MUST TAKE UP 16 BYTES, USE PADDING IF NECESSARY)\nROMSTART:\n\tDC.L\t$00000000\t\t\t;ROM Start\nROMLEN:\n\tDC.L\t$003FFFFF\t\t\t;ROM Length\nRAMSTART:\n\tDC.L\t$00FF0000\nRAMEND:\n\tDC.L\t$00FFFFFF\t;RAM start/end (fixed)\n\n\tDC.B\t\"            \"\t\t;External RAM Data\t(MUST TAKE UP 12 BYTES, USE PADDING IF NECESSARY)\n\tDC.B\t\"            \"\t\t;Modem Data\t\t(MUST TAKE UP 12 BYTES, USE PADDING IF NECESSARY)\nMEMO:\n\tDC.B\t\"                                        \"      ;(MUST TAKE UP 40 BYTES, USE PADDING IF NECESSARY)\nREGION:\n\tDC.B\t\"JUE             \"\t;Regions Allowed        (MUST TAKE UP 16 BYTES, USE PADDING IF NECESSARY)\n\teven\nHEADER_END:\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;\t\t\t\t\tGeneric Interrupt Handler\nIntReturn:\n\trte                            ;immediately return to game\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;\t\t\t\t\tProgram Start\nProgramStart:\n\t;initialize TMSS (TradeMark Security System)\n\tmove.b ($A10001),D0\t\t;A10001 test the hardware version\n\tand.b #$0F,D0\n\tbeq\tNoTmss\t\t\t\t;branch if no TMSS chip\n\tmove.l #'SEGA',($A14000);A14000 disable TMSS\nNoTmss:\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;\t\t\t\t\tSet Up Graphics\n\n\tlea VDPSettings,A5\t\t      ;Initialize Screen Registers\n\tmove.l #VDPSettingsEnd-VDPSettings,D1 ;length of Settings\n\t\n\tmove.w (VDP_ctrl),D0\t              ;C00004 read VDP status (interrupt acknowledge?)\n\tmove.l #$00008000,d5\t              ;VDP Reg command (%8rvv)\n\t\nNextInitByte:\n\tmove.b (A5)+,D5\t\t\t      ;get next video control byte\n\tmove.w D5,(VDP_ctrl)\t              ;C00004 send write register command to VDP\n\t\t;   8RVV - R=Reg V=Value\n\tadd.w #$0100,D5\t\t\t      ;point to next VDP register\n\tdbra D1,NextInitByte\t              ;loop for rest of block\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;       Set up palette\n\t\n\t;Define palette\n\tmove.l #$C0000000,d0\t;Color 0 (background)\n\tmove.l d0,VDP_Ctrl\n\t;        ----BBB-GGG-RRR-\n\tmove.w #%0000011000000000,VDP_data\n\t\n\tmove.l #$C01E0000,d0\t;Color 15 (Font)\n\tmove.l d0,VDP_Ctrl\n\tmove.w #%0000000011101110,VDP_data\n\t\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;\t\t\t\t\tSet up Font\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n; FONT IS 1BPP, THIS ROUTINE CONVERTS IT TO A 4BPP FORMAT.\n\tlea Font,A1\t\t\t\t\t ;Font Address in ROM\n\tmove.l #Font_End-Font,d6\t                 ;Our font contains 96 letters 8 lines each\n\t\n\tmove.l #$40000000,(VDP_Ctrl);Start writes to VRAM address $0000\nNextFont:\n\tmove.b (A1)+,d0\t\t;Get byte from font\n\tmoveq.l #7,d5\t\t;Bit Count (8 bits)\n\tclr.l d1\t\t;Reset BuildUp Byte\n\t\nFont_NextBit:\t\t\t;1 color per nibble = 4 bytes\n\n\trol.l #3,d1\t\t;Shift BuildUp 3 bits left\n\troxl.b #1,d0\t\t;Shift a Bit from the 1bpp font into the Pattern\n\troxl.l #1,d1\t\t;Shift bit into BuildUp\n\tdbra D5,Font_NextBit    ;Next Bit from Font\n\t\n\tmove.l d1,d0\t\t; Make fontfrom Color 1 to color 15\n\trol.l #1,d1\t\t;Bit 1\n\tor.l d0,d1\n\trol.l #1,d1\t\t;Bit 2\n\tor.l d0,d1\n\trol.l #1,d1\t\t;Bit 3\n\tor.l d0,d1\n\t\n\tmove.l d1,(VDP_Data);Write next Long of char (one line) to VDP\n\tdbra d6,NextFont\t;Loop until done\n\n\t\n\n\tclr.b Cursor_X\t\t;Clear Cursor XY\n\tclr.b Cursor_Y\n\t\n\t;Turn on screen\n\tmove.w\t#$8144,(VDP_Ctrl);C00004 reg 1 = 0x44 unblank display\n\t\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n; all of the above was just the prep work to boot the Sega Genesis, and had nothing to do with a 15 Puzzle.\n; That's hardware for you!\n\n\tLEA GameRam,A0\n        ;load the initial state of the puzzle. There is no randomization here unfortunately, as creating a sufficient pseudo-RNG\n        ;to make the game \"believable\" is more difficult than programming the game itself!\n        ;so instead we'll start in such a manner that the player has to do quite a bit of work to win.\n\tMOVE.B #'F',(A0)+\n\tMOVE.B #'E',(A0)+\n\tMOVE.B #'D',(A0)+\n\tMOVE.B #'C',(A0)+\n\tMOVE.B #'B',(A0)+\n\tMOVE.B #'A',(A0)+\n\tMOVE.B #'9',(A0)+\n\tMOVE.B #'8',(A0)+\n\tMOVE.B #'7',(A0)+\n\tMOVE.B #'6',(A0)+\n\tMOVE.B #'5',(A0)+\n\tMOVE.B #'4',(A0)+\n\tMOVE.B #'3',(A0)+\n\tMOVE.B #'2',(A0)+\n\tMOVE.B #'1',(A0)+\n\tMOVE.B #' ',(A0)+\n\n       ;puzzle will look like:\n       ;FEDC\n       ;BA98\n       ;7654\n       ;321\n\nmain:\n\tJSR Player_ReadControlsDual     ;get controller input\n\tmove.w d0,(joypad1)\n\n\n\t;adjust the number of these as you see fit.\n\t;this affects the game's overall speed.\n\tJSR waitVBlank\n\tJSR waitVBlank\n\tJSR waitVBlank\n\tJSR waitVBlank\n\tJSR waitVBlank\n\tJSR waitVBlank\n\tJSR waitVBlank\n\tJSR waitVBlank\n\tJSR waitVBlank\n\tJSR waitVBlank\n\n        ;find where the blank space is among GameRAM\n\tLEA GameRAM,a0\n\tMOVE.B #' ',D0\n\tJSR REPNE_SCASB\n\tMOVE.L A0,A1\t\n\t\n;;;;;;;;;;;;;;;;;;; check controller presses\nJOYPAD_BITFLAG_M equ 2048\nJOYPAD_BITFLAG_Z equ 1024\nJOYPAD_BITFLAG_Y equ 512\nJOYPAD_BITFLAG_X equ 256\nJOYPAD_BITFLAG_S equ 128\nJOYPAD_BITFLAG_C equ 64\nJOYPAD_BITFLAG_B equ 32\nJOYPAD_BITFLAG_A equ 16\nJOYPAD_BITFLAG_R equ 8\nJOYPAD_BITFLAG_L equ 4\nJOYPAD_BITFLAG_D equ 2\nJOYPAD_BITFLAG_U equ 1\n\nJOYPAD_BITNUM_M equ 11\nJOYPAD_BITNUM_Z equ 10\nJOYPAD_BITNUM_Y equ 9\nJOYPAD_BITNUM_X equ 8\nJOYPAD_BITNUM_S equ 7\nJOYPAD_BITNUM_C equ 6\nJOYPAD_BITNUM_B equ 5\nJOYPAD_BITNUM_A equ 4\nJOYPAD_BITNUM_R equ 3\nJOYPAD_BITNUM_L equ 2\nJOYPAD_BITNUM_D equ 1\nJOYPAD_BITNUM_U equ 0\n\n\n\n\n\tmove.w (joypad1),D0\n\n\tBTST #JOYPAD_BITNUM_U,D0\n\tBNE JoyNotUp\n\t\tMOVEM.L D0/A1,-(SP)\n\t\t\tADDA.L #4,A1\n\t\t\tCMPA.L #GameRam_End,A1\n\t\t\tBHI .doNothing\n\t\t\t;OTHERWISE SWAP THE EMPTY SPACE WITH THE BYTE BELOW IT.\n\t\t\t\tMOVE.B (A1),D7\n\t\t\t\tMOVE.B (A0),(A1)\n\t\t\t\tMOVE.B D7,(A0)\t\n.doNothing\n\t\tMOVEM.L (SP)+,D0/A1\n\t\tbra vdraw\t\nJoyNotUp:\n\tBTST #JOYPAD_BITNUM_D,D0\n\tBNE JoyNotDown\n\t\tMOVEM.L D0/A1,-(SP)\n\n\t\t\tSUBA.L #4,A1\t\t;CHECK ONE ROW ABOVE WHERE WE ARE\n\t\t\tCMPA.L #GameRam,A1\n\t\t\tBCS .doNothing\t\t;if A1-4 IS BELOW THE START OF GAME RAM, DON'T MOVE\n\t\t\t;OTHERWISE SWAP THE EMPTY SPACE WITH THE BYTE ABOVE IT.\n\t\t\t\tMOVE.B (A1),D7\n\t\t\t\tMOVE.B (A0),(A1)\n\t\t\t\tMOVE.B D7,(A0)\t\t\t\t\n.doNothing:\n\t\tMOVEM.L (SP)+,D0/A1\n\t\tbra vdraw\nJoyNotDown:\n\tBTST #JOYPAD_BITNUM_L,D0\n\tBNE JoyNotLeft\n\t\tMOVEM.L D0/A1,-(SP)\n\t\t\tADDA.L #1,A1\n\t\t\tMOVE.L A1,D4\n\t\t\tMOVE.L A0,D3\n\t\t\tAND.L #3,D4\n\t\t\tAND.L #3,D3\n\t\t\tCMP.L D3,D4\t\n\t\t\tBCS .doNothing\n\t\t\t;OTHERWISE SWAP THE EMPTY SPACE WITH THE BYTE TO THE LEFT\n\t\t\t\tMOVE.B (A1),D7\n\t\t\t\tMOVE.B (A0),(A1)\n\t\t\t\tMOVE.B D7,(A0)\t\t\t\t\n.doNothing:\n\t\tMOVEM.L (SP)+,D0/A1\n\t\tbra vdraw\nJoyNotLeft:\n\tBTST #JOYPAD_BITNUM_R,D0\n\tBNE JoyNotRight\n\t\tMOVEM.L D0/A1,-(SP)\n\t\t\tSUBA.L #1,A1\n\t\t\tMOVE.L A1,D4\n\t\t\tMOVE.L A0,D3\n\t\t\tAND.L #3,D4\n\t\t\tAND.L #3,D3\n\t\t\tCMP.L D3,D4\t\n\t\t\tBHI .doNothing\n\t\t\t;OTHERWISE SWAP THE EMPTY SPACE WITH THE BYTE TO THE RIGHT\n\t\t\t\tMOVE.B (A1),D7\n\t\t\t\tMOVE.B (A0),(A1)\n\t\t\t\tMOVE.B D7,(A0)\t\t\t\t\n.doNothing:\n\t\tMOVEM.L (SP)+,D0/A1\n\t\tbra vdraw\nJoyNotRight:\n\nvdraw:\n\t;this actually draws the current state of the puzzle to the screen.\n\tLEA GameRam,A0\n\tCLR.B (Cursor_X)   ;reset text cursors to top left of screen\n\tCLR.B (Cursor_Y)\n\t\n;draw the puzzle\n\n;anything insize a REPT N...ENDR block is in-lined N times, back to back.\n       rept 4\n\n\t      MOVE.B (A0)+,D0\n\t      JSR PrintChar\n\n\t      MOVE.B (A0)+,D0\n\t      JSR PrintChar\n\n\t      MOVE.B (A0)+,D0\n\t      JSR PrintChar\n\n\t      MOVE.B (A0)+,D0\n\t      JSR PrintChar         ;we just finished drawing one row of the puzzle. Now, begin a new line and continue drawing.\n\n              jsr newline\n       endr\n\t\n\t\ncheckIfWin:\n\t;YES THIS IS MESSY, I TRIED IT WITH A LOOP BUT IT WOULDN'T WORK SO I JUST UNROLLED THE LOOP.\n\tLEA GameRam,a4\n\tMOVE.B (A4)+,D5\n\tCMP.B #'1',D5\n\tBNE .keepGoing\n\n\tMOVE.B (A4)+,D5\n\tCMP.B #'2',D5\n\tBNE .keepGoing\n\n\tMOVE.B (A4)+,D5\n\tCMP.B #'3',D5\n\tBNE .keepGoing\n\n\tMOVE.B (A4)+,D5\n\tCMP.B #'4',D5\n\tBNE .keepGoing\n\n\tMOVE.B (A4)+,D5\n\tCMP.B #'5',D5\n\tBNE .keepGoing\n\n\tMOVE.B (A4)+,D5\n\tCMP.B #'6',D5\n\tBNE .keepGoing\n\n\tMOVE.B (A4)+,D5\n\tCMP.B #'7',D5\n\tBNE .keepGoing\n\n\tMOVE.B (A4)+,D5\n\tCMP.B #'8',D5\n\tBNE .keepGoing\n\n\tMOVE.B (A4)+,D5\n\tCMP.B #'9',D5\n\tBNE .keepGoing\n\n\tMOVE.B (A4)+,D5\n\tCMP.B #'A',D5\n\tBNE .keepGoing\n\n\tMOVE.B (A4)+,D5\n\tCMP.B #'B',D5\n\tBNE .keepGoing\n\n\tMOVE.B (A4)+,D5\n\tCMP.B #'C',D5\n\tBNE .keepGoing\n\n\tMOVE.B (A4)+,D5\n\tCMP.B #'D',D5\n\tBNE .keepGoing\n\n\tMOVE.B (A4)+,D5\n\tCMP.B #'E',D5\n\tBNE .keepGoing\n\n\tMOVE.B (A4)+,D5\n\tCMP.B #'F',D5\n\tBNE .keepGoing\n\n\tMOVE.B (A4)+,D5\n\tCMP.B #' ',D5\n\tBNE .keepGoing\n\t\n\tclr.b (Cursor_X)\n\tmove.b #7,(Cursor_Y)\n\tLEA victoryMessage,a3\n\tjsr PrintString\n\tjmp *  ;game freezes after you win.\n\n.keepGoing:\n;it's unlikely that the label \"main\" is in range of here so I didn't bother checking and just assumed it was out of range.\n;Otherwise I would have said \"BEQ main\" instead of BNE .keepGoing\n\tjmp main\n\t\t\n\nVictoryMessage:\n\tDC.B \"A WINNER IS YOU\",255\n\tEVEN\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\nREPNE_SCASB:\n\t;INPUT:\n\t;A0 = POINTER TO START OF MEMORY\n\t;D0 = THE BYTE TO SEARCH FOR\n\t;OUTPUT = A0 POINTS TO THE BYTE THAT CONTAINED D0\n\tMOVE.B (A0),D1\n\tCMP.B D0,D1\n\tBEQ .done\n\tADDA.L #1,A0\n\tBRA REPNE_SCASB\n.done:\n\tRTS\n\t\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n\n\nPlayer_ReadControlsDual:\n\t\n\tmove.b #%01000000,($A1000B)\t; Set direction IOIIIIII (I=In O=Out)\n\tmove.l #$A10003,a0\t\t;RW port for player 1\n\n\tmove.b  #$40,(a0)\t; TH = 1\n\tnop\t\t;Delay\n\tnop\n\tmove.b  (a0),d2\t\t; d0.b = --CBRLDU\tStore in D2\n\t\n\tmove.b\t#$0,(a0)\t; TH = 0\n\tnop\t\t;Delay\n\tnop\n\tmove.b\t(a0),d1\t\t; d1.b = --SA--DU\tStore in D1\n\t\n\tmove.b  #$40,(a0)\t; TH = 1\n\tnop\t\t;Delay\n\tnop\n\tmove.b\t#$0,(a0)\t; TH = 0\n\tnop\t\t;Delay\n\tnop\n\tmove.b  #$40,(a0)\t; TH = 1\n\tnop\t\t;Delay\n\tnop\n\tmove.b\t(a0),d3\t\t; d1.b = --CBXYZM\tStore in D3\n\tmove.b\t#$0,(a0)\t; TH = 0\n\t\n\tclr.l d0\t\t\t;Clear buildup byte\n\troxr.b d2\n\troxr.b d0\t\t\t;U\n\troxr.b d2\n\troxr.b d0\t\t\t;D\n\troxr.b d2\n\troxr.b d0\t\t\t;L\n\troxr.b d2\n\troxr.b d0\t\t\t;R\n\troxr.b #5,d1\n\troxr.b d0\t\t\t;A\n\troxr.b d2\n\troxr.b d0\t\t\t;B\n\troxr.b d2\n\troxr.b d0\t\t\t;C\n\troxr.b d1\n\troxr.b d0\t\t\t;S\n\t\n\tmove.l d3,d1\n\troxl.l #7,d1\t\t;XYZ\n\tand.l #%0000011100000000,d1\n\tor.l d1,d0\t\t\t\n\t\n\tmove.l d3,d1\n\troxl.l #8,d1\t\t;M\n\troxl.l #3,d1\t\t\n\tand.l #%0000100000000000,d1\n\tor.l d1,d0\n\t\n\tor.l #$FFFFF000,d0\t;Set unused bits to 1\n\n\t\n\t\n\t;this returns player 1's buttons into D0 as the following:\n\t;----MZYXSCBARLDU\n\trts\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\nwaitVBlank:\t\t\t\t\t\t\t;Bit 3 defines if we're in Vblank\n\tMOVE.L d0,-(sp)\n.wait:\n\t\tmove.w VDP_ctrl,d0\n\t\tand.w #%0000000000001000,d0\t\t;See if vblank is running\n\t\tbne .wait\t\t\t\t\t;wait until it is\n\t\t\nwaitVBlank2:\n\t\tmove.w VDP_ctrl,d0\n\t\tand.w #%0000000000001000,d0\t\t;See if vblank is running\n\t\tbeq waitVBlank2\t\t\t\t\t;wait until it isnt\n\tMOVE.L (SP)+,d0\n\trts\t\t\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\t\nPrintChar:\t\t\t\t;Show D0 to screen\n\tmoveM.l d0-d7/a0-a7,-(sp)\n\t\tand.l #$FF,d0\t\t\t;Keep only 1 byte\n\t\tsub #32,d0\t\t\t\t;No Characters in our font below 32\nPrintCharAlt:\t\t\n\t\tMove.L  #$40000003,d5\t;top 4=write, bottom $3=Cxxx range\n\t\tclr.l d4\t\t\t\t\t;Tilemap at $C000+\n\n\t\tMove.B (Cursor_Y),D4\t\n\t\trol.L #8,D4\t\t\t\t;move $-FFF to $-FFF----\n\t\trol.L #8,D4\n\t\trol.L #7,D4\t\t\t\t;2 bytes per tile * 64 tiles per line\n\t\tadd.L D4,D5\t\t\t\t;add $4------3\n\t\t\n\t\tMove.B (Cursor_X),D4\n\t\trol.L #8,D4\t\t\t\t;move $-FFF to $-FFF----\n\t\trol.L #8,D4\n\t\trol.L #1,D4\t\t\t\t;2 bytes per tile\n\t\tadd.L D4,D5\t\t\t\t;add $4------3\n\t\t\n\t\tMOVE.L\tD5,(VDP_ctrl)\t; C00004 write next character to VDP\n\t\tMOVE.W\tD0,(VDP_data)\t; C00000 store next word of name data\n\n\t\taddq.b #1,(Cursor_X)\t;INC Xpos\n\t\tmove.b (Cursor_X),d0\n\t\tcmp.b #39,d0\n\t\tbls nextpixel_Xok\n\t\tjsr NewLine\t\t\t;If we're at end of line, start newline\nnextpixel_Xok:\n\tmoveM.l (sp)+,d0-d7/a0-a7\n\trts\n\t\nPrintString:\n\t\tmove.b (a3)+,d0\t\t\t;Read a character in from A3\n\t\tcmp.b #255,d0\n\t\tbeq PrintString_Done\t;return on 255\n\t\tjsr PrintChar\t\t\t;Print the Character\n\t\tbra PrintString\nPrintString_Done:\t\t\n\trts\n\t\nNewLine:\n\taddq.b #1,(Cursor_Y)\t\t;INC Y\n\tclr.b (Cursor_X)\t\t\t;Zero X\n\trts\t\n\t\nFont:\t\t\t\t\t\t\t\n;1bpp font - 8x8 96 characters\n;looks just like your typical \"8-bit\" font. You'll just have to take my word for it.\n     DC.B $00,$00,$00,$00,$00,$00,$00,$00,$18,$3c,$3c,$18,$18,$00,$18,$18\n     DC.B $36,$36,$12,$24,$00,$00,$00,$00,$00,$12,$7f,$24,$24,$fe,$48,$00\n     DC.B $00,$04,$1e,$28,$1c,$0a,$3c,$10,$00,$62,$64,$08,$10,$26,$46,$00\n     DC.B $00,$18,$24,$20,$12,$2c,$44,$3a,$18,$18,$08,$10,$00,$00,$00,$00\n     DC.B $08,$10,$20,$20,$20,$20,$10,$08,$10,$08,$04,$04,$04,$04,$08,$10\n     DC.B $00,$10,$38,$10,$28,$00,$00,$00,$00,$00,$10,$10,$7c,$10,$10,$00\n     DC.B $00,$00,$00,$00,$0c,$0c,$04,$08,$00,$00,$00,$00,$7e,$00,$00,$00\n     DC.B $00,$00,$00,$00,$00,$18,$18,$00,$01,$02,$04,$08,$10,$20,$40,$00\n     DC.B $1c,$26,$63,$63,$63,$32,$1c,$00,$0c,$1c,$0c,$0c,$0c,$0c,$3f,$00\n     DC.B $3e,$63,$07,$1e,$3c,$70,$7f,$00,$3f,$06,$0c,$1e,$03,$63,$3e,$00\n     DC.B $0e,$1e,$36,$66,$7f,$06,$06,$00,$7e,$60,$7e,$03,$03,$63,$3e,$00\n     DC.B $1e,$30,$60,$7e,$63,$63,$3e,$00,$7f,$63,$06,$0c,$18,$18,$18,$00\n     DC.B $3c,$62,$72,$3c,$4f,$43,$3e,$00,$3e,$63,$63,$3f,$03,$06,$3c,$00\n     DC.B $00,$18,$18,$00,$18,$18,$00,$00,$00,$0c,$0c,$00,$0c,$0c,$04,$08\n     DC.B $00,$00,$06,$18,$60,$18,$06,$00,$00,$00,$00,$7e,$00,$7e,$00,$00\n     DC.B $00,$00,$60,$18,$06,$18,$60,$00,$1c,$36,$36,$06,$0c,$00,$0c,$0c\n     DC.B $3c,$42,$99,$a1,$a1,$99,$42,$3c,$1c,$36,$63,$63,$7f,$63,$63,$00\n     DC.B $7e,$63,$63,$7e,$63,$63,$7e,$00,$1e,$33,$60,$60,$60,$33,$1e,$00\n     DC.B $7c,$66,$63,$63,$63,$66,$7c,$00,$3f,$30,$30,$3e,$30,$30,$3f,$00\n     DC.B $7f,$60,$60,$7e,$60,$60,$60,$00,$1f,$30,$60,$67,$63,$33,$1f,$00\n     DC.B $63,$63,$63,$7f,$63,$63,$63,$00,$3f,$0c,$0c,$0c,$0c,$0c,$3f,$00\n     DC.B $03,$03,$03,$03,$03,$63,$3e,$00,$63,$66,$6c,$78,$7c,$6e,$67,$00\n     DC.B $30,$30,$30,$30,$30,$30,$3f,$00,$63,$77,$7f,$7f,$6b,$63,$63,$00\n     DC.B $63,$73,$7b,$7f,$6f,$67,$63,$00,$3e,$63,$63,$63,$63,$63,$3e,$00\n     DC.B $7e,$63,$63,$63,$7e,$60,$60,$00,$3e,$63,$63,$63,$6f,$66,$3d,$00\n     DC.B $7e,$63,$63,$67,$7c,$6e,$67,$00,$3c,$66,$60,$3e,$03,$63,$3e,$00\n     DC.B $3f,$0c,$0c,$0c,$0c,$0c,$0c,$00,$63,$63,$63,$63,$63,$63,$3e,$00\n     DC.B $63,$63,$63,$77,$3e,$1c,$08,$00,$63,$63,$6b,$7f,$7f,$77,$63,$00\n     DC.B $63,$77,$3e,$1c,$3e,$77,$63,$00,$33,$33,$33,$1e,$0c,$0c,$0c,$00\n     DC.B $7f,$07,$0e,$1c,$38,$70,$7f,$00,$00,$38,$20,$20,$20,$20,$38,$00\n     DC.B $80,$40,$20,$10,$08,$04,$02,$00,$00,$1c,$04,$04,$04,$04,$1c,$00\n     DC.B $10,$28,$44,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$7e,$00\n     DC.B $00,$20,$10,$00,$00,$00,$00,$00,$00,$18,$04,$1c,$24,$2c,$1c,$00\n     DC.B $00,$20,$20,$38,$24,$24,$38,$00,$00,$00,$1c,$20,$20,$20,$1c,$00\n     DC.B $00,$04,$04,$1c,$24,$24,$1c,$00,$00,$00,$1c,$24,$3c,$20,$1c,$00\n     DC.B $00,$18,$24,$20,$30,$20,$20,$00,$00,$1c,$24,$24,$1c,$04,$3c,$00\n     DC.B $00,$20,$20,$38,$24,$24,$24,$00,$00,$10,$00,$10,$10,$10,$10,$00\n     DC.B $08,$00,$08,$08,$08,$08,$28,$10,$20,$20,$24,$28,$30,$28,$24,$00\n     DC.B $10,$10,$10,$10,$10,$10,$18,$00,$00,$00,$40,$68,$54,$54,$54,$00\n     DC.B $00,$00,$28,$34,$24,$24,$24,$00,$00,$00,$1c,$22,$22,$22,$1c,$00\n     DC.B $00,$00,$38,$24,$24,$38,$20,$20,$00,$00,$1c,$24,$24,$1c,$04,$04\n     DC.B $00,$00,$2c,$30,$20,$20,$20,$00,$00,$00,$1c,$20,$1c,$02,$3c,$00\n     DC.B $00,$10,$3c,$10,$10,$14,$08,$00,$00,$00,$24,$24,$24,$24,$1a,$00\n     DC.B $00,$00,$24,$24,$24,$14,$18,$00,$00,$00,$92,$92,$92,$5a,$6c,$00\n     DC.B $00,$00,$22,$14,$08,$14,$22,$00,$00,$00,$24,$24,$1c,$04,$18,$00\n     DC.B $00,$00,$3c,$04,$18,$20,$3c,$00,$00,$08,$10,$10,$20,$10,$10,$08\n     DC.B $18,$18,$18,$18,$18,$18,$18,$18,$00,$10,$08,$08,$04,$08,$08,$10\n     DC.B $00,$00,$00,$30,$4a,$04,$00,$00,$1c,$7f,$00,$7f,$55,$55,$55,$00\nFont_End:\n\nVDPSettings:\n\tDC.B $04 ; 0 mode register 1\t\t\t\t\t\t\t\t\t\t\t---H-1M-\n\tDC.B $04 ; 1 mode register 2\t\t\t\t\t\t\t\t\t\t\t-DVdP---\n\tDC.B $30 ; 2 name table base for scroll A (A=top 3 bits)\t\t\t\t--AAA--- = $C000\n\tDC.B $3C ; 3 name table base for window (A=top 4 bits / 5 in H40 Mode)\t--AAAAA- = $F000\n\tDC.B $07 ; 4 name table base for scroll B (A=top 3 bits)\t\t\t\t-----AAA = $E000\n\tDC.B $6C ; 5 sprite attribute table base (A=top 7 bits / 6 in H40)\t\t-AAAAAAA = $D800\n\tDC.B $00 ; 6 unused register\t\t\t\t\t\t\t\t\t\t\t--------\n\tDC.B $00 ; 7 background color (P=Palette C=Color)\t\t\t\t\t\t--PPCCCC\n\tDC.B $00 ; 8 unused register\t\t\t\t\t\t\t\t\t\t\t--------\n\tDC.B $00 ; 9 unused register\t\t\t\t\t\t\t\t\t\t\t--------\n\tDC.B $FF ;10 H interrupt register (L=Number of lines)\t\t\t\t\tLLLLLLLL\n\tDC.B $00 ;11 mode register 3\t\t\t\t\t\t\t\t\t\t\t----IVHL\n\tDC.B $81 ;12 mode register 4 (C bits both1 = H40 Cell)\t\t\t\t\tC---SIIC\n\tDC.B $37 ;13 H scroll table base (A=Top 6 bits)\t\t\t\t\t\t\t--AAAAAA = $FC00\n\tDC.B $00 ;14 unused register\t\t\t\t\t\t\t\t\t\t\t--------\n\tDC.B $02 ;15 auto increment (After each Read/Write)\t\t\t\t\t\tNNNNNNNN\n\tDC.B $01 ;16 scroll size (Horiz & Vert size of ScrollA & B)\t\t\t\t--VV--HH = 64x32 tiles\n\tDC.B $00 ;17 window H position (D=Direction C=Cells)\t\t\t\t\tD--CCCCC\n\tDC.B $00 ;18 window V position (D=Direction C=Cells)\t\t\t\t\tD--CCCCC\n\tDC.B $FF ;19 DMA length count low\t\t\t\t\t\t\t\t\t\tLLLLLLLL\n\tDC.B $FF ;20 DMA length count high\t\t\t\t\t\t\t\t\t\tHHHHHHHH\n\tDC.B $00 ;21 DMA source address low\t\t\t\t\t\t\t\t\t\tLLLLLLLL\n\tDC.B $00 ;22 DMA source address mid\t\t\t\t\t\t\t\t\t\tMMMMMMMM\n\tDC.B $80 ;23 DMA source address high (C=CMD)\t\t\t\t\t\t\tCCHHHHHH\nVDPSettingsEnd:\n\teven\n"
                },
                {
                    "language": "VBScript",
                    "solution": "'----------------15 game-------------------------------------\n'WARNING: this script uses ANSI escape codes to position items on console so\n'it won't work in Windows from XP to 8.1 where Microsoft removed ANSI support...\n'Windows 10, 11 or 98 are ok!!!\n\noption explicit\nconst maxshuffle=100 'level\n\ndim ans0:ans0=chr(27)&\"[\"\ndim anscls:anscls=ans0 & \"2J\"\n\ndim dirs:dirs=array(6,-1,-6,1)\ndim a:a=array(-1,-1,-1,-1,-1,-1,_\n              -1, 1, 2, 3, 4,-1,_\n              -1, 5, 6, 7, 8,-1,_\n              -1, 9,10,11,12,-1,_\n              -1,13,14,15, 0,-1,_\n              -1,-1,-1,-1,-1,-1)\ndim b(35)\ndim pos0\ndim s:s=Array(\"W+Enter: up   Z+Enter: down  A+Enter: left   S+Enter right \",_\n              \"Bad move!!                                                 \",_\n\t      \"You did it! Another game? [y/n]+Enter                      \",_\n\t      \"Bye!                                                       \")\n\n\ndo\n  shuffle\n  draw\n  toxy 10,1,s(0)\n  do\n   if usr(wait()) then\n     draw\n     toxy 10,1,s(0)\n   else \t\n     toxy 10,1,s(1)\n   end if\n  loop until checkend\n  toxy 10,1,s(2)\nloop until wait()=\"n\"\ntoxy 10,1,s(3)\n\nfunction wait():\n toxy 11,1,\"\":\n wait=left(lcase(wscript.stdin.readline),1):\t\nend function\n\nsub toxy(x,y,s)\n wscript.StdOut.Write ans0 & x & \";\" & y & \"H\"& \" \"& s\nend sub\n\nsub draw\n  dim i,j\n  wscript.stdout.write anscls\n  for i=0 to 3 'row\n    for j=0 to 3  'col\n      toxy (j*2)+2,(i*3)+3,iif(b(j*6+i+7)<>0,b(j*6+i+7),\" \")\n    next\n  next\n  toxy 10,1,\"\"\nend sub\n\n\nfunction checkend\n  dim i\n  for i=0 to ubound(a)\n   if (b(i)<>a(i)) then checkend=false : exit function\n  next\n  checkend=true\nend function\t\n\nfunction move(d)\n dim p1\n p1=pos0+d\n if b(p1) <>-1 then\n    b(pos0)=b(p1):\n    b(p1)=0:\n    pos0=p1:\n    move=true\n else\n   move=false\n end if\nend function\n\nsub shuffle\n  dim cnt,r,i\n   randomize timer\n   for i=0 to ubound(a):b(i)=a(i):next\n   pos0=28\n   cnt=0\n   do\n     r=int(rnd*4)\n     if move(dirs(r))=true then cnt=cnt+1\n   loop until cnt=maxshuffle\nend sub\t\n\nfunction iif(a,b,c): if a then iif=b else iif=c end if:end function\t\t\t\n\nfunction usr(a)\n  dim d\n  select case lcase(a)\n  case \"w\" :d=-6\n  case \"z\" :d=6\n  case \"a\" :d=-1\n  case \"s\" :d=1\n  end select\n  usr= move(d)\nend function\t\n"
                }
            ],
            [
                {
                    "language": "Fortran",
                    "solution": "      SUBROUTINE SWAP(I,J)\t!Alas, furrytran does not provide this.\n       INTEGER I,J,T\t\t!So, we're stuck with supplying the obvious.\n        T = I\t\t\t!And, only for one type at a go.\n        I = J\t\t\t!One could define a MODULE containing a collection\n        J = T\t\t\t!And thence a \"generic\" routine,\n      END SUBROUTINE SWAP\t!But this will do for now.\n\n      SUBROUTINE SHOW(NR,NC,BOARD)\t!The layout won't work for NC > 99...\n       INTEGER NR,NC\t\t!Number of rows and columns.\n       INTEGER BOARD(NC,NR)\t!The board is stored transposed!\n       INTEGER I\t\t!A stepper.\n       COMMON/IODEV/ MSG\t!I talk to the trees...\n        WRITE (MSG,1) (I,I = 1,NC)\t!Prepare a heading.\n    1   FORMAT (\"Row|\",9(\"__\",I1,:),90(\"_\",I2,:))\t!This should suffice.\n        DO I = 1,NR\t\t!Chug down the rows.\n          WRITE (MSG,2) I,BOARD(1:NC,I)\t!The columns of the row. Usage is BOARD(column,row).\n    2     FORMAT (I3,\"|\",99I3)\t!Could use parameters, but enough.\n        END DO\t\t\t!On to the next row.\n      END SUBROUTINE SHOW\t!That was nice.\n\n      PROGRAM PUZZLE\n      INTEGER LOCN(2),NR,NC,N\t!Describes the shape of the board.\n      INTEGER LOCZ(2),ZC,ZR\t!Fingers the location of the \"blank\" square.\n      INTEGER LOCI(2),IC,IR\t!Fingers a location.\nCan't EQUIVALENCE (LOCN(1),NC),(LOCN(2),NR)\t!This usage and a PARAMETER statement is too scary.\n      EQUIVALENCE (LOCZ(1),ZC),(LOCZ(2),ZR)\t!Annotate my (column,row) usage.\n      EQUIVALENCE (LOCI(1),IC),(LOCI(2),IR)\t!Rather than the displayed (row,column) style.\n      PARAMETER (NR = 4, NC = 4, N = NR*NC)\t!Determine the shape of the board.\n      INTEGER BOARD(NC,NR)\t\t!Thus transpose furrytran's column-major usage. Beware!!!\n      INTEGER BORED(N)\t\t\t!This allows for consecutive comparisons.\n      EQUIVALENCE (BOARD,BORED)\t\t!Because the arrays are in the same place.\n      INTEGER WAYS\t\t\t!Now define adjacency.\n      PARAMETER (WAYS = 4)\t\t!Just orthogonal neghbours.\n      INTEGER WAY(2,WAYS)\t\t!Now list the allowed adjacencies.\n      PARAMETER (WAY = (/1,0, 0,1, -1,0, 0,-1/))\t!W(1,1), W(2,1), W(1,2), W(2,2), W(1,3), ...\n      INTEGER M,MOVE(WAYS),LOCM(2,WAYS)\t!Move possibilities.\n      INTEGER SPACE\t\t\t!Document the empty square's code number.\n      PARAMETER (SPACE = 0)\t\t!Zero will do.\n      INTEGER I,IT,PARITY,TRY\t\t!Odds and ends.\n      REAL VALUE\t\t\t!Humph. Yet another interface to a \"random\" number generator.\n      COMMON/IODEV/ MSG,KBD\t!Pass the word.\n\n      KBD = 5\t!Standard input. (Keyboard -> Display screen)\n      MSG = 6\t!Standard output. (Display screen)\n      WRITE (MSG,1) NR,NC\t!Announce.\n    1 FORMAT (\"To play 'slide-square' with \",I0,\" rows and \",\n     1 I0,\" columns.\",/,\"The game is to slide a square into the space\",/\n     2 \"(thus leaving a space behind) until you attain\"/\n     3 \"the nice orderly layout as follows:\",/)\nConcoct a board layout.\n   10 FOR ALL (I = 1:N - 1) BORED(I) = I\t!Prepare the board. Definitely unique values.\n      BORED(N) = SPACE\t        !The empty square is not at the start! Oh well.\n      CALL SHOW(NR,NC,BOARD)\t!Reveal the nice layout.\n   11 DO I = 1,N - 1\t\t!Now shuffle the squares a bit.\n        CALL RANDOM(VALUE)\t\t!0 <= VALUE < 1.\n        IT = VALUE*(N - 1) + 1\t\t!1 <= IT < N. Don't round up!\n        IF (I.NE.IT) CALL SWAP(BORED(I),BORED(IT))\t!Whee!\n      END DO\t\t\t!On to the next victim, leaving the last cell alone.\nCalculate the parity, knowing the space is at the end. The target state has even parity, with zero inversions.\n      PARITY = 0\t!There are two classes of arrangements, that can't mix.\n      DO I = 1,N - 2\t!Skipping the blank cell still at BORED(N).\n        PARITY = PARITY + COUNT(BORED(I) > BORED(I + 1:N - 1))\t!For each square,\n      END DO\t\t!Count the inversions following.\n      IF (MOD(PARITY,2).NE.0) GO TO 11\t!No transition can change the parity, so, try for another arrangement.\nChoose a new position for the space. Using approved moves will not change the parity.\n      CALL RANDOM(VALUE)\t\t!0 <= VALUE < 1.\n      ZC = VALUE*(NC - 2) + 1\t\t!1 <= ZC < NC: Choose a random column other than the last.\n      BOARD(ZC + 1:NC,NR) = BOARD(ZC:NC - 1,NR)\t!Shift the end of the last row back one place.\n      BOARD(ZC,NR) = SPACE\t\t\t!Put the space in the hole.\n      CALL RANDOM(VALUE)\t\t\t!So the parity doesn't change.\n      ZR = VALUE*(NR - 2) + 1\t\t!1 <= ZR < NR: Choose a random row, other than the last.\n      BOARD(ZC,ZR + 1:NR) = BOARD(ZC,ZR:NR - 1)\t!Shift the end of column ZC up one.\n      BOARD(ZC,ZR) = SPACE\t\t\t!Revive the space again.\nCast forth the starting position.\n      WRITE (MSG,12)\t\t!Announce the result.\n   12 FORMAT (/,\"But, your board looks like this...\")\t!Alas. Almost certainly not in order.\n      CALL SHOW(NR,NC,BOARD)\t!Just so.\n      TRY = 0\t\t!No moves made yet.\n\nConsider possible moves.\n   20 TRY = TRY + 1\t!Here we go again.\n      M = 0\t\t!No moveable pieces are known.\n      DO I = 1,WAYS\t!So scan the possible ways away from LOCZ.\n        LOCI = LOCZ + WAY(1:2,I)\t!Finger an adjacent location, via the adjacency offsets in array WAY.\n        IF (ALL(LOCI > 0) .AND. ALL(LOCI <= (/NC,NR/))) THEN\t!Within bounds?\n          M = M + 1\t\t\t!Yes. We have a candidate.\n          MOVE(M) = BOARD(IC,IR)\t!Record the piece's name.\n          LOCM(:,M) = LOCI\t\t!And, remember where it is...\n        END IF\t\t\t!So much for that location.\n      END DO\t\t!Try another offset.\n   21 WRITE (MSG,22,ADVANCE=\"no\") MOVE(1:M)\t!Two-stage output.\n   22 FORMAT (\"Moveable pieces: \",<WAYS>(I0:\",\"))\t!Since M is not necessarily WAYS, a trailing $ may not be reached..\n      WRITE (MSG,23)\t\t!Now for the question. Always at least two moveable squares.\n   23 FORMAT(\". Choose one: \",$)\t!Continue the line, presuming screen and keyboard->screen.\n      READ (KBD,*) IT\t\t!Now request the answer. Rather doggedly: blank lines won't do.\n      DO I = M,1,-1\t\t!There are at least two possible moves.\n        IF (MOVE(I) .EQ. IT) EXIT\t!Perhaps this piece was selected.\n      END DO\t\t\t!The INDEX function is alas, only for CHARACTER variables. Grr.\n      IF (I .LE. 0) THEN\t!I'm suspicious.\n        WRITE (MSG,*) \"Huh? That is not a moveable piece!\"\t!Justified!\n        IF (IT.GT.0) GO TO 21\t\t!Try again.\n        STOP \"Oh well.\"\t\t\t!Or quit, on negative vibrations.\n      END IF\t\t\t!So much for selecting a piece.\nComplete the selected move.\n   30 BOARD(ZC,ZR) = IT\t\t!Place the named piece where the space was.\n      LOCZ = LOCM(:,I)\t\t!The space is now where that piece came from.\n      BOARD(ZC,ZR) = SPACE\t\t!And now holds a space.\nc      write (6,*)\nc     1 \"disorder=\",COUNT(BORED(1:N - 2) + 1 .NE. BORED(2:N - 1))\n      IF (TRY.LE.6) WRITE (MSG,31)\t!Set off with a nice heading.\n   31 FORMAT (/\"The new layout...\")\t!Just for clarity.\n      CALL SHOW(NR,NC,BOARD)\t\t!Perhaps it will be good.\nCheck for success.\n      IF (BORED(N).NE.SPACE) GO TO 20\t!Is the space at the end?\n      IF (ANY(BORED(1:N - 2) + 1 .NE. BORED(2:N - 1))) GO TO 20\t!Are we there yet?\n      WRITE (MSG,*) TRY,\"Steps to success!\"\t!Yes!\n      END\t!That was fun.\n"
                },
                {
                    "language": "J",
                    "solution": "   game''\n15 puzzle\nh for help, q to quit\ncurrent board:\n\u250c\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u2510\n\u25021 \u25022 \u25023 \u25024 \u2502\n\u251c\u2500\u2500\u253c\u2500\u2500\u253c\u2500\u2500\u253c\u2500\u2500\u2524\n\u25025 \u25026 \u25027 \u25028 \u2502\n\u251c\u2500\u2500\u253c\u2500\u2500\u253c\u2500\u2500\u253c\u2500\u2500\u2524\n\u25029 \u250210\u2502  \u250211\u2502\n\u251c\u2500\u2500\u253c\u2500\u2500\u253c\u2500\u2500\u253c\u2500\u2500\u2524\n\u250213\u250214\u250215\u250212\u2502\n\u2514\u2500\u2500\u2534\u2500\u2500\u2534\u2500\u2500\u2534\u2500\u2500\u2518\nValid moves: 7 10 11 15\nmove which number? 11\ncurrent board:\n\u250c\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u2510\n\u25021 \u25022 \u25023 \u25024 \u2502\n\u251c\u2500\u2500\u253c\u2500\u2500\u253c\u2500\u2500\u253c\u2500\u2500\u2524\n\u25025 \u25026 \u25027 \u25028 \u2502\n\u251c\u2500\u2500\u253c\u2500\u2500\u253c\u2500\u2500\u253c\u2500\u2500\u2524\n\u25029 \u250210\u250211\u2502  \u2502\n\u251c\u2500\u2500\u253c\u2500\u2500\u253c\u2500\u2500\u253c\u2500\u2500\u2524\n\u250213\u250214\u250215\u250212\u2502\n\u2514\u2500\u2500\u2534\u2500\u2500\u2534\u2500\u2500\u2534\u2500\u2500\u2518\nValid moves: 8 11 12\nmove which number? 12\ncurrent board:\n\u250c\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u2510\n\u25021 \u25022 \u25023 \u25024 \u2502\n\u251c\u2500\u2500\u253c\u2500\u2500\u253c\u2500\u2500\u253c\u2500\u2500\u2524\n\u25025 \u25026 \u25027 \u25028 \u2502\n\u251c\u2500\u2500\u253c\u2500\u2500\u253c\u2500\u2500\u253c\u2500\u2500\u2524\n\u25029 \u250210\u250211\u250212\u2502\n\u251c\u2500\u2500\u253c\u2500\u2500\u253c\u2500\u2500\u253c\u2500\u2500\u2524\n\u250213\u250214\u250215\u2502  \u2502\n\u2514\u2500\u2500\u2534\u2500\u2500\u2534\u2500\u2500\u2534\u2500\u2500\u2518\nYou win.\n"
                }
            ]
        ]
    },
    {
        "task_name": "15-puzzle-solver",
        "task_description": "Your task is to write a program that finds a solution in the fewest moves possible single moves to a random [[wp:15_puzzle|Fifteen Puzzle Game]].<br />\nFor this task you will be using the following puzzle:<br />\n<pre>15 14  1  6\n 9 11  4 12\n 0 10  7  3\n13  8  5  2</pre>\n<br />\nSolution:<pre>\n 1  2  3  4\n 5  6  7  8\n 9 10 11 12\n13 14 15  0\n</pre>\n\nThe output must show the moves' directions, like so: left, left, left, down, right... and so on.<br />\nThere are two solutions, of fifty-two moves:<br>\nrrrulddluuuldrurdddrullulurrrddldluurddlulurruldrdrd<br>\nrrruldluuldrurdddluulurrrdlddruldluurddlulurruldrrdd<br>\nsee: [http://www.rosettacode.org/wiki/15_puzzle_solver/Optimal_solution Pretty Print of Optimal Solution]\n\nFinding either one, or both is an acceptable result.<br>\n\n;Extra credit.\nSolve the following problem:\n<pre>\n  0 12  9 13\n 15 11 10 14\n  3  7  2  5\n  4  8  6  1\n</pre>\n\n\n;Related Task:\n* [[15_Puzzle_Game|15 puzzle game]]\n* [[A* search algorithm]]\n<br><br>\n",
        "solution_pairs": [
            [
                {
                    "language": "C++",
                    "solution": "int main (){\n  fifteenSolver start(0,0x0c9dfbae37254861);\n  start.Solve();\n}\n"
                },
                {
                    "language": "Phix",
                    "solution": "-->\n <span style=\"color: #000080;font-style:italic;\">-- demo\\rosetta\\Solve15puzzle.exw</span>\n <span style=\"color: #008080;\">constant</span> <span style=\"color: #000000;\">STM</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #000000;\">0</span>    <span style=\"color: #000080;font-style:italic;\">-- single-tile metrics.</span>\n <span style=\"color: #008080;\">constant</span> <span style=\"color: #000000;\">MTM</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #000000;\">0</span>    <span style=\"color: #000080;font-style:italic;\">-- multi-tile metrics.</span>\n <span style=\"color: #008080;\">if</span> <span style=\"color: #000000;\">STM</span> <span style=\"color: #008080;\">and</span> <span style=\"color: #000000;\">MTM</span> <span style=\"color: #008080;\">then</span> <span style=\"color: #0000FF;\">?<span style=\"color: #000000;\">9<span style=\"color: #0000FF;\">/<span style=\"color: #000000;\">0</span> <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">if</span> <span style=\"color: #000080;font-style:italic;\">-- both prohibited\n --  0       0   -- fastest, but non-optimal\n --  1       0   -- optimal in STM\n --  0       1   -- optimal in MTM (slowest by far)\n\n --Note: The fast method uses an inadmissible heuristic - see \"not STM\" in iddfs().\n --      It explores mtm-style using the higher stm heuristic and may therefore\n --      fail badly in some cases.</span>\n\n <span style=\"color: #008080;\">constant</span> <span style=\"color: #000000;\">SIZE</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #000000;\">4</span>\n\n <span style=\"color: #008080;\">constant</span> <span style=\"color: #000000;\">goal</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #0000FF;\">{</span> <span style=\"color: #000000;\">1<span style=\"color: #0000FF;\">,</span> <span style=\"color: #000000;\">2<span style=\"color: #0000FF;\">,</span> <span style=\"color: #000000;\">3<span style=\"color: #0000FF;\">,</span> <span style=\"color: #000000;\">4<span style=\"color: #0000FF;\">,</span>\n                   <span style=\"color: #000000;\">5<span style=\"color: #0000FF;\">,</span> <span style=\"color: #000000;\">6<span style=\"color: #0000FF;\">,</span> <span style=\"color: #000000;\">7<span style=\"color: #0000FF;\">,</span> <span style=\"color: #000000;\">8<span style=\"color: #0000FF;\">,</span>\n                   <span style=\"color: #000000;\">9<span style=\"color: #0000FF;\">,<span style=\"color: #000000;\">10<span style=\"color: #0000FF;\">,<span style=\"color: #000000;\">11<span style=\"color: #0000FF;\">,<span style=\"color: #000000;\">12<span style=\"color: #0000FF;\">,</span>\n                  <span style=\"color: #000000;\">13<span style=\"color: #0000FF;\">,<span style=\"color: #000000;\">14<span style=\"color: #0000FF;\">,<span style=\"color: #000000;\">15<span style=\"color: #0000FF;\">,</span> <span style=\"color: #000000;\">0<span style=\"color: #0000FF;\">}</span>\n\n <span style=\"color: #000080;font-style:italic;\">--\n -- multi-tile-metric walking distance heuristic lookup (mmwd).\n -- ==========================================================\n -- Uses patterns of counts of tiles in/from row/col, eg the solved state\n --  (ie goal above) could be represented by the following:\n --      {{4,0,0,0},\n --       {0,4,0,0},\n --       {0,0,4,0},\n --       {0,0,0,3}}\n --  ie row/col 1 contains 4 tiles from col/row 1, etc. In this case\n --  both are identical, but you can count row/col or col/row, and then\n --  add them together. There are up to 24964 possible patterns. The\n --  blank space is not counted. Note that a vertical move cannot change\n --  a vertical pattern, ditto horizontal, and basic symmetry means that\n --  row/col and col/row patterns will match (at least, that is, if they\n --  are calculated sympathetically), halving the setup cost.\n -- The data is just the number of moves made before this pattern was\n --  first encountered, in a breadth-first search, backwards from the\n --  goal state, until all patterns have been enumerated.\n -- (The same ideas/vars are now also used for stm metrics when MTM=0)\n --</span>\n <span style=\"color: #004080;\">sequence</span> <span style=\"color: #000000;\">wdkey</span>              <span style=\"color: #000080;font-style:italic;\">-- one such 4x4 pattern</span>\n <span style=\"color: #008080;\">constant</span> <span style=\"color: #000000;\">mmwd</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">new_dict<span style=\"color: #0000FF;\">(<span style=\"color: #0000FF;\">)</span>  <span style=\"color: #000080;font-style:italic;\">-- lookup table, data is walking distance.\n\n\n --\n -- We use two to-do lists: todo is the current list, and everything\n -- of walkingdistance+1 ends up on tdnx. Once todo is exhausted, we\n -- swap the dictionary-ids, so tdnx automatically becomes empty.\n -- Key is an mmwd pattern as above, and data is {distance,space_idx}.\n --</span>\n <span style=\"color: #004080;\">integer</span> <span style=\"color: #000000;\">todo</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">new_dict<span style=\"color: #0000FF;\">(<span style=\"color: #0000FF;\">)</span>\n <span style=\"color: #004080;\">integer</span> <span style=\"color: #000000;\">tdnx</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">new_dict<span style=\"color: #0000FF;\">(<span style=\"color: #0000FF;\">)</span>\n\n <span style=\"color: #000080;font-style:italic;\">--</span>\n\n <span style=\"color: #008080;\">enum</span> <span style=\"color: #000000;\">UP</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #000000;\">1<span style=\"color: #0000FF;\">,</span> <span style=\"color: #000000;\">DOWN</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #0000FF;\">-<span style=\"color: #000000;\">1</span>\n\n <span style=\"color: #008080;\">procedure</span> <span style=\"color: #000000;\">explore<span style=\"color: #0000FF;\">(<span style=\"color: #004080;\">integer</span> <span style=\"color: #000000;\">space_idx<span style=\"color: #0000FF;\">,</span> <span style=\"color: #000000;\">walking_distance<span style=\"color: #0000FF;\">,</span> <span style=\"color: #000000;\">direction<span style=\"color: #0000FF;\">)</span>\n <span style=\"color: #000080;font-style:italic;\">--\n --  Given a space index, explore all the possible moves in direction,\n --  setting the distance and extending the tdnx table.\n --</span>\n <span style=\"color: #004080;\">integer</span> <span style=\"color: #000000;\">tile_idx</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #000000;\">space_idx<span style=\"color: #0000FF;\">+<span style=\"color: #000000;\">direction</span>\n     <span style=\"color: #008080;\">for</span> <span style=\"color: #000000;\">group<span style=\"color: #0000FF;\">=<span style=\"color: #000000;\">1</span> <span style=\"color: #008080;\">to</span> <span style=\"color: #000000;\">SIZE</span> <span style=\"color: #008080;\">do</span>\n         <span style=\"color: #008080;\">if</span> <span style=\"color: #000000;\">wdkey<span style=\"color: #0000FF;\">[<span style=\"color: #000000;\">tile_idx<span style=\"color: #0000FF;\">]<span style=\"color: #0000FF;\">[<span style=\"color: #000000;\">group<span style=\"color: #0000FF;\">]</span> <span style=\"color: #008080;\">then</span>\n             <span style=\"color: #000080;font-style:italic;\">-- ie: check row tile_idx for tiles belonging to rows 1..4\n             -- Swap one of those tiles with the space</span>\n             <span style=\"color: #000000;\">wdkey<span style=\"color: #0000FF;\">[<span style=\"color: #000000;\">tile_idx<span style=\"color: #0000FF;\">]<span style=\"color: #0000FF;\">[<span style=\"color: #000000;\">group<span style=\"color: #0000FF;\">]</span> <span style=\"color: #0000FF;\">-=</span> <span style=\"color: #000000;\">1</span>\n             <span style=\"color: #000000;\">wdkey<span style=\"color: #0000FF;\">[<span style=\"color: #000000;\">space_idx<span style=\"color: #0000FF;\">]<span style=\"color: #0000FF;\">[<span style=\"color: #000000;\">group<span style=\"color: #0000FF;\">]</span> <span style=\"color: #0000FF;\">+=</span> <span style=\"color: #000000;\">1</span>\n\n             <span style=\"color: #008080;\">if</span> <span style=\"color: #7060A8;\">getd_index<span style=\"color: #0000FF;\">(<span style=\"color: #000000;\">wdkey<span style=\"color: #0000FF;\">,<span style=\"color: #000000;\">mmwd<span style=\"color: #0000FF;\">)<span style=\"color: #0000FF;\">=<span style=\"color: #000000;\">0</span> <span style=\"color: #008080;\">then</span>\n                 <span style=\"color: #000080;font-style:italic;\">-- save the walking distance value</span>\n                 <span style=\"color: #7060A8;\">setd<span style=\"color: #0000FF;\">(<span style=\"color: #000000;\">wdkey<span style=\"color: #0000FF;\">,<span style=\"color: #000000;\">walking_distance<span style=\"color: #0000FF;\">+<span style=\"color: #000000;\">1<span style=\"color: #0000FF;\">,<span style=\"color: #000000;\">mmwd<span style=\"color: #0000FF;\">)</span>\n                 <span style=\"color: #000080;font-style:italic;\">-- and add to the todo next list:</span>\n                 <span style=\"color: #008080;\">if</span> <span style=\"color: #7060A8;\">getd_index<span style=\"color: #0000FF;\">(<span style=\"color: #000000;\">wdkey<span style=\"color: #0000FF;\">,<span style=\"color: #000000;\">tdnx<span style=\"color: #0000FF;\">)<span style=\"color: #0000FF;\">!=<span style=\"color: #000000;\">0</span> <span style=\"color: #008080;\">then</span> <span style=\"color: #0000FF;\">?<span style=\"color: #000000;\">9<span style=\"color: #0000FF;\">/<span style=\"color: #000000;\">0</span> <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">if</span>\n                 <span style=\"color: #7060A8;\">setd<span style=\"color: #0000FF;\">(<span style=\"color: #000000;\">wdkey<span style=\"color: #0000FF;\">,<span style=\"color: #0000FF;\">{<span style=\"color: #000000;\">walking_distance<span style=\"color: #0000FF;\">+<span style=\"color: #000000;\">1<span style=\"color: #0000FF;\">,<span style=\"color: #000000;\">tile_idx<span style=\"color: #0000FF;\">}<span style=\"color: #0000FF;\">,<span style=\"color: #000000;\">tdnx<span style=\"color: #0000FF;\">)</span>\n             <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">if</span>\n\n <span style=\"color: #008080;\">if</span> <span style=\"color: #000000;\">MTM</span> <span style=\"color: #008080;\">then</span>\n             <span style=\"color: #008080;\">if</span> <span style=\"color: #000000;\">tile_idx<span style=\"color: #0000FF;\">><span style=\"color: #000000;\">1</span> <span style=\"color: #008080;\">and</span> <span style=\"color: #000000;\">tile_idx<span style=\"color: #0000FF;\"><<span style=\"color: #000000;\">SIZE</span> <span style=\"color: #008080;\">then</span>\n                 <span style=\"color: #000080;font-style:italic;\">-- mtm: same direction means same distance:</span>\n                 <span style=\"color: #000000;\">explore<span style=\"color: #0000FF;\">(<span style=\"color: #000000;\">tile_idx<span style=\"color: #0000FF;\">,</span> <span style=\"color: #000000;\">walking_distance<span style=\"color: #0000FF;\">,</span> <span style=\"color: #000000;\">direction<span style=\"color: #0000FF;\">)</span>\n             <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">if</span>\n <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">if</span>\n\n             <span style=\"color: #000080;font-style:italic;\">-- Revert the swap so we can look at the next candidate.</span>\n             <span style=\"color: #000000;\">wdkey<span style=\"color: #0000FF;\">[<span style=\"color: #000000;\">tile_idx<span style=\"color: #0000FF;\">]<span style=\"color: #0000FF;\">[<span style=\"color: #000000;\">group<span style=\"color: #0000FF;\">]</span> <span style=\"color: #0000FF;\">+=</span> <span style=\"color: #000000;\">1</span>\n             <span style=\"color: #000000;\">wdkey<span style=\"color: #0000FF;\">[<span style=\"color: #000000;\">space_idx<span style=\"color: #0000FF;\">]<span style=\"color: #0000FF;\">[<span style=\"color: #000000;\">group<span style=\"color: #0000FF;\">]</span> <span style=\"color: #0000FF;\">-=</span> <span style=\"color: #000000;\">1</span>\n         <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">if</span>\n     <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">for</span>\n <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">procedure</span>\n\n <span style=\"color: #008080;\">procedure</span> <span style=\"color: #000000;\">generate_mmwd<span style=\"color: #0000FF;\">(<span style=\"color: #0000FF;\">)</span>\n <span style=\"color: #000080;font-style:italic;\">-- Perform a breadth-first search begining with the solved puzzle state\n --  and exploring from there until no more new patterns emerge.</span>\n <span style=\"color: #004080;\">integer</span> <span style=\"color: #000000;\">walking_distance</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #000000;\">0<span style=\"color: #0000FF;\">,</span> <span style=\"color: #000000;\">space</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #000000;\">4</span>\n\n     <span style=\"color: #000000;\">wdkey</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #0000FF;\">{<span style=\"color: #0000FF;\">{<span style=\"color: #000000;\">4<span style=\"color: #0000FF;\">,<span style=\"color: #000000;\">0<span style=\"color: #0000FF;\">,<span style=\"color: #000000;\">0<span style=\"color: #0000FF;\">,<span style=\"color: #000000;\">0<span style=\"color: #0000FF;\">}<span style=\"color: #0000FF;\">,</span> <span style=\"color: #000080;font-style:italic;\">-- \\</span>\n              <span style=\"color: #0000FF;\">{<span style=\"color: #000000;\">0<span style=\"color: #0000FF;\">,<span style=\"color: #000000;\">4<span style=\"color: #0000FF;\">,<span style=\"color: #000000;\">0<span style=\"color: #0000FF;\">,<span style=\"color: #000000;\">0<span style=\"color: #0000FF;\">}<span style=\"color: #0000FF;\">,</span> <span style=\"color: #000080;font-style:italic;\">--  } 4 tiles in correct row positions</span>\n              <span style=\"color: #0000FF;\">{<span style=\"color: #000000;\">0<span style=\"color: #0000FF;\">,<span style=\"color: #000000;\">0<span style=\"color: #0000FF;\">,<span style=\"color: #000000;\">4<span style=\"color: #0000FF;\">,<span style=\"color: #000000;\">0<span style=\"color: #0000FF;\">}<span style=\"color: #0000FF;\">,</span> <span style=\"color: #000080;font-style:italic;\">-- /</span>\n              <span style=\"color: #0000FF;\">{<span style=\"color: #000000;\">0<span style=\"color: #0000FF;\">,<span style=\"color: #000000;\">0<span style=\"color: #0000FF;\">,<span style=\"color: #000000;\">0<span style=\"color: #0000FF;\">,<span style=\"color: #000000;\">3<span style=\"color: #0000FF;\">}<span style=\"color: #0000FF;\">}</span> <span style=\"color: #000080;font-style:italic;\">--    3 tiles in correct row position</span>\n     <span style=\"color: #7060A8;\">setd<span style=\"color: #0000FF;\">(<span style=\"color: #000000;\">wdkey<span style=\"color: #0000FF;\">,<span style=\"color: #000000;\">walking_distance<span style=\"color: #0000FF;\">,<span style=\"color: #000000;\">mmwd<span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #008080;\">while</span> <span style=\"color: #000000;\">1</span> <span style=\"color: #008080;\">do</span>\n         <span style=\"color: #008080;\">if</span> <span style=\"color: #000000;\">space<span style=\"color: #0000FF;\"><<span style=\"color: #000000;\">4</span> <span style=\"color: #008080;\">then</span> <span style=\"color: #000000;\">explore<span style=\"color: #0000FF;\">(<span style=\"color: #000000;\">space<span style=\"color: #0000FF;\">,</span> <span style=\"color: #000000;\">walking_distance<span style=\"color: #0000FF;\">,</span> <span style=\"color: #000000;\">UP<span style=\"color: #0000FF;\">)</span>    <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">if</span>\n         <span style=\"color: #008080;\">if</span> <span style=\"color: #000000;\">space<span style=\"color: #0000FF;\">><span style=\"color: #000000;\">1</span> <span style=\"color: #008080;\">then</span> <span style=\"color: #000000;\">explore<span style=\"color: #0000FF;\">(<span style=\"color: #000000;\">space<span style=\"color: #0000FF;\">,</span> <span style=\"color: #000000;\">walking_distance<span style=\"color: #0000FF;\">,</span> <span style=\"color: #000000;\">DOWN<span style=\"color: #0000FF;\">)</span> <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">if</span>\n         <span style=\"color: #008080;\">if</span> <span style=\"color: #7060A8;\">dict_size<span style=\"color: #0000FF;\">(<span style=\"color: #000000;\">todo<span style=\"color: #0000FF;\">)<span style=\"color: #0000FF;\">=<span style=\"color: #000000;\">0</span> <span style=\"color: #008080;\">then</span>\n             <span style=\"color: #008080;\">if</span> <span style=\"color: #7060A8;\">dict_size<span style=\"color: #0000FF;\">(<span style=\"color: #000000;\">tdnx<span style=\"color: #0000FF;\">)<span style=\"color: #0000FF;\">=<span style=\"color: #000000;\">0</span> <span style=\"color: #008080;\">then</span> <span style=\"color: #008080;\">exit</span> <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">if</span>\n             <span style=\"color: #0000FF;\">{<span style=\"color: #000000;\">todo<span style=\"color: #0000FF;\">,<span style=\"color: #000000;\">tdnx<span style=\"color: #0000FF;\">}</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #0000FF;\">{<span style=\"color: #000000;\">tdnx<span style=\"color: #0000FF;\">,<span style=\"color: #000000;\">todo<span style=\"color: #0000FF;\">}</span>\n         <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">if</span>\n         <span style=\"color: #000000;\">wdkey</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">getd_partial_key<span style=\"color: #0000FF;\">(<span style=\"color: #000000;\">0<span style=\"color: #0000FF;\">,<span style=\"color: #000000;\">todo<span style=\"color: #0000FF;\">)</span>\n         <span style=\"color: #0000FF;\">{<span style=\"color: #000000;\">walking_distance<span style=\"color: #0000FF;\">,<span style=\"color: #000000;\">space<span style=\"color: #0000FF;\">}</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">getd<span style=\"color: #0000FF;\">(<span style=\"color: #000000;\">wdkey<span style=\"color: #0000FF;\">,<span style=\"color: #000000;\">todo<span style=\"color: #0000FF;\">)</span>\n         <span style=\"color: #7060A8;\">deld<span style=\"color: #0000FF;\">(<span style=\"color: #000000;\">wdkey<span style=\"color: #0000FF;\">,<span style=\"color: #000000;\">todo<span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">while</span>\n <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">procedure</span>\n\n <span style=\"color: #008080;\">function</span> <span style=\"color: #000000;\">walking_distance<span style=\"color: #0000FF;\">(<span style=\"color: #004080;\">sequence</span> <span style=\"color: #000000;\">puzzle<span style=\"color: #0000FF;\">)</span>\n <span style=\"color: #004080;\">sequence</span> <span style=\"color: #000000;\">rkey</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">repeat<span style=\"color: #0000FF;\">(<span style=\"color: #7060A8;\">repeat<span style=\"color: #0000FF;\">(<span style=\"color: #000000;\">0<span style=\"color: #0000FF;\">,<span style=\"color: #000000;\">SIZE<span style=\"color: #0000FF;\">)<span style=\"color: #0000FF;\">,<span style=\"color: #000000;\">SIZE<span style=\"color: #0000FF;\">)<span style=\"color: #0000FF;\">,</span>\n          <span style=\"color: #000000;\">ckey</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">repeat<span style=\"color: #0000FF;\">(<span style=\"color: #7060A8;\">repeat<span style=\"color: #0000FF;\">(<span style=\"color: #000000;\">0<span style=\"color: #0000FF;\">,<span style=\"color: #000000;\">SIZE<span style=\"color: #0000FF;\">)<span style=\"color: #0000FF;\">,<span style=\"color: #000000;\">SIZE<span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #004080;\">integer</span> <span style=\"color: #000000;\">k</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #000000;\">1</span>\n     <span style=\"color: #008080;\">for</span> <span style=\"color: #000000;\">i<span style=\"color: #0000FF;\">=<span style=\"color: #000000;\">1</span> <span style=\"color: #008080;\">to</span> <span style=\"color: #000000;\">SIZE</span> <span style=\"color: #008080;\">do</span>  <span style=\"color: #000080;font-style:italic;\">-- rows</span>\n         <span style=\"color: #008080;\">for</span> <span style=\"color: #000000;\">j<span style=\"color: #0000FF;\">=<span style=\"color: #000000;\">1</span> <span style=\"color: #008080;\">to</span> <span style=\"color: #000000;\">SIZE</span> <span style=\"color: #008080;\">do</span>  <span style=\"color: #000080;font-style:italic;\">-- columns</span>\n             <span style=\"color: #004080;\">integer</span> <span style=\"color: #000000;\">tile</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #000000;\">puzzle<span style=\"color: #0000FF;\">[<span style=\"color: #000000;\">k<span style=\"color: #0000FF;\">]</span>\n             <span style=\"color: #008080;\">if</span> <span style=\"color: #000000;\">tile<span style=\"color: #0000FF;\">!=<span style=\"color: #000000;\">0</span> <span style=\"color: #008080;\">then</span>\n                 <span style=\"color: #004080;\">integer</span> <span style=\"color: #000000;\">row</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">floor<span style=\"color: #0000FF;\">(<span style=\"color: #0000FF;\">(<span style=\"color: #000000;\">tile<span style=\"color: #0000FF;\">-<span style=\"color: #000000;\">1<span style=\"color: #0000FF;\">)<span style=\"color: #0000FF;\">/<span style=\"color: #000000;\">4<span style=\"color: #0000FF;\">)<span style=\"color: #0000FF;\">+<span style=\"color: #000000;\">1<span style=\"color: #0000FF;\">,</span>\n                         <span style=\"color: #000000;\">col</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">mod<span style=\"color: #0000FF;\">(<span style=\"color: #000000;\">tile<span style=\"color: #0000FF;\">-<span style=\"color: #000000;\">1<span style=\"color: #0000FF;\">,<span style=\"color: #000000;\">4<span style=\"color: #0000FF;\">)<span style=\"color: #0000FF;\">+<span style=\"color: #000000;\">1</span>\n                 <span style=\"color: #000000;\">rkey<span style=\"color: #0000FF;\">[<span style=\"color: #000000;\">i<span style=\"color: #0000FF;\">]<span style=\"color: #0000FF;\">[<span style=\"color: #000000;\">row<span style=\"color: #0000FF;\">]</span> <span style=\"color: #0000FF;\">+=</span> <span style=\"color: #000000;\">1</span>\n                 <span style=\"color: #000000;\">ckey<span style=\"color: #0000FF;\">[<span style=\"color: #000000;\">j<span style=\"color: #0000FF;\">]<span style=\"color: #0000FF;\">[<span style=\"color: #000000;\">col<span style=\"color: #0000FF;\">]</span> <span style=\"color: #0000FF;\">+=</span> <span style=\"color: #000000;\">1</span>\n             <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">if</span>\n             <span style=\"color: #000000;\">k</span> <span style=\"color: #0000FF;\">+=</span> <span style=\"color: #000000;\">1</span>\n         <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">for</span>\n     <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">for</span>\n     <span style=\"color: #008080;\">if</span> <span style=\"color: #7060A8;\">getd_index<span style=\"color: #0000FF;\">(<span style=\"color: #000000;\">rkey<span style=\"color: #0000FF;\">,<span style=\"color: #000000;\">mmwd<span style=\"color: #0000FF;\">)<span style=\"color: #0000FF;\">=<span style=\"color: #000000;\">0</span>\n     <span style=\"color: #008080;\">or</span> <span style=\"color: #7060A8;\">getd_index<span style=\"color: #0000FF;\">(<span style=\"color: #000000;\">ckey<span style=\"color: #0000FF;\">,<span style=\"color: #000000;\">mmwd<span style=\"color: #0000FF;\">)<span style=\"color: #0000FF;\">=<span style=\"color: #000000;\">0</span> <span style=\"color: #008080;\">then</span>\n         <span style=\"color: #0000FF;\">?<span style=\"color: #000000;\">9<span style=\"color: #0000FF;\">/<span style=\"color: #000000;\">0</span> <span style=\"color: #000080;font-style:italic;\">-- sanity check</span>\n     <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">if</span>\n     <span style=\"color: #004080;\">integer</span> <span style=\"color: #000000;\">rwd</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">getd<span style=\"color: #0000FF;\">(<span style=\"color: #000000;\">rkey<span style=\"color: #0000FF;\">,<span style=\"color: #000000;\">mmwd<span style=\"color: #0000FF;\">)<span style=\"color: #0000FF;\">,</span>\n             <span style=\"color: #000000;\">cwd</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">getd<span style=\"color: #0000FF;\">(<span style=\"color: #000000;\">ckey<span style=\"color: #0000FF;\">,<span style=\"color: #000000;\">mmwd<span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #008080;\">return</span> <span style=\"color: #000000;\">rwd<span style=\"color: #0000FF;\">+<span style=\"color: #000000;\">cwd</span>\n <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">function</span>\n\n <span style=\"color: #004080;\">sequence</span> <span style=\"color: #000000;\">puzzle</span>\n <span style=\"color: #004080;\">string</span> <span style=\"color: #000000;\">res</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #008000;\">\"\"</span>\n <span style=\"color: #004080;\">atom</span> <span style=\"color: #000000;\">t0</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">time<span style=\"color: #0000FF;\">(<span style=\"color: #0000FF;\">)<span style=\"color: #0000FF;\">,</span>\n      <span style=\"color: #000000;\">t1</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">time<span style=\"color: #0000FF;\">(<span style=\"color: #0000FF;\">)<span style=\"color: #0000FF;\">+<span style=\"color: #000000;\">1</span>\n <span style=\"color: #004080;\">atom</span> <span style=\"color: #000000;\">tries</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #000000;\">0</span>\n\n <span style=\"color: #008080;\">constant</span> <span style=\"color: #000000;\">ok</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #0000FF;\">{<span style=\"color: #0000FF;\">{<span style=\"color: #000000;\">0<span style=\"color: #0000FF;\">,<span style=\"color: #000000;\">1<span style=\"color: #0000FF;\">,<span style=\"color: #000000;\">1<span style=\"color: #0000FF;\">,<span style=\"color: #000000;\">1<span style=\"color: #0000FF;\">,<span style=\"color: #000000;\">0<span style=\"color: #0000FF;\">,<span style=\"color: #000000;\">1<span style=\"color: #0000FF;\">,<span style=\"color: #000000;\">1<span style=\"color: #0000FF;\">,<span style=\"color: #000000;\">1<span style=\"color: #0000FF;\">,<span style=\"color: #000000;\">0<span style=\"color: #0000FF;\">,<span style=\"color: #000000;\">1<span style=\"color: #0000FF;\">,<span style=\"color: #000000;\">1<span style=\"color: #0000FF;\">,<span style=\"color: #000000;\">1<span style=\"color: #0000FF;\">,<span style=\"color: #000000;\">0<span style=\"color: #0000FF;\">,<span style=\"color: #000000;\">1<span style=\"color: #0000FF;\">,<span style=\"color: #000000;\">1<span style=\"color: #0000FF;\">,<span style=\"color: #000000;\">1<span style=\"color: #0000FF;\">}<span style=\"color: #0000FF;\">,</span>   <span style=\"color: #000080;font-style:italic;\">-- left</span>\n                <span style=\"color: #0000FF;\">{<span style=\"color: #000000;\">0<span style=\"color: #0000FF;\">,<span style=\"color: #000000;\">0<span style=\"color: #0000FF;\">,<span style=\"color: #000000;\">0<span style=\"color: #0000FF;\">,<span style=\"color: #000000;\">0<span style=\"color: #0000FF;\">,<span style=\"color: #000000;\">1<span style=\"color: #0000FF;\">,<span style=\"color: #000000;\">1<span style=\"color: #0000FF;\">,<span style=\"color: #000000;\">1<span style=\"color: #0000FF;\">,<span style=\"color: #000000;\">1<span style=\"color: #0000FF;\">,<span style=\"color: #000000;\">1<span style=\"color: #0000FF;\">,<span style=\"color: #000000;\">1<span style=\"color: #0000FF;\">,<span style=\"color: #000000;\">1<span style=\"color: #0000FF;\">,<span style=\"color: #000000;\">1<span style=\"color: #0000FF;\">,<span style=\"color: #000000;\">1<span style=\"color: #0000FF;\">,<span style=\"color: #000000;\">1<span style=\"color: #0000FF;\">,<span style=\"color: #000000;\">1<span style=\"color: #0000FF;\">,<span style=\"color: #000000;\">1<span style=\"color: #0000FF;\">}<span style=\"color: #0000FF;\">,</span>   <span style=\"color: #000080;font-style:italic;\">-- up</span>\n                <span style=\"color: #0000FF;\">{<span style=\"color: #000000;\">1<span style=\"color: #0000FF;\">,<span style=\"color: #000000;\">1<span style=\"color: #0000FF;\">,<span style=\"color: #000000;\">1<span style=\"color: #0000FF;\">,<span style=\"color: #000000;\">1<span style=\"color: #0000FF;\">,<span style=\"color: #000000;\">1<span style=\"color: #0000FF;\">,<span style=\"color: #000000;\">1<span style=\"color: #0000FF;\">,<span style=\"color: #000000;\">1<span style=\"color: #0000FF;\">,<span style=\"color: #000000;\">1<span style=\"color: #0000FF;\">,<span style=\"color: #000000;\">1<span style=\"color: #0000FF;\">,<span style=\"color: #000000;\">1<span style=\"color: #0000FF;\">,<span style=\"color: #000000;\">1<span style=\"color: #0000FF;\">,<span style=\"color: #000000;\">1<span style=\"color: #0000FF;\">,<span style=\"color: #000000;\">0<span style=\"color: #0000FF;\">,<span style=\"color: #000000;\">0<span style=\"color: #0000FF;\">,<span style=\"color: #000000;\">0<span style=\"color: #0000FF;\">,<span style=\"color: #000000;\">0<span style=\"color: #0000FF;\">}<span style=\"color: #0000FF;\">,</span>   <span style=\"color: #000080;font-style:italic;\">-- down</span>\n                <span style=\"color: #0000FF;\">{<span style=\"color: #000000;\">1<span style=\"color: #0000FF;\">,<span style=\"color: #000000;\">1<span style=\"color: #0000FF;\">,<span style=\"color: #000000;\">1<span style=\"color: #0000FF;\">,<span style=\"color: #000000;\">0<span style=\"color: #0000FF;\">,<span style=\"color: #000000;\">1<span style=\"color: #0000FF;\">,<span style=\"color: #000000;\">1<span style=\"color: #0000FF;\">,<span style=\"color: #000000;\">1<span style=\"color: #0000FF;\">,<span style=\"color: #000000;\">0<span style=\"color: #0000FF;\">,<span style=\"color: #000000;\">1<span style=\"color: #0000FF;\">,<span style=\"color: #000000;\">1<span style=\"color: #0000FF;\">,<span style=\"color: #000000;\">1<span style=\"color: #0000FF;\">,<span style=\"color: #000000;\">0<span style=\"color: #0000FF;\">,<span style=\"color: #000000;\">1<span style=\"color: #0000FF;\">,<span style=\"color: #000000;\">1<span style=\"color: #0000FF;\">,<span style=\"color: #000000;\">1<span style=\"color: #0000FF;\">,<span style=\"color: #000000;\">0<span style=\"color: #0000FF;\">}<span style=\"color: #0000FF;\">}</span>   <span style=\"color: #000080;font-style:italic;\">-- right\n<!--\n"
                }
            ],
            [
                {
                    "language": "Rust",
                    "solution": "const NR: [i32; 16] = [3, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3];\nconst NC: [i32; 16] = [3, 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2];\n\nconst I: u8 = 1;\nconst G: u8 = 8;\nconst E: u8 = 2;\nconst L: u8 = 4;\n\nstruct FifteenSolver {\n    n: usize,\n    limit: usize,\n    n0: [i32; 85],\n    n3: [u8; 85],\n    n4: [usize; 85],\n    n2: [u64; 85],\n}\n\nimpl FifteenSolver {\n    fn f_y(&mut self) -> bool {\n        if self.n2[self.n] == 0x123456789abcdef0 {\n            return true;\n        }\n        if self.n4[self.n] <= self.limit {\n            return self.f_n();\n        }\n        false\n    }\n\n    fn f_z(&mut self, w: u8) -> bool {\n        if w & I != 0 {\n            self.f_i();\n            if self.f_y() {\n                return true;\n            }\n            self.n -= 1;\n        }\n        if w & G != 0 {\n            self.f_g();\n            if self.f_y() {\n                return true;\n            }\n            self.n -= 1;\n        }\n        if w & E != 0 {\n            self.f_e();\n            if self.f_y() {\n                return true;\n            }\n            self.n -= 1;\n        }\n        if w & L != 0 {\n            self.f_l();\n            if self.f_y() {\n                return true;\n            }\n            self.n -= 1;\n        }\n        false\n    }\n\n    fn f_n(&mut self) -> bool {\n        self.f_z(match self.n0[self.n] {\n            0 => match self.n3[self.n] {\n                b'l' => I,\n                b'u' => E,\n                _ => I + E,\n            },\n            3 => match self.n3[self.n] {\n                b'r' => I,\n                b'u' => L,\n                _ => I + L,\n            },\n            1 | 2 => match self.n3[self.n] {\n                b'l' => I + L,\n                b'r' => I + E,\n                b'u' => E + L,\n                _ => L + E + I,\n            },\n            12 => match self.n3[self.n] {\n                b'l' => G,\n                b'd' => E,\n                _ => E + G,\n            },\n            15 => match self.n3[self.n] {\n                b'r' => G,\n                b'd' => L,\n                _ => G + L,\n            },\n            13 | 14 => match self.n3[self.n] {\n                b'l' => G + L,\n                b'r' => E + G,\n                b'd' => E + L,\n                _ => G + E + L,\n            },\n            4 | 8 => match self.n3[self.n] {\n                b'l' => I + G,\n                b'u' => G + E,\n                b'd' => I + E,\n                _ => I + G + E,\n            },\n            7 | 11 => match self.n3[self.n] {\n                b'd' => I + L,\n                b'u' => G + L,\n                b'r' => I + G,\n                _ => I + G + L,\n            },\n            _ => match self.n3[self.n] {\n                b'd' => I + E + L,\n                b'l' => I + G + L,\n                b'r' => I + G + E,\n                b'u' => G + E + L,\n                _ => I + G + E + L,\n            },\n        })\n    }\n\n    fn f_i(&mut self) {\n        let g = (11 - self.n0[self.n]) * 4;\n        let a = self.n2[self.n] & (15u64 << g);\n        self.n0[self.n + 1] = self.n0[self.n] + 4;\n        self.n2[self.n + 1] = self.n2[self.n] - a + (a << 16);\n        self.n3[self.n + 1] = b'd';\n        self.n4[self.n + 1] = self.n4[self.n];\n        let cond = NR[(a >> g) as usize] <= self.n0[self.n] / 4;\n        if !cond {\n            self.n4[self.n + 1] += 1;;\n        }\n        self.n += 1;\n    }\n\n    fn f_g(&mut self) {\n        let g = (19 - self.n0[self.n]) * 4;\n        let a = self.n2[self.n] & (15u64 << g);\n        self.n0[self.n + 1] = self.n0[self.n] - 4;\n        self.n2[self.n + 1] = self.n2[self.n] - a + (a >> 16);\n        self.n3[self.n + 1] = b'u';\n        self.n4[self.n + 1] = self.n4[self.n];\n        let cond = NR[(a >> g) as usize] >= self.n0[self.n] / 4;\n        if !cond {\n            self.n4[self.n + 1] += 1;\n        }\n        self.n += 1;\n    }\n\n    fn f_e(&mut self) {\n        let g = (14 - self.n0[self.n]) * 4;\n        let a = self.n2[self.n] & (15u64 << g);\n        self.n0[self.n + 1] = self.n0[self.n] + 1;\n        self.n2[self.n + 1] = self.n2[self.n] - a + (a << 4);\n        self.n3[self.n + 1] = b'r';\n        self.n4[self.n + 1] = self.n4[self.n];\n        let cond = NC[(a >> g) as usize] <= self.n0[self.n] % 4;\n        if !cond {\n            self.n4[self.n + 1] += 1;\n        }\n        self.n += 1;\n    }\n\n    fn f_l(&mut self) {\n        let g = (16 - self.n0[self.n]) * 4;\n        let a = self.n2[self.n] & (15u64 << g);\n        self.n0[self.n + 1] = self.n0[self.n] - 1;\n        self.n2[self.n + 1] = self.n2[self.n] - a + (a >> 4);\n        self.n3[self.n + 1] = b'l';\n        self.n4[self.n + 1] = self.n4[self.n];\n        let cond = NC[(a >> g) as usize] >= self.n0[self.n] % 4;\n        if !cond {\n            self.n4[self.n + 1] += 1;\n        }\n        self.n += 1;\n    }\n\n    fn new(n: i32, g: u64) -> Self {\n        let mut solver = FifteenSolver {\n            n: 0,\n            limit: 0,\n            n0: [0; 85],\n            n3: [0; 85],\n            n4: [0; 85],\n            n2: [0; 85],\n        };\n        solver.n0[0] = n;\n        solver.n2[0] = g;\n        solver\n    }\n\n    fn solve(&mut self) {\n        while !self.f_n() {\n            self.n = 0;\n            self.limit += 1;\n        }\n        println!(\n            \"Solution found in {} moves: {}\",\n            self.n,\n            std::str::from_utf8(&self.n3[1..=self.n]).unwrap()\n        );\n    }\n}\n\nfn main() {\n    FifteenSolver::new(8, 0xfe169b4c0a73d852).solve();\n}\n"
                },
                {
                    "language": "Scala",
                    "solution": "import scala.collection.mutable\ncase class Board(table: Array[Int], r: Int, c: Int, parent: List[String] = List()) {\n  def cloneSwap(r: Int, c: Int, rr: Int, cc: Int) = {\n    val cTable = table.clone\n    // Fancy way to access table(r)(c) in linear array\n    // Equivalent with cTable(r*4 + c)\n    cTable(r << 2 | c) = table(rr << 2 | cc)\n    cTable(rr << 2 | cc) = table(r << 2 | c)\n    cTable\n  }\n  def up() =\n    if (r > 0) { Some(Board(cloneSwap(r, c, r - 1, c), r - 1, c, \"u\" :: parent))\n    } else None\n  def down() =\n    if (r < 3) { Some(Board(cloneSwap(r, c, r + 1, c), r + 1, c, \"d\" :: parent))\n    } else None\n  def left() =\n    if (c > 0) { Some(Board(cloneSwap(r, c, r, c - 1), r, c - 1, \"l\" :: parent))\n    } else None\n  def right() =\n    if (c < 3) { Some(Board(cloneSwap(r, c, r, c + 1), r, c + 1, \"r\" :: parent))\n    } else None\n  def format: String = {\n    table.sliding(4, 4).toList.map(_.map(i \u21d2 f\"$i%4d\").mkString).mkString(\"\\n\")\n  }\n  // Manhattan distance\n  def heuristic() = {\n    val posF = Board.finalBoard.positionMap\n    val posT = positionMap\n    var res = 0;\n    for (i \u2190 0 to 15) {\n      val (x, y) = posF(i)\n      val (xx, yy) = posT(i)\n      res += (Math.abs(x - xx) + Math.abs(y - yy))\n    }\n    res\n  }\n  def key = table.mkString(\",\")\n  def travelled() = parent.length\n  // Find children/neighbours, flatten eliminates the empty boundaries\n  def children: List[Board] = List(this.up(), this.down(), this.right(), this.left()).flatten\n  // Map number to positions\n  lazy val positionMap: Map[Int, (Int, Int)] = {\n    val res = mutable.Map[Int, (Int, Int)]()\n    for (x \u2190 0 to 3; y \u2190 0 to 3) {\n      res(table(x << 2 | y)) = (x, y)\n    }\n    res.toMap\n  }\n}\n\nimport Board._\nobject Solver extends App {\n  def solve(initBoard: Board, wTravel:Int, wHeuristic: Int ) {\n    // Setup weights for the heuristic, more weight to heuristic faster but longer solution.\n    def aStar(b:  Board) = wHeuristic * b.heuristic() + wTravel * b.travelled()\n    implicit val ob = new Ordering[Board] {\n      override def compare(x: Board, y: Board) = {\n        aStar(y) - aStar(x)\n      }\n    }\n    val start = System.currentTimeMillis()\n    var found = false\n    var head = initBoard\n    val pq: mutable.PriorityQueue[Board] = new mutable.PriorityQueue()\n    pq.enqueue(head)\n    val visited = mutable.HashSet[String]()\n    var explore = 0\n    while (pq.nonEmpty && !found) {\n      head = pq.dequeue()\n      visited.add(head.key)\n      if (!head.key.equals(finalBoard.key)) {\n        val newChildren = head.children.filter(child \u21d2 !visited.contains(child.key))\n        visited ++= (newChildren.map(_.key))\n        pq.enqueue(newChildren: _*)\n        explore += 1\n      } else found = true\n      if (explore % 5000 == 0)\n        println(s\"# $explore: A* ${aStar(head)}  g:${head.travelled()} h:${head.heuristic()}\")\n    }\n    if (found) {\n      println(s\"Exploring $explore states, solution with length ${head.parent.length}.\")\n      println(s\"Weighted heuristic used $wHeuristic * heuristic + $wTravel * travel.\")\n      println(initBoard.format)\n      println(head.parent.mkString.reverse)\n    }\n    println(\"Total time: \" + (System.currentTimeMillis() - start) / 1000.0 + \" seconds\")\n  }\n  solve(startEasy, 4, 5)\n  solve(startHard, 1, 2 )\n}\n\nobject Board {\n  val finalBoard = Board(Array(Array(1, 2, 3, 4), Array(5, 6, 7, 8), Array(9, 10, 11, 12), Array(13, 14, 15, 0)).flatten, 3, 3)\n  val startEasy = Board(Array(Array(15, 14, 1, 6), Array(9, 11, 4, 12), Array(0, 10, 7, 3), Array(13, 8, 5, 2)).flatten, 2, 0)\n  val startHard = Board(Array(Array(0, 12, 9, 13), Array(15, 11, 10, 14), Array(3, 7, 2, 5), Array(4, 8, 6, 1)).flatten, 0, 0)\n}\n"
                }
            ],
            [
                {
                    "language": "Java",
                    "solution": "import java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\nimport java.util.Set;\nimport java.util.stream.Collectors;\n\npublic final class Puzzle15Solver {\n\n    public static void main(String[] aArgs) {\n        List<Integer> start = List.of( 15, 14, 1, 6, 9, 11, 4, 12, 0, 10, 7, 3, 13, 8, 5, 2 );\n        final int zeroIndex = 8;\n        Puzzle initial = new Puzzle(start, new ArrayList<String>(), zeroIndex, 0);\n        openSet.add(initial);\n        System.out.println(\"Solving the 15 puzzle:\");\n        initial.display();\n\n        while ( solution == null ) {\n            search();\n        }\n\n        System.out.println(solution.moves.stream().collect(Collectors.joining(\"\")));\n        System.out.println(\"Number of steps: \" + solution.moves.size());\n        System.out.println(\"Number of puzzle states checked: \" + closedSet.size());\n    }\n\n    private static void search() {\n\t\tPuzzle current = openSet.poll();\n\t    closedSet.add(current);\n\t    final int zeroIndex = current.zeroIndex;\n\t    final int row = zeroIndex / 4;\n        final int column = zeroIndex % 4;\n\t\n\t\tif ( column > 0 ) {\n\t\t\tPuzzle nextPuzzle = current.clone();\n\t\t\tnextPuzzle.makeMove(Move.LEFT);\n\t    }\n\t    if ( column < 3 ) {\n\t    \tPuzzle nextPuzzle = current.clone();\n\t    \tnextPuzzle.makeMove(Move.RIGHT);\n\t    }\n\t    if ( row > 0 ) {\n\t    \tPuzzle nextPuzzle = current.clone();\n\t    \tnextPuzzle.makeMove(Move.UP);\n\t    }\n\t    if ( row < 3 ) {\n\t    \tPuzzle nextPuzzle = current.clone();\n\t    \tnextPuzzle.makeMove(Move.DOWN);\n\t    }\n\t}\n\n    private enum Move {\t\t\n\t\tLEFT(\"L\", -1), RIGHT(\"R\", +1), UP(\"U\", -4), DOWN(\"D\", +4);\t\t\n\t\t\n\t\tprivate Move(String aSymbol, int aStep) {\n\t\t\tsymbol = aSymbol;\n\t\t\tstep = aStep;\n\t\t}\n\t\t\n\t\tprivate String symbol;\n\t\tprivate Integer step;\t\t\n\t}\n\n    private static class Puzzle {\n\n        public Puzzle(List<Integer> aTiles, List<String> aMoves, int aZeroIndex, int aSearchDepth) {\n        \ttiles = aTiles;\n            moves = aMoves;\n            zeroIndex = aZeroIndex;\n            searchDepth = aSearchDepth;\n        }\n\n        public void makeMove(Move aMove) {    \t\t\n    \t\tInteger temp = tiles.get(zeroIndex + aMove.step);\n    \t\ttiles.set(zeroIndex + aMove.step, 0);\n    \t\ttiles.set(zeroIndex, temp);\n    \t\t\n    \t\tzeroIndex += aMove.step;\n    \t\tmoves.add(aMove.symbol);\n    \t\t\n    \t\tif ( ! closedSet.contains(this) ) {\n                openSet.add(this);\n                if ( tiles.equals(Puzzle.GOAL) ) {\n                    solution = this;\n                }\n            }\n    \t}\n\n        public long heuristic() {\n        \tint distance = 0;\n        \tfor ( int i = 0; i < tiles.size(); i++ ) {\n        \t\tfinal int tile = tiles.get(i);\n            \tif ( tile > 0 ) {\n            \t\tdistance += Math.abs( ( i / 4 ) - ( tile - 1 ) / 4 ) + Math.abs( ( i % 4 ) - ( tile - 1 ) % 4 );\n            \t}\n            }\n            return distance + searchDepth;\n        }\n\n        public Puzzle clone() {\n            return new Puzzle(new ArrayList<Integer>(tiles), new ArrayList<String>(moves), zeroIndex, searchDepth + 1);\n        }\n\n        public void display() {\n        \t for ( int i = 0; i < tiles.size(); i++ ) {\n                 System.out.print(String.format(\"%s%2d%s\",\n                 \t( i % 4 == 0 ) ? \"[\" : \"\", tiles.get(i), ( i % 4 == 3 ) ? \"]\\n\" : \" \"));\n             }\n             System.out.println();\n        }\n\n        @Override\n        public boolean equals(Object aObject) {\n        \treturn switch(aObject) {\n        \t\tcase Puzzle puzzle -> tiles.equals(puzzle.tiles);\n        \t\tcase Object object -> false;\n        \t};\n        }\n\n        @Override\n        public int hashCode() {\n            int hash = 3;\n            hash = 23 * hash + tiles.hashCode();\n            hash = 23 * hash + zeroIndex;\n            return hash;\n        }\n\n        private List<Integer> tiles;\n        private List<String> moves;\n        private int zeroIndex;\n        private int searchDepth;\n\n        private static final List<Integer> GOAL = List.of( 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0 );\n\n    }\n\n    private static Queue<Puzzle> openSet =\n    \tnew PriorityQueue<Puzzle>( (one, two) -> Long.compare(one.heuristic(), two.heuristic()) );\n    private static Set<Puzzle> closedSet = new HashSet<Puzzle>();\n    private static Puzzle solution;\n\n}\n"
                },
                {
                    "language": "Lua",
                    "solution": "----------\n-- SOLVER\n----------\n\nlocal table_concat = table.concat -- local alias\n\nlocal function Solver(root, h, successors)\n  local pathlist, pathhash, iters\n  -- it is required that \"h(node)\" returns:\n  --   0 when \"is_goal(node)==true\"\n  --   >0 when \"is_goal(node)==false\"\n  --   (because it allows for some simplification herein)\n  local FOUND = 0 -- ie: \"is_goal(node)==true\"\n  local NOT_FOUND = 1e9 -- some number larger than largest possible f\n\n  local function hash(node)\n    return table_concat(node,\",\")\n  end\n\n  local function search(g, bound)\n    iters = iters + 1\n    --if ((iters % 1000000) == 0) then print(\"iterations:\", iters) end\n    local node = pathlist[#pathlist]\n    local h = h(node)\n    local f = g + h\n    if (f > bound) then return f end\n    if (h == FOUND) then return FOUND end\n    local min = NOT_FOUND\n    for succ, cost in successors(node) do\n      local succhash = hash(succ)\n      if (not pathhash[succhash]) then\n        pathlist[#pathlist+1], pathhash[succhash] = succ, true\n        local t = search(g+cost, bound)\n        if (t == FOUND) then return FOUND end\n        if (t < min) then min = t end\n        pathlist[#pathlist], pathhash[succhash] = nil, nil\n      end\n    end\n    return min\n  end\n\n  return {\n    solve = function()\n      pathlist = { root }\n      pathhash = { [hash(root)] = true }\n      iters = 0\n      local bound = h(root)\n      while true do\n        bound = search(0, bound)\n        if (bound == FOUND) then return bound, iters, pathlist end\n        if (bound == NOT_FOUND) then return bound, iters, nil end\n      end\n    end\n  }\nend\n\n------------------\n-- DOMAIN SUPPORT\n------------------\n\nlocal i2c = { [0]=0, 1,2,3,4, 1,2,3,4, 1,2,3,4, 1,2,3,4 } -- convert index to column\nlocal i2r = { [0]=0, 1,1,1,1, 2,2,2,2, 3,3,3,3, 4,4,4,4 } -- convert index to row\nlocal R, U, L, D = 1, -4, -1, 4 -- move indexing values\nlocal movenames = { -- move names\n  [0]=\"\", [R]=\"r\", [U]=\"u\", [L]=\"l\", [D]=\"d\"\n}\nlocal succmoves = { -- successor directions\n  {R,D}, {R,L,D}, {R,L,D}, {L,D},\n  {R,U,D}, {R,U,L,D}, {R,U,L,D}, {U,L,D},\n  {R,U,D}, {R,U,L,D}, {R,U,L,D}, {U,L,D},\n  {R,U}, {R,U,L}, {R,U,L}, {U,L}\n}\nlocal manhdists = { -- manhattan distances\n  { [0]=0, 0, 1, 2, 3, 1, 2, 3, 4, 2, 3, 4, 5, 3, 4, 5, 6 },\n  { [0]=0, 1, 0, 1, 2, 2, 1, 2, 3, 3, 2, 3, 4, 4, 3, 4, 5 },\n  { [0]=0, 2, 1, 0, 1, 3, 2, 1, 2, 4, 3, 2, 3, 5, 4, 3, 4 },\n  { [0]=0, 3, 2, 1, 0, 4, 3, 2, 1, 5, 4, 3, 2, 6, 5, 4, 3 },\n  { [0]=0, 1, 2, 3, 4, 0, 1, 2, 3, 1, 2, 3, 4, 2, 3, 4, 5 },\n  { [0]=0, 2, 1, 2, 3, 1, 0, 1, 2, 2, 1, 2, 3, 3, 2, 3, 4 },\n  { [0]=0, 3, 2, 1, 2, 2, 1, 0, 1, 3, 2, 1, 2, 4, 3, 2, 3 },\n  { [0]=0, 4, 3, 2, 1, 3, 2, 1, 0, 4, 3, 2, 1, 5, 4, 3, 2 },\n  { [0]=0, 2, 3, 4, 5, 1, 2, 3, 4, 0, 1, 2, 3, 1, 2, 3, 4 },\n  { [0]=0, 3, 2, 3, 4, 2, 1, 2, 3, 1, 0, 1, 2, 2, 1, 2, 3 },\n  { [0]=0, 4, 3, 2, 3, 3, 2, 1, 2, 2, 1, 0, 1, 3, 2, 1, 2 },\n  { [0]=0, 5, 4, 3, 2, 4, 3, 2, 1, 3, 2, 1, 0, 4, 3, 2, 1 },\n  { [0]=0, 3, 4, 5, 6, 2, 3, 4, 5, 1, 2, 3, 4, 0, 1, 2, 3 },\n  { [0]=0, 4, 3, 4, 5, 3, 2, 3, 4, 2, 1, 2, 3, 1, 0, 1, 2 },\n  { [0]=0, 5, 4, 3, 4, 4, 3, 2, 3, 3, 2, 1, 2, 2, 1, 0, 1 },\n  { [0]=0, 6, 5, 4, 3, 5, 4, 3, 2, 4, 3, 2, 1, 3, 2, 1, 0 },\n}\n\n--- create a state from a pattern, optionally applying a move\nlocal function state(patt, move)\n  local node = {}\n  for k,v in pairs(patt) do node[k] = v end\n  if (move) then\n    local e = node.e\n    local ep = e + move\n    node[e], node[ep] = node[ep], 0\n    node.e, node.m = ep, move\n  end\n  return node\nend\n\n--- iterator for successors of node\nlocal function successors(node)\n  local moves = succmoves[node.e]\n  local i, n = 0, #moves\n  return function()\n    i = i + 1\n    if (i <= n) then\n      return state(node, moves[i]), 1\n    end\n  end\nend\n\n--- hueristic estimate of travel cost from node to goal\nlocal function h(node)\n  local sum, ijx, jix, t = 0, 1, 1\n  for i = 1, 4 do\n    local colmax, rowmax = 0, 0\n    for j = 1, 4 do\n      t = node[ijx]\n      sum = sum + manhdists[ijx][t] -- manhattan\n      if (i2r[t] == i) then -- row conflicts\n        if (t > rowmax) then rowmax=t else sum=sum+2 end\n      end\n      t = node[jix]\n      if (i2c[t] == i) then -- col conflicts\n        if (t > colmax) then colmax=t else sum=sum+2 end\n      end\n      ijx, jix = ijx+1, jix+4\n    end\n    jix = jix - 15\n  end\n  return sum\nend\n\n------------------\n-- PRINT SUPPORT:\n------------------\n\nlocal function printnode(node)\n  print(\"+--+--+--+--+\")\n  for i = 0, 12, 4 do\n    print( string.format(\"|%2d|%2d|%2d|%2d|\", node[i+1], node[i+2], node[i+3], node[i+4]) )\n    print(\"+--+--+--+--+\")\n  end\nend\n\nlocal function printpath(path)\n  -- note that #path is 1 longer than solution due to root node at path[1]\n  -- concatenated result will be correct length since movenames[root.m]==\"\"\n  local t = {}\n  for i, node in ipairs(path) do\n    t[i] = movenames[node.m]\n  end\n  local pathstr = table_concat(t)\n  print(\"SOLUTION: \" .. pathstr .. \" (length: \" .. #pathstr .. \")\")\nend\n\n---------\n-- TASKS:\n---------\n\n-- goal is implied by h(), never actually used (see solver's notes)\n-- local goal = state({ 1,2,3,4, 5,6,7,8, 9,10,11,12, 13,14,15,0, e=16, m=0 })\n\ndo\n  print(\"PRIMARY TASK (OPTIMALLY)\")\n  local sclock = os.clock()\n  local root = state({ 15,14,1,6, 9,11,4,12, 0,10,7,3, 13,8,5,2, e=9, m=0 })\n  printnode(root)\n  local solver = Solver(root, h, successors)\n  local bound, iters, path = solver:solve()\n  printpath(path)\n  printnode(path[#path])\n  print(\"ITERATIONS: \" .. iters)\n  print(\"ELAPSED: \" .. (os.clock()-sclock) .. \"s\")\nend\n\nprint()\n\ndo\n  print(\"EXTRA CREDIT TASK (APPROXIMATELY, NON-OPTIMALLY)\")\n  -- only primary task specifies \"fewest possible moves\"\n  -- extra credit task only specifies \"solve\", so..\n  local sclock = os.clock()\n  local root = state({ 0,12,9,13, 15,11,10,14, 3,7,2,5, 4,8,6,1, e=1, m=0 })\n  printnode(root)\n  local function hec(node)\n    -- overweighting h makes it not admissible,\n    -- causing solver to favor g when minimizing,\n    -- leading to non-optimal (but much easier to find!) solutions\n    return h(node)*1.5\n  end\n  local solver = Solver(root, hec, successors)\n  local bound, iters, path = solver:solve()\n  printpath(path) --> 86, optimal solution is known to be 80\n  printnode(path[#path])\n  print(\"ITERATIONS: \" .. iters)\n  print(\"ELAPSED: \" .. (os.clock()-sclock) .. \"s\")\nend\n"
                }
            ],
            [
                {
                    "language": "ARM-Assembly",
                    "solution": "/* ARM assembly Raspberry PI  */\n/*  program puzzle15solver.s   */\n/* my first other program find \u00e0 solution in 134 moves !!! */\n/* this second program is a adaptation algorithme C++ and go rosetta code */\n/* thanck for the creators */\n/* 1 byte by box on game board */\n\n/* create a file with nano  */\n/*  15,  2,   3,   4\n    5,   6,   7,   1\n    9,   10,  8,   11\n   13,  14,  12, 0     */\n\n/*   Run this programm : puzzle15solver <file name> */\n/*   wait several minutes for r\u00e9sult */\n\n/* REMARK 1 : this program use routines in a include file\n   see task Include a file language arm assembly\n   for the routine affichageMess conversion10\n   see at end of this program the instruction include */\n/* for constantes see task include a file in arm assembly */\n/************************************/\n/* Constantes                       */\n/************************************/\n.include \"../constantes.inc\"\n\n.equ STDIN,  0     @ Linux input console\n.equ STDOUT, 1     @ Linux output console\n.equ EXIT,   1     @ Linux syscall\n.equ READ,   3     @ Linux syscall\n.equ WRITE,  4     @ Linux syscall\n.equ OPEN,   5     @ Linux syscall\n.equ CLOSE,  6     @ Linux syscall\n\n.equ TRUE, 1\n.equ FALSE, 0\n\n.equ O_RDWR,    0x0002        @ open for reading and writing\n\n.equ SIZE,           4\n.equ NBBOX,          SIZE * SIZE\n.equ TAILLEBUFFER,   100\n.equ NBMAXIELEMENTS, 100\n\n.equ CONST_I,    1\n.equ CONST_G,    8\n.equ CONST_E,    2\n.equ CONST_L,    4\n\n/*********************************/\n/* Initialized data              */\n/*********************************/\n.data\nszMessTitre:            .asciz \"Nom du fichier : \"\nsMessResult:           .ascii \" \"\nsMessValeur:           .fill 11, 1, ' '             @ size => 11\nszCarriageReturn:      .asciz \"\\n\"\nszMessCounterSolution: .asciz \"Solution in @ moves : \\n\"\n\n//szMessMoveError:       .asciz \"Huh... Impossible move !!!!\\n\"\nszMessErreur:          .asciz \"Error detected.\\n\"\nszMessImpossible:      .asciz \"!!! Impossible solution !!!\\n\"\nszMessErrBuffer:       .asciz \"buffer size too less !!\"\nszMessSpaces:          .asciz \"    \"\n\niTabNr:  .int 3, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3\niTabNc:  .int 3, 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2\n/*********************************/\n/* UnInitialized data            */\n/*********************************/\n.bss\n.align 4\nsZoneConv:      .skip 24\niAdrHeap:       .skip 4\nibox:           .skip SIZE * SIZE           @ game boxes\niAdrFicName:    .skip 4\niTabN0:         .skip 4 * NBMAXIELEMENTS    @ empty box\niTabN3:         .skip 4 * NBMAXIELEMENTS    @ moves\niTabN4:         .skip 4 * NBMAXIELEMENTS    @ ????\niTabN2:         .skip 4 * NBMAXIELEMENTS    @ table game address\nsBuffer:        .skip TAILLEBUFFER\n/*********************************/\n/*  code section                 */\n/*********************************/\n.text\n.global main\nmain:                            @ INFO: main\n    mov r0,sp                    @ stack address for load parameter\n    bl traitFic                  @ read file and store value in array\n    cmp r0,#-1\n    beq 100f                     @ error ?\n\n    ldr r0,iAdribox\n    bl displayGame               @ display array game\n\n    ldr r0,iAdribox              @ control if solution exists\n    bl controlSolution\n    cmp r0,#TRUE\n    beq 1f\n    ldr r0,iAdrszMessImpossible  @ no solution !!!\n    bl affichageMess\n    b 100f\n\n1:\n    ldr r0,iAdribox\n    ldr r9,iAdriTabN2\n    str r0,[r9]                  @ N2 address global\n\n    mov r10,#0                   @ variable _n global\n    mov r12,#0                   @ variable n global\n    bl searchSolution\n    cmp r0,#TRUE\n    bne 100f                     @ no solution ?\n    ldr r3,iAdriTabN2\n    ldr r0,[r3,r12,lsl #2]       @ visual solution control\n    bl displayGame\n    mov r0,r12                   @ move counter\n    ldr r1,iAdrsZoneConv\n    bl conversion10              @ conversion counter\n    mov r2,#0\n    strb r2,[r1,r0]              @ and display\n    ldr r0,iAdrszMessCounterSolution\n    bl strInsertAtCharInc\n    ldr r1,iAdrsZoneConv\n    bl affichageMess\n    ldr r5,iAdriTabN3\n    ldr r3,iAdrsBuffer\n    mov r2,#1\n    mov r4,#0\n2:                                @ loop solution display\n    ldrb r1,[r5,r2,lsl #2]\n    cmp r2,#TAILLEBUFFER\n    bge 99f\n    strb r1,[r3,r4]\n    add r4,r4,#1\n    add r2,r2,#1\n    cmp r2,r12\n    ble 2b\n    mov r1,#0\n    str r1,[r3,r4]                 @ z\u00e9ro final\n    mov r0,r3\n    bl affichageMess\n    ldr r0,iAdrszCarriageReturn\n    bl affichageMess\n\n    b 100f\n\n99:\n    ldr r0,iAdrszMessErrBuffer\n    bl affichageMess\n100:                                 @ standard end of the program\n    mov r0, #0                       @ return code\n    mov r7, #EXIT                    @ request to exit program\n    svc #0                           @ perform the system call\n\niAdribox:                  .int ibox\niAdriTabN0:                .int iTabN0\niAdriTabN2:                .int iTabN2\niAdriTabN3:                .int iTabN3\niAdriTabN4:                .int iTabN4\niAdrszMessCounterSolution: .int szMessCounterSolution\niAdrszMessImpossible:      .int szMessImpossible\niAdrszMessErrBuffer:       .int szMessErrBuffer\niAdrsZoneConv:             .int sZoneConv\n/******************************************************************/\n/*      search    Solution                                        */\n/******************************************************************/\nsearchSolution:                      @ INFO: searchSolution\n    push {r1-r8,lr}                  @ save  registers\n                                     @ address allocation place on the heap\n    mov r0,#0                        @ allocation place heap\n    mov r7,#0x2D                     @ call system 'brk'\n    svc #0\n    cmp r0,#-1                       @ allocation error\n    beq 99f\n    ldr r1,iAdriAdrHeap\n    str r0,[r1]                      @ store heap address\n    bl functionFN\n    ldr r3,iAdriTabN2\n    ldr r0,[r3,r12,lsl #2]           @ last current game\n    bl gameOK                        @ it is Ok ?\n    cmp r0,#TRUE\n    beq 100f                         @ yes --> end\n\n    ldr r1,iAdriAdrHeap              @ free up resources\n    ldr r0,[r1]                      @ restaur start address heap\n    mov r7,#0x2D                     @ call system 'brk'\n    svc #0\n    cmp r0,#-1                       @ allocation error\n    beq 99f\n    add r10,r10,#1                   @ _n\n    mov r12,#0                       @ n\n    bl searchSolution                @ next recursif call\n    b 100f\n99:\n    ldr r0,iAdrszMessErreur\n    bl affichageMess\n100:\n    pop {r1-r8,lr}                   @ restaur registers\n    bx lr                            @return\niAdrszMessErreur:           .int szMessErreur\niAdriAdrHeap:               .int iAdrHeap\n/******************************************************************/\n/*     Fonction FN                                                */\n/******************************************************************/\nfunctionFN:                          @ INFO: functionFN\n    push {lr}                        @ save  register\n    ldr r4,iAdriTabN3\n    ldr r3,[r4,r12,lsl #2]\n    ldr r5,iAdriTabN0                @ load position empty box\n    ldr r6,[r5,r12,lsl #2]\n    cmp r6,#15                       @ last box\n    bne 2f\n    cmp r3,#'R'\n    bne 11f\n    mov r0,#CONST_G\n    bl functionFZ\n    b 100f\n11:\n    cmp r3,#'D'\n    bne 12f\n    mov r0,#CONST_L\n    bl functionFZ\n    b 100f\n12:\n    mov r0,#CONST_G + CONST_L\n    bl functionFZ\n    b 100f\n\n2:\n    cmp r6,#12\n    bne 3f\n    cmp r3,#'L'\n    bne 21f\n    mov r0,#CONST_G\n    bl functionFZ\n    b 100f\n21:\n    cmp r3,#'D'\n    bne 22f\n    mov r0,#CONST_E\n    bl functionFZ\n    b 100f\n22:\n    mov r0,#CONST_E + CONST_G\n    bl functionFZ\n    b 100f\n3:\n    cmp r6,#13\n    beq 30f\n    cmp r6,#14\n    bne 4f\n30:\n    cmp r3,#'L'\n    bne 31f\n    mov r0,#CONST_G + CONST_L\n    bl functionFZ\n    b 100f\n31:\n    cmp r3,#'R'\n    bne 32f\n    mov r0,#CONST_G + CONST_E\n    bl functionFZ\n    b 100f\n32:\n    cmp r3,#'D'\n    bne 33f\n    mov r0,#CONST_E + CONST_L\n    bl functionFZ\n    b 100f\n33:\n    mov r0,#CONST_L + CONST_E + CONST_G\n    bl functionFZ\n    b 100f\n4:\n    cmp r6,#3\n    bne 5f\n    cmp r3,#'R'\n    bne 41f\n    mov r0,#CONST_I\n    bl functionFZ\n    b 100f\n41:\n    cmp r3,#'U'\n    bne 42f\n    mov r0,#CONST_L\n    bl functionFZ\n    b 100f\n42:\n    mov r0,#CONST_I + CONST_L\n    bl functionFZ\n    b 100f\n5:\n    cmp r6,#0\n    bne 6f\n    cmp r3,#'L'\n    bne 51f\n    mov r0,#CONST_I\n    bl functionFZ\n    b 100f\n51:\n    cmp r3,#'U'\n    bne 52f\n    mov r0,#CONST_E\n    bl functionFZ\n    b 100f\n52:\n    mov r0,#CONST_I + CONST_E\n    bl functionFZ\n    b 100f\n6:\n    cmp r6,#1\n    beq 60f\n    cmp r6,#2\n    bne 7f\n60:\n    cmp r3,#'L'\n    bne 61f\n    mov r0,#CONST_I + CONST_L\n    bl functionFZ\n    b 100f\n61:\n    cmp r3,#'R'\n    bne 62f\n    mov r0,#CONST_E + CONST_I\n    bl functionFZ\n    b 100f\n62:\n    cmp r3,#'U'\n    bne 63f\n    mov r0,#CONST_E + CONST_L\n    bl functionFZ\n    b 100f\n63:\n    mov r0,#CONST_I + CONST_E + CONST_L\n    bl functionFZ\n    b 100f\n7:\n    cmp r6,#7\n    beq 70f\n    cmp r6,#11\n    bne 8f\n70:\n    cmp r3,#'R'\n    bne 71f\n    mov r0,#CONST_I + CONST_G\n    bl functionFZ\n    b 100f\n71:\n    cmp r3,#'U'\n    bne 72f\n    mov r0,#CONST_G + CONST_L\n    bl functionFZ\n    b 100f\n72:\n    cmp r3,#'D'\n    bne 73f\n    mov r0,#CONST_I + CONST_L\n    bl functionFZ\n    b 100f\n73:\n    mov r0,#CONST_I + CONST_G + CONST_L\n    bl functionFZ\n    b 100f\n8:\n    cmp r6,#4\n    beq 80f\n    cmp r6,#8\n    bne 9f\n80:\n    cmp r3,#'D'\n    bne 81f\n    mov r0,#CONST_I + CONST_E\n    bl functionFZ\n    b 100f\n81:\n    cmp r3,#'U'\n    bne 82f\n    mov r0,#CONST_G + CONST_E\n    bl functionFZ\n    b 100f\n82:\n    cmp r3,#'L'\n    bne 83f\n    mov r0,#CONST_I + CONST_G\n    bl functionFZ\n    b 100f\n83:\n    mov r0,#CONST_G + CONST_E + CONST_I\n    bl functionFZ\n    b 100f\n9:\n    cmp r3,#'D'\n    bne 91f\n    mov r0,#CONST_I + CONST_E + CONST_L\n    bl functionFZ\n    b 100f\n91:\n    cmp r3,#'L'\n    bne 92f\n    mov r0,#CONST_I + CONST_G + CONST_L\n    bl functionFZ\n    b 100f\n92:\n    cmp r3,#'R'\n    bne 93f\n    mov r0,#CONST_I + CONST_G + CONST_E\n    bl functionFZ\n    b 100f\n93:\n    cmp r3,#'U'\n    bne 94f\n    mov r0,#CONST_G + CONST_E +  CONST_L\n    bl functionFZ\n    b 100f\n94:\n    mov r0,#CONST_G + CONST_L + CONST_I + CONST_E\n    bl functionFZ\n    b 100f\n\n99:                                  @ error\n    ldr r0,iAdrszMessErreur\n    bl affichageMess\n100:\n    pop {lr}                         @ restaur registers\n    bx lr                            @return\n\n/******************************************************************/\n/*     function FZ                           */\n/*                                                 */\n/***************************************************************/\n/* r0 contains variable w           */\nfunctionFZ:                    @ INFO: functionFZ\n    push {r1,r2,lr}            @ save  registers\n    mov r2,r0\n    and r1,r2,#CONST_I\n    cmp r1,#0\n    ble 1f\n    bl functionFI\n    bl functionFY\n    cmp r0,#TRUE\n    beq 100f\n    sub r12,r12,#1              @ variable n\n1:\n    ands r1,r2,#CONST_G\n    ble 2f\n    bl functionFG\n    bl functionFY\n    cmp r0,#TRUE\n    beq 100f\n    sub r12,r12,#1              @ variable n\n2:\n    ands r1,r2,#CONST_E\n    ble 3f\n    bl functionFE\n    bl functionFY\n    cmp r0,#TRUE\n    beq 100f\n    sub r12,r12,#1              @ variable n\n3:\n    ands r1,r2,#CONST_L\n    ble 4f\n    bl functionFL\n    bl functionFY\n    cmp r0,#TRUE\n    beq 100f\n    sub r12,r12,#1              @ variable n\n4:\n    mov r0,#FALSE\n100:\n    pop {r1,r2,lr}              @ restaur registers\n    bx lr                       @return\n/******************************************************************/\n/*               function FY                                 */\n/******************************************************************/\nfunctionFY:                    @ INFO: functionFY\n    push {lr}                  @ save  registers\n    ldr r1,iAdriTabN2\n    ldr r0,[r1,r12,lsl #2]\n    bl gameOK                  @ game OK ?\n    cmp r0,#TRUE\n    beq 100f\n    ldr r1,iAdriTabN4\n    ldr r0,[r1,r12,lsl #2]\n    cmp r0,r10\n    bgt 1f\n    bl functionFN\n    b 100f\n1:\n    mov r0,#FALSE\n100:\n    pop {lr}                     @ restaur registers\n    bx lr                        @return\n\n/******************************************************************/\n/*     the empty box is down                                     */\n/******************************************************************/\nfunctionFI:                       @ INFO: functionFI\n    push {r0-r8,lr}               @ save  registers\n    ldr r0,iAdriTabN0\n    ldr r1,[r0,r12,lsl #2]        @ empty box\n    add r2,r1,#4\n    ldr r3,[r9,r12,lsl #2]        @ load game current\n    ldrb r4,[r3,r2]               @ load box down empty box\n    add r5,r12,#1                 @ n+1\n    add r8,r1,#4                  @ new position empty case\n    str r8,[r0,r5,lsl #2]         @ store new position empty case\n    ldr r6,iAdriTabN3\n\n    mov r7,#'D'                   @ down\n    str r7,[r6,r5,lsl #2]         @ store move\n    ldr r6,iAdriTabN4\n    ldr r7,[r6,r12,lsl #2]\n    str r7,[r6,r5,lsl #2]         @ N4 (n+1) = n4(n)\n    mov r0,r3\n    bl createGame                 @ create copy game\n    ldrb r3,[r0,r1]               @ and inversion box\n    ldrb r8,[r0,r2]\n    strb r8,[r0,r1]\n    strb r3,[r0,r2]\n    str r0,[r9,r5,lsl #2]         @ store new game in table\n    lsr r1,r1,#2                  @ line position empty case = N\u00b0/ 4\n    ldr r0,iAdriTabNr\n    ldr r2,[r0,r4,lsl #2]         @ load N\u00b0 line box moved\n    cmp r2,r1                     @ compare ????\n    ble 1f\n    add r7,r7,#1                  @ and increment ????\n    str r7,[r6,r5,lsl #2]\n1:\n    add r12,r12,#1                @ increment N\n    pop {r0-r8,lr}\n    bx lr                         @return\niAdriTabNr:        .int iTabNr\niAdriTabNc:        .int iTabNc\n/******************************************************************/\n/*     empty case UP   see explain in english in function FI      */\n/******************************************************************/\nfunctionFG:                      @ INFO: functionFG\n    push {r0-r8,lr}              @ save  registers\n    ldr r0,iAdriTabN0\n    ldr r1,[r0,r12,lsl #2]       @ case vide\n    sub r2,r1,#4                 @ position case au dessus\n    ldr r3,[r9,r12,lsl #2]       @ extrait jeu courant\n    ldrb r4,[r3,r2]              @ extrait le contenu case au dessus\n    add r5,r12,#1                @ N+1 = N\n    sub r8,r1,#4                 @ nouvelle position case vide\n    str r8,[r0,r5,lsl #2]        @ et on la stocke\n    ldr r6,iAdriTabN3\n    mov r7,#'U'                  @ puis on stocke le code mouvement\n    str r7,[r6,r5,lsl #2]\n    ldr r6,iAdriTabN4\n    ldr r7,[r6,r12,lsl #2]\n    str r7,[r6,r5,lsl #2]        @ N4 (N+1) = N4 (N)\n    mov r0,r3                    @ jeu courant\n    bl createGame                @ cr\u00e9ation nouveau jeu\n    ldrb r3,[r0,r1]              @ et echange les 2 cases\n    ldrb r8,[r0,r2]\n    strb r8,[r0,r1]\n    strb r3,[r0,r2]\n    str r0,[r9,r5,lsl #2]        @ stocke la nouvelle situation\n    lsr r1,r1,#2                 @ ligne case vide = position /4\n    ldr r0,iAdriTabNr\n    ldr r2,[r0,r4,lsl #2]        @ extrait table \u00e0 la position case\n    cmp r2,r1                    @ et comparaison ???\n    bge 1f\n    add r7,r7,#1                 @ puis increment N4 de 1  ???\n    str r7,[r6,r5,lsl #2]\n1:\n    add r12,r12,#1               @ increment de N\n    pop {r0-r8,lr}\n    bx lr                        @return\n/******************************************************************/\n/*    empty case go right see explain finction FI ou FG en fran\u00e7ais */\n/******************************************************************/\nfunctionFE:                       @ INFO: functionFE\n    push {r0-r8,lr}               @ save  registers\n    ldr r0,iAdriTabN0\n    ldr r1,[r0,r12,lsl #2]\n    add r2,r1,#1\n    ldr r3,[r9,r12,lsl #2]\n    ldrb r4,[r3,r2]               @ extrait le contenu case\n    add r5,r12,#1\n    add r8,r1,#1\n    str r8,[r0,r5,lsl #2]         @ nouvelle case vide\n    ldr r6,iAdriTabN3\n    mov r7,#'R'\n    str r7,[r6,r5,lsl #2]         @ mouvement\n    ldr r6,iAdriTabN4\n    ldr r7,[r6,r12,lsl #2]\n    str r7,[r6,r5,lsl #2]         @ N4 ??\n    mov r0,r3\n    bl createGame\n    ldrb r3,[r0,r1]               @ exchange two boxes\n    ldrb r8,[r0,r2]\n    strb r8,[r0,r1]\n    strb r3,[r0,r2]\n    str r0,[r9,r5,lsl #2]         @ stocke la nouvelle situation\n    lsr r3,r1,#2\n    sub r1,r1,r3,lsl #2\n    ldr r0,iAdriTabNc\n    ldr r2,[r0,r4,lsl #2]         @ extrait table \u00e0 la position case\n    cmp r2,r1\n    ble 1f\n    add r7,r7,#1\n    str r7,[r6,r5,lsl #2]\n1:\n    add r12,r12,#1\n    pop {r0-r8,lr}\n    bx lr                        @return\n/******************************************************************/\n/*     empty box go left see explain function FI ou FG en fran\u00e7ais */\n/******************************************************************/\nfunctionFL:                       @ INFO: functionFL\n    push {r0-r8,lr}               @ save  registers\n    ldr r0,iAdriTabN0\n    ldr r1,[r0,r12,lsl #2]        @ case vide\n    sub r2,r1,#1\n    ldr r3,[r9,r12,lsl #2]       @ extrait jeu courant\n    ldrb r4,[r3,r2]              @ extrait le contenu case\n    add r5,r12,#1\n    sub r8,r1,#1\n    str r8,[r0,r5,lsl #2]         @ nouvelle case vide\n    ldr r6,iAdriTabN3\n    mov r7,#'L'\n    str r7,[r6,r5,lsl #2]         @ mouvement\n    ldr r6,iAdriTabN4\n    ldr r7,[r6,r12,lsl #2]\n    str r7,[r6,r5,lsl #2]         @ N4 ??\n    mov r0,r3\n    bl createGame\n    ldrb r3,[r0,r1]               @ exchange two boxes\n    ldrb r8,[r0,r2]\n    strb r8,[r0,r1]\n    strb r3,[r0,r2]\n    str r0,[r9,r5,lsl #2]         @ stocke la nouvelle situation\n    lsr r3,r1,#2\n    sub r1,r1,r3,lsl #2           @ compute remainder\n    ldr r0,iAdriTabNc\n    ldr r2,[r0,r4,lsl #2]         @ extrait table colonne \u00e0 la position case\n    cmp r2,r1\n    bge 1f\n    add r7,r7,#1\n    str r7,[r6,r5,lsl #2]\n1:\n    add r12,r12,#1\n    pop {r0-r8,lr}\n    bx lr                         @return\n/******************************************************************/\n/*     create new Game                                            */\n/******************************************************************/\n/* r0 contains box address            */\n/* r0 return address new game  */\ncreateGame:                          @ INFO: createGame\n    push {r1-r8,lr}                  @ save  registers\n    mov r4,r0                        @ save value\n    mov r0,#0                        @ allocation place heap\n    mov r7,#0x2D                     @ call system 'brk'\n    svc #0\n    cmp r0,#-1                       @ allocation error\n    beq 99f\n    mov r5,r0                        @ save address heap for output string\n    add r0,#SIZE * SIZE              @ reservation place one element\n    mov r7,#0x2D                     @ call system 'brk'\n    svc #0\n    cmp r0,#-1                       @ allocation error\n    beq 99f\n    mov r2,#0\n1:                                   @ loop copy boxes\n    ldrb r3,[r4,r2]\n    strb r3,[r5,r2]\n    add r2,r2,#1\n    cmp r2,#NBBOX\n    blt 1b\n    add r11,r11,#1\n    mov r0,r5\n    b 100f\n99:                                  @ error\n    ldr r0,iAdrszMessErreur\n    bl affichageMess\n100:\n    pop {r1-r8,lr}                   @ restaur registers\n    bx lr                            @return\n/******************************************************************/\n/*     read file                                                   */\n/******************************************************************/\n/* r0 contains address stack begin           */\ntraitFic:                             @ INFO: traitFic\n    push {r1-r8,fp,lr}                @ save  registers\n    mov fp,r0                         @  fp <- start address\n    ldr r4,[fp]                       @ number of Command line arguments\n    cmp r4,#1\n    movle r0,#-1\n    ble 99f\n    add r5,fp,#8                      @ second parameter address\n    ldr r5,[r5]\n    ldr r0,iAdriAdrFicName\n    str r5,[r0]\n    ldr r0,iAdrszMessTitre\n    bl affichageMess                  @ display string\n    mov r0,r5\n    bl affichageMess\n    ldr r0,iAdrszCarriageReturn\n    bl affichageMess                  @ display carriage return\n\n    mov r0,r5                         @ file name\n    mov r1,#O_RDWR                    @ flags\n    mov r2,#0                         @ mode\n    mov r7, #OPEN                     @ call system OPEN\n    svc 0\n    cmp r0,#0                         @ error ?\n    ble 99f\n    mov r8,r0                         @ File Descriptor\n    ldr r1,iAdrsBuffer                @ buffer address\n    mov r2,#TAILLEBUFFER              @ buffer size\n    mov r7,#READ                      @ read file\n    svc #0\n    cmp r0,#0                         @ error ?\n    blt 99f\n    @ extraction datas\n    ldr r1,iAdrsBuffer                @ buffer address\n    add r1,r0\n    mov r0,#0                         @ store z\u00e9ro final\n    strb r0,[r1]\n    ldr r0,iAdribox                   @ game box address\n    ldr r1,iAdrsBuffer                @ buffer address\n    bl extracDatas\n                                      @ close file\n    mov r0,r8\n    mov r7, #CLOSE\n    svc 0\n    mov r0,#0\n    b 100f\n99:                                   @ error\n    ldr r1,iAdrszMessErreur           @ error message\n    bl   displayError\n    mov r0,#-1\n100:\n    pop {r1-r8,fp,lr}                 @ restaur registers\n    bx lr                             @return\niAdriAdrFicName:              .int iAdrFicName\niAdrszMessTitre:              .int szMessTitre\niAdrsBuffer:                  .int sBuffer\n/******************************************************************/\n/*     extrac digit file buffer                                   */\n/******************************************************************/\n/* r0 contains boxs address           */\n/* r1 contains buffer address         */\nextracDatas:                     @ INFO: extracDatas\n    push {r1-r8,lr}              @ save  registers\n    mov r7,r0\n    mov r6,r1\n    mov r2,#0                    @ string buffer indice\n    mov r4,r1                    @ start digit ascii\n    mov r5,#0                    @ box index\n1:\n    ldrb r3,[r6,r2]\n    cmp r3,#0\n    beq 4f                       @ end\n    cmp r3,#0xA\n    beq 2f\n    cmp r3,#','\n    beq 3f\n    add r2,#1\n    b 1b\n2:\n    mov r3,#0\n    strb r3,[r6,r2]\n    ldrb r3,[r6,r2]\n    cmp r3,#0xD\n    addeq r2,#2\n    addne r2,#1\n    b 4f\n\n3:\n    mov r3,#0\n    strb r3,[r6,r2]\n    add r2,#1\n4:\n    mov r0,r4\n    bl conversionAtoD\n    strb r0,[r7,r5]\n    cmp r0,#0\n    ldreq r0,iAdriTabN0\n    streq r5,[r0]                @ empty box in item z\u00e9ro\n    add r5,#1\n    cmp r5,#NBBOX                @ number box = maxi ?\n    bge 100f\n    add r4,r6,r2                 @ new start address digit ascii\n    b 1b\n100:\n    pop {r1-r8,lr}               @ restaur registers\n    bx lr                        @return\n/******************************************************************/\n/*     control of the game solution                                      */\n/******************************************************************/\n/* r0 contains boxs address           */\n/* r0 returns 0 if not possible       */\n/* r0 returns 1 if possible           */\ncontrolSolution:                 @ INFO: controlSolution\n    push {r1-r8,lr}              @ save  registers\n    mov r5,r0\n    ldr r8,iAdriTabN0\n    ldr r8,[r8]                  @ empty box\n    @ empty box\n    mov r7,#0\n    cmp r8,#1\n    moveq r7,#1\n    beq 1f\n    cmp r8,#3\n    moveq r7,#1\n    beq 1f\n    cmp r8,#4\n    moveq r7,#1\n    beq 1f\n    cmp r8,#6\n    moveq r7,#1\n    beq 1f\n    cmp r8,#9\n    moveq r7,#1\n    beq 1f\n    cmp r8,#11\n    moveq r7,#1\n    beq 1f\n    cmp r8,#12\n    moveq r7,#1\n    beq 1f\n    cmp r8,#14\n    moveq r7,#1\n1:\n    rsb r6,r8,#NBBOX - 1\n    add r7,r6\n                                 @ count permutations\n    mov r1,#-1\n    mov r6,#0\n2:\n    add r1,#1\n    cmp r1,#NBBOX\n    bge 80f\n    cmp r1,r8\n    beq 2b\n    ldrb r3,[r5,r1]\n    mov r2,r1\n3:\n    add r2,#1\n    cmp r2,#NBBOX\n    bge 2b\n    cmp r2,r8\n    beq 3b\n    ldrb r4,[r5,r2]\n    cmp r4,r3\n    addlt r6,#1\n    b 3b\n80:\n    add r6,r7\n    tst r6,#1\n    movne r0,#0                  @ impossible\n    moveq r0,#1                  @ OK\n\n100:\n    pop {r1-r8,lr}               @ restaur registers\n    bx lr                        @return\n/******************************************************************/\n/*     game Ok ?                                      */\n/******************************************************************/\n/* r0 contains boxs address           */\ngameOK:                          @ INFO: gameOK\n    push {r1-r4,lr}              @ save  registers\n    mov r2,#0\n    ldrb r3,[r0,r2]\n    cmp r3,#0\n    moveq r3,#0xF\n    add r2,#1\n1:\n    ldrb r4,[r0,r2]\n    cmp r4,#0\n    moveq r3,#0xF\n    cmp r4,r3\n    movle  r0,#FALSE              @ game not Ok\n    ble 100f\n    mov r3,r4\n    add r2,#1\n    cmp r2,#NBBOX -2\n    ble 1b\n    mov r0,#TRUE                  @ game Ok\n\n100:\n    pop {r1-r4,lr}                @ restaur registers\n    bx lr                         @return\n/******************************************************************/\n/*     display game                                       */\n/******************************************************************/\n/* r0 contains boxs address           */\ndisplayGame:                            @ INFO: displayGame\n    push {r0-r5,lr}                     @ save  registers\n    mov r4,r0\n    ldr r0,iAdrszMessTitre\n    bl affichageMess                    @ display string\n    ldr r0,iAdriAdrFicName\n    ldr r0,[r0]\n    bl affichageMess                    @ display string\n    ldr r0,iAdrszCarriageReturn\n    bl affichageMess                    @ display line return\n    mov r2,#0\n    ldr r1,iAdrsMessValeur\n1:\n    ldrb r0,[r4,r2]\n    cmp r0,#0\n    ldreq r0,iSpaces                    @ store spaces\n    streq r0,[r1]\n    beq 2f\n    bl conversion10                     @ call conversion decimal\n    mov r0,#0\n    strb r0,[r1,#3]                     @ z\u00e9ro final\n2:\n\n    ldr r0,iAdrsMessResult\n    bl affichageMess                    @ display message\n    add r0,r2,#1\n    tst r0,#0b11\n    bne 3f\n    ldr r0,iAdrszCarriageReturn\n    bl affichageMess                    @ display message\n3:\n    add r2,#1\n    cmp r2,#NBBOX - 1\n    ble 1b\n    ldr r0,iAdrszCarriageReturn\n    bl affichageMess                    @ display line return\n\n100:\n    pop {r0-r5,lr}                      @ restaur registers\n    bx lr                               @return\niSpaces:                       .int 0x00202020       @ spaces\n//iAdrszMessMoveError:           .int szMessMoveError\niAdrszCarriageReturn:          .int szCarriageReturn\niAdrsMessValeur:               .int sMessValeur\niAdrsMessResult:               .int sMessResult\n/***************************************************/\n/*      ROUTINES INCLUDE                           */\n/***************************************************/\n.include \"../affichage.inc\"\n"
                },
                {
                    "language": "Raku",
                    "solution": "# 20210623 Raku programming solution vCSMt9hkak0\n\nconstant \\Nr = <3 0 0 0 0 1 1 1 1 2 2 2 2 3 3 3>;\nconstant \\Nc = <3 0 1 2 3 0 1 2 3 0 1 2 3 0 1 2>;\n\nmy ($n,$m) = 0,0 ;\nmy @N0 is default(0);\nmy @N3 is default(0);\nmy @N4 is default(0);\nmy @N2 is default(0);\n\nsub fY() {\n   if @N2[$n] == 0x123456789abcdef0 {\n      say \"Solution found in \", $n, \" moves: \", [~] @N3[1..$n] and exit();\n   }\n   return @N4[$n] \u2264 $m ?? fN() !! False ;\n}\n\nsub fN() {\n   sub common { ++$n; return True if fY(); --$n }\n   if (@N3[$n] ne 'u' && @N0[$n] div 4 < 3) { fI() and common }\n   if (@N3[$n] ne 'd' && @N0[$n] div 4 > 0) { fG() and common }\n   if (@N3[$n] ne 'l' && @N0[$n]  %  4 < 3) { fE() and common }\n   if (@N3[$n] ne 'r' && @N0[$n]  %  4 > 0) { fL() and common }\n   return False;\n}\n\nsub fI() {\n   my \\g = (11-@N0[$n])*4;\n   my \\a = @N2[$n] +& (15 +< g);\n   @N0[$n+1]=@N0[$n]+4;\n   @N2[$n+1]=@N2[$n]-a+(a+<16);\n   @N3[$n+1]='d';\n   @N4[$n+1]=@N4[$n]+(Nr[a+>g] \u2264 @N0[$n] div 4 ?? 0 !! 1);\n}\n\nsub fG() {\n   my \\g = (19-@N0[$n])*4;\n   my \\a = @N2[$n] +& (15 +< g);\n   @N0[$n+1]=@N0[$n]-4;\n   @N2[$n+1]=@N2[$n]-a+(a+>16);\n   @N3[$n+1]='u';\n   @N4[$n+1]=@N4[$n]+(Nr[a+>g] \u2265 @N0[$n] div 4 ?? 0 !! 1);\n}\n\nsub fE() {\n   my \\g = (14-@N0[$n])*4;\n   my \\a = @N2[$n] +& (15 +< g);\n   @N0[$n+1]=@N0[$n]+1;\n   @N2[$n+1]=@N2[$n]-a+(a+<4);\n   @N3[$n+1]='r';\n   @N4[$n+1]=@N4[$n]+(Nc[a+>g] \u2264 @N0[$n]%4 ?? 0 !! 1);\n}\n\nsub fL(){\n   my \\g = (16-@N0[$n])*4;\n   my \\a = @N2[$n] +& (15 +< g);\n   @N0[$n+1]=@N0[$n]-1;\n   @N2[$n+1]=@N2[$n]-a+(a+>4);\n   @N3[$n+1]='l';\n   @N4[$n+1]=@N4[$n]+(Nc[a+>g] \u2265 @N0[$n]%4 ?? 0 !! 1);\n}\n\nsub fifteenSolver(\\n, \\g){@N0[0]=n; @N2[0]=g}\n\n\nfifteenSolver(8,0xfe169b4c0a73d852);\nloop { fY() or ++$m }\n"
                }
            ],
            [
                {
                    "language": "Rust",
                    "solution": "use keyed_priority_queue::KeyedPriorityQueue;\nuse std::cmp::{Ord, Ordering, PartialOrd, Reverse};\n\nstatic CORRECT_ORDER: [u8; 16] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0];\nstatic ROW: [i32; 16] = [0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3];\nstatic COLUMN: [i32; 16] = [0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3];\n\n#[derive(Debug, Clone)]\nstruct State {\n    est_tot_moves: u8,\n    moves: String,\n    est_moves_rem: u8,\n}\n\nimpl PartialOrd for State {\n    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n        Some(self.est_tot_moves.cmp(&other.est_tot_moves))\n    }\n}\n\nimpl Eq for State {}\n\nimpl PartialEq for State {\n    fn eq(&self, other: &Self) -> bool {\n        self.est_tot_moves.cmp(&other.est_tot_moves) == Ordering::Equal\n    }\n}\n\nimpl Ord for State {\n    fn cmp(&self, other: &Self) -> Ordering {\n        self.est_tot_moves\n            .partial_cmp(&other.est_tot_moves)\n            .unwrap()\n    }\n}\n\nimpl State {\n    fn init(order: &[u8; 16]) -> State {\n        State {\n            est_tot_moves: State::estimate_moves(&order),\n            moves: String::from(\"\"),\n            est_moves_rem: 0,\n        }\n    }\n\n    fn find_index(order: &[u8; 16], tile: &u8) -> usize {\n        order.iter().position(|&x| x == *tile).unwrap()\n    }\n\n    fn estimate_moves(current: &[u8; 16]) -> u8 {\n        let mut h = 0;\n        for tile in current.iter() {\n            let current_index = State::find_index(current, &tile);\n            let correct_index = State::find_index(&CORRECT_ORDER, &tile);\n            h += ((COLUMN[current_index] - COLUMN[correct_index]).abs()\n                + (ROW[current_index] - ROW[correct_index]).abs()) as u8;\n        }\n        h\n    }\n\n    fn make_move(\n        &self,\n        order: &[u8; 16],\n        dir: fn(usize, [u8; 16]) -> ([u8; 16], String),\n    ) -> ([u8; 16], State) {\n        let est_moves_rem = State::estimate_moves(order);\n        let (new_order, from) = dir(State::find_index(order, &0), *order);\n        let moves = format!(\"{}{}\", self.moves, from);\n        let new_state = State {\n            est_tot_moves: moves.len() as u8 + est_moves_rem,\n            moves,\n            est_moves_rem,\n        };\n        return (new_order, new_state);\n    }\n\n    fn left(index: usize, mut order: [u8; 16]) -> ([u8; 16], String) {\n        order.swap(index, index - 1);\n        return (order, String::from(\"l\"));\n    }\n\n    fn right(index: usize, mut order: [u8; 16]) -> ([u8; 16], String) {\n        order.swap(index, index + 1);\n        return (order, String::from(\"r\"));\n    }\n\n    fn up(index: usize, mut order: [u8; 16]) -> ([u8; 16], String) {\n        order.swap(index, index - 4);\n        return (order, String::from(\"u\"));\n    }\n\n    fn down(index: usize, mut order: [u8; 16]) -> ([u8; 16], String) {\n        order.swap(index, index + 4);\n        return (order, String::from(\"d\"));\n    }\n\n    fn children(&self, order: &[u8; 16]) -> Vec<([u8; 16], State)> {\n        let index = State::find_index(order, &0);\n        let mut new_states: Vec<([u8; 16], State)> = Vec::new();\n        if COLUMN[index] > 0 {\n            new_states.push(self.make_move(order, State::left))\n        }\n        if COLUMN[index] < 3 {\n            new_states.push(self.make_move(order, State::right))\n        }\n        if ROW[index] > 0 {\n            new_states.push(self.make_move(order, State::up))\n        }\n        if ROW[index] < 3 {\n            new_states.push(self.make_move(order, State::down))\n        }\n        new_states\n    }\n}\n\nfn main() {\n    let mut open_states = KeyedPriorityQueue::<[u8; 16], Reverse<State>>::new();\n    let start_order = [15, 14, 1, 6, 9, 11, 4, 12, 0, 10, 7, 3, 13, 8, 5, 2];\n    // let start_order = [0, 1, 2, 3, 5, 6, 7, 4, 9, 10, 11, 8, 13, 14, 15, 12];\n    open_states.push(start_order, Reverse(State::init(&start_order)));\n    let mut closed_states = KeyedPriorityQueue::<[u8; 16], Reverse<State>>::new();\n\n    'outer: while let Some((parent_order, Reverse(parent_state))) = open_states.pop() {\n        for (child_order, child_state) in parent_state.children(&parent_order) {\n            match (\n                open_states.get_priority(&child_order).as_ref(),\n                closed_states.get_priority(&child_order).as_ref(),\n            ) {\n                (None, None) => {\n                    if child_order == CORRECT_ORDER {\n                        println!(\"There are {} entries in the open list.\", open_states.len());\n                        println!(\n                            \"There are {} entries in the closed list.\",\n                            closed_states.len()\n                        );\n                        println!(\n                            \"Reaching the final board took {} moves.\",\n                            child_state.moves.len()\n                        );\n                        println!(\"The moves used were {}.\", child_state.moves);\n                        println!(\n                            \"The final order is:\\n{:?}\\n{:?}\\n{:?}\\n{:?}.\",\n                            &child_order[0..4],\n                            &child_order[4..8],\n                            &child_order[8..12],\n                            &child_order[12..16]\n                        );\n                        break 'outer;\n                    }\n                    open_states.push(child_order, Reverse(child_state.clone()));\n                }\n                (Some(&Reverse(open_state)), None)\n                    if open_state.moves.len() > child_state.moves.len() =>\n                {\n                    open_states.set_priority(&child_order, Reverse(child_state.clone()));\n                }\n                // (None, Some(&Reverse(closed_state))) if closed_state.moves.len() > child_state.moves.len() => {\n                //     closed_states.remove_item(&child_order);\n                //     open_states.push(child_order, Reverse(child_state.clone()));\n                // },\n                _ => {}\n            };\n        }\n        closed_states.push(parent_order, Reverse(parent_state));\n    }\n}\n"
                },
                {
                    "language": "F-Sharp",
                    "solution": "let test n g=match [1..15]|>Seq.tryPick(solve n g) with\n               Some n->n|>List.rev|>List.iter(fun n->printf \"%c\" (match n with N->'d'|I->'u'|G->'r'|E->'l'|L->'\\u0000'));printfn \" (%n moves)\" (List.length n)\n              |_     ->printfn \"No solution found\"\ntest 0xfe169b4c0a73d852UL 8\n"
                }
            ]
        ]
    },
    {
        "task_name": "2048",
        "task_description": ";Task:\nImplement a 2D sliding block puzzle game where blocks with numbers are combined to add their values.\n\n\n;Rules of the game:\n:* &nbsp; The rules are that on each turn the player must choose a direction &nbsp; (up, down, left or right).\n:* &nbsp; All tiles move as far as possible in that direction, some move more than others. \n:* &nbsp; Two adjacent tiles (in that direction only) with matching numbers combine into one bearing the sum of those numbers. \n:* &nbsp; A move is valid when at least one tile can be moved, including by combination. \n:* &nbsp; A new tile is spawned at the end of each turn at a randomly chosen empty square &nbsp; (if there is one). \n:* &nbsp; Most of the time, a new '''2''' is to be added, but occasionally ('''10%''' of the time), a '''4'''.\n:* &nbsp; To win, the player must create a tile with the number '''2048'''. \n:* &nbsp; The player loses if no valid moves are possible.\n\n\nThe name comes from the popular open-source implementation of this game mechanic, [https://gabrielecirulli.github.io/2048/ 2048].\n\n\n;Requirements:\n* &nbsp; \"Non-greedy\" movement.<br>&nbsp; The tiles that were created by combining other tiles should not be combined again during the same turn (move).<br>&nbsp; That is to say, that moving the tile row of:\n\n               <big><big> [2][2][2][2] </big></big>\n\n:: to the right should result in: \n\n               <big><big> ......[4][4] </big></big>\n\n:: and not:\n\n               <big><big> .........[8] </big></big>\n\n* &nbsp; \"Move direction priority\".<br>&nbsp; If more than one variant of combining is possible, move direction shall indicate which combination will take effect. <br>&nbsp; For example, moving the tile row of:\n\n               <big><big> ...[2][2][2] </big></big>\n\n:: to the right should result in:\n\n               <big><big> ......[2][4] </big></big>\n\n:: and not:\n\n               <big><big> ......[4][2] </big></big>\n\n\n\n* &nbsp; Check for valid moves. The player shouldn't be able to gain new tile by trying a move that doesn't change the board.\n* &nbsp; Check for a win condition.\n* &nbsp; Check for a lose condition.\n<br><br>\n\n",
        "solution_pairs": [
            [
                {
                    "language": "C++",
                    "solution": "#include <time.h>\n#include <iostream>\n#include <string>\n#include <iomanip>\n#include <cstdlib>\n\ntypedef unsigned int uint;\nusing namespace std;\nenum movDir { UP, DOWN, LEFT, RIGHT };\n\nclass tile\n{\npublic:\n    tile() : val( 0 ), blocked( false ) {}\n    uint val;\n    bool blocked;\n};\n\nclass g2048\n{\npublic:\n    g2048() : done( false ), win( false ), moved( true ), score( 0 ) {}\n    void loop()\n    {\n\taddTile();\n\twhile( true )\n\t{\n\t    if( moved ) addTile();\n\t    drawBoard();\n\t    if( done ) break;\n\t    waitKey();\n\t}\n\tstring s = \"Game Over!\";\n\tif( win ) s = \"You've made it!\";\n\tcout << s << endl << endl;\n    }\nprivate:\n    void drawBoard()\n    {\n\tsystem( \"cls\" );\n\tcout << \"SCORE: \" << score << endl << endl;\n\tfor( int y = 0; y < 4; y++ )\n\t{\n\t    cout << \"+------+------+------+------+\" << endl << \"| \";\n\t    for( int x = 0; x < 4; x++ )\n\t    {\n\t\tif( !board[x][y].val ) cout << setw( 4 ) << \" \";\n\t\telse cout << setw( 4 ) << board[x][y].val;\n\t\tcout << \" | \";\n\t    }\n\t    cout << endl;\n\t}\n\tcout << \"+------+------+------+------+\" << endl << endl;\n    }\n    void waitKey()\n    {\n\tmoved = false; char c;\n\tcout << \"(W)Up (S)Down (A)Left (D)Right \"; cin >> c; c &= 0x5F;\n\tswitch( c )\n\t{\n\t    case 'W': move( UP );break;\n\t    case 'A': move( LEFT ); break;\n\t    case 'S': move( DOWN ); break;\n\t    case 'D': move( RIGHT );\n\t}\n\tfor( int y = 0; y < 4; y++ )\n\t    for( int x = 0; x < 4; x++ )\n\t\tboard[x][y].blocked = false;\n    }\n    void addTile()\n    {\n\tfor( int y = 0; y < 4; y++ )\n\t    for( int x = 0; x < 4; x++ )\n\t\tif( !board[x][y].val )\n\t\t{\n\t\t    uint a, b;\n\t\t    do\n\t\t    { a = rand() % 4; b = rand() % 4; }\n\t\t    while( board[a][b].val );\n\n\t\t    int s = rand() % 100;\n\t\t    if( s > 89 ) board[a][b].val = 4;\n\t\t    else board[a][b].val = 2;\n\t\t    if( canMove() ) return;\n\t\t}\n\tdone = true;\n    }\n    bool canMove()\n    {\n\tfor( int y = 0; y < 4; y++ )\n\t    for( int x = 0; x < 4; x++ )\n\t\tif( !board[x][y].val ) return true;\n\n\tfor( int y = 0; y < 4; y++ )\n\t    for( int x = 0; x < 4; x++ )\n\t    {\n\t\tif( testAdd( x + 1, y, board[x][y].val ) ) return true;\n\t\tif( testAdd( x - 1, y, board[x][y].val ) ) return true;\n\t\tif( testAdd( x, y + 1, board[x][y].val ) ) return true;\n\t\tif( testAdd( x, y - 1, board[x][y].val ) ) return true;\n\t    }\n\treturn false;\n    }\n    bool testAdd( int x, int y, uint v )\n    {\n\tif( x < 0 || x > 3 || y < 0 || y > 3 ) return false;\n\treturn board[x][y].val == v;\n    }\n    void moveVert( int x, int y, int d )\n    {\n\tif( board[x][y + d].val && board[x][y + d].val == board[x][y].val && !board[x][y].blocked && !board[x][y + d].blocked  )\n\t{\n\t    board[x][y].val = 0;\n\t    board[x][y + d].val *= 2;\n\t    score += board[x][y + d].val;\n\t    board[x][y + d].blocked = true;\n\t    moved = true;\n\t}\n\telse if( !board[x][y + d].val && board[x][y].val )\n\t{\n\t    board[x][y + d].val = board[x][y].val;\n\t    board[x][y].val = 0;\n\t    moved = true;\n\t}\n\tif( d > 0 ) { if( y + d < 3 ) moveVert( x, y + d,  1 ); }\n\telse        { if( y + d > 0 ) moveVert( x, y + d, -1 ); }\n    }\n    void moveHori( int x, int y, int d )\n    {\n\tif( board[x + d][y].val && board[x + d][y].val == board[x][y].val && !board[x][y].blocked && !board[x + d][y].blocked  )\n\t{\n\t    board[x][y].val = 0;\n\t    board[x + d][y].val *= 2;\n\t    score += board[x + d][y].val;\n\t    board[x + d][y].blocked = true;\n\t    moved = true;\n\t}\n\telse if( !board[x + d][y].val && board[x][y].val )\n\t{\n\t    board[x + d][y].val = board[x][y].val;\n\t    board[x][y].val = 0;\n\t    moved = true;\n\t}\n\tif( d > 0 ) { if( x + d < 3 ) moveHori( x + d, y,  1 ); }\n\telse        { if( x + d > 0 ) moveHori( x + d, y, -1 ); }\n    }\n    void move( movDir d )\n    {\n\tswitch( d )\n\t{\n\t    case UP:\n\t    \tfor( int x = 0; x < 4; x++ )\n\t\t{\n\t\t    int y = 1;\n\t\t    while( y < 4 )\n\t\t    { if( board[x][y].val ) moveVert( x, y, -1 ); y++;}\n\t\t}\n\t\tbreak;\n\t    case DOWN:\n\t\tfor( int x = 0; x < 4; x++ )\n\t\t{\n\t\t    int y = 2;\n\t\t    while( y >= 0 )\n\t\t    { if( board[x][y].val ) moveVert( x, y, 1 ); y--;}\n\t\t}\n\t\tbreak;\n\t    case LEFT:\n\t\tfor( int y = 0; y < 4; y++ )\n\t\t{\n\t\t    int x = 1;\n\t\t    while( x < 4 )\n\t\t    { if( board[x][y].val ) moveHori( x, y, -1 ); x++;}\n\t\t}\n\t\tbreak;\n\t    case RIGHT:\n\t\tfor( int y = 0; y < 4; y++ )\n\t\t{\n\t\t    int x = 2;\n\t\t    while( x >= 0 )\n\t\t    { if( board[x][y].val ) moveHori( x, y, 1 ); x--;}\n\t\t}\n\t}\n    }\n    tile board[4][4];\n    bool win, done, moved;\n    uint score;\n};\nint main( int argc, char* argv[] )\n{\n    srand( static_cast<uint>( time( NULL ) ) );\n    g2048 g; g.loop();\n    return system( \"pause\" );\n}\n"
                },
                {
                    "language": "Visual-Basic-.NET",
                    "solution": "Friend Class Tile\n    Public Sub New()\n        Me.Value = 0\n        Me.IsBlocked = False\n    End Sub\n    Public Property Value As Integer\n    Public Property IsBlocked As Boolean\nEnd Class\n\nFriend Enum MoveDirection\n     Up\n     Down\n     Left\n     Right\nEnd Enum\n\n    Friend Class G2048\n        Public Sub New()\n            _isDone = False\n            _isWon = False\n            _isMoved = True\n            _score = 0\n            InitializeBoard()\n        End Sub\n\n        Private Sub InitializeBoard()\n            For y As Integer = 0 To 3\n                For x As Integer = 0 To 3\n                    _board(x, y) = New Tile()\n                Next\n            Next\n        End Sub\n\n        Private _isDone As Boolean\n        Private _isWon As Boolean\n        Private _isMoved As Boolean\n        Private _score As Integer\n        Private ReadOnly _board As Tile(,) = New Tile(3, 3) {}\n        Private ReadOnly _rand As Random = New Random()\n        Const empty As String = \" \"\n\n        Public Sub [Loop]()\n            AddTile()\n            While True\n                If _isMoved Then AddTile()\n                DrawBoard()\n                If _isDone Then Exit While\n                WaitKey()\n            End While\n            Dim endMessage As String = If(_isWon, \"You've made it!\", \"Game Over!\")\n            Console.WriteLine(endMessage)\n        End Sub\n\n        Public Sub DrawBoard()\n            Console.Clear()\n            Console.WriteLine(\"Score: \" & _score & vbNewLine)\n            For y As Integer = 0 To 3\n                Console.WriteLine(\"+------+------+------+------+\")\n                Console.Write(\"| \")\n                For x As Integer = 0 To 3\n                    If _board(x, y).Value = 0 Then\n                        Console.Write(empty.PadRight(4))\n                    Else\n                        Console.Write(_board(x, y).Value.ToString().PadRight(4))\n                    End If\n                    Console.Write(\" | \")\n                Next\n                Console.WriteLine()\n            Next\n            Console.WriteLine(\"+------+------+------+------+\" & vbNewLine & vbNewLine)\n        End Sub\n\n        Private Sub WaitKey()\n            _isMoved = False\n            Console.WriteLine(\"(W) Up (S) Down (A) Left (D) Right\")\n            Dim input As Char\n            Char.TryParse(Console.ReadKey().Key.ToString(), input)\n            Select Case input\n                Case \"W\"c\n                    Move(MoveDirection.Up)\n                Case \"A\"c\n                    Move(MoveDirection.Left)\n                Case \"S\"c\n                    Move(MoveDirection.Down)\n                Case \"D\"c\n                    Move(MoveDirection.Right)\n            End Select\n            For y As Integer = 0 To 3\n                For x As Integer = 0 To 3\n                    _board(x, y).IsBlocked = False\n                Next\n            Next\n        End Sub\n\n        Private Sub AddTile()\n            For y As Integer = 0 To 3\n                For x As Integer = 0 To 3\n                    If _board(x, y).Value <> 0 Then Continue For\n                    Dim a As Integer, b As Integer\n                    Do\n                        a = _rand.Next(0, 4)\n                        b = _rand.Next(0, 4)\n                    Loop While _board(a, b).Value <> 0\n                    Dim r As Double = _rand.NextDouble()\n                    _board(a, b).Value = If(r > 0.89F, 4, 2)\n                    If CanMove() Then Return\n                Next\n            Next\n            _isDone = True\n        End Sub\n\n        Private Function CanMove() As Boolean\n            For y As Integer = 0 To 3\n                For x As Integer = 0 To 3\n                    If _board(x, y).Value = 0 Then Return True\n                Next\n            Next\n            For y As Integer = 0 To 3\n                For x As Integer = 0 To 3\n                    If TestAdd(x + 1, y, _board(x, y).Value) OrElse TestAdd(x - 1, y, _board(x, y).Value) OrElse TestAdd(x, y + 1, _board(x, y).Value) OrElse TestAdd(x, y - 1, _board(x, y).Value) Then Return True\n                Next\n            Next\n            Return False\n        End Function\n\n        Private Function TestAdd(ByVal x As Integer, ByVal y As Integer, ByVal value As Integer) As Boolean\n            If x < 0 OrElse x > 3 OrElse y < 0 OrElse y > 3 Then Return False\n            Return _board(x, y).Value = value\n        End Function\n\n        Private Sub MoveVertically(ByVal x As Integer, ByVal y As Integer, ByVal d As Integer)\n            If _board(x, y + d).Value <> 0 AndAlso _board(x, y + d).Value = _board(x, y).Value AndAlso Not _board(x, y).IsBlocked AndAlso Not _board(x, y + d).IsBlocked Then\n                _board(x, y).Value = 0\n                _board(x, y + d).Value *= 2\n                _score += _board(x, y + d).Value\n                _board(x, y + d).IsBlocked = True\n                _isMoved = True\n            ElseIf _board(x, y + d).Value = 0 AndAlso _board(x, y).Value <> 0 Then\n                _board(x, y + d).Value = _board(x, y).Value\n                _board(x, y).Value = 0\n                _isMoved = True\n            End If\n            If d > 0 Then\n                If y + d < 3 Then MoveVertically(x, y + d, 1)\n            Else\n                If y + d > 0 Then MoveVertically(x, y + d, -1)\n            End If\n        End Sub\n\n        Private Sub MoveHorizontally(ByVal x As Integer, ByVal y As Integer, ByVal d As Integer)\n            If _board(x + d, y).Value <> 0 AndAlso _board(x + d, y).Value = _board(x, y).Value AndAlso Not _board(x + d, y).IsBlocked AndAlso Not _board(x, y).IsBlocked Then\n                _board(x, y).Value = 0\n                _board(x + d, y).Value *= 2\n                _score += _board(x + d, y).Value\n                _board(x + d, y).IsBlocked = True\n                _isMoved = True\n            ElseIf _board(x + d, y).Value = 0 AndAlso _board(x, y).Value <> 0 Then\n                _board(x + d, y).Value = _board(x, y).Value\n                _board(x, y).Value = 0\n                _isMoved = True\n            End If\n            If d > 0 Then\n                If x + d < 3 Then MoveHorizontally(x + d, y, 1)\n            Else\n                If x + d > 0 Then MoveHorizontally(x + d, y, -1)\n            End If\n        End Sub\n\n        Private Sub Move(ByVal direction As MoveDirection)\n            Select Case direction\n                Case MoveDirection.Up\n                    For x As Integer = 0 To 3\n                        Dim y As Integer = 1\n                        While y < 4\n                            If _board(x, y).Value <> 0 Then MoveVertically(x, y, -1)\n                            y += 1\n                        End While\n                    Next\n                Case MoveDirection.Down\n                    For x As Integer = 0 To 3\n                        Dim y As Integer = 2\n                        While y >= 0\n                            If _board(x, y).Value <> 0 Then MoveVertically(x, y, 1)\n                            y -= 1\n                        End While\n                    Next\n                Case MoveDirection.Left\n                    For y As Integer = 0 To 3\n                        Dim x As Integer = 1\n                        While x < 4\n                            If _board(x, y).Value <> 0 Then MoveHorizontally(x, y, -1)\n                            x += 1\n                        End While\n                    Next\n                Case MoveDirection.Right\n                    For y As Integer = 0 To 3\n                        Dim x As Integer = 2\n                        While x >= 0\n                            If _board(x, y).Value <> 0 Then MoveHorizontally(x, y, 1)\n                            x -= 1\n                        End While\n                    Next\n            End Select\n        End Sub\n    End Class\n\n    Module Module1\n        Sub Main()\n            RunGame()\n        End Sub\n\n        Private Sub RunGame()\n            Dim game As G2048 = New G2048()\n            game.Loop()\n            CheckRestart()\n        End Sub\n\n        Private Sub CheckRestart()\n            Console.WriteLine(\"(N) New game (P) Exit\")\n            While True\n                Dim input As Char\n                Char.TryParse(Console.ReadKey().Key.ToString(), input)\n                Select Case input\n                    Case \"N\"c\n                        RunGame()\n                    Case \"P\"c\n                        Return\n                    Case Else\n                        ClearLastLine()\n                End Select\n            End While\n        End Sub\n\n        Private Sub ClearLastLine()\n            Console.SetCursorPosition(0, Console.CursorTop)\n            Console.Write(New String(\" \", Console.BufferWidth))\n            Console.SetCursorPosition(0, Console.CursorTop - 1)\n        End Sub\n    End Module\n"
                }
            ],
            [
                {
                    "language": "Forth",
                    "solution": "\\ in Forth, you do many things on your own. This word is used to define 2D arrays\n: 2D-ARRAY ( height width )\n\tCREATE DUP ,\n\t* CELLS ALLOT\n\tDOES> ( y x baseaddress )\n\t\tROT    ( x baseaddress y )\n\t\tOVER @ ( x baseaddress y width )\n\t\t*      ( x baseaddress y*width )\n\t\tROT    ( baseaddress y*width x )\n\t\t+ 1+ CELLS +\n;\n\nrequire random.fs\nHERE SEED !\n\n0 CONSTANT D-INVALID\n1 CONSTANT D-UP\n2 CONSTANT D-DOWN\n3 CONSTANT D-LEFT\n4 CONSTANT D-RIGHT\n\n4 CONSTANT NROWS\n4 CONSTANT NCOLS\n\nNROWS NCOLS * CONSTANT GRIDSIZE\nNROWS NCOLS 2D-ARRAY GRID\nCREATE HAVE-MOVED CELL ALLOT\nCREATE TOTAL-SCORE CELL ALLOT\nCREATE MOVE-SCORE CELL ALLOT\n\n: DIE-DIRECTIONCONST .\" Unknown direction constant:\" . BYE ;\n: ESC #ESC EMIT ;\n: CLS\n\tESC .\" [2J\"\n\tESC .\" [H\"\n;\n\n: GRID-VALUE 1 SWAP LSHIFT ;\n: DASHES 0 ?DO [CHAR] - EMIT LOOP ;\n\n: DRAW ( -- )\n\tCLS .\" Score: \"\n\tTOTAL-SCORE @ 0 U.R\n\tMOVE-SCORE  @ ?DUP IF\n\t\t.\"  (+\" 0 U.R .\" )\"\n\tTHEN\n\tCR 25 DASHES CR\n\n\tNROWS 0 ?DO\n\t\t.\" |\"\n\t\tNCOLS 0 ?DO\n\t\t\tJ I GRID @ ?DUP IF\n\t\t\t\tGRID-VALUE 4 U.R\n\t\t\tELSE\n\t\t\t\t4 SPACES\n\t\t\tTHEN\n\t\t\t.\"  |\"\n\t\tLOOP\n\t\tCR\n\tLOOP\n\n\t25 DASHES CR\n;\n\n: COUNT-FREE-SPACES ( -- free-spaces )\n\t0 ( count )\n\tNROWS 0 ?DO\n\t\tNCOLS 0 ?DO\n\t\t\tJ I GRID @ 0= IF 1+ THEN\n\t\tLOOP\n\tLOOP\n;\n\n: GET-FREE-SPACE ( index -- addr )\n\t0 0 GRID SWAP ( curr-addr index )\n\t0 0 GRID @ 0<> IF 1+ THEN\n\t0 ?DO ( find the next free space index times )\n\t\tBEGIN\n\t\t\tCELL+ DUP @ 0=\n\t\tUNTIL\n\tLOOP\n;\n\n: NEW-BLOCK ( -- )\n\tCOUNT-FREE-SPACES\n\tDUP 0<= IF DROP EXIT THEN\n\tRANDOM GET-FREE-SPACE\n\t10 RANDOM 0= IF 2 ELSE 1 THEN SWAP !\n;\n\n: 2GRID ( a-y a-x b-y b-x -- a-addr b-addr ) GRID -ROT GRID SWAP ;\n: CAN-MERGE ( dest-addr other-addr -- can-merge? )\n\t@ SWAP @ ( other-val dest-val )\n\tDUP 0<> -ROT = AND\n;\n\n: CAN-GRAVITY ( dest-addr other-addr -- can-gravity? )\n\t@ SWAP @ ( other-val dest-val )\n\t0= SWAP 0<> AND\n;\n\n: TRY-MERGE ( dest-y dest-x other-y other-x -- )\n\t2GRID ( dest-addr other-addr )\n\t2DUP CAN-MERGE IF\n\t\tTRUE HAVE-MOVED !\n\t\t0 SWAP ! ( dest-addr )\n\t\tDUP @ 1+ DUP ( dest-addr dest-val dest-val )\n\t\tROT ! ( dest-val )\n\t\tGRID-VALUE DUP ( score-diff score-diff )\n\t\tMOVE-SCORE +!\n\t\tTOTAL-SCORE +!\n\tELSE\n\t\t2DROP\n\tTHEN\n;\n\n: TRY-GRAVITY ( did-something-before operator dest-y dest-x other-y other-x -- did-something-after operator )\n\t2GRID ( ... dest-addr other-addr )\n\t2DUP CAN-GRAVITY IF\n\t\tTRUE HAVE-MOVED !\n\t\tDUP @ ( ... dest-addr other-addr other-val )\n\t\tROT ( ... other-addr other-val dest-addr ) ! ( ... other-addr )\n\t\t0 SWAP !\n\t\tNIP TRUE SWAP\n\tELSE\n\t\t2DROP\n\tTHEN\n;\n\n: TRY-LOST? ( lost-before operator dy dx oy ox -- lost-after operator )\n\t2GRID CAN-MERGE INVERT ( lost-before operator lost-now )\n\tROT AND SWAP ( lost-after operator )\n;\n\n: MOVEMENT-LOOP ( direction operator -- ) CASE\n\tSWAP\n\tD-UP OF NROWS 1- 0 ?DO\n\t\tNCOLS 0 ?DO\n\t\t\tJ I J 1+ I 4 PICK EXECUTE\n\t\tLOOP\n\tLOOP ENDOF\n\tD-DOWN OF 1 NROWS 1- ?DO\n\t\tNCOLS 0 ?DO\n\t\t\tJ I J 1- I 4 PICK EXECUTE\n\t\tLOOP\n\t-1 +LOOP ENDOF\n\tD-LEFT OF NCOLS 1- 0 ?DO\n\t\tNROWS 0 ?DO\n\t\t\tI J I J 1+ 4 PICK EXECUTE\n\t\tLOOP\n\tLOOP ENDOF\n\tD-RIGHT OF 1 NCOLS 1- ?DO\n\t\tNROWS 0 ?DO\n\t\t\tI J I J 1- 4 PICK EXECUTE\n\t\tLOOP\n\t-1 +LOOP ENDOF\n\tDIE-DIRECTIONCONST\nENDCASE DROP ;\n\n: MERGE ( move -- ) ['] TRY-MERGE MOVEMENT-LOOP ;\n: GRAVITY-ONCE ( move -- success? ) FALSE SWAP ['] TRY-GRAVITY MOVEMENT-LOOP ;\n: GRAVITY ( move -- )\n\tBEGIN\n\t\tDUP GRAVITY-ONCE INVERT\n\tUNTIL DROP\n;\n\n: MOVE-LOST? ( move -- lost? ) TRUE SWAP ['] TRY-LOST? MOVEMENT-LOOP ;\n: END-IF-LOST ( -- lost? )\n\tCOUNT-FREE-SPACES 0= IF\n\t\tTRUE\n\t\t5 1 DO I MOVE-LOST? AND LOOP\n\t\tIF .\" You lose!\" CR BYE THEN\n\tTHEN\n;\n\n: END-IF-WON ( -- )\n\tNROWS 0 ?DO\n\t\tNCOLS 0 ?DO\n\t\t\tJ I GRID @ GRID-VALUE 2048 = IF .\" You win!\" CR BYE THEN\n\t\tLOOP\n\tLOOP\n;\n\n: TICK ( move -- )\n\tFALSE HAVE-MOVED !\n\t0 MOVE-SCORE !\n\tDUP GRAVITY DUP MERGE GRAVITY\n\tHAVE-MOVED @ IF NEW-BLOCK DRAW THEN\n\tEND-IF-WON\n\tEND-IF-LOST\n;\n\n: GET-MOVE ( -- move )\n\tBEGIN\n\t\tKEY CASE\n\t\t\t#EOF OF BYE ENDOF\n\t\t\t#ESC OF BYE ENDOF\n\t\t\t[CHAR] q OF BYE ENDOF\n\t\t\t[CHAR] Q OF BYE ENDOF\n\t\t\t[CHAR] k OF D-UP TRUE ENDOF\n\t\t\t[CHAR] K OF D-UP TRUE ENDOF\n\t\t\t[CHAR] j OF D-DOWN TRUE ENDOF\n\t\t\t[CHAR] J OF D-DOWN TRUE ENDOF\n\t\t\t[CHAR] h OF D-LEFT TRUE ENDOF\n\t\t\t[CHAR] H OF D-LEFT TRUE ENDOF\n\t\t\t[CHAR] l OF D-RIGHT TRUE ENDOF\n\t\t\t[CHAR] L OF D-RIGHT TRUE ENDOF\n\t\t\tFALSE SWAP\n\t\tENDCASE\n\tUNTIL\n;\n\n: INIT ( -- )\n\tNROWS 0 ?DO\n\t\tNCOLS 0 ?DO\n\t\t\t0 J I GRID !\n\t\tLOOP\n\tLOOP\n\n\t0 TOTAL-SCORE !\n\t0 MOVE-SCORE !\n\tNEW-BLOCK\n\tNEW-BLOCK\n\tDRAW\n;\n\n: MAIN-LOOP ( -- )\n\tBEGIN\n\t\tGET-MOVE TICK\n\tAGAIN\n;\n\nINIT\nMAIN-LOOP\n"
                },
                {
                    "language": "Factor",
                    "solution": "USE: accessors\nFROM: arrays => <array> array ;\nFROM: assocs => assoc-filter keys zip ;\nFROM: combinators => case cleave cond ;\nFROM: combinators.short-circuit => 1|| 1&& 2&& ;\nFROM: continuations => cleanup ;\nFROM: formatting => printf sprintf ;\nFROM: fry => '[ _ ;\nFROM: grouping => all-equal? clump group ;\nFROM: io => bl flush nl readln write ;\nFROM: kernel => = 2bi 2dup 2drop and bi bi* bi@ boa boolean clone equal? dip drop dup if if* keep loop nip not over swap throw tri unless when with xor ;\nFROM: math => integer times * + > >= ;\nFROM: math.functions => ^ ;\nFROM: math.parser => hex> ;\nFROM: math.order => +lt+ +gt+ +eq+ ;\nFROM: random => random sample ;\nFROM: sequences => <iota> <repetition> any? all? append concat each first flip head if-empty interleave length map pop push reduce reverse second set-nth tail ;\nFROM: sorting => sort ;\nFROM: vectors => <vector> ;\nIN: 2048-game\n\n\nERROR: invalid-board ;\n\nSYMBOL: left\nSYMBOL: right\nSYMBOL: up\nSYMBOL: down\n\nTUPLE: tile\n{ level integer }\n;\n\nTUPLE: board\n{ width integer }\n{ height integer }\n{ tiles array }\n;\n\nM: tile equal?\n    {\n        [ and ] ! test for f\n        [ [ level>> ] bi@ = ]\n    }\n    2&&\n;\n\n: valid-board? ( w h -- ? )\n    * 0 > ! board with 0 tiles does not have a meaningful representation\n;\n\n: <board> ( w h -- board )\n    [ valid-board? [ invalid-board throw ] unless ]\n    [ 2dup * f <array> board boa ] 2bi\n;\n\n: <tile> ( n -- tile )\n    tile boa\n;\n\n! 1 in 10 tile starts as 4\n: new-tile ( -- tile )\n    10 random 0 = [ 2 ] [ 1 ] if\n    <tile>\n;\n\n<PRIVATE\n\n: space-left? ( board -- ? )\n    tiles>> [ f = ] any?\n;\n\n: rows>> ( board -- seq )\n    dup tiles>>\n    [ drop { } ] [ swap width>> group ] if-empty\n;\n\n: rows<< ( seq board -- )\n    [ concat ] dip tiles<<\n;\n\n: columns>> ( board -- seq )\n    rows>> flip\n;\n\n: columns<< ( seq board -- )\n    [ flip concat ] dip tiles<<\n;\n\n: change-rows ( board quote -- board )\n    over [ rows>> swap call( seq -- seq ) ] [ rows<< ] bi\n; inline\n\n: change-columns ( board quote -- board )\n    over [ columns>> swap call( seq -- seq ) ] [ columns<< ] bi\n; inline\n\n: can-move-left? ( seq -- ? )\n    {\n        ! one element seq cannot move\n        [ length 1 = not ]\n        ! empty seq cannot move\n        [ [ f = ] all? not ]\n        [ 2 clump\n            [\n                {\n                    ! test for identical adjescent tiles\n                    [ [ first ] [ second ] bi [ and ] [ = ] 2bi and ]\n                    ! test for empty space on the left and tile on the right\n                    [ [ first ] [ second ] bi [ xor ] [ drop f = ] 2bi and ]\n                } 1||\n            ] any?\n        ]\n    } 1&&\n;\n\n: can-move-direction? ( board direction -- ? )\n    {\n        { left  [ rows>>    [         can-move-left? ] any? ] }\n        { right [ rows>>    [ reverse can-move-left? ] any? ] }\n        { up    [ columns>> [         can-move-left? ] any? ] }\n        { down  [ columns>> [ reverse can-move-left? ] any? ] }\n    } case\n;\n\n: can-move-any? ( board -- ? )\n    { left right up down } [ can-move-direction? ] with any?\n;\n\n: empty-indices ( seq -- seq )\n    [ length <iota> ] keep zip\n    [ nip f = ] assoc-filter keys\n;\n\n: pick-random ( seq -- elem )\n    1 sample first\n;\n\n! create a new tile on an empty space\n: add-tile ( board -- )\n    [ new-tile swap [ empty-indices pick-random ] keep [ set-nth ] keep ] change-tiles drop\n;\n\n! combines equal tiles justified right or does nothing\n: combine-tiles ( tile1 tile2 -- tile3 tile4 )\n    2dup { [ and ] [ = ] } 2&&\n    [ drop [ 1 + ] change-level f swap ] when\n;\n\n: justify-left ( seq -- seq )\n    [\n        {\n            { [ dup  f = ] [ 2drop +lt+ ] }\n            { [ over f = ] [ 2drop +gt+ ] }\n            [ 2drop +eq+ ]\n        } cond\n    ] sort\n;\n\n: collapse ( seq -- seq )\n    justify-left\n\n    ! combine adjescent\n    dup length <vector>\n    [ over\n        [ swap [ push ] keep ]\n        [\n            {\n                [ pop combine-tiles ]\n                [ push ]\n                [ push ]\n            } cleave\n        ] if-empty\n    ] reduce\n\n    ! fill in the gaps after combination\n    justify-left\n;\n\n! draws an object\nGENERIC: draw ( obj -- )\n\nPRIVATE>\n\n! a single tile is higher than 2048 (level 10)\n: won? ( board -- ? )\n    tiles>> [ dup [ level>> 11 >= ] when ] any?\n;\n\n! if there is no space left and no neightboring tiles are the same, end the board\n: lost? ( board -- ? )\n    {\n        [ space-left? ]\n        [ won? ]\n        [ can-move-any? ]\n    } 1|| not\n;\n\n: serialize ( board -- str )\n    [ width>> ]\n    [ height>> ]\n    [ tiles>>\n        [ dup f = [ drop 0 ] [ level>> ] if \"%02x\" sprintf ] map concat\n    ] tri\n    \"%02x%02x%s\" sprintf\n;\n\n: deserialize ( str -- board )\n    [ 2 head hex> ] [ 2 tail ] bi\n    [ 2 head hex> ] [ 2 tail ] bi\n    2 group [ hex> dup 0 = [ drop f ] [ tile boa ] if ] map\n    board boa\n;\n\n: move ( board direction -- )\n    {\n        { left  [ [ [         collapse         ] map ] change-rows    ] }\n        { right [ [ [ reverse collapse reverse ] map ] change-rows    ] }\n        { up    [ [ [         collapse         ] map ] change-columns ] }\n        { down  [ [ [ reverse collapse reverse ] map ] change-columns ] }\n    } case drop\n;\n\n\n: get-input ( -- line )\n    readln\n;\n\n: parse-input ( line -- direction/f )\n    {\n        { \"a\" [ left  ] }\n        { \"d\" [ right ] }\n        { \"w\" [ up    ] }\n        { \"s\" [ down  ] }\n        { \"q\" [ f ] }\n        [ \"Wrong input: %s\\n\" printf flush\n          get-input parse-input ]\n    } case\n;\n\n<PRIVATE\n\n: init ( board -- )\n    '[ _ add-tile ] 2 swap times\n;\n\nM: tile draw ( tile -- )\n    level>> 2 swap ^ \"% 4d\" printf\n;\n\nM: boolean draw ( _ -- )\n    drop 4 [ bl ] times\n;\n\n: horizontal-line ( board -- )\n    width>>\n    \" \" write\n    \"+------\" <repetition> concat\n    write \"+ \" write nl\n;\n\n: separator ( -- )\n    \" | \" write\n;\n\nM: board draw ( board -- )\n    [ horizontal-line ] keep\n    [ rows>> ]\n    [\n       '[ _ horizontal-line ]\n        [   separator\n            [ separator ] [ draw ] interleave\n            separator nl\n        ] interleave\n    ]\n    [ horizontal-line ]\n    tri\n    flush\n;\n\n: update ( board -- f )\n    {\n        [\n            get-input parse-input [\n                {\n                    [ can-move-direction? ]\n                    [ over [ move ] [ add-tile ] bi* t ]\n                } 2&& drop t\n            ] [ drop f ] if*\n        ]\n        [ can-move-any? ]\n    } 1&&\n;\n\n: exit ( board -- )\n    {\n        { [ dup lost? ] [ \"You lost! Better luck next time.\" write nl ] }\n        { [ dup won?  ] [ \"You won! Congratulations!\" write nl ] }\n        [ \"Bye!\" write nl ]\n    } cond drop\n;\n\nPRIVATE>\n\n: start-2048 ( -- )\n    4 4 <board>\n    [\n        ! Initialization\n        [ init ]\n        [ draw ]\n        ! Event loop\n        [ [ dup [ update ] [ draw ] bi ] loop ] tri\n    ]\n    ! Cleanup\n    [ exit ]\n    [ ]\n    cleanup\n;\n\nMAIN: start-2048\n"
                }
            ],
            [
                {
                    "language": "M2000-Interpreter",
                    "solution": "Module Game2048 {\n      \\\\ 10% 4 and 90% 2\n      Def GetTlleNumber()=If(Random(10)<2->4, 2)\n      \\\\ tile\n      Def Tile$(x)=If$(x=0->\"[    ]\", format$(\"[{0::-4}]\", x))\n      \\\\ empty board\n      BoardTileRight=lambda (x, y)->x+y*4\n      BoardTileLeft=lambda (x, y)->3-x+y*4\n      BoardTileUp=lambda (x, y)->x*4+y\n      BoardTileDown=lambda (x, y)->(3-x)*4+y\n      Dim Board(0 to 15)\n      Inventory EmptyTiles\n      \\\\ Score is a statement but we can use it as a variable too.\n      Score=0\n      \\\\ Win is also a statement but we can use it as a variable too.\n      Win=False\n      ExitNow=False\n      BoardDirection=BoardtileRight\n      Process(BoardDirection)\n      \\\\ Split Rem lines to insert start condition to check valid moves\n      Rem : board(0)=2\n      Rem : board(1)=2, 2, 2   ' place to (1), (2), (3)\n            While len(EmptyTiles) {\n            NewTile()\n            DrawBoard()\n            Action=False\n            do {\n                  a$=key$\n                  if len(a$)=2 then {\n                        Action=true\n                        Select case Asc(mid$(a$,2))\n                        Case 72\n                        BoardDirection=BoardTileUp\n                        Case 75\n                        BoardDirection=BoardTileRight\n                        Case 77\n                        BoardDirection=BoardTileLeft\n                        Case 80\n                        BoardDirection=BoardTileDown\n                        Case 79 ' End key\n                              ExitNow=True\n                        Else\n                        Action=false\n                        end select\n                  }\n            } until Action\n            If ExitNow then exit\n            Process(BoardDirection)\n      }\n      If Win then {\n            Print \"You Win\"\n      } Else {\n            Print \"You Loose\"\n      }\n      End\n      Sub Process(Boardtile)\n      Inventory EmptyTiles   ' clear inventory\n      local where, i, j, k\n      For i=0 to 3\n            Gravity()\n            k=boardtile(0,i)\n            For j=1 to 3\n                  where=boardtile(j,i)\n                  if Board(where)<>0 then {\n                        if board(k)=board(where) then {\n                               board(k)*=2 : score+=board(where): board(where)=0\n                               if board(k)=2048 Then Win=True : ExitNow=true\n                        }\n                  }\n                  k=where\n            Next j\n            Gravity()\n            For j=0 to 3\n                  where=boardtile(j,i)\n                  if board(where)=0 then Append EmptyTiles, where\n            Next j\n      Next i\n      End Sub\n      Sub NewTile()\n            local m=EmptyTiles(Random(0, len(EmptyTiles)-1)!)\n            Board(m)=GetTlleNumber()\n            Delete EmptyTiles, m\n      End Sub\n      Sub DrawBoard()\n            Refresh 2000\n            Cls\n            Cursor 0, 10\n            Local Doc$, line$\n            Document Doc$\n            Doc$=Format$(\"Game 2048 Score {0}\", score)\n            \\\\ Using Report 2 we use rendering as text, with center justify\n            Report 2, Doc$\n            Doc$={\n            }\n            Local i, j\n            For i=0 to 3\n                  line$=\"\"\n                  For j=0 to 3\n                        line$+=Tile$(Board(BoardTileRight(j, i)))\n                  Next j\n                  Print Over $(2), Line$\n                  Print\n                  Doc$=Line$+{\n                  }\n            Next i\n            Report 2, \"Next:Use Arrows | Exit: Press End\"\n            Refresh\n            ClipBoard Doc$\n      End Sub\n      Sub Gravity()\n            k=-1\n            for j=0 to 3 {\n                  where=boardtile(j,i)\n                  if k=-1 then if board(where)=0 then k=j : continue\n                  if board(where)=0  then continue\n                  if k=-1 then continue\n                  board(boardtile(k,i))=board(where)\n                  board(where)=0\n                  k++\n            }\n      End Sub\n}\nGame2048\n"
                },
                {
                    "language": "FutureBasic",
                    "solution": "begin enum 123\n  _lf\n  _rt\n  _dn\n  _up\n  _new\n  _end\nend enum\nstr63 bd\ncolorref color(11)\nbyte zs\n\nvoid local fn initialize\n  subclass window 1, @\"2048\",(0,0,438,438)\n  fn WindowSetBackgroundColor( 1, fn ColorBlack )\n  color(0)  = fn ColorDarkGray\n  color(1)  = fn ColorGray\n  color(2)  = fn ColorLightGray\n  color(3)  = fn ColorBlue\n  color(4)  = fn ColorBrown\n  color(5)  = fn ColorCyan\n  color(6)  = fn ColorGreen\n  color(7)  = fn ColorMagenta\n  color(8)  = fn ColorOrange\n  color(9)  = fn ColorPurple\n  color(10) = fn ColorYellow\n  color(11) = fn ColorRed\nend fn\n\nvoid local  fn drawBoard\n  int x, y,r = 1, add\n  cls\n  for y = 320 to 20 step -100\n    for x = 20 to 320 step 100\n      rect fill (x,y,98,98),color( bd[r] )\n      select bd[r]\n        case <  4 : add = 40\n        case <  7 : add = 30\n        case < 10 : add = 20\n        case else : add =  6\n      end select\n      if bd[r] then print %(x+add, y+25)2^bd[r]\n      r++\n    next\n  next\nend fn\n\nlocal fn finish( won as bool )\n  CFStringRef s = @\"GAME OVER\"\n  CGRect r      = fn windowContentRect( 1 )\n  r.origin.y   += r.size.height - 20\n  r.size.height = 100\n  window 2,,r,NSwindowStyleMaskBorderless\n  if won\n    fn windowSetBackgroundColor( 2, color(11) )\n    s = @\"CONGRATULATIONS\u2014YOU DID IT!!\"\n    text,24,fn ColorBlack,,NSTextAlignmentCenter\n  else\n    fn windowSetBackgroundColor( 2, fn ColorBlack )\n    text,24,fn ColorWhite,,NSTextAlignmentCenter\n  end if\n  print s\n  button _new,,,@\"New Game\", (229,20,100,32)\n  button _end,,,@\"Quit\",     (109,20,100,32)\nend fn\n\nvoid local  fn newGame\n  int r\n  text @\"Arial bold\", 36, fn ColorBlack, fn ColorClear\n  bd = chr$(0)\n  for r = 1 to 4\n    bd += bd\n  next\n  bd[rnd(16)] ++\n  do\n    r = rnd(16)\n  until bd[r] == 0\n  bd[r]++\n  zs = 14\n  fn drawBoard\nend fn\n\nlocal fn play( st as short, rd as short, cd as short )\n  short a, b, c, t, moved = 0\n\n  for a = st to st + rd * 3 step rd\n    //  SHIFT\n    t = a\n    for b = a to a + cd * 3 step cd\n      if bd[b]\n        if t <> b then swap bd[t], bd[b] : moved ++\n        t += cd\n      end if\n    next\n    //  MERGE\n    for b = a to a + cd * 2 step cd\n      if bd[b] > 0 && bd[b] == bd[b+cd]\n        bd[b]++ : c = b + cd\n        //  FILL IN\n        while c <> a+cd*3\n          bd[c] = bd[c+cd] : c += cd\n        wend\n        bd[c] = 0\n        //  CHECK FOR WIN\n        if bd[b] == 11 then fn drawBoard : fn finish( yes ) : exit fn\n        zs ++ : moved ++\n      end if\n    next\n  next\n\n  fn drawBoard\n  if moved == 0 then exit fn\n\n  //  GROW\n  b = 0 : c = rnd(zs)\n  while c\n    b ++\n    if bd[b] == 0 then c--\n  wend\n  if rnd(10) - 1 then bd[b]++ else bd[b] = 2\n  zs--\n  timerbegin 0.25\n    fn drawBoard\n  timerend\n  if zs then exit fn\n\n  //  IS GAME OVER?\n  for a = 1 to 12\n    if bd[a] == bd[a+4] then exit fn\n  next\n  for a = 1 to 13 step 4\n    if bd[a] == bd[a+1] || bd[a+1] == bd[a+2] || bd[a+2] == bd[a+3]\u00ac\n      then exit fn\n    next\n\n    fn finish( no )\nend fn\n\nlocal fn doDialog(ev as long,tag as long, wnd as long)\n  select ev\n    case _windowKeyDown : if window() == 2 then exit fn\n      select fn EventKeyCode\n        case _up  : fn play(13, 1, -4)\n        case _dn  : fn play( 1, 1,  4)\n        case _lf  : fn play( 1, 4,  1)\n        case _rt  : fn play( 4, 4, -1)\n        case else : exit fn\n      end select\n      DialogEventSetBool(yes)\n    case _btnClick : window close 2\n      if tag == _end then end\n      fn newGame\n    case _windowWillClose : if wnd == 1 then end\n  end select\nend fn\n\nfn initialize\nfn newGame\non dialog fn doDialog\n\nhandleevents\n"
                }
            ],
            [
                {
                    "language": "Ring",
                    "solution": "# Project : 2048 Game\n\nload \"stdlib.ring\"\nload \"guilib.ring\"\n\nC_GAMETITLE\t\t= '2048 Game'\nC_WINDOWBACKGROUND \t= \"background-color: gray;\"\nif isMobile()\n\tC_LABELFONTSIZE \t= \"font-size:120px;\"\n\tC_BUTTONFONTSIZE \t= \"font-size:160px;\"\nelse\n\tC_LABELFONTSIZE \t= \"font-size:50px;\"\n\tC_BUTTONFONTSIZE \t= \"font-size:80px;\"\nok\nC_PLAYERSCORESTYLE\t= \"color:white;background-color:rgb(50,50,50);border-radius:17px;\" + C_LABELFONTSIZE\nC_NEWGAMESTYLE\t\t= 'color:white;background-color:rgb(50,50,50);border-radius:17px;' + C_LABELFONTSIZE\nC_EMPTYBUTTONSTYLE \t= 'border-radius:17px;background-color:silver;' + C_BUTTONFONTSIZE\nC_BUTTON2STYLE \t\t= 'border-radius:17px;color:black; background-color: yellow ;' + C_BUTTONFONTSIZE\nC_BUTTON4STYLE \t\t= 'border-radius:17px;color:black; background-color: violet ;' + C_BUTTONFONTSIZE\nC_BUTTON8STYLE \t\t= 'border-radius:17px;color:white; background-color: purple ;' + C_BUTTONFONTSIZE\nC_BUTTON16STYLE \t= 'border-radius:17px;color:white; background-color: blue ;' + C_BUTTONFONTSIZE\nC_BUTTON32STYLE \t= 'border-radius:17px;color:white; background-color: red ;' + C_BUTTONFONTSIZE\nC_BUTTON64STYLE \t= 'border-radius:17px;color:black; background-color: lightgray ;' + C_BUTTONFONTSIZE\nC_BUTTON128STYLE \t= 'border-radius:17px;color:black; background-color: white ;' + C_BUTTONFONTSIZE\nC_BUTTON256STYLE \t= 'border-radius:17px;color:white; background-color: black ;' + C_BUTTONFONTSIZE\nC_BUTTON512STYLE \t= 'border-radius:17px;color:white; background-color: Purple ;' + C_BUTTONFONTSIZE\nC_BUTTON1024STYLE \t= 'border-radius:17px;color:black; background-color: Yellow ;' + C_BUTTONFONTSIZE\nC_BUTTON2048STYLE \t= 'border-radius:17px;color:white; background-color: Green ;' + C_BUTTONFONTSIZE\nC_LAYOUTSPACING\t\t= 10\nC_PLAYERSCORE\t\t= 'Player Score :  '\n\nsize = 4\nlimit = 2\nnum = 0\nflag = 0\nx1 = 0\nx2 = 0\ny1 = 0\ny2 = 0\nnScore = 0\nbutton = newlist(size,size)\nbuttonsave = newlist(size,size)\nLayoutButtonRow = list(size+2)\nmoveleft = []\nmoveright = []\nmoveup = []\nmovedown = []\nmyfilter2 = null\nmyfilter3 = null\nwinheight = 0\nwinwidth = 0\n\napp = new qApp {\n          StyleFusion()\n          processevents()\n          win = new qWidget() {\n                  setWindowTitle(C_GAMETITLE)\n                  setgeometry(100,100,600,700)\n                  setminimumwidth(300)\n                  setminimumheight(300)\n\t\t  if not isMobile()\n\t                  grabkeyboard()\n\t\t  ok\n                  setstylesheet(C_WINDOWBACKGROUND)\n                  move(490,100)\n                  for n = 1 to size\n                       for m = 1 to size\n                            button[n][m] = new MyButton(win)\n                       next\n                  next\n                  newgame = new qLabel(win)\n                  playerscore = new qLabel(win)\n                  myfilter3 = new qAllEvents(win) {\n                  setMouseButtonPressEvent(\"pPress()\")\n                  setMouseButtonReleaseEvent(\"pRelease()\")}\n                  installeventfilter(myfilter3)\n                  myfilter2 = new qAllEvents(win) {\n                  setkeypressevent(\"keypress()\") }\n                  installeventfilter(myfilter2)\n                  winwidth = win.width()\n                  winheight = win.height()\n                  for n = 1 to size + 2\n\t\t\tLayoutButtonRow[n] = new QHBoxLayout() {\n\t\t\t\tsetSpacing(C_LAYOUTSPACING)\n\t\t\t}\n                  next\n                  for n = 1 to size\n                       for m = 1 to size\n                            button[n][m] { temp = text() }\n                            buttonsave[n][m] = temp\n                            button[n][m] = new MyButton(win) {\n                                                   setalignment(Qt_AlignHCenter | Qt_AlignVCenter)\n                                                   setstylesheet(C_EMPTYBUTTONSTYLE)\n                                                   show()\n                                           }\n                       next\n                  next\n                  for n = 1 to size\n                       for m = 1 to size\n                            LayoutButtonRow[n].AddWidget(button[m][n])\n                            win.show()\n                            temp = buttonsave[n][m]\n                            button[n][m].settext(temp)\n                       next\n  \t\t       LayoutButtonRow[n].setSpacing(C_LAYOUTSPACING)\n                  next\n                  playerscore {\n                                    setGeometry(0,4*floor(winheight/6),winwidth,floor(winheight/6))\n                                    setalignment(Qt_AlignHCenter | Qt_AlignVCenter)\n                                    settext(C_PLAYERSCORE + nScore)\n\t\t\t\t    setStylesheet(C_PLAYERSCORESTYLE)\n                                    show()\n\t\t  }\n                  newgame  {\n                                  setGeometry(0,5*floor(winheight/6),winwidth,floor(winheight/6))\n                                  setalignment(Qt_AlignHCenter | Qt_AlignVCenter)\n                                  setstylesheet(C_NEWGAMESTYLE)\n                                  settext('New Game')\n                                  myfilter4 = new qallevents(newgame)\n                                  myfilter4.setMouseButtonPressEvent(\"pbegin()\")\n                                  installeventfilter(myfilter4)\n                                  show()\n                                  }\n                  LayoutButtonRow[size+1].AddWidget(playerscore)\n                  LayoutButtonRow[size+2].AddWidget(newgame)\n                  LayoutButtonMain = new QVBoxLayout() {\n\t\t\tsetSpacing(C_LAYOUTSPACING)\n\t\t\tfor n = 1 to size+2\n\t\t\t\tAddLayout(LayoutButtonRow[n])\n\t\t\t\twin.show()\n\t\t\tnext\n\t\t  }\n\t\t  win.setLayout(LayoutButtonMain)\n                  win.show()\n                  pbegin()\n                  show()\n         }\n    exec()\n}\n\nfunc pPress()\n        x1 = myfilter3.getglobalx()\n        y1 = myfilter3.getglobaly()\n\nfunc pRelease()\n        x2 = myfilter3.getglobalx()\n        y2 = myfilter3.getglobaly()\n        difx = x2 - x1\n\tdify = y2 - y1\n\tif fabs(difx) > fabs(dify)\n\t\tif difx < 0\n\t\t\tpleft()\n\t\telse\n\t\t\tpRight()\n\t\tok\n\telse\n\t\tif dify < 0\n\t\t\tpUp()\n\t\telse\n\t\t\tpDown()\n\t\tok\n\tok\n\nfunc keypress()\n        nKey = myfilter2.getkeycode()\n        switch nKey\n                   on 16777234 pleft()\n                   on 16777236 pright()\n                   on 16777235 pup()\n                   on 16777237 pdown()\n        off\n\nfunc pbegin()\n       numbers = [['2','2'],['2','4']]\n       randnew = newlist(2,2)\n       for n = 1 to size\n            for m = 1 to size\n                 button[n][m].setStylesheet(C_EMPTYBUTTONSTYLE)\n                 button[n][m].settext('')\n            next\n        next\n        while true\n                rn1 = random(size - 1) + 1\n                rm1 = random(size - 1) + 1\n                rn2 = random(size - 1) + 1\n                rm2 = random(size - 1) + 1\n                bool = (rn1 = rn2) and (rm1 = rm2)\n                if not bool\n                   exit\n                ok\n        end\n        rand = random(limit - 1) + 1\n        button[rn1][rm1].settext(numbers[rand][1])\n        button[rn2][rm2].settext(numbers[rand][2])\n        nScore = 0\n        playerscore.settext(C_PLAYERSCORE)\n\nfunc pMoveInDirection cFunc\n        num = gameover()\n        if num = size*size\n           flag = 1\n           msgBox('You lost!')\n           pbegin()\n        ok\n        if flag = 0\n           call cFunc()\n           sleep(0.5)\n           newnum()\n        ok\n\nfunc pdown()\n\tpMoveInDirection(:pMoveDown)\n\nfunc pup()\n\tpMoveInDirection(:pMoveUp)\n\nfunc pleft()\n\tpMoveInDirection(:pMoveLeft)\n\nfunc pright()\n\tpMoveInDirection(:pMoveRight)\n\nfunc pmoveleft()\n       for n = 1 to size\n            moveleft = []\n            for m = 1 to size\n                 button[m][n] {temp = text()}\n                 if temp != ''\n                    add(moveleft,temp)\n                 ok\n            next\n            movetilesleft(n,moveleft)\n       next\n\nfunc pmoveright()\n       for n = 1 to size\n            moveright = []\n            for m = size to 1 step -1\n                 button[m][n] {temp = text()}\n                 if temp != ''\n                    add(moveright,temp)\n                 ok\n            next\n            movetilesright(n,moveright)\n        next\n        return\n\nfunc pmoveup()\n       for n = 1 to size\n            moveup = []\n            for m = 1 to size\n                 button[n][m] {temp = text()}\n                 if temp != ''\n                    add(moveup,temp)\n                 ok\n            next\n            movetilesup(n,moveup)\n        next\n        return\n\nfunc pmovedown()\n       for n = 1 to size\n            movedown = []\n            for m = size to 1 step -1\n                 button[n][m] {temp = text()}\n                 if temp != ''\n                    add(movedown,temp)\n                 ok\n            next\n            movetilesdown(n,movedown)\n        next\n        return\n\nfunc movetilesleft(nr,moveleft)\n       for p = 1 to len(moveleft) - 1\n            temp1 = moveleft[p]\n            temp2 = moveleft[p+1]\n            temp = string(number(temp1) + number(temp2))\n            if (temp1 = temp2) and (temp1 != '0') and (temp2 != '0') and (temp1 != '') and (temp2 != '')\n               if temp != '0' and temp != ''\n                  nScore = nScore + temp\n                  playerscore.settext(C_PLAYERSCORE + nScore)\n                  flag = 1\n                  moveleft[p] = temp\n                  del(moveleft,p+1)\n               ok\n            ok\n       next\n       for n = 1 to len(moveleft)\n            button[n][nr].settext(moveleft[n])\n       next\n       for n = len(moveleft) + 1 to size\n            if n <= size\n               button[n][nr].setStylesheet(C_EMPTYBUTTONSTYLE)\n               button[n][nr].settext('')\n            ok\n       next\n       return\n\nfunc movetilesright(nr,moveright)\n       flag = 0\n       for p = 2 to len(moveright)\n            temp1 = moveright[p]\n            temp2 = moveright[p-1]\n             if (temp1 = temp2) and (temp1 != '0') and (temp2 != '0') and (temp1 != '') and (temp2 != '')\n               temp = string(number(temp1) + number(temp2))\n               if temp != '0' and temp != ''\n                  nScore = nScore + temp\n                  playerscore.settext(C_PLAYERSCORE + nScore)\n                  flag = 1\n                  moveright[p] = temp\n                  del(moveright,p-1)\n               ok\n            ok\n       next\n       for n = 1 to len(moveright)\n            button[size-n+1][nr].settext(moveright[n])\n       next\n       for n = 1 to size - len(moveright)\n            if n <= size\n               button[n][nr].setStylesheet(C_EMPTYBUTTONSTYLE)\n               button[n][nr].settext('')\n            ok\n       next\n\n\nfunc movetilesup(nr,moveup)\n        flag = 0\n        for p = 1 to len(moveup) - 1\n             temp1 = moveup[p]\n             temp2 = moveup[p+1]\n             if (temp1 = temp2) and (temp1 != '0') and (temp2 != '0') and (temp1 != '') and (temp2 != '')\n               temp = string(number(temp1) + number(temp2))\n               if temp != '0' and temp != ''\n                  nScore = nScore + temp\n                  playerscore.settext(C_PLAYERSCORE + nScore)\n                  flag = 1\n                  moveup[p] = temp\n                  del(moveup,p+1)\n               ok\n            ok\n       next\n       for n = 1 to len(moveup)\n            button[nr][n].settext(moveup[n])\n       next\n       for n = len(moveup) + 1 to size\n            if n <= size\n               button[nr][n].setStylesheet(C_EMPTYBUTTONSTYLE)\n               button[nr][n].settext('')\n            ok\n       next\n\nfunc movetilesdown(nr,movedown)\n        flag = 0\n        for p = 1 to len(movedown) - 1\n             temp1 = movedown[p]\n             temp2 = movedown[p+1]\n             if (temp1 = temp2) and (temp1 != '0') and (temp2 != '0') and (temp1 != '') and (temp2 != '')\n               temp = string(number(temp1) + number(temp2))\n               if temp != '0' and temp != ''\n                  nScore = nScore + temp\n                  playerscore.settext(C_PLAYERSCORE + nScore)\n                  flag = 1\n                  movedown[p] = temp\n                  del(movedown,p+1)\n               ok\n            ok\n       next\n       for n = 1 to len(movedown)\n            button[nr][size-n+1].settext(movedown[n])\n       next\n       for n = size - len(movedown) to 1 step -1\n            if n <= size\n               button[nr][n].setStylesheet(C_EMPTYBUTTONSTYLE)\n               app.processevents()\n               button[nr][n].settext('')\n            ok\n       next\n\nfunc newnum()\n        while true\n                rn = random(size - 1) + 1\n                rm = random(size - 1) + 1\n                if button[rn][rm].text() = ''\n                   button[rn][rm].settext('2')\n                   exit\n                ok\n        end\n        return\n\nfunc gameover()\n        num = 0\n        flag = 0\n        for n = 1 to size\n             for m = 1 to size\n                  if button[n][m].text() != ''\n                     num = num + 1\n                  ok\n              next\n        next\n        return num\n\nfunc msgBox(text) {\n\tm = new qMessageBox(win) {\n\t       setWindowTitle('2048 Game')\n\t       setText(text)\n\t       show()\n\t       }\n        }\n\nfunc showarray(vect)\n        see \"[\"\n        svect = \"\"\n        for n = 1 to len(vect)\n              svect = svect + vect[n] + \" \"\n        next\n        svect = left(svect, len(svect) - 1)\n        see svect\n        see \"]\" + nl\n\nclass MyButton from qLabel\n       func setText(cValue)\n              Super.setText(cValue)\n              switch cValue\n                        on '2' \t\tsetStyleSheet(C_BUTTON2STYLE)\n                        on '4' \t\tsetStylesheet(C_BUTTON4STYLE)\n                        on '8' \t\tsetStylesheet(C_BUTTON8STYLE)\n                        on '16' \tsetStylesheet(C_BUTTON16STYLE)\n                        on '32' \tsetStylesheet(C_BUTTON32STYLE)\n                        on '64' \tsetStylesheet(C_BUTTON64STYLE)\n                        on '128' \tsetStylesheet(C_BUTTON128STYLE)\n\t\t\ton '256'\tsetStylesheet(C_BUTTON256STYLE)\n\t\t\ton '512'\tsetStylesheet(C_BUTTON512STYLE)\n\t\t\ton '1024'\tsetStylesheet(C_BUTTON1024STYLE)\n\t\t\ton '2048'\tsetStylesheet(C_BUTTON2048STYLE)\n              off\n"
                },
                {
                    "language": "JavaScript",
                    "solution": "/* Tile object: */\n\nfunction Tile(pos, val, puzzle){\n\tthis.pos     = pos;\n\tthis.val     = val;\n\tthis.puzzle  = puzzle;\n\tthis.merging = false;\n\t\n\tthis.getCol = () => Math.round(this.pos % 4);\n\tthis.getRow = () => Math.floor(this.pos / 4);\n\t\n\t/* draw tile on a P5.js canvas: */\n\t\n\tthis.show = function(){\n\t\tlet padding = this.merging ? 0 : 5;\n\t\tlet size = 0.25*width;\n\t\tnoStroke();\n\t\tcolorMode(HSB, 255);\n\t\tfill(10*(11 - Math.log2(this.val)), 50 + 15*Math.log2(this.val), 200);\n\t\trect(this.getCol()*size + padding, this.getRow()*size + padding, size - 2*padding, size - 2*padding);\n\t\tfill(255);\n\t\ttextSize(0.1*width);\n\t\ttextAlign(CENTER, CENTER);\n\t\ttext(this.val, (this.getCol() + 0.5)*size, (this.getRow() + 0.5)*size);\n\t}\n\t\n\t/* move tile in a given direction: */\n\t\n\tthis.move = function(dir){\n\t\tlet col = this.getCol() + (1 - 2*(dir < 0))*Math.abs(dir)%4;\n\t\tlet row = this.getRow() + (1 - 2*(dir < 0))*Math.floor(Math.abs(dir)/4);\n\t\tlet target = this.puzzle.getTile(this.pos + dir);\n\t\t\n\t\tif (col < 0 || col > 3 || row < 0 || row > 3) {\n\t\t\t/* target position out of bounds */\n\t\t\treturn false;\n\t\t} else if (target){\n\t\t\t/* tile blocked by other tile */\n\t\t\tif(this.merging || target.merging || target.val !== this.val)\n\t\t\t\treturn false;\n\t\t\t\n\t\t\t/* merge with target tile (equal values):*/\n\t\t\ttarget.val += this.val;\n\t\t\ttarget.merging = true;\n\t\t\tthis.puzzle.score += target.val;\n\t\t\tthis.puzzle.removeTile(this);\n\t\t\treturn true;\n\t\t}\n\t\n\t\t/* move tile: */\n\t\tthis.pos += dir;\n\t\treturn true;\n\t}\n}\n\n/* Puzzle object: */\n\nfunction Puzzle(){\n\tthis.tiles    = [];\n\tthis.dir      = 0;\n\tthis.score    = 0;\n\tthis.hasMoved = false;\n\tthis.validPositions = [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15];\n\t\n\tthis.getOpenPositions = () => this.validPositions.filter(i => this.tiles.map(x => x.pos).indexOf(i) === -1);\n\tthis.getTile          = pos => this.tiles.filter(x => x.pos === pos)[0];\n\tthis.removeTile       = tile => this.tiles.splice(this.tiles.indexOf(tile), 1);\n\tthis.winCondition     = () => this.tiles.some(x => x.val === 2048);\n\n\t/* check for valid moves: */\n\t\n\tthis.validMoves = function(){\n\t\t/* return true if there are empty spaces */\n\t\tif(this.tiles.length < 16)\n\t\t\treturn true;\n\t\t\n\t\t/* otherwise check for neighboring tiles with the same value */\n\t\tlet res = false;\n\t\tthis.tiles.sort((x,y) => x.pos - y.pos);\n\t\tfor(let i = 0; i < 16; i++)\n\t\t\tres = res || ( (i%4 < 3) ? this.tiles[i].val === this.tiles[i+1].val : false )\n\t\t\t\t\t  || ( (i  < 12) ? this.tiles[i].val === this.tiles[i+4].val : false );\n\t\treturn res;\n\t}\n\t\n\t/* check win and lose condition: */\n\t\n\tthis.checkGameState = function(){\n\t\tif(this.winCondition()){\n\t\t\talert('You win!');\n\t\t} else if (!this.validMoves()){\n\t\t\talert('You Lose!');\n\t\t\tthis.restart();\n\t\t}\n\t}\n\t\n\tthis.restart = function(){\n\t\tthis.tiles    = [];\n\t\tthis.dir      = 0;\n\t\tthis.score    = 0;\n\t\tthis.hasMoved = false;\n\t\tthis.generateTile();\n\t\tthis.generateTile();\n\t}\n\t\n\t/* draw the board on the p5.js canvas: */\n\t\n\tthis.show = function(){\n\t\tbackground(200);\n\t\tfill(255);\n\t\ttextSize(0.05*width);\n\t\ttextAlign(CENTER, TOP);\n\t\ttext(\"SCORE: \" + this.score, 0.5*width, width);\n\t\t\n\t\tfor(let tile of this.tiles)\n\t\t\ttile.show();\n\t}\n\t\n\t/* update the board: */\n\t\n\tthis.animate = function(){\n\t\tif(this.dir === 0)\n\t\t\treturn;\n\t\t\n\t\t/* move all tiles in a given direction */\n\t\tlet moving = false;\n\t\tthis.tiles.sort((x,y) => this.dir*(y.pos - x.pos));\n\t\tfor(let tile of this.tiles)\n\t\t\tmoving = moving || tile.move(this.dir);\n\t\t\n\t\t/* check if the move is finished and generate a new tile */\n\t\tif(this.hasMoved && !moving){\n\t\t\tthis.dir = 0;\n\t\t\tthis.generateTile();\n\t\t\t\n\t\t\tfor(let tile of this.tiles)\n\t\t\t\ttile.merging = false;\n\t\t}\n\t\tthis.hasMoved = moving;\n\t}\n\t\n\tthis.generateTile = function(){\n\t\tlet positions = this.getOpenPositions();\n\t\tlet pos       = positions[Math.floor(Math.random()*positions.length)];\n\t\tlet val       = 2 + 2*Math.floor(Math.random()*1.11);\n\t\tthis.tiles.push(new Tile(pos, val, this));\n\t}\n\tthis.generateTile();\n\tthis.generateTile();\n\t\n\t/* process key inputs: */\n\t\n\tthis.keyHandler = function(key){\n\t\tif      (key === UP_ARROW)    this.dir = -4\n\t\telse if (key === DOWN_ARROW)  this.dir = 4\n\t\telse if (key === RIGHT_ARROW) this.dir = 1\n\t\telse if (key === LEFT_ARROW)  this.dir = -1;\n\t}\n}\n\n\nlet game;\n\nfunction setup() {\n\tcreateCanvas(400, 420);\t\n\tgame = new Puzzle();\n}\n\n/* game loop: */\n\nfunction draw() {\n\tgame.checkGameState();\n\tgame.animate();\n\tgame.show();\n}\n\nfunction keyPressed(){\n\tgame.keyHandler(keyCode);\n}\n"
                }
            ],
            [
                {
                    "language": "Common-Lisp",
                    "solution": "(ql:quickload '(cffi alexandria))\n\n(defpackage :2048-lisp\n  (:use :common-lisp :cffi :alexandria))\n\n(in-package :2048-lisp)\n\n(defvar *lib-loaded* nil)\n\n(unless *lib-loaded*\n  ;; Load msvcrt.dll to access _getch.\n  (define-foreign-library msvcrt\n    (:windows (:default \"msvcrt\")))\n\n  (use-foreign-library msvcrt)\n\n  (defcfun \"_getch\" :int)\n\n  (setf *lib-loaded* t))\n\n(defun read-arrow ()\n  \"Get an arrow key from input as UP, DOWN, LEFT, or RIGHT, otherwise\nreturn a char of whatever was pressed.\"\n  (let ((first-char (-getch)))\n    (if (= 224 first-char)\n        (case (-getch)\n          (75 'left)\n          (80 'down)\n          (77 'right)\n          (72 'up))\n        (code-char first-char))))\n\n(defmacro swap (place1 place2)\n  \"Exchange the values of two places.\"\n  (let ((temp (gensym \"TEMP\")))\n    `(cl:let ((,temp ,place1))\n       (cl:setf ,place1 ,place2)\n       (cl:setf ,place2 ,temp))))\n\n(defun nflip (board &optional (left-right t))\n  \"Flip the elements of a BOARD left and right or optionally up and down.\"\n  (let* ((y-len (array-dimension board 0))\n         (x-len (array-dimension board 1))\n         (y-max (if left-right y-len (truncate y-len 2)))\n         (x-max (if left-right (truncate x-len 2) x-len)))\n    (loop for y from 0 below y-max\n       for y-place = (- y-len 1 y) do\n         (loop for x from 0 below x-max\n            for x-place = (- x-len 1 x) do\n              (if left-right\n                  (swap (aref board y x) (aref board y x-place))\n                  (swap (aref board y x) (aref board y-place x)))))\n    board))\n\n(defun flip (board &optional (left-right t))\n  \"Flip the elements of a BOARD left and right or optionally up and down.\nNon-destructive version.\"\n  (nflip (copy-array board) left-right))\n\n(defun transpose (board)\n  \"Transpose the elements of BOARD into a new array.\"\n  (let* ((y-len (array-dimension board 0))\n         (x-len (array-dimension board 1))\n         (new-board (make-array (reverse (array-dimensions board)))))\n    (loop for y from 0 below y-len do\n         (loop for x from 0 below x-len do\n              (setf (aref new-board x y) (aref board y x))))\n    new-board))\n\n(defun add-random-piece (board)\n  \"Find a random empty spot on the BOARD to add a new piece.\nReturn T if successful, NIL otherwise.\"\n  (loop\n     for x from 0 below (array-total-size board)\n     unless (row-major-aref board x)\n     count 1 into count\n     and collect x into indices\n     finally\n       (unless (= 0 count)\n         (setf (row-major-aref board (nth (random count) indices))\n               (if (= 0 (random 10)) 4 2))\n         (return t))))\n\n(defun squash-line (line)\n  \"Reduce a sequence of numbers from left to right according to\nthe rules of 2048. Return the score of squashing as well.\"\n  (let* ((squashed\n          (reduce\n           (lambda (acc x)\n             (if (equal x (car acc))\n                 (cons (list (* 2 x)) (cdr acc))\n                 (cons x acc)))\n           (nreverse (remove-if #'null line))\n           :initial-value nil))\n         (new-line (flatten squashed)))\n    (list (append (make-list (- (length line) (length new-line))) new-line)\n          (reduce #'+ (flatten (remove-if-not #'listp squashed))))))\n\n(defun squash-board (board)\n  \"Reduce each row of a board from left to right according to\nthe rules of 2048. Return the total score of squashing the board as well.\"\n  (let ((y-len (array-dimension board 0))\n        (x-len (array-dimension board 1))\n        (total 0))\n    (list (make-array (array-dimensions board) :initial-contents\n                      (loop for y from 0 below y-len\n                         for (line score) =\n                           (squash-line\n                            (make-array x-len\n                                        :displaced-to board\n                                        :displaced-index-offset\n                                        (array-row-major-index board y 0)))\n                         collect line\n                         do (incf total score)))\n          total)))\n\n(defun make-move (board direction)\n  \"Make a move in the given DIRECTION on a new board.\"\n  ;; Move by always squashing right, but transforming the board as needed.\n  (destructuring-bind (new-board score)\n      (case direction\n        (up (squash-board (flip (transpose board))))\n        (down (squash-board (flip (transpose board) nil)))\n        (left (squash-board (nflip (flip board nil))))\n        (right (squash-board board)))\n    (let ((new-board\n           ;; Reverse the transformation.\n           (case direction\n             (up (transpose (nflip new-board)))\n             (down (transpose (nflip new-board nil)))\n             (left (nflip (nflip new-board nil)))\n             (right new-board))))\n      (unless (equalp board new-board)\n        (add-random-piece new-board)\n        (list new-board score)))))\n\n(defun winp (board winning-tile)\n  \"Determine if a BOARD is in a winning state.\"\n  (loop for x from 0 below (array-total-size board)\n     for val = (row-major-aref board x)\n     when (eql val winning-tile) do (return t)))\n\n(defun game-overp (board)\n  \"Determine if a BOARD is in a game over state.\"\n  ;; If a move is simulated in every direction and nothing changes,\n  ;; then we can assume there are no valid moves left.\n  (notany (lambda (dir) (car (make-move board dir)))\n          '(up down left right)))\n\n(defun print-divider (cells cell-size)\n  \"A print helper function for PRINT-BOARD.\"\n  (dotimes (_ cells)\n    (princ \"+\")\n    (dotimes (_ cell-size)\n      (princ \"-\")))\n  (princ \"+\")\n  (terpri))\n\n(defun print-board (board cell-size)\n  \"Pretty print the given BOARD with a particular CELL-SIZE.\"\n  (let* ((y-len (array-dimension board 0))\n         (x-len (array-dimension board 1))\n         (super-size (+ 2 cell-size)))\n    (loop for y from 0 below y-len do\n         (print-divider x-len super-size)\n         (loop for x from 0 below x-len\n            for val = (aref board y x)\n            do\n              (princ \"|\")\n              (if val\n                  (format t \" ~VD \" cell-size val)\n                  (dotimes (_ super-size) (princ \" \"))))\n         (princ \"|\")\n         (terpri))\n    (print-divider x-len super-size)))\n\n(defun init-board ()\n  (let ((board (make-array '(4 4) :initial-element nil)))\n    (setf (row-major-aref board (random (array-total-size board))) 2)\n    board))\n\n(defun prompt-input (board score &optional (check t))\n  (cond\n    ((and check (winp board 2048)) (format t \"You win!\"))\n    ((and check (game-overp board)) (format t \"Game over...\"))\n    (t (let ((choice (read-arrow)))\n         (cond\n           ((symbolp choice)\n            (destructuring-bind (&optional move (new-score 0))\n                (make-move board choice)\n              (if move\n                  (prompt move (+ score new-score))\n                  (prompt-input board score))))\n           ((find choice \"qQ\")\n            (format t \"Quitting.\"))\n           (t (prompt-input board score nil)))))))\n\n(defun prompt (&optional (board (init-board)) (score 0))\n  (format t \"~%   Score: ~D~%\" score)\n  (print-board board 4)\n  (prompt-input board score))\n"
                },
                {
                    "language": "Visual-Basic-.NET",
                    "solution": "Friend Class Tile\n    Public Sub New()\n        Me.Value = 0\n        Me.IsBlocked = False\n    End Sub\n    Public Property Value As Integer\n    Public Property IsBlocked As Boolean\nEnd Class\n\nFriend Enum MoveDirection\n     Up\n     Down\n     Left\n     Right\nEnd Enum\n\n    Friend Class G2048\n        Public Sub New()\n            _isDone = False\n            _isWon = False\n            _isMoved = True\n            _score = 0\n            InitializeBoard()\n        End Sub\n\n        Private Sub InitializeBoard()\n            For y As Integer = 0 To 3\n                For x As Integer = 0 To 3\n                    _board(x, y) = New Tile()\n                Next\n            Next\n        End Sub\n\n        Private _isDone As Boolean\n        Private _isWon As Boolean\n        Private _isMoved As Boolean\n        Private _score As Integer\n        Private ReadOnly _board As Tile(,) = New Tile(3, 3) {}\n        Private ReadOnly _rand As Random = New Random()\n        Const empty As String = \" \"\n\n        Public Sub [Loop]()\n            AddTile()\n            While True\n                If _isMoved Then AddTile()\n                DrawBoard()\n                If _isDone Then Exit While\n                WaitKey()\n            End While\n            Dim endMessage As String = If(_isWon, \"You've made it!\", \"Game Over!\")\n            Console.WriteLine(endMessage)\n        End Sub\n\n        Public Sub DrawBoard()\n            Console.Clear()\n            Console.WriteLine(\"Score: \" & _score & vbNewLine)\n            For y As Integer = 0 To 3\n                Console.WriteLine(\"+------+------+------+------+\")\n                Console.Write(\"| \")\n                For x As Integer = 0 To 3\n                    If _board(x, y).Value = 0 Then\n                        Console.Write(empty.PadRight(4))\n                    Else\n                        Console.Write(_board(x, y).Value.ToString().PadRight(4))\n                    End If\n                    Console.Write(\" | \")\n                Next\n                Console.WriteLine()\n            Next\n            Console.WriteLine(\"+------+------+------+------+\" & vbNewLine & vbNewLine)\n        End Sub\n\n        Private Sub WaitKey()\n            _isMoved = False\n            Console.WriteLine(\"(W) Up (S) Down (A) Left (D) Right\")\n            Dim input As Char\n            Char.TryParse(Console.ReadKey().Key.ToString(), input)\n            Select Case input\n                Case \"W\"c\n                    Move(MoveDirection.Up)\n                Case \"A\"c\n                    Move(MoveDirection.Left)\n                Case \"S\"c\n                    Move(MoveDirection.Down)\n                Case \"D\"c\n                    Move(MoveDirection.Right)\n            End Select\n            For y As Integer = 0 To 3\n                For x As Integer = 0 To 3\n                    _board(x, y).IsBlocked = False\n                Next\n            Next\n        End Sub\n\n        Private Sub AddTile()\n            For y As Integer = 0 To 3\n                For x As Integer = 0 To 3\n                    If _board(x, y).Value <> 0 Then Continue For\n                    Dim a As Integer, b As Integer\n                    Do\n                        a = _rand.Next(0, 4)\n                        b = _rand.Next(0, 4)\n                    Loop While _board(a, b).Value <> 0\n                    Dim r As Double = _rand.NextDouble()\n                    _board(a, b).Value = If(r > 0.89F, 4, 2)\n                    If CanMove() Then Return\n                Next\n            Next\n            _isDone = True\n        End Sub\n\n        Private Function CanMove() As Boolean\n            For y As Integer = 0 To 3\n                For x As Integer = 0 To 3\n                    If _board(x, y).Value = 0 Then Return True\n                Next\n            Next\n            For y As Integer = 0 To 3\n                For x As Integer = 0 To 3\n                    If TestAdd(x + 1, y, _board(x, y).Value) OrElse TestAdd(x - 1, y, _board(x, y).Value) OrElse TestAdd(x, y + 1, _board(x, y).Value) OrElse TestAdd(x, y - 1, _board(x, y).Value) Then Return True\n                Next\n            Next\n            Return False\n        End Function\n\n        Private Function TestAdd(ByVal x As Integer, ByVal y As Integer, ByVal value As Integer) As Boolean\n            If x < 0 OrElse x > 3 OrElse y < 0 OrElse y > 3 Then Return False\n            Return _board(x, y).Value = value\n        End Function\n\n        Private Sub MoveVertically(ByVal x As Integer, ByVal y As Integer, ByVal d As Integer)\n            If _board(x, y + d).Value <> 0 AndAlso _board(x, y + d).Value = _board(x, y).Value AndAlso Not _board(x, y).IsBlocked AndAlso Not _board(x, y + d).IsBlocked Then\n                _board(x, y).Value = 0\n                _board(x, y + d).Value *= 2\n                _score += _board(x, y + d).Value\n                _board(x, y + d).IsBlocked = True\n                _isMoved = True\n            ElseIf _board(x, y + d).Value = 0 AndAlso _board(x, y).Value <> 0 Then\n                _board(x, y + d).Value = _board(x, y).Value\n                _board(x, y).Value = 0\n                _isMoved = True\n            End If\n            If d > 0 Then\n                If y + d < 3 Then MoveVertically(x, y + d, 1)\n            Else\n                If y + d > 0 Then MoveVertically(x, y + d, -1)\n            End If\n        End Sub\n\n        Private Sub MoveHorizontally(ByVal x As Integer, ByVal y As Integer, ByVal d As Integer)\n            If _board(x + d, y).Value <> 0 AndAlso _board(x + d, y).Value = _board(x, y).Value AndAlso Not _board(x + d, y).IsBlocked AndAlso Not _board(x, y).IsBlocked Then\n                _board(x, y).Value = 0\n                _board(x + d, y).Value *= 2\n                _score += _board(x + d, y).Value\n                _board(x + d, y).IsBlocked = True\n                _isMoved = True\n            ElseIf _board(x + d, y).Value = 0 AndAlso _board(x, y).Value <> 0 Then\n                _board(x + d, y).Value = _board(x, y).Value\n                _board(x, y).Value = 0\n                _isMoved = True\n            End If\n            If d > 0 Then\n                If x + d < 3 Then MoveHorizontally(x + d, y, 1)\n            Else\n                If x + d > 0 Then MoveHorizontally(x + d, y, -1)\n            End If\n        End Sub\n\n        Private Sub Move(ByVal direction As MoveDirection)\n            Select Case direction\n                Case MoveDirection.Up\n                    For x As Integer = 0 To 3\n                        Dim y As Integer = 1\n                        While y < 4\n                            If _board(x, y).Value <> 0 Then MoveVertically(x, y, -1)\n                            y += 1\n                        End While\n                    Next\n                Case MoveDirection.Down\n                    For x As Integer = 0 To 3\n                        Dim y As Integer = 2\n                        While y >= 0\n                            If _board(x, y).Value <> 0 Then MoveVertically(x, y, 1)\n                            y -= 1\n                        End While\n                    Next\n                Case MoveDirection.Left\n                    For y As Integer = 0 To 3\n                        Dim x As Integer = 1\n                        While x < 4\n                            If _board(x, y).Value <> 0 Then MoveHorizontally(x, y, -1)\n                            x += 1\n                        End While\n                    Next\n                Case MoveDirection.Right\n                    For y As Integer = 0 To 3\n                        Dim x As Integer = 2\n                        While x >= 0\n                            If _board(x, y).Value <> 0 Then MoveHorizontally(x, y, 1)\n                            x -= 1\n                        End While\n                    Next\n            End Select\n        End Sub\n    End Class\n\n    Module Module1\n        Sub Main()\n            RunGame()\n        End Sub\n\n        Private Sub RunGame()\n            Dim game As G2048 = New G2048()\n            game.Loop()\n            CheckRestart()\n        End Sub\n\n        Private Sub CheckRestart()\n            Console.WriteLine(\"(N) New game (P) Exit\")\n            While True\n                Dim input As Char\n                Char.TryParse(Console.ReadKey().Key.ToString(), input)\n                Select Case input\n                    Case \"N\"c\n                        RunGame()\n                    Case \"P\"c\n                        Return\n                    Case Else\n                        ClearLastLine()\n                End Select\n            End While\n        End Sub\n\n        Private Sub ClearLastLine()\n            Console.SetCursorPosition(0, Console.CursorTop)\n            Console.Write(New String(\" \", Console.BufferWidth))\n            Console.SetCursorPosition(0, Console.CursorTop - 1)\n        End Sub\n    End Module\n"
                }
            ]
        ]
    },
    {
        "task_name": "21-game",
        "task_description": "'''21''' is a two player game, the game is played by choosing \na number ('''1''', '''2''', or '''3''')  to be added to the ''running&nbsp;total''.\n\nThe game is won by the player whose chosen number causes the ''running&nbsp;total''\nto reach ''exactly''&nbsp;'''21'''.\n\nThe ''running total'' starts at zero. \nOne player will be the computer.\n \nPlayers alternate supplying a number to be added to the ''running&nbsp;total''. \n\n\n;Task:\nWrite a computer program that will:\n::* do the prompting (or provide a button menu), \n::* check for errors and display appropriate error messages, \n::* do the additions (add a chosen number to the ''running&nbsp;total''), \n::* display the ''running&nbsp;total'', \n::* provide a mechanism for the player to quit/exit/halt/stop/close the program,\n::* issue a notification when there is a winner, and\n::* determine who goes first (maybe a random or user choice, or can be specified when the game begins). \n<br><br>\n",
        "solution_pairs": [
            [
                {
                    "language": "Lua",
                    "solution": "gamewon = false\nrunning_total = 0\nplayer = 1\nopponent = 2\n\nwhile not gamewon do\n  num = 0\n\n  if player == 1 then\n    opponent = 2\n    repeat\n      print(\"Enter a number between 1 and 3 (0 to quit):\")\n      num = io.read(\"*n\")\n      if num == 0 then\n          os.exit()\n      end\n    until (num > 0) and (num <=3)\n  end\n\n  if player == 2 and not (gamewon) then\n      opponent = 1\n      if (21 - running_total <= 3) then\n        num = 21 - running_total\n      else\n        num = math.random(1,3)\n      end\n      print(\"Player 2 picks number \"..num)\n  end\n\n  running_total = running_total + num\n  print(\"Total: \"..running_total)\n\n  if running_total == 21 then\n    print(\"Player \"..player..\" wins!\")\n    gamewon = true\n  end\n\n  if running_total > 21 then\n    print(\"Player \"..player..\" lost...\")\n    print(\"Player \"..opponent..\" wins!\")\n    gamewon = true\n  end\n\n  if player == 1 then\n    player = 2\n  else player = 1\n  end\n\nend\n"
                },
                {
                    "language": "AArch64-Assembly",
                    "solution": "/* ARM assembly AARCH64 Raspberry PI 3B */\n/*  program game21_64.s   */\n\n/*******************************************/\n/* Constantes file                         */\n/*******************************************/\n/* for this file see task include a file in language AArch64 assembly*/\n.include \"../includeConstantesARM64.inc\"\n\n.equ HITTOTAL,   21\n.equ BUFFERSIZE, 10\n\n\n/*********************************/\n/* Initialized data              */\n/*********************************/\n.data\nszMessRules:         .ascii \"21 Game\\n\"\n                    .ascii \"21 is a two player game, the game is played by choosing a number \\n\"\n                    .ascii \"(1, 2, or 3) to be added to the running total. The game is won by\\n\"\n                    .ascii \"the player whose chosen number causes the running total to reach \\n\"\n                    .asciz \"exactly 21. The running total starts at zero.\\n\\n\\n\"\n\nszMessHumanChoice:  .asciz \"Enter your choice (1,2, 3 or type (q)uit to exit): \"\nszMessErrChoise:    .asciz \"invalid choice.\\n  \"\nszMessHumanBegin:   .asciz \"The first move is human move.\\n\"\nszMessPiBegin:      .asciz \"The first move is Raspberry pi. \\n\"\nszMessHumanWon:     .asciz \"You won. \\n\"\nszMessHumanLost:    .asciz \"You lost. \\n\"\nszMessTotal:        .asciz \"The running total is @ \\n\"\nszMessPiChoice:     .asciz \"Raspberry choice is  @ \\n\"\nszMessNewGame:      .asciz \"New game (y/n) ? \\n\"\nszCarriageReturn:   .asciz \"\\n\"\n.align 4\nqGraine:  .quad 123456\n/*********************************/\n/* UnInitialized data            */\n/*********************************/\n.bss\nsZoneConv:        .skip 24\nsBuffer:          .skip BUFFERSIZE\n/*********************************/\n/*  code section                 */\n/*********************************/\n.text\n.global main\nmain:                                 // entry of program\n\n    ldr x0,qAdrszMessRules\n    bl affichageMess\n1:\n    mov x10,#0                         // total = 0\n    mov x0,#100\n    bl genereraleas\n    cmp x0,#50\n    blt 2f\n    ldr x0,qAdrszMessHumanBegin        // human begin\n    bl affichageMess\n    b 4f\n2:                                     // Rasp begin\n    ldr x0,qAdrszMessPiBegin\n    bl affichageMess\n    mov x0,#1\n3:                                    // rasp turn\n    add x10,x10,x0\n    ldr x1,qAdrsZoneConv\n    bl conversion10                   // call decimal conversion\n    ldr x0,qAdrszMessPiChoice\n    ldr x1,qAdrsZoneConv              // insert conversion in message\n    bl strInsertAtCharInc\n    bl affichageMess\n    cmp x10,#HITTOTAL\n    bne 4f\n    ldr x0,qAdrszMessHumanLost\n    bl affichageMess\n    b 12f\n4:                                    // display current total\n    mov x0,x10\n    ldr x1,qAdrsZoneConv\n    bl conversion10                   // call decimal conversion\n    ldr x0,qAdrszMessTotal\n    ldr x1,qAdrsZoneConv              // insert conversion in message\n    bl strInsertAtCharInc\n    bl affichageMess\n\n5:                                    // human turn\n    ldr x0,qAdrszMessHumanChoice\n    bl affichageMess\n    bl saisie\n    cmp x0,#'q'                       // quit ?\n    beq 100f\n    cmp x0,#'Q'\n    beq 100f\n    cmp x0,#'1'\n    add x9,x10,1\n    csel x10,x9,x10,eq\n    beq 6f\n    cmp x0,#'2'\n    add x9,x10,2\n    csel x10,x9,x10,eq\n    beq 6f\n    cmp x0,#'3'\n    add x9,x10,3\n    csel x10,x9,x10,eq\n    beq 6f\n    ldr x0,qAdrszMessErrChoise\n    bl affichageMess\n    b 5b\n6:\n    cmp x10,#HITTOTAL                // total = maxi ?\n    beq 11f                           // yes -> human won\n    cmp x10,#5                       // else compute rasp number\n    mov x9,5                         // compare total and optimun\n7:\n    cmp x10,x9\n    ble 8f\n    add x9,x9,4\n    b 7b\n8:\n    sub x0,x9,x10                   // compute number rasp\n9:                                  // control number rasp\n    cmp x0,#0\n    ble 10f\n    cmp x0,#3\n    ble 3b\n10:                                  // if not ok, generate random number\n    mov x0,#2\n    bl genereraleas\n    add x0,x0,#1\n    b 3b                            // and loop\n\n11:                                  // display human won\n    ldr x0,qAdrszMessHumanWon\n    bl affichageMess\n12:                                 // display new game ?\n    ldr x0,qAdrszCarriageReturn\n    bl affichageMess\n    ldr x0,qAdrszMessNewGame\n    bl affichageMess\n    bl saisie\n    cmp x0,#'y'\n    beq 1b\n    cmp x0,#'Y'\n    beq 1b\n\n100:                                  // standard end of the program\n    mov x0, #0                        // return code\n    mov x8, #EXIT                     // request to exit program\n    svc #0                            // perform the system call\n\nqAdrszCarriageReturn:     .quad szCarriageReturn\nqAdrszMessRules:          .quad szMessRules\nqAdrszMessHumanBegin:     .quad szMessHumanBegin\nqAdrszMessPiBegin:        .quad szMessPiBegin\nqAdrszMessPiChoice:       .quad szMessPiChoice\nqAdrszMessTotal:          .quad szMessTotal\nqAdrszMessHumanChoice:    .quad szMessHumanChoice\nqAdrszMessHumanLost:      .quad szMessHumanLost\nqAdrszMessHumanWon:       .quad szMessHumanWon\nqAdrszMessNewGame:        .quad szMessNewGame\nqAdrszMessErrChoise:      .quad szMessErrChoise\nqAdrsZoneConv:            .quad sZoneConv\n/******************************************************************/\n/*            string saisie                                       */\n/******************************************************************/\n/* x0 return the first character of human entry */\nsaisie:\n    stp x1,lr,[sp,-16]!    // save  registers\n    stp x2,x8,[sp,-16]!    // save  registers\n    mov x0,#STDIN          // Linux input console\n    ldr x1,qAdrsBuffer     // buffer address\n    mov x2,#BUFFERSIZE     // buffer size\n    mov x8,#READ           // request to read datas\n    svc 0                  // call system\n    ldr x1,qAdrsBuffer     // buffer address\n    ldrb w0,[x1]           // load first character\n100:\n    ldp x2,x8,[sp],16      // restaur  2 registers\n    ldp x1,lr,[sp],16      // restaur  2 registers\n    ret                    // return to address lr x30\n\nqAdrsBuffer:         .quad sBuffer\n/***************************************************/\n/*   Generation random number                  */\n/***************************************************/\n/* x0 contains limit  */\ngenereraleas:\n    stp x1,lr,[sp,-16]!        // save  registers\n    stp x2,x3,[sp,-16]!        // save  registers\n    stp x4,x5,[sp,-16]!        // save  registers\n    ldr x4,qAdrqGraine\n    ldr x2,[x4]\n    ldr x3,qNbDep1\n    mul x2,x3,x2\n    ldr x3,qNbDep2\n    add x2,x2,x3\n    str x2,[x4]                // maj de la graine pour l appel suivant\n    cmp x0,#0\n    beq 100f\n    udiv x3,x2,x0\n    msub x0,x3,x0,x2           // r\u221a\u00a9sult = remainder\n\n100:                           // end function\n    ldp x4,x5,[sp],16          // restaur  2 registers\n    ldp x2,x3,[sp],16          // restaur  2 registers\n    ldp x1,lr,[sp],16          // restaur  2 registers\n    ret                        // return to address lr x30\n/*****************************************************/\nqAdrqGraine: .quad qGraine\nqNbDep1:     .quad 0x0019660d\nqNbDep2:     .quad 0x3c6ef35f\n\n/********************************************************/\n/*        File Include fonctions                        */\n/********************************************************/\n/* for this file see task include a file in language AArch64 assembly */\n.include \"../includeARM64.inc\"\n"
                }
            ],
            [
                {
                    "language": "Perl",
                    "solution": "print <<'HERE';\nThe 21 game. Each player chooses to add 1, 2, or 3 to a running total.\nThe player whose turn it is when the total reaches 21 wins. Enter q to quit.\nHERE\n\nmy $total = 0;\n\nwhile () {\n    print \"Running total is: $total\\n\";\n    my ($me,$comp);\n    while () {\n        print 'What number do you play> ';\n        $me = <>; chomp $me;\n        last if $me =~ /^[123]$/;\n        insult($me);\n    }\n    $total += $me;\n    win('Human') if $total >= 21;\n    print \"Computer plays: \" . ($comp = 1+int(rand(3))) . \"\\n\";\n    $total += $comp;\n    win('Computer') if $total >= 21;\n}\n\nsub win {\n    my($player) = @_;\n    print \"$player wins.\\n\";\n    exit;\n}\n\nsub insult {\n    my($g) = @_;\n    exit if $g =~ /q/i;\n    my @insults = ('Yo mama', 'Jeez', 'Ummmm', 'Grow up');\n    my $i = $insults[1+int rand($#insults)];\n    print \"$i, $g is not an integer between 1 and 3...\\n\"\n}\n"
                },
                {
                    "language": "JavaScript",
                    "solution": "<!DOCTYPE html><html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"keywords\"    content=\"Game 21\">\n    <meta name=\"description\" content=\"\n      21 is a two player game, the game is played by choosing a number\n      (1, 2, or 3) to be added to the running total. The game is won by\n      the player whose chosen number causes the running total to reach\n      exactly 21. The running total starts at zero.\n    \">\n    <!--DCMI metadata (Dublin Core Metadata Initiative)-->\n    <meta name=\"dc.publisher\" content=\"Rosseta Code\">\n    <meta name=\"dc.date\"      content=\"2020-07-23\">\n    <meta name=\"dc.created\"   content=\"2020-07-23\">\n    <meta name=\"dc.modified\"  content=\"2020-07-30\">\n    <title>\n        21 Game\n    </title>\n    <!-- Remove the line below in the final/production version. -->\n    <meta http-equiv=\"cache-control\" content=\"no-cache\">\n\n    <style>\n      .ui div   { width: 50%; display: inline-flex; justify-content: flex-end; }\n      div.total { margin-bottom: 1ch; }\n      label     { padding-right: 1ch; }\n      button + button { margin-left: 1em; }\n    </style>\n</head>\n\n<body>\n  <h1>\n    21 Game in ECMA Script (Java Script)\n  </h1>\n\n  <p>\n    21 is a two player game, the game is played by choosing a number\n    (1, 2, or 3) to be added to the running total. The game is won by\n    the player whose chosen number causes the running total to reach\n    exactly 21. The running total starts at zero.\n  </p>\n\n  <p><span id=\"first\"></span> Use buttons to play.</p>\n\n  <div class=\"ui\">\n    <div class=\"total\">\n      <label for=\"human\">human last choice:</label>\n      <input type=\"text\" id=\"human\" readonly>\n    </div>\n    <div class=\"total\">\n      <label for=\"AI\">AI last choice:</label>\n      <input type=\"text\" id=\"AI\" readonly>\n    </div>\n    <div class=\"total\">\n      <label for=\"runningTotalText\">running total:</label>\n      <input type=\"text\" id=\"runningTotalText\" readonly>\n    </div>\n    <div class=\"buttons\">\n      <button onclick=\"choice(1);\" id=\"choice1\"> one   </button>\n      <button onclick=\"choice(2);\" id=\"choice2\"> two   </button>\n      <button onclick=\"choice(3);\" id=\"choice3\"> three </button>\n      <button onclick=\"restart();\"> restart </button>\n    </div>\n  </div>\n\n  <p id=\"message\"></p>\n\n  <noscript>\n    No script, no fun. Turn on Javascript on.\n  </noscript>\n\n  <script>\n    // I really dislike global variables, but in any (?) WWW browser the global\n    // variables are in the window (separately for each tab) context space.\n    //\n    var runningTotal = 0;\n    const human = document.getElementById('human');\n    const AI = document.getElementById('AI');\n    const runningTotalText = document.getElementById('runningTotalText');\n    const first = document.getElementById('first')\n    const message = document.getElementById('message');\n    const choiceButtons = new Array(3);\n\n    // An function to restart game in any time, should be called as a callback\n    // from the WWW page, see above for an example.\n    //\n    function restart()\n    {\n      runningTotal = 0;\n      runningTotalText.value = runningTotal;\n      human.value = '';\n      AI.value = '';\n      for (let i = 1; i <= 3; i++)\n      {\n        let button = document.getElementById('choice' + i);\n        button.disabled = false;\n        choiceButtons[i] = button;\n      }\n      message.innerText = '';\n      if (Math.random() > 0.5)\n      {\n        update(AI, ai());\n        first.innerText = 'The first move is AI move.'\n      }\n      else\n        first.innerText = 'The first move is human move.'\n    }\n\n    // This function update an (read-only for a user) two text boxes\n    // as well as runningTotal. It should be called only once per a move/turn.\n    //\n    function update(textBox, n)\n    {\n      textBox.value = n;\n      runningTotal = runningTotal + n;\n      runningTotalText.value = runningTotal;\n      for (let i = 1; i <= 3; i++)\n        if (runningTotal + i > 21)\n          choiceButtons[i].disabled = true;\n    }\n\n    // An callback function called when the human player click the button.\n    //\n    function choice(n)\n    {\n      update(human, n);\n      if (runningTotal == 21)\n        message.innerText = 'The winner is human.';\n      else\n      {\n        update(AI, ai());\n        if (runningTotal == 21)\n          message.innerText = 'The winner is AI.';\n      }\n    }\n\n    // A rather simple function to calculate a computer move for the given total.\n    //\n    function ai()\n    {\n      for (let i = 1; i <= 3; i++)\n        if (runningTotal + i == 21)\n          return i;\n\n      for (let i = 1; i <= 3; i++)\n        if ((runningTotal + i - 1) % 4 == 0)\n          return i;\n\n      return 1;\n    }\n\n    // Run the script - actually this part do only some initialization, because\n    // the game is interactively driven by events from an UI written in HTML.\n    //\n    restart();\n  </script>\n\n</body>\n</html>\n"
                }
            ],
            [
                {
                    "language": "Scala",
                    "solution": "object Game21 {\n\n  import scala.collection.mutable.ListBuffer\n  import scala.util.Random\n\n  val N = 21 // the same game would also work for N other than 21...\n\n  val RND = new Random() // singular random number generator; add a seed number, if you want reproducibility\n\n  /** tuple: name and a play function: (rest: remaining number, last: value of opponent's last move) => new move\n    */\n  type Player = (String, (Int,Int) => Int)\n\n  // indeed, the following could also be written using a class and instances, I've choosen a\n  // more functional and math way (using tuples)...\n  val playerRandom:Player = (\"RandomRobot\", { (rest, last) =>\n    if (rest <= 3) rest\n    else 1 + RND.nextInt(3)\n  })\n  val playerBest:Player = (\"BestRobot\", { (rest, last) =>\n    val i = rest % 4\n    if (i > 0) i else 1 + RND.nextInt(3)\n  })\n  val playerHuman:Player = (\"YOU\", { (rest, last) =>\n    println(\"Rest: \"+rest)\n    println(\"Last: \"+last)\n    var in = \"\"\n    while (in!=\"1\" && in!=\"2\" && in!=\"3\") {\n      in = scala.io.StdIn.readLine(\"Your move (1,2,3,q)> \").trim\n      if (\"q\" == in)\n        throw new Exception(\"q => quit\")\n    }\n    in.toInt\n  })\n\n  /** Execute a whole game. NOTE that we're counting DOWN from N to 0!\n    * @param players\n    * @return list of all moves\n    */\n  def play(players:Seq[Player]):Seq[Int] = {\n    require(players.size == 2)\n    var last = -1\n    var rest = N\n    var p = 0 // player 0 always starts\n    val l = ListBuffer[Int]() // list of all moves\n    while (rest > 0) {\n      last = players(p)._2(rest,last)\n      require(1<=last && last<=3,\"Player must always play 1,2,3: \"+last)\n      l += last\n      rest -= last\n      p = 1 - p // other player's turn\n    }\n    l.toSeq\n  }\n\n  /** Evaluate a whole game.\n    * @param game list of moves of one game\n    * @param rest mainly for recursion\n    * @return evaluation, for each move a tuple: (rest, what was played, whether this player won in the end)\n    */\n  def evaluate(game:Seq[Int],rest:Int=N):Seq[(Int,Int,Boolean)] = {\n    if (game.size == 0) Seq()\n    else Seq((rest,game.head,game.size%2 == 1)) ++ evaluate(game.tail,rest - game.head)\n  }\n\n  def main(args: Array[String]): Unit = {\n    // here you can put whatever player combination you like\n    val players = Seq(playerRandom,playerRandom) // random robot vs random robot\n    //val players = Seq(playerRandom,playerBest) // random robot vs best robot\n    //val players = Seq(playerHuman,playerBest) // You vs best robot\n    var p0won = 0\n    val n = 1000 // number of games to play\n    var m = 0 // games actually played (a human player might quit before n)\n    try {\n      (1 to n).foreach { i =>\n        val g = play(players)\n        require(g.sum == N) // some validity checks\n        val e = evaluate(g)\n        require(e.size == g.size && e.last._3 && e(0)._3 != e(1)._3) // some validity checks\n        if (e(0)._3) p0won += 1\n        m += 1\n        println(i + \": \" + players(0)._1 + \" \" + (if (e(0)._3) \"won\" else \"lost\") + \" against \" + players(1)._1 + \". \" + g + \" => \" + e)\n      }\n    } catch {\n      case t:Throwable => println(t.getMessage)\n    }\n    println(\"Player0: \"+players(0)._1)\n    println(\"Player1: \"+players(1)._1)\n    println(f\"Player0 won ${p0won} times out of ${m}, or ${p0won * 100.0 / m}%%\")\n  }\n}\n"
                },
                {
                    "language": "Applesoft-BASIC",
                    "solution": " 5  DIM P$(2),HC(2),CA(4),CN$(6): READ CA(0),CA(1),CA(2),CA(3): FOR I = 1 TO 6: READ CN$(I): NEXT : DEF  FN M(X) = (X - ( INT (X / 4)) * 4): DEF  FN U(K) = K - (K > 95) * 32:L$ = \" \":M$ =  CHR$ (13): DATA 1,1,3,2\n 9  FOR PLAY = 0 TO 1\n 10     REM SET SCREEN COLORS HERE\n 11     LET C% =  INT ( RND (1) * 16)\n 12     LET B% =  INT ( RND (1) * 15 + C% + 1): IF B% > 15 THEN B% = B% - 16\n 13     POKE 49186,C% + B% * 16: REM FOREGROUND&BACKGROUND\n 14     POKE 49204, INT ( RND (1) * 16): REM BORDER\n 20     HOME : PRINT M$ SPC( 16);\"21 GAME\"M$M$\" THE GOAL OF THIS GAME IS TO TAKE TURNS\"M$\" ADDING THE VALUE OF EITHER 1, 2, OR 3\"M$\" TO A RUNNING TOTAL. THE FIRST PLAYER\"M$\" TO BRING THE TOTAL TO 21...\"M$M$ SPC( 10);\"... WINS THE GAME!\"M$\n 30     GOSUB 1000\n 40     FOR SETUP = 0 TO 1: HOME : PRINT\n 42         FOR P = 1 TO 2\n 44             PRINT M$\"PLAYER\";L$;P;\", [H]UMAN OR [C]OMPUTER? \";\n 45             FOR K = 0 TO 1: GET K$:K$ =  CHR$ ( FN U( ASC (K$))):K = K$ = \"C\" OR K$ = \"H\": NEXT K\n 46              PRINT K$M$M$\"PLAYER\";L$;P;\",\": PRINT \"ENTER YOUR NAME\";\n 50              LET HC(P) = (K$ = \"C\"): IF HC(P) THEN  FOR PC = 0 TO 1:PN =  INT ( RND (1) * 6) + 1:T$ = CN$(PN):PC = T$ <  > P$(P - 1): NEXT PC:P$(P) = T$: PRINT \"? \";P$(P)\n 52              IF  NOT HC(P) THEN  INPUT P$(P)\n 54          NEXT P\n 60          FOR P = 1 TO 2: PRINT M$L$;P;\". \";P$(P);: NEXT P: PRINT M$M$\"IS THIS CORRECT (Y/N)? \";: FOR K = 0 TO 1: GET K$:K$ =  CHR$ ( FN U( ASC (K$))):K = K$ = \"Y\" OR K$ = \"N\": NEXT K: PRINT K$:SETUP = K$ <  > \"N\"\n 70      NEXT SETUP\n 80      PRINT M$\"WHO WILL PLAY FIRST (1 OR 2)? \";: FOR K = 0 TO 1: GET K$:K = K$ = \"1\" OR K$ = \"2\": NEXT K\n 90     FP =  VAL (K$): PRINT K$M$M$\"OKAY, \";P$(FP);\" WILL PLAY FIRST.\"M$: GOSUB 1000\n 100    LET RT = 0:PI = FP - 1\n 110    FOR GAME = 0 TO 1\n 115        PI = PI * (PI < 2) + 1: HOME : PRINT \"TOTAL SO FAR:\";L$;RT;M$M$P$(PI);\"'S TURN.\"\n 120        IF HC(PI) THEN  PRINT M$\"THINKING...\";:TT =  INT ( RND (1) * 10): FOR T = 1 TO TT: PRINT \".\";: FOR I = 1 TO 250: NEXT I,T:RM =  FN M(RT):AD = CA(RM): PRINT M$M$P$(PI);\" ADDS\";L$;CA(RM);\".\": FOR T = 1 TO 1000: NEXT T\n 125        IF  NOT HC(PI) THEN  FOR AMOUNT = 0 TO 1: PRINT  MID$ (M$ + \"ILLEGAL AMOUNT. TRY AGAIN.\" + M$,1,AMOUNT * 255)M$\"HOW MUCH TO ADD,\": INPUT \"1, 2, OR 3 (0 TO QUIT) ?\";AD:AMOUNT = AD >  = 0 AND AD <  = 3: NEXT AMOUNT\n 128        LET RT = RT + AD:GAME = RT >  = 21 OR AD = 0\n 130      NEXT GAME\n 140      IF RT > 21 THEN  PRINT M$P$(PI);\" LOSES BY GOING OVER 21!!\"\n 150      IF RT = 21 THEN  PRINT M$\"21! \";P$(PI);\" WINS THE GAME!!!\"\n 160      IF  NOT AD THEN  PRINT M$\"GAME WAS ENDED BY \";P$(PI);\".\":PLAY = 1\n 210      IF AD THEN  PRINT : PRINT \"WOULD YOU LIKE TO PLAY AGAIN? \";: FOR K = 0 TO 1: GET K$:K$ =  CHR$ ( FN U( ASC (K$))):K = K$ = \"N\" OR K$ = \"Y\": NEXT K: PRINT K$:PLAY = K$ = \"N\"\n 220  NEXT PLAY\n 230  IF AD THEN  PRINT M$\"OKAY, MAYBE ANOTHER TIME. BYE!\"\n 240  END\n 1000 Z$ = \" PRESS A KEY TO CONTINUE. \": PRINT  SPC( 20 -  INT ( LEN (Z$) / 2));: INVERSE : PRINT Z$;: NORMAL : WAIT 49152,128:K =  PEEK (49168): RETURN\n 2010  DATA \"APPLE IIE\",\"APPLE II PLUS\",\"APPLE IIC\",\"APPLE II\",\"APPLE IIGS\",\"MACINTOSH LC\"\n"
                }
            ],
            [
                {
                    "language": "Quackery",
                    "solution": "  [ say\n    \"Who goes first: Computer, Player\"\n    say \" or Random?\"  cr\n    [ $ \"Enter C, P or R: \" input\n      dup size 1 != iff drop again\n      0 peek\n      dup char C = iff [ drop 0 ] done\n      dup char P = iff [ drop 1 ] done\n      char R = iff [ 2 random ] done\n       again ]\n    cr\n    dup iff [ say \"You go first.\" ]\n    else [ say \"I will go first.\" ]\n    cr ]                                  is chooseplayer (   --> n   )\n\n                                  forward is player       ( n --> n x )\n\n  [ [ dup 17 > iff 1 done\n      4 over 4 mod\n      dup 0 = if [ drop 3 ]\n      - ]\n    dup say \"Computer chooses \" echo\n    say \".\" cr\n    + ' player ]                          is computer     ( n --> n x )\n\n  [ say \"Choose 1 2 or 3 (running \"\n    $ \"total must not exceed 21, Q to quit): \" input\n    dup $ \"Q\" = iff [ drop 21 999 ] done\n    trim reverse trim reverse\n    $->n not iff drop again\n    dup 1 4 within not iff drop again\n    2dup + 21 > iff drop again\n    + ' computer ]                  resolves player       ( n --> n x )\n\n  [ say \"The player who makes 21 loses.\" cr\n    0 chooseplayer\n    iff [ ' player ] else [ ' computer ]\n    [ say \"Running total is \"\n      over echo say \".\" cr cr\n      do\n      over 21 = until ]\n    cr\n    dup 999 = iff\n      [ drop 2drop say \"Quitter!\" ] done\n    ' computer = iff\n        [ say \"The computer won!\" ]\n    else [ say \"You won! Well done!\" ]\n    drop ]                                 is play        (   -->     )\n"
                },
                {
                    "language": "Pascal",
                    "solution": "program Game21;\n\n{$APPTYPE CONSOLE}\n\n{$R *.res}\n\nuses\n  System.SysUtils,\n  System.StrUtils, // for IfThen\n  Winapi.Windows;  // for ClearScreen\n\nconst\n  HARD_MODE = True;\n\nvar\n  computerPlayer: string = 'Computer';\n  humanPlayer: string = 'Player 1';\n\n  // for change color\n  ConOut: THandle;\n  BufInfo: TConsoleScreenBufferInfo;\n\nprocedure ClearScreen;\nvar\n  stdout: THandle;\n  csbi: TConsoleScreenBufferInfo;\n  ConsoleSize: DWORD;\n  NumWritten: DWORD;\n  Origin: TCoord;\nbegin\n  stdout := GetStdHandle(STD_OUTPUT_HANDLE);\n  Win32Check(stdout <> INVALID_HANDLE_VALUE);\n  Win32Check(GetConsoleScreenBufferInfo(stdout, csbi));\n  ConsoleSize := csbi.dwSize.X * csbi.dwSize.Y;\n  Origin.X := 0;\n  Origin.Y := 0;\n  Win32Check(FillConsoleOutputCharacter(stdout, ' ', ConsoleSize, Origin, NumWritten));\n  Win32Check(FillConsoleOutputAttribute(stdout, csbi.wAttributes, ConsoleSize,\n    Origin, NumWritten));\n  Win32Check(SetConsoleCursorPosition(stdout, Origin));\nend;\n\nprocedure ResetColor;\nbegin\n  SetConsoleTextAttribute(ConOut, BufInfo.wAttributes);\nend;\n\nprocedure ChangeColor(color: Word);\nbegin\n  ConOut := TTextRec(Output).Handle;\n  GetConsoleScreenBufferInfo(ConOut, BufInfo);\n  SetConsoleTextAttribute(TTextRec(Output).Handle, color);\nend;\n\nfunction SwapPlayer(currentPlayer: string): string;\nbegin\n  Result := IfThen(currentPlayer = humanPlayer, computerPlayer, humanPlayer);\nend;\n\nfunction RandomPlayerSelect(): string;\nbegin\n  Result := IfThen(Random() < 0.5, computerPlayer, humanPlayer);\nend;\n\nfunction CheckIfCanWin(total: Integer): Boolean;\nbegin\n  result := (total >= 18);\nend;\n\nfunction CheckIfCanLose(total: Integer; var choose: Integer; hardMode: Boolean =\n  False): Boolean;\nvar\n  range: Integer;\nbegin\n  range := 17 - total;\n  Result := false;\n  if (range > 0) and (range < 4) then\n  begin\n    Result := true;\n    if hardMode then\n      choose := range\n    else\n      choose := Random(range - 1) + 1;\n  end;\nend;\n\nfunction CompMove(total: Integer): Integer;\nbegin\n  if (CheckIfCanWin(total)) then\n  begin\n    exit(21 - total);\n  end;\n\n  if CheckIfCanLose(total, Result, HARD_MODE) then\n    exit;\n\n  Result := Random(3) + 1;\nend;\n\nfunction HumanMove: Integer;\nvar\n  choice: string;\nbegin\n  repeat\n    Writeln('Choose from numbers: 1, 2, 3');\n    Readln(choice);\n  until TryStrToInt(choice, Result) and (Result in [1..3]);\nend;\n\nprocedure PlayGame();\nvar\n  playAnother: Boolean;\n  total, final_, roundChoice, compWins, humanWins: Integer;\n  choice, currentPlayer: string;\nbegin\n  playAnother := True;\n  total := 0;\n  final_ := 21;\n  roundChoice := 0;\n  Randomize;\n  currentPlayer := RandomPLayerSelect();\n  compWins := 0;\n  humanWins := 0;\n\n  while (playAnother) do\n  begin\n    ClearScreen;\n    ChangeColor(FOREGROUND_INTENSITY or FOREGROUND_GREEN);\n    Writeln(total);\n    ResetColor;\n    Writeln('');\n\n    Writeln('Now playing: ' + currentPlayer);\n    if currentPlayer = computerPlayer then\n      roundChoice := CompMove(total)\n    else\n      roundChoice := HumanMove;\n    inc(total, roundChoice);\n\n    if (total = final_) then\n    begin\n      if (currentPlayer = computerPlayer) then\n      begin\n        inc(compWins);\n      end\n      else\n      begin\n        inc(humanWins);\n      end;\n\n      ClearScreen;\n      Writeln('Winner: ' + currentPlayer);\n      Writeln('Comp wins: ', compWins, '. Human wins: ', humanWins, #10);\n      Writeln('Do you wan to play another round? y/n');\n\n      readln(choice);\n\n      if choice = 'y' then\n      begin\n        total := 0;\n        ClearScreen;\n      end\n      else if choice = 'n' then\n        playAnother := false\n      else\n      begin\n        Writeln('Invalid choice! Choose from y or n');\n        Continue;\n      end;\n    end\n    else if total > 21 then\n    begin\n      Writeln('Not the right time to play this game :)');\n      break;\n    end;\n\n    currentPlayer := SwapPlayer(currentPlayer);\n  end;\n\nend;\n\nconst\n  WELLCOME_MSG: array[0..5] of string = ('Welcome to 21 game'#10,\n    '21 is a two player game.', 'The game is played by choosing a number.',\n    '1, 2, or 3 to be added a total sum.'#10,\n    'The game is won by the player reaches exactly 21.'#10, 'Press ENTER to start!'#10);\n\nvar\n  i: Integer;\n\nbegin\n  try\n    for i := 0 to High(WELLCOME_MSG) do\n      Writeln(WELLCOME_MSG[i]);\n    ResetColor;\n    Readln; // Wait press enter\n\n    PlayGame();\n  except\n    on E: Exception do\n      Writeln(E.ClassName, ': ', E.Message);\n  end;\nend.\n"
                }
            ],
            [
                {
                    "language": "R",
                    "solution": "game21(first = \"ai\")\n"
                },
                {
                    "language": "Chipmunk-Basic",
                    "solution": "100 rem 21 game\n110 rem for rosetta code\n120 '\n130 rem initialization\n140 l$ = chr$(157) : rem left cursor\n150 dim p$(2),hc(2),ca(4) : hc(1) = 0 : hc(2) = 0 : rem players\n160 ca(0) = 1 : ca(1) = 1 : ca(2) = 3 : ca(3) = 2 : rem computer answers\n170 dim cn$(6) : for i = 1 to 6 : read cn$(i) : next i : rem computer names\n180 def fnm(X)=(X-(INT(X/4))*4):REM modulo function\n190 '\n200 rem optionally set screen colors here\n210 cls\n220 print \"                21 GAME\"\n230 print : print \" The goal of this game is to take turns\"\n240 print \" adding the value of either 1, 2, or 3\"\n250 print \" to a running total. The first player\"\n260 print \" to bring the total to 21...\"\n270 print : print \"          ... WINS THE GAME!\"\n280 print : gosub 1110\n290 for p = 1 to 2\n300 '\n310  rem game setup and get players\n320  for p = 1 to 2\n330   print : print \"Player \";p;l$;\", [H]uman or [C]omputer? \";\n340   k$ = inkey$ : if k$ <> \"c\" and k$ <> \"h\" then 340\n350   print k$ : hc(p) = (k$ = \"c\")\n360   print : print \"Player\";p;l$ \",\" : print \"Enter your name\"; : if hc(p) then goto 400\n370   input p$(p)\n380  next p\n390  goto 420\n400  gosub 1340 : print \"? \";p$(p)\n410 next p\n420 print\n430 for p = 1 to 2 : print p;l$;\". \";p$(p) : next p\n440 print : print \"Is this correct (y/n)? \";\n450 k$ = inkey$ : if k$ <> \"y\" and k$ <> \"n\" then 450\n460 print k$ : if k$ = \"n\" then goto 290\n470 print : print \"Who will play first (1 or 2)? \";\n480 k$ = inkey$ : if k$ < \"1\" or k$ > \"2\" then 480\n490 fp = asc(k$)-48 : print k$ : print\n500 print \"Okay, \";p$(fp);\" will play first.\" : print : gosub 1110\n510 cls\n520 '\n530 rem start main game loop\n540 pi = fp : rt = 0\n550 print \"Total so far:\";rt\n560 print : print p$(pi);\"'s turn.\"\n570 if hc(pi) then gosub 1240\n580 if not hc(pi) then gosub 1170\n590 rt = rt+ad\n600 if rt = 21 then goto 680\n610 if rt > 21 then print : print p$(pi);\" loses by going over 21!!\" : goto 700\n620 pi = pi+1 : if pi > 2 then pi = 1\n630 goto 550\n640 print : print \"          ... WINS THE GAME!\"\n650 print : gosub 1110\n660 '\n670 for p = 1 to 2\n680  rem winner winner chicken dinner\n690  print : print \"21! \";p$(pi);\" wins the game!!!\"\n700  print : print \"Would you like to play again? \";\n710  k$ = inkey$ : if k$ <> \"n\" and k$ <> \"y\" then 710\n720  print k$\n730  if k$ = \"n\" then print : print \"Okay, maybe another time. Bye!\" : end\n740  goto 200\n750  print k$ : hc(p) = (k$ = \"c\")\n760  print : print \"Player\";p;l$ \",\" : print \"Enter your name\"; : if hc(p) then goto 800\n770  input p$(p)\n780 next p\n790 goto 820\n800 gosub 1340 : print \"? \";p$(p)\n810 next p\n820 print : for p = 1 to 2 : print p;l$;\". \";p$(p) : next p\n830 print : print \"Is this correct (y/n)? \";\n840 k$ = inkey$ : if k$ <> \"y\" and k$ <> \"n\" then 840\n850 print k$ : if k$ = \"n\" then goto 660\n860 print : print \"Who will play first (1 or 2)? \";\n870 k$ = inkey$ : if k$ < \"1\" or k$ > \"2\" then 870\n880 fp = asc(k$)-48 : print k$ : print\n890 print \"Okay, \";p$(fp);\" will play first.\" : print : gosub 1110\n900 '\n910 rem start main game loop\n920 pi = fp : rt = 0\n930 print chr$(147);\"Total so far: \";rt\n940 print : print p$(pi);\"'s turn.\"\n950 if hc(pi) then gosub 1240\n960 if not hc(pi) then gosub 1170\n970 rt = rt+ad\n980 if rt = 21 then goto 1030\n990 if rt > 21 then print : print p$(pi);\" loses by going over 21!!\" : goto 1050\n1000 pi = pi+1 : if pi > 2 then pi = 1\n1010 goto 930\n1020 '\n1030 rem winner winner chicken dinner\n1040 print : print \"21! \";p$(pi);\" wins the game!!!\"\n1050 print : print \"Would you like to play again? \";\n1060 k$ = inkey$ : if k$ <> \"n\" and k$ <> \"y\" then 1060\n1070 print k$\n1080 if k$ = \"n\" then print : print \"Okay, maybe another time. Bye!\" : end\n1090 goto 490\n1100 '\n1110 rem pause for keypress\n1120 z$ = \" Press a key to continue. \"\n1130 print z$\n1140 k$ = inkey$ : if k$ = \"\" then 1140\n1150 return\n1160 '\n1170 rem human player move\n1180 print : print \"How much to add,\"\n1190 print \"1, 2, or 3 (0 to quit)\"; : input ad\n1200 if ad < 0 or ad > 3 then print : print \"Illegal amount. Try again.\" : goto 1180\n1210 if ad = 0 then print : print \"Game was ended by \";p$(pi);\".\" : end\n1220 return\n1230 '\n1240 rem computer player move\n1250 print : print \"Thinking...\";\n1260 tt = int(rnd(1)*10)\n1270 for t = 1 to tt : print \".\"; : for i = 1 to 250 : next i : next t : print\n1280 rm = fn m(rt)\n1290 ad = ca(rm)\n1300 print : print p$(pi);\" adds \";ca(rm);l$;\".\"\n1310 for t = 1 to 1000 : next t\n1320 return\n1330 '\n1340 rem pick a computer name\n1350 pn = int(rnd(1)*6)+1 : t$ = cn$(pn)\n1360 if t$ = p$(p-1) then goto 1350\n1370 p$(p) = t$\n1380 return\n1390 '\n1400 rem some computer names to pick from\n1410 data \"Commodore 64\",\"VIC-20\",\"Commodore 128\"\n1420 data \"PET\",\"Plus/4\",\"Commodore 16\"\n"
                }
            ]
        ]
    },
    {
        "task_name": "24-game",
        "task_description": "The [[wp:24 Game|24 Game]] tests one's mental arithmetic. \n\n\n;Task\nWrite a program that [[task feature::Rosetta Code:randomness|randomly]] chooses and [[task feature::Rosetta Code:user output|displays]] four digits, each from 1 \u2500\u2500\u25ba 9 (inclusive) with repetitions allowed.\n\nThe program should prompt for the player to enter an arithmetic expression using ''just'' those, and ''all'' of those four digits, used exactly ''once'' each. The program should ''check'' then [[task feature::Rosetta Code:parsing|evaluate the expression]]. \n\nThe goal is for the player to [[task feature::Rosetta Code:user input|enter]] an expression that (numerically) evaluates to '''24'''.\n*  Only the following operators/functions are allowed: multiplication, division, addition, subtraction\n*  Division should use floating point or rational arithmetic, etc, to preserve remainders.\n*  Brackets are allowed, if using an infix expression evaluator.\n*  Forming multiple digit numbers from the supplied digits is ''disallowed''. (So an answer of 12+12 when given 1, 2, 2, and 1 is wrong).\n*  The order of the digits when given does not have to be preserved.\n\n<br>\n;Notes\n* The type of expression evaluator used is not mandated. An [[wp:Reverse Polish notation|RPN]] evaluator is equally acceptable for example.\n* The task is not for the program to generate the expression, or test whether an expression is even possible.\n\n\n;Related tasks\n* [[24 game/Solve]]\n\n\n;Reference\n* [http://www.bbc.co.uk/dna/h2g2/A933121 The 24 Game] on h2g2.\n<br><br>\n\n",
        "solution_pairs": [
            [
                {
                    "language": "Yabasic",
                    "solution": "do\n\tclear screen\n\tn$=\"\"\n\tfor i=1 to 4\n\t\tn$=n$+str$(int(ran(9)+1))\n\tnext i\n\tprint at(35,0) \"24 GAME\\n\"\n\tprint \"Combine numbers and operators for obtain 24.\"\n\tprint \"Allowed characters: \";\n\ti$=n$+\"+-*/()\"\n\tfor i=1 to 10\n\t\tprint mid$(i$,i,1),\" \";\n\tnext i\n\tprint \"[nothing to end program]\\n\"\nlabel accept\n\tp$=\"\"\n\ti$=n$+\"+-*/()\"\n\tprint at(0,4);:input \"Enter the formula: \" f$\n\tif f$=\"\" end\n\tfor i=1 to len(f$)\n\t\tc$=mid$(f$,i,1)\n\t\tswitch c$\n\t\t\tcase \" \": f$=left$(f$,i-1)+right$(f$,len(f$)-i): break\n\t\t\tcase \"+\":case \"-\":case \"*\":case \"/\": p$=p$+\"o\": break\n\t\t\tcase \"(\":case \")\": p$=p$+c$: break\n\t\t\tcase mid$(i$,1,1): p$=p$+\"n\": mid$(i$,1,1)=\" \": break\n\t\t\tcase mid$(i$,2,1): p$=p$+\"n\": mid$(i$,2,1)=\" \": break\n\t\t\tcase mid$(i$,3,1): p$=p$+\"n\": mid$(i$,3,1)=\" \": break\n\t\t\tcase mid$(i$,4,1): p$=p$+\"n\": mid$(i$,4,1)=\" \": break\n\t\t\tdefault: message(\" = Invalid argument!  \"): break\n\t\tend switch\n\t\tif f$=\"\" goto accept\n\tnext i\n\trestore\n\tfor i=1 to 11\n\t\tread t$\n\t\tif t$=p$ break\n\tnext i\n\tif t$<>p$ then\n\t\tmessage(\" = Bad construction!  \")\n\t\tgoto accept\n\tend if\n\tlet r=eval(f$)\n\tprint \"\\n\",f$,\" = \",r,\" \";\n\tif r<>24 then\n\t\tmessage(\" = Wrong!             \")\n\t\tgoto accept\n\telse\n\t\tmessage(\" = Correct!           \")\n\t\tpause 5\n\tend if\nloop\n\nDATA \"nononon\"\nDATA \"(non)onon\"\nDATA \"nono(non)\"\nDATA \"no(no(non))\"\nDATA \"((non)on)on\"\nDATA \"no(non)on\"\nDATA \"(non)o(non)\"\nDATA \"no((non)on)\"\nDATA \"(nonon)on\"\nDATA \"(no(non))on\"\nDATA \"no(nonon)\"\n\nsub message(m$)\n\tprint at(0,7) f$,m$\n\tbeep: beep: beep\n\tpause 1\n\tprint at(19,4) \"                     \"\n\tf$=\"\"\nend sub\n\nsub eval(c$)\n\tstatic linea\n\t\n\tlinea=linea+1\n\tc$=\"sub s\"+str$(linea+1000000,\"#######\")+\"():return \"+c$+\":end sub\"\n\tcompile c$\n\treturn execute(mid$(c$,5,8))\nend sub\n"
                },
                {
                    "language": "Kotlin",
                    "solution": "import java.util.Random\nimport java.util.Scanner\nimport java.util.Stack\n\ninternal object Game24 {\n    fun run() {\n        val r = Random()\n        val digits = IntArray(4).map { r.nextInt(9) + 1 }\n        println(\"Make 24 using these digits: $digits\")\n        print(\"> \")\n\n        val s = Stack<Float>()\n        var total = 0L\n        val cin = Scanner(System.`in`)\n        for (c in cin.nextLine()) {\n            when (c) {\n                in '0'..'9' -> {\n                    val d = c - '0'\n                    total += (1 shl (d * 5)).toLong()\n                    s += d.toFloat()\n                }\n                else ->\n                    if (\"+/-*\".indexOf(c) != -1) {\n                        s += c.applyOperator(s.pop(), s.pop())\n                    }\n            }\n        }\n\n        when {\n            tally(digits) != total ->\n                print(\"Not the same digits. \")\n            s.peek().compareTo(target) == 0 ->\n                println(\"Correct!\")\n            else ->\n                print(\"Not correct.\")\n        }\n    }\n\n    private fun Char.applyOperator(a: Float, b: Float) = when (this) {\n        '+' -> a + b\n        '-' -> b - a\n        '*' -> a * b\n        '/' -> b / a\n        else -> Float.NaN\n    }\n\n    private fun tally(a: List<Int>): Long = a.reduce({ t, i -> t + (1 shl (i * 5)) }).toLong()\n\n    private val target = 24\n}\n\nfun main(args: Array<String>) = Game24.run()\n"
                }
            ],
            [
                {
                    "language": "Go",
                    "solution": "package main\n\nimport (\n    \"fmt\"\n    \"math\"\n    \"math/rand\"\n    \"time\"\n)\n\nfunc main() {\n    rand.Seed(time.Now().Unix())\n    n := make([]rune, 4)\n    for i := range n {\n        n[i] = rune(rand.Intn(9) + '1')\n    }\n    fmt.Printf(\"Your numbers: %c\\n\", n)\n    fmt.Print(\"Enter RPN: \")\n    var expr string\n    fmt.Scan(&expr)\n    if len(expr) != 7 {\n        fmt.Println(\"invalid. expression length must be 7.\" +\n            \" (4 numbers, 3 operators, no spaces)\")\n        return\n    }\n    stack := make([]float64, 0, 4)\n    for _, r := range expr {\n        if r >= '0' && r <= '9' {\n            if len(n) == 0 {\n                fmt.Println(\"too many numbers.\")\n                return\n            }\n            i := 0\n            for n[i] != r {\n                i++\n                if i == len(n) {\n                    fmt.Println(\"wrong numbers.\")\n                    return\n                }\n            }\n            n = append(n[:i], n[i+1:]...)\n            stack = append(stack, float64(r-'0'))\n            continue\n        }\n        if len(stack) < 2 {\n            fmt.Println(\"invalid expression syntax.\")\n            return\n        }\n        switch r {\n        case '+':\n            stack[len(stack)-2] += stack[len(stack)-1]\n        case '-':\n            stack[len(stack)-2] -= stack[len(stack)-1]\n        case '*':\n            stack[len(stack)-2] *= stack[len(stack)-1]\n        case '/':\n            stack[len(stack)-2] /= stack[len(stack)-1]\n        default:\n            fmt.Printf(\"%c invalid.\\n\", r)\n            return\n        }\n        stack = stack[:len(stack)-1]\n    }\n    if math.Abs(stack[0]-24) > 1e-6 {\n        fmt.Println(\"incorrect.\", stack[0], \"!= 24\")\n    } else {\n        fmt.Println(\"correct.\")\n    }\n}\n"
                },
                {
                    "language": "C++",
                    "solution": "#include <random>\n#include <iostream>\n#include <stack>\n#include <set>\n#include <string>\n#include <functional>\nusing namespace std;\n\nclass RPNParse\n{\npublic:\n  stack<double> stk;\n  multiset<int> digits;\n\n  void op(function<double(double,double)> f)\n  {\n    if(stk.size() < 2)\n      throw \"Improperly written expression\";\n    int b = stk.top(); stk.pop();\n    int a = stk.top(); stk.pop();\n    stk.push(f(a, b));\n  }\n\n  void parse(char c)\n  {\n    if(c >= '0' && c <= '9')\n    {\n      stk.push(c - '0');\n      digits.insert(c - '0');\n    }\n    else if(c == '+')\n      op([](double a, double b) {return a+b;});\n    else if(c == '-')\n      op([](double a, double b) {return a-b;});\n    else if(c == '*')\n      op([](double a, double b) {return a*b;});\n    else if(c == '/')\n      op([](double a, double b) {return a/b;});\n  }\n\n  void parse(string s)\n  {\n    for(int i = 0; i < s.size(); ++i)\n      parse(s[i]);\n  }\n\n  double getResult()\n  {\n    if(stk.size() != 1)\n      throw \"Improperly written expression\";\n    return stk.top();\n  }\n};\n\nint main()\n{\n  random_device seed;\n  mt19937 engine(seed());\n  uniform_int_distribution<> distribution(1, 9);\n  auto rnd = bind(distribution, engine);\n\n  multiset<int> digits;\n  cout << \"Make 24 with the digits: \";\n  for(int i = 0; i < 4; ++i)\n  {\n    int n = rnd();\n    cout << \" \" << n;\n    digits.insert(n);\n  }\n  cout << endl;\n\n  RPNParse parser;\n\n  try\n  {\n    string input;\n    getline(cin, input);\n    parser.parse(input);\n\n    if(digits != parser.digits)\n      cout << \"Error: Not using the given digits\" << endl;\n    else\n    {\n      double r = parser.getResult();\n      cout << \"Result: \" << r << endl;\n\n      if(r > 23.999 && r < 24.001)\n        cout << \"Good job!\" << endl;\n      else\n        cout << \"Try again.\" << endl;\n    }\n  }\n  catch(char* e)\n  {\n    cout << \"Error: \" << e << endl;\n  }\n  return 0;\n}\n"
                }
            ],
            [
                {
                    "language": "Lasso",
                    "solution": "[\nif(sys_listunboundmethods !>> 'randoms') => {\n\tdefine randoms()::array => {\n\t\tlocal(out = array)\n\t\tloop(4) => { #out->insert(math_random(9,1)) }\n\t\treturn #out\n\t}\n}\nif(sys_listunboundmethods !>> 'checkvalid') => {\n\tdefine checkvalid(str::string, nums::array)::boolean => {\n\t\tlocal(chk = array('*','/','+','-','(',')',' '), chknums = array, lastintpos = -1, poscounter = 0)\n\t\tloop(9) => { #chk->insert(loop_count) }\n\t\twith s in #str->values do => {\n\t\t\t#poscounter++\n\t\t\t#chk !>> #s && #chk !>> integer(#s) ? return false\n\t\t\tinteger(#s) > 0 && #lastintpos + 1 >= #poscounter ? return false\n\t\t\tinteger(#s) > 0 ? #chknums->insert(integer(#s))\n\t\t\tinteger(#s) > 0 ? #lastintpos = #poscounter\n\t\t}\n\t\t#chknums->size != 4 ? return false\n\t\t#nums->sort\n\t\t#chknums->sort\n\t\tloop(4) => { #nums->get(loop_count) != #chknums(loop_count) ? return false }\n\t\treturn true\n\t}\n}\nif(sys_listunboundmethods !>> 'executeexpr') => {\n\tdefine executeexpr(expr::string)::integer => {\n\t\tlocal(keep = string)\n\t\twith i in #expr->values do => {\n\t\t\tif(array('*','/','+','-','(',')') >> #i) => {\n\t\t\t\t#keep->append(#i)\n\t\t\telse\n\t\t\t\tinteger(#i) > 0 ? #keep->append(decimal(#i))\n\t\t\t}\n\t\t}\n\t\treturn integer(sourcefile('['+#keep+']','24game',true,true)->invoke)\n\t}\n}\n\nlocal(numbers = array, exprsafe = true, exprcorrect = false, exprresult = 0)\nif(web_request->param('nums')->asString->size) => {\n\twith n in web_request->param('nums')->asString->split(',') do => { #numbers->insert(integer(#n->trim&)) }\n}\n#numbers->size != 4 ? #numbers = randoms()\nif(web_request->param('nums')->asString->size) => {\n\t#exprsafe = checkvalid(web_request->param('expr')->asString,#numbers)\n\tif(#exprsafe) => {\n\t\t#exprresult = executeexpr(web_request->param('expr')->asString)\n\t\t#exprresult == 24 ? #exprcorrect = true\n\t}\n}\n\n]<h1>24 Game</h1>\n<p><b>Rules:</b><br>\nEnter an expression that evaluates to 24</p>\n<ul>\n<li>Only multiplication, division, addition, and subtraction operators/functions are allowed.</li>\n<li>Brackets are allowed.</li>\n<li>Forming multiple digit numbers from the supplied digits is disallowed. (So an answer of 12+12 when given 1, 2, 2, and 1 is wrong).</li>\n<li>The order of the digits when given does not have to be preserved.</li>\n</ul>\n\n<h2>Numbers</h2>\n<p>[#numbers->join(', ')] (<a href=\"?\">Reload</a>)</p>\n[!#exprsafe ? '<p>Please provide a valid expression</p>']\n<form><input type=\"hidden\" value=\"[#numbers->join(',')]\" name=\"nums\"><input type=\"text\" name=\"expr\" value=\"[web_request->param('expr')->asString]\"><input type=\"submit\" name=\"submit\" value=\"submit\"></form>\n[if(#exprsafe)]\n<p>Result: <b>[#exprresult]</b> [#exprcorrect ? 'is CORRECT!' | 'is incorrect']</p>\n[/if]\n"
                },
                {
                    "language": "MIRC-Scripting-Language",
                    "solution": "alias 24 {\n  dialog -m 24-Game 24-Game\n}\n\ndialog 24-Game {\n  title \"24-Game\"\n  size -1 -1 100 70\n  option dbu\n  text \"\", 1, 29 7 42 8\n  text \"Equation\", 2, 20 21 21 8\n  edit \"\", 3, 45 20 40 10\n  text \"Status\", 4, 10 34 80 8, center\n  button \"Calculate\", 5, 5 45 40 20\n  button \"New\", 6, 57 47 35 15\n}\n\non *:DIALOG:24-Game:init:*: {\n  did -o 24-Game 1 1 Numbers: $rand(1,9) $rand(1,9) $rand(1,9) $rand(1,9)\n}\n\non *:DIALOG:24-Game:sclick:*: {\n  if ($did == 5) {\n    if ($regex($did(3),/^[ (]*\\d *[-+*/][ (]*\\d[ ()]*[-+*/][ ()]*\\d[ )]*[-+*/] *\\d[ )]*$/)) && ($sorttok($regsubex($did(3),/[^\\d]+/g,$chr(32)),32) == $sorttok($remove($did(1),Numbers:),32)) {\n      did -o 24-Game 4 1 $iif($calc($did(3)) == 24,Correct,Wrong)\n    }\n    else {\n      did -o 24-Game 4 1 Wrong Numbers or Syntax\n    }\n  }\n  elseif ($did == 6) {\n    did -o 24-Game 1 1 Numbers: $rand(1,9) $rand(1,9) $rand(1,9) $rand(1,9)\n  }\n}\n"
                }
            ],
            [
                {
                    "language": "C++",
                    "solution": "#include <random>\n#include <iostream>\n#include <stack>\n#include <set>\n#include <string>\n#include <functional>\nusing namespace std;\n\nclass RPNParse\n{\npublic:\n  stack<double> stk;\n  multiset<int> digits;\n\n  void op(function<double(double,double)> f)\n  {\n    if(stk.size() < 2)\n      throw \"Improperly written expression\";\n    int b = stk.top(); stk.pop();\n    int a = stk.top(); stk.pop();\n    stk.push(f(a, b));\n  }\n\n  void parse(char c)\n  {\n    if(c >= '0' && c <= '9')\n    {\n      stk.push(c - '0');\n      digits.insert(c - '0');\n    }\n    else if(c == '+')\n      op([](double a, double b) {return a+b;});\n    else if(c == '-')\n      op([](double a, double b) {return a-b;});\n    else if(c == '*')\n      op([](double a, double b) {return a*b;});\n    else if(c == '/')\n      op([](double a, double b) {return a/b;});\n  }\n\n  void parse(string s)\n  {\n    for(int i = 0; i < s.size(); ++i)\n      parse(s[i]);\n  }\n\n  double getResult()\n  {\n    if(stk.size() != 1)\n      throw \"Improperly written expression\";\n    return stk.top();\n  }\n};\n\nint main()\n{\n  random_device seed;\n  mt19937 engine(seed());\n  uniform_int_distribution<> distribution(1, 9);\n  auto rnd = bind(distribution, engine);\n\n  multiset<int> digits;\n  cout << \"Make 24 with the digits: \";\n  for(int i = 0; i < 4; ++i)\n  {\n    int n = rnd();\n    cout << \" \" << n;\n    digits.insert(n);\n  }\n  cout << endl;\n\n  RPNParse parser;\n\n  try\n  {\n    string input;\n    getline(cin, input);\n    parser.parse(input);\n\n    if(digits != parser.digits)\n      cout << \"Error: Not using the given digits\" << endl;\n    else\n    {\n      double r = parser.getResult();\n      cout << \"Result: \" << r << endl;\n\n      if(r > 23.999 && r < 24.001)\n        cout << \"Good job!\" << endl;\n      else\n        cout << \"Try again.\" << endl;\n    }\n  }\n  catch(char* e)\n  {\n    cout << \"Error: \" << e << endl;\n  }\n  return 0;\n}\n"
                },
                {
                    "language": "Kotlin",
                    "solution": "import java.util.Random\nimport java.util.Scanner\nimport java.util.Stack\n\ninternal object Game24 {\n    fun run() {\n        val r = Random()\n        val digits = IntArray(4).map { r.nextInt(9) + 1 }\n        println(\"Make 24 using these digits: $digits\")\n        print(\"> \")\n\n        val s = Stack<Float>()\n        var total = 0L\n        val cin = Scanner(System.`in`)\n        for (c in cin.nextLine()) {\n            when (c) {\n                in '0'..'9' -> {\n                    val d = c - '0'\n                    total += (1 shl (d * 5)).toLong()\n                    s += d.toFloat()\n                }\n                else ->\n                    if (\"+/-*\".indexOf(c) != -1) {\n                        s += c.applyOperator(s.pop(), s.pop())\n                    }\n            }\n        }\n\n        when {\n            tally(digits) != total ->\n                print(\"Not the same digits. \")\n            s.peek().compareTo(target) == 0 ->\n                println(\"Correct!\")\n            else ->\n                print(\"Not correct.\")\n        }\n    }\n\n    private fun Char.applyOperator(a: Float, b: Float) = when (this) {\n        '+' -> a + b\n        '-' -> b - a\n        '*' -> a * b\n        '/' -> b / a\n        else -> Float.NaN\n    }\n\n    private fun tally(a: List<Int>): Long = a.reduce({ t, i -> t + (1 shl (i * 5)) }).toLong()\n\n    private val target = 24\n}\n\nfun main(args: Array<String>) = Game24.run()\n"
                }
            ],
            [
                {
                    "language": "Quackery",
                    "solution": "  [ stack ]                                       is operators       (   --> s )\n\n  0 $ \"*/+-\" witheach [ bit | ]\n  operators put\n\n  [ stack ]                                       is numbers         (   --> s )\n\n  [ 0 swap\n    witheach [ bit | ]\n    numbers put ]                                 is putnumbers      ( $ -->   )\n\n  [ $ \"123456789\" shuffle 4 split drop sort ]     is choosenumbers   (   --> $ )\n\n  [ say \"Using any of the operators * / + -\" cr\n    say \"and each of the numbers \"\n    witheach [ emit sp ] say \"once,\" cr\n    say \"enter an RPN expression equal to 24.\" cr\n    $ \"Spaces between characters are optional: \"\n    input ]                                       is getexpression   ( $ --> $ )\n\n  [ $ \"\" swap witheach\n      [ dup space = iff drop else join ] ]        is stripspaces     ( $ --> $ )\n\n  [ stack ]                                       is opcount         (   --> s )\n  [ stack ]                                       is numcount        (   --> s )\n  [ stack ]                                       is numsused        (   --> s )\n\n  [ true swap\n    0 opcount put\n    0 numcount put\n    0 numsused put\n    witheach\n      [ bit dup numbers share & iff\n          [ 1 numcount tally\n            numsused take | numsused put ]\n        else\n          [ operators share & if\n              [ 1 opcount tally ] ]\n        opcount share numcount share < not if\n          [ drop false conclude ] ]\n    numsused take\n    numbers share != if [ drop false ]\n    numcount take 4 != if [ drop false ]\n    opcount take 3 != if [ drop false ] ]         is checkexpression ( $ --> b )\n\n  [ $ \"\" swap\n    witheach\n      [ dup char 0 char 9 1+ within iff\n          [ join $ \" n->v \" join ] done\n        [ switch\n          char * case [ $ \"v* \" join ]\n          char / case [ $ \"v/ \" join ]\n          char + case [ $ \"v+ \" join ]\n          char - case [ $ \"v- \" join ]\n          otherwise [ $ \"Error!\" fail ] ] ] ]     is quackerise      ( $ --> [ )\n\n    [ choosenumbers\n      dup putnumbers\n      [ dup getexpression\n        stripspaces\n        dup checkexpression not while\n        cr\n        say \"Badly formed expression. Try again.\"\n        cr cr\n        drop again ]\n      nip\n      quackerise\n      quackery\n      cr\n      say \"Your expression is equal to \"\n      2dup 10 point$ echo$\n      24 n->v v- v0= iff\n      [ say \". :-)\" ] else [ say \". :-(\" ]\n      numbers release ]                           is game            (   -->   )\n"
                },
                {
                    "language": "Argile",
                    "solution": "use std, array, list\n\ndo\n  generate random digits\n  show random digits\n  let result = parse expression (get input line)\n  if result != ERROR\n    if some digits are unused\n      print \"Wrong ! (you didn't use all digits)\" ; failure++\n    else if result == 24.0\n      print \"Correct !\" ; success++\n    else\n      print \"Wrong ! (you got \"result\")\" ; failure++\n while play again ?\nprint \"success:\"success\" failure:\"failure\" total:\"(success+failure) as int\n\nlet success = 0, failure = 0.\n\n.: generate random digits :.\n   our nat seed = 0xc6f31 (: default seed when /dev/urandom doesn't exist :)\n   let urandom = fopen \"/dev/urandom\" \"r\"\n   if  urandom isn't nil\n     fread &seed size of seed 1 urandom\n     fclose urandom\n   Cfunc srandom seed\n   seed = (Cfunc random) as nat\n   for each (val int d) from 0 to 3\n     digits[d] = '1' + (seed % 9)\n     seed /= 9\n\nlet digits be an array of 4 byte\n\n.: show random digits :.\n   print \"Enter an expression that equates to 24 using only all these digits:\"\n   printf \"%c , %c , %c , %c\\n\"(digits[0])(digits[1])(digits[2])(digits[3])\n   printf \"24 = \"\n\n.: some digits are unused :. -> bool\n   for each (val int d) from 0 to 3\n     return true if digits[d] != '\\0'\n   false\n\n.: get input line :. -> text\n   our array of 64 byte line\n   Cfunc fgets (line) (size of line) (stdin)\n   let int i\n   for (i = 0) (line[i] != 0) (i++)\n     line[i] = '\\0' if (line[i] == '\\n')\n   line as text\n\n.: play again ? :. -> bool\n   while true\n     printf \"Play again ? (y/n) \" ; Cfunc fflush stdout\n     let answer = get input line\n     switch answer[0]\n       case 'n' {return false}\n       case 'y' {return true }\n       default  {continue    }\n   false\n\n=: ERROR := -> real {-32202.0}\n\n.: parse expression <text expr> :. -> real\n   let x = 0.0, x_is_set = false, op = ' '.\n   let stack be a list of State ; class State {byte op; real x}\n   for (stack = nil) (*expr != 0) (expr++)\n     switch *expr\n       case '+' ; case '-' ; case '*' ; case '/'\n         error \"bad syntax\" if not x_is_set\n\t op = *expr\n       case '1' ; case '2' ; case '3' ; case '4' ; case '5'\n       case '6' ; case '7' ; case '8' ; case '9'\n\t error \"missing operator\" if (x_is_set and op == ' ')\n\t error \"unavailable digit\" unless consume digit expr[0]\n\t do operation with (expr[0] - '0') as real\n       case (Cgen \"'('\")\n\t error \"missing operator\" if (op == ' ' but x_is_set)\n\t (new list (new State) (code of del State())) << stack\n\t op = ' ' ; x_is_set = false (: start fresh state :)\n       case (Cgen \"')'\")\n         error \"mismatched parenthesis\" if stack is nil\n\t error \"wrong syntax\" if not x_is_set\n\t let y = x\n\t x = stack.data.x ; op = stack.data.op\n\t delete pop stack\n\t do operation with y\n       default {error \"disallowed character\"}\n\n       .:new State          :. -> State {let s=new(State); s.x=x; s.op=op; s}\n       .:del State <State s>:.          {               free s              }\n       .:do operation with <real y>:.\n  \t switch op\n\t   case '+' {x += y}\n\t   case '-' {x -= y}\n\t   case '*' {x *= y}\n\t   case '/' {x /= y}\n\t   default  {x  = y; x_is_set = true}\n         op = ' '\n   =:error<text msg>:= ->real {eprint \"Error: \"msg\" at [\"expr\"]\";return ERROR}\n   .:consume digit <byte b>:. -> bool\n     for each (val int d) from 0 to 3\n       if digits[d] == b\n         digits[d] = '\\0'\n       \t return true\n     false\n\n   if stack isn't nil\n     delete all stack\n     error \"unclosed parenthesis\"\n   return x\n"
                }
            ]
        ]
    },
    {
        "task_name": "24-game-Solve",
        "task_description": ";task:\nWrite a program that takes four digits, either from user input or by random generation, and computes arithmetic expressions following the rules of the [[24 game]].\n\nShow examples of solutions generated by the program.\n\n\n;Related task:\n* &nbsp; [[Arithmetic Evaluator]]\n<br><br>\n",
        "solution_pairs": [
            [
                {
                    "language": "Mathematica",
                    "solution": "treeR[n_] := Table[o[trees[a], trees[n - a]], {a, 1, n - 1}]\ntreeR[1] := n\ntree[n_] :=\n Flatten[treeR[n] //. {o[a_List, b_] :> (o[#, b] & /@ a),\n    o[a_, b_List] :> (o[a, #] & /@ b)}]\ngame24play[val_List] :=\n Union[StringReplace[StringTake[ToString[#, InputForm], {10, -2}],\n     \"-1*\" ~~ n_ :> \"-\" <> n] & /@ (HoldForm /@\n      Select[Union@\n        Flatten[Outer[# /. {o[q_Integer] :> #2[[q]],\n             n[q_] :> #3[[q]]} &,\n          Block[{O = 1, N = 1}, # /. {o :> o[O++], n :> n[N++]}] & /@\n           tree[4], Tuples[{Plus, Subtract, Times, Divide}, 3],\n          Permutations[Array[v, 4]], 1]],\n       Quiet[(# /. v[q_] :> val[[q]]) == 24] &] /.\n     Table[v[q] -> val[[q]], {q, 4}])]\n"
                },
                {
                    "language": "Ruby",
                    "solution": "class TwentyFourGame\n  EXPRESSIONS = [\n    '((%dr %s %dr) %s %dr) %s %dr',\n    '(%dr %s (%dr %s %dr)) %s %dr',\n    '(%dr %s %dr) %s (%dr %s %dr)',\n    '%dr %s ((%dr %s %dr) %s %dr)',\n    '%dr %s (%dr %s (%dr %s %dr))',\n  ]\n\n  OPERATORS = [:+, :-, :*, :/].repeated_permutation(3).to_a\n\n  def self.solve(digits)\n    solutions = []\n    perms = digits.permutation.to_a.uniq\n    perms.product(OPERATORS, EXPRESSIONS) do |(a,b,c,d), (op1,op2,op3), expr|\n      # evaluate using rational arithmetic\n      text = expr % [a, op1, b, op2, c, op3, d]\n      value = eval(text)  rescue next                 # catch division by zero\n      solutions << text.delete(\"r\")  if value == 24\n    end\n    solutions\n  end\nend\n\n# validate user input\ndigits = ARGV.map do |arg|\n  begin\n    Integer(arg)\n  rescue ArgumentError\n    raise \"error: not an integer: '#{arg}'\"\n  end\nend\ndigits.size == 4 or raise \"error: need 4 digits, only have #{digits.size}\"\n\nsolutions = TwentyFourGame.solve(digits)\nif solutions.empty?\n  puts \"no solutions\"\nelse\n  puts \"found #{solutions.size} solutions, including #{solutions.first}\"\n  puts solutions.sort\nend\n"
                }
            ],
            [
                {
                    "language": "PicoLisp",
                    "solution": "(be play24 (@Lst @Expr)                # Define Pilog rule\n   (permute @Lst (@A @B @C @D))\n   (member @Op1 (+ - * /))\n   (member @Op2 (+ - * /))\n   (member @Op3 (+ - * /))\n   (or\n      ((equal @Expr (@Op1 (@Op2 @A @B) (@Op3 @C @D))))\n      ((equal @Expr (@Op1 @A (@Op2 @B (@Op3 @C @D))))) )\n   (^ @ (= 24 (catch '(\"Div/0\") (eval (-> @Expr))))) )\n\n(de play24 (A B C D)                   # Define PicoLisp function\n   (pilog\n      (quote\n         @L (list A B C D)\n         (play24 @L @X) )\n      (println @X) ) )\n\n(play24 5 6 7 8)                       # Call 'play24' function\n"
                },
                {
                    "language": "Jq",
                    "solution": "$ jq -r -f Solve.jq\n[1,2,3,4]\nThat was too easy. I found 242 answers, e.g. [4 * [1 + [2 + 3]]]\nPlease try again.\n[1,2,3,40,1]\nThat was too easy. I found 636 answers, e.g. [[[1 / 2] * 40] + [3 + 1]]\nPlease try again.\n[3,8,9]\nThat was too easy. I found 8 answers, e.g. [[8 / 3] * 9]\nPlease try again.\n[4,5,6]\nYou lose! There are no solutions.\nPlease try again.\n[1,2,3,4,5,6]\nThat was too easy. I found 197926 answers, e.g. [[2 * [1 + 4]] + [3 + [5 + 6]]]\nPlease try again.\n"
                }
            ],
            [
                {
                    "language": "Lua",
                    "solution": "local SIZE = #arg[1]\nlocal GOAL = tonumber(arg[2]) or 24\n\nlocal input = {}\nfor v in arg[1]:gmatch(\"%d\") do\n\ttable.insert(input, v)\nend\nassert(#input == SIZE, 'Invalid input')\n\nlocal operations = {'+', '-', '*', '/'}\n\nlocal function BinaryTrees(vert)\n\tif vert == 0 then\n\t\treturn {false}\n\telse\n\t\tlocal buf = {}\n\t\tfor leften = 0, vert - 1 do\n\t\t\tlocal righten = vert - leften - 1\n\t\t\tfor _, left in pairs(BinaryTrees(leften)) do\n\t\t\t\tfor _, right in pairs(BinaryTrees(righten)) do\n\t\t\t\t\ttable.insert(buf, {left, right})\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\t\treturn buf\n\tend\nend\nlocal trees = BinaryTrees(SIZE-1)\nlocal c, opc, oper, str\nlocal max = math.pow(#operations, SIZE-1)\nlocal function op(a,b)\n\topc = opc + 1\n\tlocal i = math.floor(oper/math.pow(#operations, opc-1))%#operations+1\n\treturn '('.. a .. operations[i] .. b ..')'\nend\n\nlocal function EvalTree(tree)\n\tif tree == false then\n\t\tc = c + 1\n\t\treturn input[c-1]\n\telse\n\t\treturn op(EvalTree(tree[1]), EvalTree(tree[2]))\n\tend\nend\n\nlocal function printResult()\n\tfor _, v in ipairs(trees) do\n\t\tfor i = 0, max do\n\t\t\tc, opc, oper = 1, 0, i\n\t\t\tstr = EvalTree(v)\n\t\t\tloadstring('res='..str)()\n\t\t\tif(res == GOAL) then print(str, '=', res) end\n\t\tend\n\tend\nend\n\nlocal uniq = {}\nlocal function permgen (a, n)\n\tif n == 0 then\n\t\tlocal str = table.concat(a)\n\t\tif not uniq[str] then\n\t\t\tprintResult()\n\t\t\tuniq[str] = true\n\t\tend\n\telse\n\t\tfor i = 1, n do\n\t\t\ta[n], a[i] = a[i], a[n]\n\t\t\tpermgen(a, n - 1)\n\t\t\ta[n], a[i] = a[i], a[n]\n\t\tend\n\tend\nend\n\npermgen(input, SIZE)\n"
                },
                {
                    "language": "Clojure",
                    "solution": "(ns rosettacode.24game.solve\n  (:require [clojure.math.combinatorics :as c]\n            [clojure.walk :as w]))\n\n(def ^:private op-maps\n  (map #(zipmap [:o1 :o2 :o3] %) (c/selections '(* + - /) 3)))\n\n(def ^:private patterns '(\n  (:o1 (:o2 :n1 :n2) (:o3 :n3 :n4))\n  (:o1 :n1 (:o2 :n2 (:o3 :n3 :n4)))\n  (:o1 (:o2 (:o3 :n1 :n2) :n3) :n4)))\n\n(defn play24 [& digits]\n  {:pre (and (every? #(not= 0 %) digits)\n             (= (count digits) 4))}\n  (->> (for [:let [digit-maps\n                     (->> digits sort c/permutations\n                          (map #(zipmap [:n1 :n2 :n3 :n4] %)))]\n             om op-maps, dm digit-maps]\n         (w/prewalk-replace dm\n           (w/prewalk-replace om patterns)))\n       (filter #(= (eval %) 24))\n       (map println)\n       doall\n       count))\n"
                }
            ],
            [
                {
                    "language": "Mathematica",
                    "solution": "treeR[n_] := Table[o[trees[a], trees[n - a]], {a, 1, n - 1}]\ntreeR[1] := n\ntree[n_] :=\n Flatten[treeR[n] //. {o[a_List, b_] :> (o[#, b] & /@ a),\n    o[a_, b_List] :> (o[a, #] & /@ b)}]\ngame24play[val_List] :=\n Union[StringReplace[StringTake[ToString[#, InputForm], {10, -2}],\n     \"-1*\" ~~ n_ :> \"-\" <> n] & /@ (HoldForm /@\n      Select[Union@\n        Flatten[Outer[# /. {o[q_Integer] :> #2[[q]],\n             n[q_] :> #3[[q]]} &,\n          Block[{O = 1, N = 1}, # /. {o :> o[O++], n :> n[N++]}] & /@\n           tree[4], Tuples[{Plus, Subtract, Times, Divide}, 3],\n          Permutations[Array[v, 4]], 1]],\n       Quiet[(# /. v[q_] :> val[[q]]) == 24] &] /.\n     Table[v[q] -> val[[q]], {q, 4}])]\n"
                },
                {
                    "language": "Euler",
                    "solution": ">function try24 (v) ...\n$n=cols(v);\n$if n==1 and v[1]~=24 then\n$  \"Solved the problem\",\n$  return 1;\n$endif\n$loop 1 to n\n$  w=tail(v,2);\n$  loop 1 to n-1\n$    h=w; a=v[1]; b=w[1];\n$    w[1]=a+b; if try24(w); \"\"+a+\"+\"+b+\"=\"+(a+b), return 1; endif;\n$    w[1]=a-b; if try24(w); \"\"+a+\"-\"+b+\"=\"+(a-b), return 1; endif;\n$    w[1]=a*b; if try24(w); \"\"+a+\"*\"+b+\"=\"+(a*b), return 1; endif;\n$    if not b~=0 then\n$       w[1]=a/b; if try24(w); \"\"+a+\"/\"+b+\"=\"+(a/b), return 1; endif;\n$    endif;\n$    w=rotright(w);\n$  end;\n$  v=rotright(v);\n$end;\n$return 0;\n$endfunction\n"
                }
            ],
            [
                {
                    "language": "BBC-BASIC",
                    "solution": "      PROCsolve24(\"1234\")\n      PROCsolve24(\"6789\")\n      PROCsolve24(\"1127\")\n      PROCsolve24(\"5566\")\n      END\n\n      DEF PROCsolve24(s$)\n      LOCAL F%, I%, J%, K%, L%, P%, T%, X$, o$(), p$(), t$()\n      DIM o$(4), p$(24,4), t$(11)\n      o$() = \"\", \"+\", \"-\", \"*\", \"/\"\n      RESTORE\n      FOR T% = 1 TO 11\n        READ t$(T%)\n      NEXT\n      DATA \"abcdefg\", \"(abc)defg\", \"ab(cde)fg\", \"abcd(efg)\", \"(abc)d(efg)\", \"(abcde)fg\"\n      DATA \"ab(cdefg)\", \"((abc)de)fg\", \"(ab(cde))fg\", \"ab((cde)fg)\", \"ab(cd(efg))\"\n\n      FOR I% = 1 TO 4\n        FOR J% = 1 TO 4\n          FOR K% = 1 TO 4\n            FOR L% = 1 TO 4\n              IF I%<>J% IF J%<>K% IF K%<>L% IF I%<>K% IF J%<>L% IF I%<>L% THEN\n                P% += 1\n                p$(P%,1) = MID$(s$,I%,1)\n                p$(P%,2) = MID$(s$,J%,1)\n                p$(P%,3) = MID$(s$,K%,1)\n                p$(P%,4) = MID$(s$,L%,1)\n              ENDIF\n            NEXT\n          NEXT\n        NEXT\n      NEXT\n\n      FOR I% = 1 TO 4\n        FOR J% = 1 TO 4\n          FOR K% = 1 TO 4\n            FOR T% = 1 TO 11\n              FOR P% = 1 TO 24\n                X$ = t$(T%)\n                MID$(X$, INSTR(X$,\"a\"), 1) = p$(P%,1)\n                MID$(X$, INSTR(X$,\"b\"), 1) = o$(I%)\n                MID$(X$, INSTR(X$,\"c\"), 1) = p$(P%,2)\n                MID$(X$, INSTR(X$,\"d\"), 1) = o$(J%)\n                MID$(X$, INSTR(X$,\"e\"), 1) = p$(P%,3)\n                MID$(X$, INSTR(X$,\"f\"), 1) = o$(K%)\n                MID$(X$, INSTR(X$,\"g\"), 1) = p$(P%,4)\n                F% = TRUE : ON ERROR LOCAL F% = FALSE\n                IF F% IF EVAL(X$) = 24 THEN PRINT X$ : EXIT FOR I%\n                RESTORE ERROR\n              NEXT\n            NEXT\n          NEXT\n        NEXT\n      NEXT\n      IF I% > 4 PRINT \"No solution found\"\n      ENDPROC\n"
                },
                {
                    "language": "Mathematica",
                    "solution": "evaluate[HoldForm[op_[l_, r_]]] := op[evaluate[l], evaluate[r]];\nevaluate[x_] := x;\ncombine[l_, r_ /; evaluate[r] != 0] := {HoldForm[Plus[l, r]],\n   HoldForm[Subtract[l, r]], HoldForm[Times[l, r]],\n   HoldForm[Divide[l, r]] };\ncombine[l_, r_] := {HoldForm[Plus[l, r]], HoldForm[Subtract[l, r]],\n   HoldForm[Times[l, r]]};\nsplit[items_] :=\n  Table[{items[[1 ;; i]], items[[i + 1 ;; Length[items]]]}, {i, 1,\n    Length[items] - 1}];\nexpressions[{x_}] := {x};\nexpressions[items_] :=\n  Flatten[Table[\n    Flatten[Table[\n      combine[l, r], {l, expressions[sp[[1]]]}, {r,\n       expressions[sp[[2]]]}], 2], {sp, split[items]}]];\n\n(* Must use all atoms in given order. *)\nsolveMaintainOrder[goal_, items_] :=\n  Select[expressions[items], (evaluate[#] == goal) &];\n(* Must use all atoms, but can permute them. *)\nsolveCanPermute[goal_, items_] :=\n  Flatten[Table[\n    solveMaintainOrder[goal, pitems], {pitems,\n     Permutations[items]}]];\n(* Can use any subset of atoms. *)\nsolveSubsets[goal_, items_] :=\n  Flatten[Table[\n    solveCanPermute[goal, is], {is,\n     Subsets[items, {1, Length[items]}]}], 2];\n\n(* Demonstration to find all the ways to create 1/5 from {2, 3, 4, 5}. *)\nsolveMaintainOrder[1/5, Range[2, 5]]\nsolveCanPermute[1/5, Range[2, 5]]\nsolveSubsets[1/5, Range[2, 5]]\n"
                }
            ]
        ]
    },
    {
        "task_name": "4-rings-or-4-squares-puzzle",
        "task_description": ";Task:\nReplace &nbsp; &nbsp; &nbsp; '''a, b, c, d, e, f,''' &nbsp; and\n&nbsp; '''g ''' &nbsp; &nbsp; &nbsp; with the decimal\ndigits &nbsp; LOW &nbsp; \u2500\u2500\u2500\u25ba &nbsp; HIGH\n<br>such that the sum of the letters inside of each of the four large squares add up to\nthe same sum.\n\n<pre>\n            \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557      \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n            \u2551              \u2551      \u2551              \u2551\n            \u2551      a       \u2551      \u2551      e       \u2551\n            \u2551              \u2551      \u2551              \u2551\n            \u2551          \u250c\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n            \u2551          \u2502   \u2551      \u2551   \u2502      \u2502   \u2551         \u2502\n            \u2551          \u2502 b \u2551      \u2551 d \u2502      \u2502 f \u2551         \u2502\n            \u2551          \u2502   \u2551      \u2551   \u2502      \u2502   \u2551         \u2502\n            \u2551          \u2502   \u2551      \u2551   \u2502      \u2502   \u2551         \u2502\n            \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u255d      \u255a\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u255d         \u2502\n                       \u2502       c      \u2502      \u2502      g      \u2502\n                       \u2502              \u2502      \u2502             \u2502\n                       \u2502              \u2502      \u2502             \u2502\n                       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</pre>\n\nShow all output here.\n\n\n:* &nbsp; Show all solutions for each letter being unique with\n         LOW=1     HIGH=7\n:* &nbsp; Show all solutions for each letter being unique with\n         LOW=3     HIGH=9\n:* &nbsp; Show only the &nbsp; ''number'' &nbsp; of solutions when each letter can be non-unique\n         LOW=0     HIGH=9\n\n\n;Related task:\n* [[Solve the no connection puzzle]]\n<br><br>\n\n",
        "solution_pairs": [
            [
                {
                    "language": "REXX",
                    "solution": "/*REXX pgm solves the 4-rings puzzle,  where letters represent unique (or not) digits). */\narg LO HI unique show .                          /*the  ARG  statement capitalizes args.*/\nif LO=='' | LO==\",\"  then LO=1                   /*Not specified?  Then use the default.*/\nif HI=='' | HI==\",\"  then HI=7                   /* \"      \"         \"   \"   \"     \"    */\nif unique=='' | unique==',' | unique=='UNIQUE'  then unique=1  /*unique letter solutions*/\n                                                else unique=0  /*non-unique        \"    */\nif   show=='' |   show==',' |   show=='SHOW'    then show=1    /*noshow letter solutions*/\n                                                else show=0    /*  show    \"       \"    */\nw=max(3, length(LO), length(HI) )                /*maximum width of any number found.   */\nbar=copies('\u2550', w)                               /*define a horizontal bar (for title). */\ntimes=HI - LO + 1                                /*calculate number of times to loop.   */\n#=0                                              /*number of solutions found (so far).  */\n       do a=LO     for times\n          do b=LO  for times\n          if unique  then  if b==a  then  iterate\n             do c=LO  for times\n             if unique  then  do;  if c==a  then  iterate\n                                   if c==b  then  iterate\n                              end\n                do d=LO  for times\n                if unique  then  do;  if d==a  then  iterate\n                                      if d==b  then  iterate\n                                      if d==c  then  iterate\n                                 end\n                   do e=LO  for times\n                   if unique  then  do;  if e==a  then  iterate\n                                         if e==b  then  iterate\n                                         if e==c  then  iterate\n                                         if e==d  then  iterate\n                                    end\n                      do f=LO  for times\n                      if unique  then  do;  if f==a  then  iterate\n                                            if f==b  then  iterate\n                                            if f==c  then  iterate\n                                            if f==d  then  iterate\n                                            if f==e  then  iterate\n                                       end\n                         do g=LO  for times\n                         if unique  then  do;  if g==a  then  iterate\n                                               if g==b  then  iterate\n                                               if g==c  then  iterate\n                                               if g==d  then  iterate\n                                               if g==e  then  iterate\n                                               if g==f  then  iterate\n                                          end\n                         sum=a+b\n                         if   f+g\\==sum  then  iterate\n                         if b+c+d\\==sum  then  iterate\n                         if d+e+f\\==sum  then  iterate\n                         #=# + 1                          /*bump the count of solutions.*/\n                         if #==1  then call align  'a',  'b',  'c',  'd',  'e',  'f',  'g'\n                         if #==1  then call align  bar,  bar,  bar,  bar,  bar,  bar,  bar\n                                       call align   a,    b,    c,    d,    e,    f,    g\n                         end   /*g*/\n                      end      /*f*/\n                   end         /*e*/\n                end            /*d*/\n             end               /*c*/\n          end                  /*b*/\n       end                     /*a*/\nsay\n                 _= ' non-unique'\nif  unique  then _= ' unique '\nsay #  _  'solutions found.'\nexit                                             /*stick a fork in it,  we're all done. */\n/*\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500*/\nalign: parse arg a1,a2,a3,a4,a5,a6,a7\n       if show  then say left('',9)  center(a1,w) center(a2,w) center(a3,w) center(a4,w),\n                                     center(a5,w) center(a6,w) center(a7,w)\n       return\n"
                },
                {
                    "language": "Visual-Basic-.NET",
                    "solution": "Module Module1\n\n    Dim CA As Char() = \"0123456789ABC\".ToCharArray()\n\n    Sub FourSquare(lo As Integer, hi As Integer, uni As Boolean, sy As Char())\n        If sy IsNot Nothing Then Console.WriteLine(\"a b c d e f g\" & vbLf & \"-------------\")\n        Dim r = Enumerable.Range(lo, hi - lo + 1).ToList(), u As New List(Of Integer),\n            t As Integer, cn As Integer = 0\n        For Each a In r\n            u.Add(a)\n            For Each b In r\n                If uni AndAlso u.Contains(b) Then Continue For\n                u.Add(b)\n                t = a + b\n                For Each c In r : If uni AndAlso u.Contains(c) Then Continue For\n                    u.Add(c)\n                    For d = a - c To a - c\n                        If d < lo OrElse d > hi OrElse uni AndAlso u.Contains(d) OrElse\n                            t <> b + c + d Then Continue For\n                        u.Add(d)\n                        For Each e In r\n                            If uni AndAlso u.Contains(e) Then Continue For\n                            u.Add(e)\n                            For f = b + c - e To b + c - e\n                                If f < lo OrElse f > hi OrElse uni AndAlso u.Contains(f) OrElse\n                                    t <> d + e + f Then Continue For\n                                u.Add(f)\n                                For g = t - f To t - f : If g < lo OrElse g > hi OrElse\n                                    uni AndAlso u.Contains(g) Then Continue For\n                                    cn += 1 : If sy IsNot Nothing Then _\n                                        Console.WriteLine(\"{0} {1} {2} {3} {4} {5} {6}\",\n                                            sy(a), sy(b), sy(c), sy(d), sy(e), sy(f), sy(g))\n                                Next : u.Remove(f) : Next : u.Remove(e) : Next : u.Remove(d)\n                    Next : u.Remove(c) : Next : u.Remove(b) : Next : u.Remove(a)\n        Next : Console.WriteLine(\"{0} {1}unique solutions for [{2},{3}]{4}\",\n                                 cn, If(uni, \"\", \"non-\"), lo, hi, vbLf)\n    End Sub\n\n    Sub main()\n        fourSquare(1, 7, True, CA)\n        fourSquare(3, 9, True, CA)\n        fourSquare(0, 9, False, Nothing)\n        fourSquare(5, 12, True, CA)\n    End Sub\n\nEnd Module\n"
                }
            ],
            [
                {
                    "language": "Zig",
                    "solution": "const std = @import(\"std\");\nconst Allocator = std.mem.Allocator;\n"
                },
                {
                    "language": "Groovy",
                    "solution": "class FourRings {\n    static void main(String[] args) {\n        fourSquare(1, 7, true, true)\n        fourSquare(3, 9, true, true)\n        fourSquare(0, 9, false, false)\n    }\n\n    private static void fourSquare(int low, int high, boolean unique, boolean print) {\n        int count = 0\n\n        if (print) {\n            println(\"a b c d e f g\")\n        }\n        for (int a = low; a <= high; ++a) {\n            for (int b = low; b <= high; ++b) {\n                if (notValid(unique, a, b)) continue\n\n                int fp = a + b\n                for (int c = low; c <= high; ++c) {\n                    if (notValid(unique, c, a, b)) continue\n                    for (int d = low; d <= high; ++d) {\n                        if (notValid(unique, d, a, b, c)) continue\n                        if (fp != b + c + d) continue\n\n                        for (int e = low; e <= high; ++e) {\n                            if (notValid(unique, e, a, b, c, d)) continue\n                            for (int f = low; f <= high; ++f) {\n                                if (notValid(unique, f, a, b, c, d, e)) continue\n                                if (fp != d + e + f) continue\n\n                                for (int g = low; g <= high; ++g) {\n                                    if (notValid(unique, g, a, b, c, d, e, f)) continue\n                                    if (fp != f + g) continue\n\n                                    ++count\n                                    if (print) {\n                                        printf(\"%d %d %d %d %d %d %d%n\", a, b, c, d, e, f, g)\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        if (unique) {\n            printf(\"There are %d unique solutions in [%d, %d]%n\", count, low, high)\n        } else {\n            printf(\"There are %d non-unique solutions in [%d, %d]%n\", count, low, high)\n        }\n    }\n\n    private static boolean notValid(boolean unique, int needle, int ... haystack) {\n        return unique && Arrays.stream(haystack).anyMatch({ p -> p == needle })\n    }\n}\n"
                }
            ],
            [
                {
                    "language": "R",
                    "solution": "# 4 rings or 4 squares puzzle\n\nperms <- function (n, r, v = 1:n, repeats.allowed = FALSE) {\n  if (repeats.allowed)\n    sub <- function(n, r, v) {\n      if (r == 1)\n        matrix(v, n, 1)\n      else if (n == 1)\n        matrix(v, 1, r)\n      else {\n        inner <- Recall(n, r - 1, v)\n        cbind(rep(v, rep(nrow(inner), n)), matrix(t(inner),\n                                                  ncol = ncol(inner), nrow = nrow(inner) * n,\n                                                  byrow = TRUE))\n      }\n    }\n  else sub <- function(n, r, v) {\n    if (r == 1)\n      matrix(v, n, 1)\n    else if (n == 1)\n      matrix(v, 1, r)\n    else {\n      X <- NULL\n      for (i in 1:n) X <- rbind(X, cbind(v[i], Recall(n - 1, r - 1, v[-i])))\n      X\n    }\n  }\n  X <- sub(n, r, v[1:n])\n\n  result <- vector(mode = \"numeric\")\n\n  for(i in 1:nrow(X)){\n    y <- X[i, ]\n    x1 <- y[1] + y[2]\n    x2 <- y[2] + y[3] + y[4]\n    x3 <- y[4] + y[5] + y[6]\n    x4 <- y[6] + y[7]\n    if(x1 == x2 & x2 == x3 & x3 == x4) result <- rbind(result, y)\n  }\n  return(result)\n}\n\nprint_perms <- function(n, r, v = 1:n, repeats.allowed = FALSE, table.out = FALSE) {\n  a <- perms(n, r, v, repeats.allowed)\n  colnames(a) <- rep(\"\", ncol(a))\n  rownames(a) <- rep(\"\", nrow(a))\n  if(!repeats.allowed){\n    print(a)\n    cat(paste('\\n', nrow(a), 'unique solutions from', min(v), 'to', max(v)))\n  } else {\n    cat(paste('\\n', nrow(a), 'non-unique solutions from', min(v), 'to', max(v)))\n  }\n}\n\nregisterS3method(\"print_perms\", \"data.frame\", print_perms)\n\nprint_perms(7, 7, repeats.allowed = FALSE, table.out = TRUE)\nprint_perms(7, 7, v = 3:9, repeats.allowed = FALSE, table.out = TRUE)\nprint_perms(10, 7, v = 0:9, repeats.allowed = TRUE, table.out = FALSE)\n"
                },
                {
                    "language": "Clojure",
                    "solution": "(use '[clojure.math.combinatorics]\n\n(defn rings [r & {:keys [unique] :or {unique true}}]\n    (if unique\n      (apply concat (map permutations (combinations r 7)))\n      (selections r 7)))\n\n(defn four-rings [low high & {:keys [unique] :or {unique true}}]\n  (for [[a b c d e f g] (rings (range low (inc high)) :unique unique)\n    :when (= (+ a b) (+ b c d) (+ d e f) (+ f g))] [a b c d e f g]))\n"
                }
            ],
            [
                {
                    "language": "AppleScript",
                    "solution": "use framework \"Foundation\" -- for basic NSArray sort\n\non run\n    unlines({\"rings(true, enumFromTo(1, 7))\\n\", \u00ac\n        map(show, (rings(true, enumFromTo(1, 7)))), \u00ac\n        \"\\nrings(true, enumFromTo(3, 9))\\n\", \u00ac\n        map(show, (rings(true, enumFromTo(3, 9)))), \u00ac\n        \"\\nlength(rings(false, enumFromTo(0, 9)))\\n\", \u00ac\n        show(|length|(rings(false, enumFromTo(0, 9))))})\nend run\n\n-- RINGS -----------------------------------------------------------------------\n\n-- rings :: noRepeatedDigits -> DigitList -> Lists of solutions\n-- rings :: Bool -> [Int] -> [[Int]]\non rings(u, digits)\n    set ds to reverse_(sort(digits))\n    set h to head(ds)\n\n    -- QUEEN -------------------------------------------------------------------\n    script queen\n        on |\u03bb|(q)\n            script\n                on |\u03bb|(x)\n                    x + q \u2264 h\n                end |\u03bb|\n            end script\n            set ts to filter(result, ds)\n            if u then\n                set bs to delete_(q, ts)\n            else\n                set bs to ds\n            end if\n\n            -- LEFT BISHOP and its ROOK-----------------------------------------\n            script leftBishop\n                on |\u03bb|(lb)\n                    set lRook to lb + q\n                    if lRook > h then\n                        {}\n                    else\n                        if u then\n                            set rbs to difference(ts, {q, lb, lRook})\n                        else\n                            set rbs to ds\n                        end if\n\n                        -- RIGHT BISHOP and its ROOK ---------------------------\n                        script rightBishop\n                            on |\u03bb|(rb)\n                                set rRook to rb + q\n                                if (rRook > h) or (u and (rRook = lb)) then\n                                    {}\n                                else\n                                    set rookDelta to lRook - rRook\n                                    if u then\n                                        set ks to difference(ds, \u00ac\n                                            {q, lb, rb, rRook, lRook})\n                                    else\n                                        set ks to ds\n                                    end if\n\n                                    -- KNIGHTS LEFT AND RIGHT ------------------\n                                    script knights\n                                        on |\u03bb|(k)\n                                            set k2 to k + rookDelta\n\n                                            if elem(k2, ks) and ((not u) or \u00ac\n                                                notElem(k2, \u00ac\n                                                    {lRook, k, lb, q, rb, rRook})) then\n                                                {{lRook, k, lb, q, rb, k2, rRook}}\n                                            else\n                                                {}\n                                            end if\n                                        end |\u03bb|\n                                    end script\n\n                                    concatMap(knights, ks)\n                                end if\n                            end |\u03bb|\n                        end script\n\n                        concatMap(rightBishop, rbs)\n                    end if\n                end |\u03bb|\n            end script\n\n            concatMap(leftBishop, bs)\n        end |\u03bb|\n    end script\n\n    concatMap(queen, ds)\nend rings\n\n-- GENERIC FUNCTIONS -----------------------------------------------------------\n\n-- concatMap :: (a -> [b]) -> [a] -> [b]\non concatMap(f, xs)\n    set lst to {}\n    set lng to length of xs\n    tell mReturn(f)\n        repeat with i from 1 to lng\n            set lst to (lst & |\u03bb|(contents of item i of xs, i, xs))\n        end repeat\n    end tell\n    return lst\nend concatMap\n\n-- delete :: Eq a => a -> [a] -> [a]\non delete_(x, xs)\n    set mbIndex to elemIndex(x, xs)\n    set lng to length of xs\n\n    if mbIndex is not missing value then\n        if lng > 1 then\n            if mbIndex = 1 then\n                items 2 thru -1 of xs\n            else if mbIndex = lng then\n                items 1 thru -2 of xs\n            else\n                tell xs to items 1 thru (mbIndex - 1) & \u00ac\n                    items (mbIndex + 1) thru -1\n            end if\n        else\n            {}\n        end if\n    else\n        xs\n    end if\nend delete_\n\n-- difference :: [a] -> [a] -> [a]\non difference(xs, ys)\n    script mf\n        on except(a, y)\n            if a contains y then\n                my delete_(y, a)\n            else\n                a\n            end if\n        end except\n    end script\n\n    foldl(except of mf, xs, ys)\nend difference\n\n-- elem :: Eq a => a -> [a] -> Bool\non elem(x, xs)\n    xs contains x\nend elem\n\n-- elemIndex :: a -> [a] -> Maybe Int\non elemIndex(x, xs)\n    set lng to length of xs\n    repeat with i from 1 to lng\n        if x = (item i of xs) then return i\n    end repeat\n    return missing value\nend elemIndex\n\n-- enumFromTo :: Int -> Int -> [Int]\non enumFromTo(m, n)\n    if n < m then\n        set d to -1\n    else\n        set d to 1\n    end if\n    set lst to {}\n    repeat with i from m to n by d\n        set end of lst to i\n    end repeat\n    return lst\nend enumFromTo\n\n-- filter :: (a -> Bool) -> [a] -> [a]\non filter(f, xs)\n    tell mReturn(f)\n        set lst to {}\n        set lng to length of xs\n        repeat with i from 1 to lng\n            set v to item i of xs\n            if |\u03bb|(v, i, xs) then set end of lst to v\n        end repeat\n        return lst\n    end tell\nend filter\n\n-- foldl :: (a -> b -> a) -> a -> [b] -> a\non foldl(f, startValue, xs)\n    tell mReturn(f)\n        set v to startValue\n        set lng to length of xs\n        repeat with i from 1 to lng\n            set v to |\u03bb|(v, item i of xs, i, xs)\n        end repeat\n        return v\n    end tell\nend foldl\n\n-- head :: [a] -> a\non head(xs)\n    if length of xs > 0 then\n        item 1 of xs\n    else\n        missing value\n    end if\nend head\n\n-- intercalate :: Text -> [Text] -> Text\non intercalate(strText, lstText)\n    set {dlm, my text item delimiters} to {my text item delimiters, strText}\n    set strJoined to lstText as text\n    set my text item delimiters to dlm\n    return strJoined\nend intercalate\n\n-- length :: [a] -> Int\non |length|(xs)\n    length of xs\nend |length|\n\n-- map :: (a -> b) -> [a] -> [b]\non map(f, xs)\n    tell mReturn(f)\n        set lng to length of xs\n        set lst to {}\n        repeat with i from 1 to lng\n            set end of lst to |\u03bb|(item i of xs, i, xs)\n        end repeat\n        return lst\n    end tell\nend map\n\n-- Lift 2nd class handler function into 1st class script wrapper\n-- mReturn :: Handler -> Script\non mReturn(f)\n    if class of f is script then\n        f\n    else\n        script\n            property |\u03bb| : f\n        end script\n    end if\nend mReturn\n\n-- notElem :: Eq a => a -> [a] -> Bool\non notElem(x, xs)\n    xs does not contain x\nend notElem\n\n-- reverse_ :: [a] -> [a]\non |reverse|:xs\n    if class of xs is text then\n        (reverse of characters of xs) as text\n    else\n        reverse of xs\n    end if\nend |reverse|:\n\n-- show :: a -> String\non show(e)\n    set c to class of e\n    if c = list then\n        script serialized\n            on |\u03bb|(v)\n                show(v)\n            end |\u03bb|\n        end script\n\n        \"[\" & intercalate(\", \", map(serialized, e)) & \"]\"\n    else if c = record then\n        script showField\n            on |\u03bb|(kv)\n                set {k, ev} to kv\n                \"\\\"\" & k & \"\\\":\" & show(ev)\n            end |\u03bb|\n        end script\n\n        \"{\" & intercalate(\", \", \u00ac\n            map(showField, zip(allKeys(e), allValues(e)))) & \"}\"\n    else if c = date then\n        \"\\\"\" & iso8601Z(e) & \"\\\"\"\n    else if c = text then\n        \"\\\"\" & e & \"\\\"\"\n    else if (c = integer or c = real) then\n        e as text\n    else if c = class then\n        \"null\"\n    else\n        try\n            e as text\n        on error\n            (\"\u00ab\" & c as text) & \"\u00bb\"\n        end try\n    end if\nend show\n\n-- sort :: [a] -> [a]\non sort(xs)\n    ((current application's NSArray's arrayWithArray:xs)'s \u00ac\n        sortedArrayUsingSelector:\"compare:\") as list\nend sort\n\n-- unlines :: [String] -> String\non unlines(xs)\n    intercalate(linefeed, xs)\nend unlines\n"
                },
                {
                    "language": "Zig",
                    "solution": "fn isUnique(allocator: Allocator, a: usize, b: usize, c: usize, d: usize, e: usize, f: usize, g: usize) !bool {\n    var data = std.AutoArrayHashMap(usize, void).init(allocator);\n    defer data.deinit();\n    try data.put(a, {});\n    try data.put(b, {});\n    try data.put(c, {});\n    try data.put(d, {});\n    try data.put(e, {});\n    try data.put(f, {});\n    try data.put(g, {});\n    return data.count() == 7;\n}\n"
                }
            ],
            [
                {
                    "language": "Koka",
                    "solution": "fun is_unique(a: int, b: int, c: int, d: int, e: int, f: int, g: int)\n  a != b && a != c && a != d && a != e && a != f && a != g &&\n  b != c && b != d && b != e && b != f && b != g &&\n  c != d && c != e && c != f && c != g &&\n  d != e && d != f && d != g &&\n  e != f && e != g &&\n  f != g\n\nfun is_solution(a: int, b: int, c: int, d: int, e: int, f: int, g: int)\n  val bcd = b + c + d\n  val ab = a + b\n  if ab != bcd then return False\n  val def = d + e + f\n  if bcd != def then return False\n  val fg = f + g\n  return def == fg\n\nfun four_squares(low: int, high: int, unique:bool=True)\n  var count := 0\n  for(low, high) fn(a)\n    for(low, high) fn(b)\n      for(low, high) fn(c)\n        for(low, high) fn(d)\n          for(low, high) fn(e)\n            for(low, high) fn(f)\n              for(low, high) fn(g)\n                if (!unique || is_unique(a, b, c, d, e, f, g)) && is_solution(a, b, c, d, e, f, g) then\n                  count := count + 1\n                  if unique then\n                    println([a, b, c, d, e, f, g].show)\n                  else\n                    ()\n  val uniquestr = if unique then \"unique\" else \"non-unique\"\n  println(count.show ++ \" \" ++ uniquestr ++ \" solutions in \" ++ low.show ++ \" to \" ++ high.show ++ \" range\\n\")\n\nfun main()\n  four_squares(1, 7)\n  four_squares(3, 9)\n  four_squares(0, 9, False)\n"
                },
                {
                    "language": "Go",
                    "solution": "package main\n\nimport \"fmt\"\n\nfunc main(){\n\tn, c := getCombs(1,7,true)\n\tfmt.Printf(\"%d unique solutions in 1 to 7\\n\",n)\n\tfmt.Println(c)\n\tn, c = getCombs(3,9,true)\n\tfmt.Printf(\"%d unique solutions in 3 to 9\\n\",n)\n\tfmt.Println(c)\n\tn, _ = getCombs(0,9,false)\n\tfmt.Printf(\"%d non-unique solutions in 0 to 9\\n\",n)\n}\n\nfunc getCombs(low,high int,unique bool) (num int,validCombs [][]int){\n\tfor a := low; a <= high; a++ {\n\t\tfor b := low; b <= high; b++ {\n\t\t\tfor c := low; c <= high; c++ {\n\t\t\t\tfor d := low; d <= high; d++ {\n\t\t\t\t\tfor e := low; e <= high; e++ {\n\t\t\t\t\t\tfor f := low; f <= high; f++ {\n\t\t\t\t\t\t\tfor g := low; g <= high; g++ {\n\t\t\t\t\t\t\t\tif validComb(a,b,c,d,e,f,g) {\n\t\t\t\t\t\t\t\t\tif !unique || isUnique(a,b,c,d,e,f,g) {\n\t\t\t\t\t\t\t\t\t\tnum++\n\t\t\t\t\t\t\t\t\t\tvalidCombs = append(validCombs,[]int{a,b,c,d,e,f,g})\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn\n}\nfunc isUnique(a,b,c,d,e,f,g int) (res bool) {\n\tdata := make(map[int]int)\n\tdata[a]++\n\tdata[b]++\n\tdata[c]++\n\tdata[d]++\n\tdata[e]++\n\tdata[f]++\n\tdata[g]++\n\treturn len(data) == 7\n}\nfunc validComb(a,b,c,d,e,f,g int) bool{\n\tsquare1 := a + b\n\tsquare2 := b + c + d\n\tsquare3 := d + e + f\n\tsquare4 := f + g\n\treturn square1 == square2 && square2 == square3 && square3 == square4\n}\n"
                }
            ]
        ]
    },
    {
        "task_name": "9-billion-names-of-God-the-integer",
        "task_description": "This task is a variation of the [[wp:The Nine Billion Names of God#Plot_summary|short story by Arthur C. Clarke]].\n \n(Solvers should be aware of the consequences of completing this task.)\n\nIn detail, to specify what is meant by a &nbsp; \u201cname\u201d:\n:The integer 1 has 1 name  &nbsp; &nbsp;  \u201c1\u201d.\n:The integer 2 has 2 names &nbsp; \u201c1+1\u201d, &nbsp; and &nbsp; \u201c2\u201d.\n:The integer 3 has 3 names &nbsp; \u201c1+1+1\u201d, &nbsp; \u201c2+1\u201d, &nbsp; and &nbsp; \u201c3\u201d.\n:The integer 4 has 5 names &nbsp; \u201c1+1+1+1\u201d, &nbsp; \u201c2+1+1\u201d, &nbsp; \u201c2+2\u201d, &nbsp; \u201c3+1\u201d, &nbsp; \u201c4\u201d.\n:The integer 5 has 7 names &nbsp; \u201c1+1+1+1+1\u201d, &nbsp; \u201c2+1+1+1\u201d, &nbsp; \u201c2+2+1\u201d, &nbsp; \u201c3+1+1\u201d, &nbsp; \u201c3+2\u201d, &nbsp; \u201c4+1\u201d, &nbsp; \u201c5\u201d.\n\n\n;Task\nDisplay the first 25 rows of a number triangle which begins:\n<pre>\n                                      1\n                                    1   1\n                                  1   1   1 \n                                1   2   1   1\n                              1   2   2   1   1\n                            1   3   3   2   1   1\n</pre>\n\nWhere row &nbsp; <math>n</math> &nbsp; corresponds to integer &nbsp; <math>n</math>, &nbsp; and each column &nbsp; <math>C</math> &nbsp; in row &nbsp; <math>m</math> &nbsp; from left to right corresponds to the number of names beginning with &nbsp; <math>C</math>.\n\nA function &nbsp; <math>G(n)</math> &nbsp; should return the sum of the &nbsp; <math>n</math>-th &nbsp; row. \n\nDemonstrate this function by displaying: &nbsp; <math>G(23)</math>, &nbsp; <math>G(123)</math>, &nbsp; <math>G(1234)</math>, &nbsp; and &nbsp; <math>G(12345)</math>.  \n\nOptionally note that the sum of the &nbsp; <math>n</math>-th &nbsp; row &nbsp; <math>P(n)</math> &nbsp; is the &nbsp;  [http://mathworld.wolfram.com/PartitionFunctionP.html &nbsp; integer partition function]. \n\nDemonstrate this is equivalent to &nbsp; <math>G(n)</math> &nbsp; by displaying: &nbsp; <math>P(23)</math>, &nbsp; <math>P(123)</math>, &nbsp; <math>P(1234)</math>, &nbsp; and &nbsp; <math>P(12345)</math>.\n\n\n;Extra credit\n\nIf your environment is able, plot &nbsp; <math>P(n)</math> &nbsp; against &nbsp; <math>n</math> &nbsp; for &nbsp; <math>n=1\\ldots 999</math>.\n\n;Related tasks\n* [[Partition function P]]\n<br><br>\n",
        "solution_pairs": [
            [
                {
                    "language": "Phix",
                    "solution": "(phixonline)-->\n <span style=\"color: #000080;font-style:italic;\">-- demo\\rosetta\\9billionnames.exw</span>\n <span style=\"color: #008080;\">with</span> <span style=\"color: #008080;\">javascript_semantics</span>\n <span style=\"color: #004080;\">sequence</span> <span style=\"color: #000000;\">cache</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #0000FF;\">{{</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">}}</span>\n <span style=\"color: #008080;\">function</span> <span style=\"color: #000000;\">cumu</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #004080;\">integer</span> <span style=\"color: #000000;\">n</span><span style=\"color: #0000FF;\">)</span>\n <span style=\"color: #004080;\">sequence</span> <span style=\"color: #000000;\">r</span>\n     <span style=\"color: #008080;\">for</span> <span style=\"color: #000000;\">l</span><span style=\"color: #0000FF;\">=</span><span style=\"color: #7060A8;\">length</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">cache</span><span style=\"color: #0000FF;\">)</span> <span style=\"color: #008080;\">to</span> <span style=\"color: #000000;\">n</span> <span style=\"color: #008080;\">do</span>\n         <span style=\"color: #000000;\">r</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #0000FF;\">{</span><span style=\"color: #000000;\">0</span><span style=\"color: #0000FF;\">}</span>\n         <span style=\"color: #008080;\">for</span> <span style=\"color: #000000;\">x</span><span style=\"color: #0000FF;\">=</span><span style=\"color: #000000;\">1</span> <span style=\"color: #008080;\">to</span> <span style=\"color: #000000;\">l</span> <span style=\"color: #008080;\">do</span>\n             <span style=\"color: #000000;\">r</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">append</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">r</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">r</span><span style=\"color: #0000FF;\">[-</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">]+</span><span style=\"color: #000000;\">cache</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">l</span><span style=\"color: #0000FF;\">-</span><span style=\"color: #000000;\">x</span><span style=\"color: #0000FF;\">+</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">][</span><span style=\"color: #7060A8;\">min</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">x</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">l</span><span style=\"color: #0000FF;\">-</span><span style=\"color: #000000;\">x</span><span style=\"color: #0000FF;\">)+</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">])</span>\n         <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">for</span>\n         <span style=\"color: #000000;\">cache</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">append</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">cache</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">r</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">for</span>\n     <span style=\"color: #008080;\">return</span> <span style=\"color: #000000;\">cache</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">n</span><span style=\"color: #0000FF;\">]</span>\n <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">function</span>\n\n <span style=\"color: #008080;\">function</span> <span style=\"color: #000000;\">row</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #004080;\">integer</span> <span style=\"color: #000000;\">n</span><span style=\"color: #0000FF;\">)</span>\n <span style=\"color: #004080;\">sequence</span> <span style=\"color: #000000;\">r</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #000000;\">cumu</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">n</span><span style=\"color: #0000FF;\">+</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">)</span>\n <span style=\"color: #004080;\">sequence</span> <span style=\"color: #000000;\">res</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">repeat</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">0</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">n</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #008080;\">for</span> <span style=\"color: #000000;\">i</span><span style=\"color: #0000FF;\">=</span><span style=\"color: #000000;\">1</span> <span style=\"color: #008080;\">to</span> <span style=\"color: #000000;\">n</span> <span style=\"color: #008080;\">do</span>\n         <span style=\"color: #000000;\">res</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">i</span><span style=\"color: #0000FF;\">]</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #000000;\">r</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">i</span><span style=\"color: #0000FF;\">+</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">]-</span><span style=\"color: #000000;\">r</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">i</span><span style=\"color: #0000FF;\">]</span>\n     <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">for</span>\n     <span style=\"color: #008080;\">return</span> <span style=\"color: #000000;\">res</span>\n <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">function</span>\n\n <span style=\"color: #008080;\">for</span> <span style=\"color: #000000;\">i</span><span style=\"color: #0000FF;\">=</span><span style=\"color: #000000;\">1</span> <span style=\"color: #008080;\">to</span> <span style=\"color: #000000;\">25</span> <span style=\"color: #008080;\">do</span>\n     <span style=\"color: #7060A8;\">puts</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #7060A8;\">repeat</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #008000;\">' '</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">50</span><span style=\"color: #0000FF;\">-</span><span style=\"color: #000000;\">2</span><span style=\"color: #0000FF;\">*</span><span style=\"color: #000000;\">i</span><span style=\"color: #0000FF;\">))</span>\n     <span style=\"color: #004080;\">sequence</span> <span style=\"color: #000000;\">r</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #000000;\">row</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">i</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #008080;\">for</span> <span style=\"color: #000000;\">j</span><span style=\"color: #0000FF;\">=</span><span style=\"color: #000000;\">1</span> <span style=\"color: #008080;\">to</span> <span style=\"color: #000000;\">i</span> <span style=\"color: #008080;\">do</span>\n         <span style=\"color: #7060A8;\">printf</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #008000;\">\"%4d\"</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">r</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">j</span><span style=\"color: #0000FF;\">])</span>\n     <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">for</span>\n     <span style=\"color: #7060A8;\">puts</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #008000;\">\"\\n\"</span><span style=\"color: #0000FF;\">)</span>\n <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">for</span>\n<!--\n"
                },
                {
                    "language": "Kotlin",
                    "solution": "import java.lang.Math.min\nimport java.math.BigInteger\nimport java.util.ArrayList\nimport java.util.Arrays.asList\n\nfun namesOfGod(n: Int): List<BigInteger> {\n    val cache = ArrayList<List<BigInteger>>()\n    cache.add(asList(BigInteger.ONE))\n\n    (cache.size..n).forEach { l ->\n        val r = ArrayList<BigInteger>()\n        r.add(BigInteger.ZERO)\n\n        (1..l).forEach { x ->\n            r.add(r[r.size - 1] + cache[l - x][min(x, l - x)])\n        }\n        cache.add(r)\n    }\n    return cache[n]\n}\n\nfun row(n: Int) = namesOfGod(n).let { r -> (0 until n).map { r[it + 1] - r[it] } }\n\nfun main(args: Array<String>) {\n    println(\"Rows:\")\n    (1..25).forEach {\n        System.out.printf(\"%2d: %s%n\", it, row(it))\n    }\n\n    println(\"\\nSums:\")\n    intArrayOf(23, 123, 1234, 1234).forEach {\n        val c = namesOfGod(it)\n        System.out.printf(\"%s %s%n\", it, c[c.size - 1])\n    }\n}\n"
                }
            ],
            [
                {
                    "language": "GAP",
                    "solution": "PrintArray(List([1 .. 25], n -> List([1 .. n], k -> NrPartitions(n, k))));\n\n[ [    1 ],\n  [    1,    1 ],\n  [    1,    1,    1 ],\n  [    1,    2,    1,    1 ],\n  [    1,    2,    2,    1,    1 ],\n  [    1,    3,    3,    2,    1,    1 ],\n  [    1,    3,    4,    3,    2,    1,    1 ],\n  [    1,    4,    5,    5,    3,    2,    1,    1 ],\n  [    1,    4,    7,    6,    5,    3,    2,    1,    1 ],\n  [    1,    5,    8,    9,    7,    5,    3,    2,    1,    1 ],\n  [    1,    5,   10,   11,   10,    7,    5,    3,    2,    1,    1 ],\n  [    1,    6,   12,   15,   13,   11,    7,    5,    3,    2,    1,    1 ],\n  [    1,    6,   14,   18,   18,   14,   11,    7,    5,    3,    2,    1,    1 ],\n  [    1,    7,   16,   23,   23,   20,   15,   11,    7,    5,    3,    2,    1,    1 ],\n  [    1,    7,   19,   27,   30,   26,   21,   15,   11,    7,    5,    3,    2,    1,    1 ],\n  [    1,    8,   21,   34,   37,   35,   28,   22,   15,   11,    7,    5,    3,    2,    1,    1 ],\n  [    1,    8,   24,   39,   47,   44,   38,   29,   22,   15,   11,    7,    5,    3,    2,    1,    1 ],\n  [    1,    9,   27,   47,   57,   58,   49,   40,   30,   22,   15,   11,    7,    5,    3,    2,    1,    1 ],\n  [    1,    9,   30,   54,   70,   71,   65,   52,   41,   30,   22,   15,   11,    7,    5,    3,    2,    1,    1 ],\n  [    1,   10,   33,   64,   84,   90,   82,   70,   54,   42,   30,   22,   15,   11,    7,    5,    3,    2,    1,    1 ],\n  [    1,   10,   37,   72,  101,  110,  105,   89,   73,   55,   42,   30,   22,   15,   11,    7,    5,    3,    2,    1,    1 ],\n  [    1,   11,   40,   84,  119,  136,  131,  116,   94,   75,   56,   42,   30,   22,   15,   11,    7,    5,    3,    2,    1,    1 ],\n  [    1,   11,   44,   94,  141,  163,  164,  146,  123,   97,   76,   56,   42,   30,   22,   15,   11,    7,    5,    3,    2,    1,    1 ],\n  [    1,   12,   48,  108,  164,  199,  201,  186,  157,  128,   99,   77,   56,   42,   30,   22,   15,   11,    7,    5,    3,    2,    1,    1 ],\n  [    1,   12,   52,  120,  192,  235,  248,  230,  201,  164,  131,  100,   77,   56,   42,   30,   22,   15,   11,    7,    5,    3,    2,    1,    1 ] ]\n\n\nList([23, 123, 1234, 12345], NrPartitions);\n\n[ 1255, 2552338241, 156978797223733228787865722354959930,\n  69420357953926116819562977205209384460667673094671463620270321700806074195845953959951425306140971942519870679768681736 ]\n"
                },
                {
                    "language": "Crystal",
                    "solution": "def g(n, g)\n  return 1 unless 1 < g && g < n-1\n  (2..g).reduce(1){ |res, q| res + (q > n-g ? 0 : g(n-g, q)) }\nend\n\n(1..25).each { |n| puts (1..n).map { |g| \"%4s\" % g(n, g) }.join }\n"
                }
            ],
            [
                {
                    "language": "Scala",
                    "solution": "object Main {\n\n  // This is a special class for memoization\n  case class Memo[A,B](f: A => B) extends (A => B) {\n\t  private val cache = Map.empty[A, B]\n\t  def apply(x: A) = cache getOrElseUpdate (x, f(x))\n  }\n\n  // Naive, but memoized solution\n  lazy val namesStartingMemo : Memo[Tuple2[Int, Int], BigInt] = Memo {\n    case (1, 1) => 1\n    case (a, n) =>\n\t    if (a > n/2) namesStartingMemo(a - 1, n - 1)\n\t    else if (n < a) 0\n\t    else if (n == a) 1\n\t    else (1 to a).map(i => namesStartingMemo(i, n - a)).sum\n\n  }\n\n  def partitions(n: Int) = (1 to n).map(namesStartingMemo(_, n)).sum\n\n  // main method\n  def main(args: Array[String]): Unit = {\n    for (i <- 1 to 25) {\n    \tfor (j <- 1 to i) {\n\t      print(namesStartingMemo(j, i));\n\t      print(' ');\n\t    }\n    \tprintln()\n    }\n    println(partitions(23))\n    println(partitions(123))\n    println(partitions(1234))\n    println(partitions(12345))\n  }\n}\n"
                },
                {
                    "language": "Groovy",
                    "solution": "def partitions(c)\n{\n\n    def p=[];\n    int k = 0;\n     p[k] = c;\n    int counter=0;\n    def counts=[];\n\tfor (i in 0..c-1)\n\t{counts[i]=0;}\n    while (true)\n    {\n\n        counter++;\n\t\tcounts[p[0]-1]=counts[p[0]-1]+1;\n\t\tint rem_val = 0;\n        while (k >= 0 && p[k] == 1)\n        { rem_val += p[k];\n            k--;}\n        if (k < 0)  { break;}\n        p[k]--;\n        rem_val++;\n        while (rem_val > p[k])\n        {\n            p[k+1] = p[k];\n            rem_val = rem_val - p[k];\n            k++;\n        }\n        p[k+1] = rem_val;\n        k++;\n    }\n\tprintln counts;\n\treturn counter;\n}\n\n\nstatic void  main(String[] args)\n{\nfor( i in 1..25 )\n{partitions(i);}\n}\n"
                }
            ],
            [
                {
                    "language": "Sidef",
                    "solution": "var cache = [[1]]\n\nfunc cumu (n) {\n    for l (cache.len .. n) {\n        var r = [0]\n        for i (1..l) {\n            r << (r[-1] + cache[l-i][min(i, l-i)])\n        }\n        cache << r\n    }\n    cache[n]\n}\n\nfunc row (n) {\n    var r = cumu(n)\n    n.of {|i| r[i+1] - r[i] }\n}\n\nsay \"rows:\"\nfor i (1..15) {\n    \"%2s: %s\\n\".printf(i, row(i))\n}\n\nsay \"\\nsums:\"\n\nfor i in [23, 123, 1234, 12345] {\n    \"%2s : %4s\\n\".printf(i, cumu(i)[-1])\n}\n"
                },
                {
                    "language": "FreeBASIC",
                    "solution": "' version 03-11-2016\n' compile with: fbc -s console\n\n#Include Once \"gmp.bi\"\n\nSub partitions(max As ULong, p() As MpZ_ptr)\n    ' based on Numericana code example\n    Dim As ULong a, b, i, k\n    Dim As Long j\n\n    Dim As Mpz_ptr s = Allocate(Len(__mpz_struct)) : Mpz_init(s)\n\n    Mpz_set_ui(p(0), 1)\n\n    For i = 1 To max\n        j = 1 : k = 1 : b = 2 : a = 5\n        While j > 0\n            ' j = i - (3*k*k+k) \\ 2\n            j = i - b : b = b + a : a = a + 3\n            If j >= 0 Then\n                If k And 1 Then Mpz_add(s, s, p(j)) Else Mpz_sub(s, s, p(j))\n            End If\n            j = j + k\n            If j >= 0 Then\n                If k And 1 Then Mpz_add(s, s, p(j)) Else Mpz_sub(s, s, p(j))\n            End If\n            k = k +1\n        Wend\n        Mpz_swap(p(i), s)\n    Next\n\n    Mpz_clear(s)\n\nEnd Sub\n\n' ------=< MAIN >=------\n\nDim As ULong n, k, max = 25              ' with max > 416 the numbers become\nDim As ULongInt p(max, max)              ' to big for a 64bit unsigned integer\n\np(1, 1) = 1                              ' fill the first 3 rows\np(2, 1) = 1 : p(2, 2) = 1\np(3, 1) = 1 : p(3, 2) = 1 : p(3, 3) = 1\n\nFor n = 4 To max                         ' fill the rest\n    For k = 1 To n\n        If k * 2 > n  Then\n           p(n,k)= p(n-1,k-1)\n        Else\n           p(n,k) = p(n-1,k-1) + p(n-k, k)\n        End If\n    Next\nNext\n\nFor n = 1 To 25                          ' print the triangle\n    Print Space((max - n) * 2);\n    For k = 1 To n\n        Print Using \"####\"; p(n, k);\n    Next\n    Print\nNext\nPrint : print\n\n                                         ' calculate the integer partition\nmax = 123456                             ' 1234567 takes about ten minutes\nDim As ZString Ptr ans\n\nReDim big_p(max) As Mpz_ptr\nFor n = 0 To max\n    big_p(n) = Allocate(Len(__mpz_struct)) : Mpz_init(big_p(n))\nNext\n\npartitions(max, big_p())\n\nFor n = 1 To Len(Str(max))\n    k = Val(Left(Str(max), n))\n    ans = Mpz_get_str (0, 10, big_p(k))\n    Print Space(10 - n); \"P(\"; Str(k); \") = \"; *ans\nNext\n\nFor n = 0 To max\n    Mpz_clear(big_p(n))\nNext\n\n' empty keyboard buffer\nWhile InKey <> \"\" : Wend\nPrint : Print \"hit any key to end program\"\nSleep\nEnd\n"
                }
            ],
            [
                {
                    "language": "Picat",
                    "solution": "pc(N) = pc(1,N).\ntable\npc(_,0) = 1.\npc(1,1) = 1.\npc(K,M) = cond(M < K, 0, pc(K, M-K) + pc(K + 1,M)).\n"
                },
                {
                    "language": "Phixmonti",
                    "solution": "/# Rosetta Code problem: http://rosettacode.org/wiki/9_billion_names_of_God_the_integer\nby Galileo, 05/2022 #/\n\ninclude ..\\Utilitys.pmt\n\ncls\n\ndef nine_billion_names >ps\n    0 ( tps dup ) dim\n\n    1 ( 1 1 ) sset\n\n    ( 2 tps ) for var i\n        ( 1 i ) for var j\n            ( i 1 - j 1 - ) sget >ps ( i j - j ) sget ps> + ( i j ) sset\n        endfor\n    endfor\n\n    ( 1 tps ) for var i\n        tps 2 * i 2 * 2 - - >ps\n        ( 1 i ) for var j\n            ( i j ) sget tostr len nip 1 swap - tps j 4 * + + i locate ( i j ) sget print\n        endfor\n        nl\n        ps> drop\n    endfor\n    ps> drop drop\nenddef\n\n20 nine_billion_names\n"
                }
            ]
        ]
    },
    {
        "task_name": "99-bottles-of-beer",
        "task_description": ";Task:\nDisplay the complete lyrics for the song: &nbsp; &nbsp; '''99 Bottles of Beer on the Wall'''. \n\n\n;The beer song:\nThe lyrics follow this form:\n\n<blockquote>\n:::              99 bottles of beer on the wall<br/>\n:::              99 bottles of beer<br/>\n:::              Take one down, pass it around<br/>\n:::              98 bottles of beer on the wall<br/><br/>\n    \n:::              98 bottles of beer on the wall<br/>\n:::              98 bottles of beer<br/>\n:::              Take one down, pass it around<br/>\n:::              97 bottles of beer on the wall\n</blockquote>\n\n... and so on, until reaching &nbsp; '''0''' &nbsp; &nbsp; (zero).\n\nGrammatical support for &nbsp; ''1 bottle of beer'' &nbsp; is optional. \n\nAs with any puzzle, try to do it in as creative/concise/comical a way \nas possible (simple, obvious solutions allowed, too).\n\n\n{{Template:Strings}}\n\n\n;See also: \n* &nbsp; http://99-bottles-of-beer.net/\n* &nbsp; [[:Category:99_Bottles_of_Beer]]\n* &nbsp; [[:Category:Programming language families]]\n* &nbsp; [https://en.wikipedia.org/wiki/99_Bottles_of_Beer Wikipedia 99 bottles of beer]\n<br><br>\n\n",
        "solution_pairs": [
            [
                {
                    "language": "Algae",
                    "solution": "# 99 Bottles of Beer on the Wall\n# in Algae\n# bottles.A\nfor (i in 99:1:1) {\n    if (i != 1) {\n        printf(\"%d bottles of beer on the wall\\n\";i);\n        printf(\"%d bottles of beer...\\n\";i);\n        printf(\"you take on down and pass it around...\\n\");\n        if ( i == 2) {\n            printf(\"%d bottles of beer on the wall\\n\\n\";i-1);\n        else\n            printf(\"%d bottles of beer on the wall\\n\\n\";i-1);\n        }\n    else\n       printf(\"1 bottle of beer on the wall\\n\");\n       printf(\"1 bottle of beer...\\n\");\n       printf(\"you take on down and pass it around..\\n\");\n       printf(\"no more bottles of beer on the wall!\\n\\n\");\n    }\n}\n"
                },
                {
                    "language": "Perl",
                    "solution": "for $n (reverse(0..99))\n{\n    $bottles = sprintf(\"%s bottle%s of beer on the wall\\n\",(($n==0)?\"No\":$n), (($n==1)?\"\":\"s\"));\n    print( (($n==99)?\"\":\"$bottles\\n\") .\n\t   (($n==0)?\"\":(substr(${bottles}x2,0,-12) . \"\\nTake one down, pass it around\\n\")) );\n}\n"
                }
            ],
            [
                {
                    "language": "Lasso",
                    "solution": "// this example adds an \"s\" to bottle until there is only 1 bottle left on the wall\n\nlocal(s = 's')\nwith n in 99 to 1 by -1 do {^\n    #n + ' bottle' + #s + ' of beer on the wall,<br>'\n    #n + ' bottle' + #s + ' of beer,<br>'\n    #n = #n - 1\n    #s = (#n != 1 ? 's' | '')\n    'Take one down, pass it around,<br>'\n    #n + ' bottle' + #s + ' of beer on the wall.<br><br>'\n^}\n"
                },
                {
                    "language": "ActionScript",
                    "solution": "for(var numBottles:uint = 99; numBottles > 0; numBottles--)\n{\n\ttrace(numBottles, \" bottles of beer on the wall\");\n\ttrace(numBottles, \" bottles of beer\");\n\ttrace(\"Take one down, pass it around\");\n\ttrace(numBottles - 1, \" bottles of beer on the wall\\n\");\t\t\n}\n"
                }
            ],
            [
                {
                    "language": "AmigaE",
                    "solution": "PROC main()\n  DEF t: PTR TO CHAR,\n      s: PTR TO CHAR,\n      u: PTR TO CHAR, i, x\n  t := 'Take one down, pass it around\\n'\n  s := '\\d bottle\\s of beer\\s\\n'\n  u := ' on the wall'\n  FOR i := 99 TO 0 STEP -1\n    ForAll({x}, [u, NIL], `WriteF(s, i, IF i <> 1 THEN 's' ELSE NIL,\n                           x))\n    IF i > 0 THEN WriteF(t)\n  ENDFOR\nENDPROC\n"
                },
                {
                    "language": "MontiLang",
                    "solution": "99 VAR i .\n\nWHILE i\n    i TOSTR OUT . | bottles of beer on the wall| PRINT .\n    i TOSTR OUT . | bottles of beer| PRINT .\n    |Take one down, pass it around| PRINT .\n\n    i 1 - VAR i .\nENDWHILE\n"
                }
            ],
            [
                {
                    "language": "Bc",
                    "solution": "i = 99;\nwhile ( 1 ) {\n     print i , \" bottles of beer on the wall\\n\";\n     print i , \" bottles of beer\\nTake one down, pass it around\\n\";\n     if (i == 2) {\n          break\n     }\n     print --i , \" bottles of beer on the wall\\n\";\n}\n\nprint --i , \" bottle of beer on the wall\\n\";\nprint   i , \" bottle of beer on the wall\\n\";\nprint   i , \" bottle of beer\\nTake it down, pass it around\\nno more bottles of beer on the wall\\n\";\nquit\n"
                },
                {
                    "language": "Make",
                    "solution": "PRED=`expr $* - 1`\n\n1-bottles: 1-beer pass\n\t@echo \"No more bottles of beer on the wall\"\n\n%-bottles: %-beer pass\n\t@echo \"$(PRED) bottles of beer on the wall\\n\"\n\t@-$(MAKE) $(PRED)-bottles\n\n1-beer:\n\t@echo \"One bottle of beer on the wall, One bottle of beer\"\n\n%-beer:\n\t@echo \"$* bottles of beer on the wall, $* bottles of beer\"\n\npass:\n\t@echo \"Take one down and pass it around,\"\n"
                }
            ],
            [
                {
                    "language": "Gnuplot",
                    "solution": "if (!exists(\"bottles\")) bottles = 99\nprint sprintf(\"%i bottles of beer on the wall\", bottles)\nprint sprintf(\"%i bottles of beer\", bottles)\nprint \"Take one down, pass it around\"\nbottles = bottles - 1\nprint sprintf(\"%i bottles of beer on the wall\", bottles)\nprint \"\"\nif (bottles > 0) reread\n"
                },
                {
                    "language": "TIScript",
                    "solution": "var beer = 99;\nwhile (beer > 0)\n{\n stdout.printf( \"%d bottles of beer on the wall\\n\", beer);\n stdout.printf( \"%d bottles of beer\\n\", beer);\n stdout.println( \"Take one down, pass it around\" );\n stdout.printf( \"%d bottles of beer on the wall\\n\", --beer );\n}\n"
                }
            ]
        ]
    },
    {
        "task_name": "A+B",
        "task_description": "<big>'''A+B'''</big> &nbsp; \u2500\u2500\u2500 a classic problem in programming contests, &nbsp; it's given so contestants can gain familiarity with the online judging system being used.\n\n\n;Task:\nGiven two integers, &nbsp; '''A''' and '''B'''. \n\nTheir sum needs to be calculated.\n\n\n;Input data:\nTwo integers are written in the input stream, separated by space(s):\n: <big><math>(-1000 \\le A,B \\le +1000)</math></big>\n\n\n;Output data:\nThe required output is one integer: &nbsp; the sum of '''A''' and '''B'''.\n\n\n;Example:\n::{|class=\"standard\"\n ! input &nbsp;\n ! output &nbsp;\n |-\n |<tt> 2 2 </tt>\n |<tt> 4 </tt>\n |-\n |<tt> 3 2 </tt>\n |<tt> 5 </tt>\n |}\n<br><br>\n\n",
        "solution_pairs": [
            [
                {
                    "language": "ERRE",
                    "solution": "PROGRAM SUM2\n\nBEGIN\n\n  LOOP\n    INPUT(LINE,Q$)\n    EXIT IF Q$=\"\"\n    SP%=INSTR(Q$,\" \")\n    PRINT(VAL(LEFT$(Q$,SP%-1))+VAL(MID$(Q$,SP%+1)))\n  END LOOP\n\nEND PROGRAM\n"
                },
                {
                    "language": "C++",
                    "solution": "// Input file: input.txt\n// Output file: output.txt\n#include <fstream>\nusing namespace std;\nint main()\n{\n   ifstream in(\"input.txt\");\n   ofstream out(\"output.txt\");\n   int a, b;\n   in >> a >> b;\n   out << a + b << endl;\n   return 0;\n}\n"
                }
            ],
            [
                {
                    "language": "XEec",
                    "solution": "i# i# ma h#10 r o# p o$ p\n"
                },
                {
                    "language": "CoffeeScript",
                    "solution": "{ stdin } = process\nsum = ( a, b ) -> a + b\n\ndisplay = ( messages... ) -> console.log messages...\n\nparse = ( input ) ->\n    parseInt x for x in ( x.trim() for x in input.split ' ' ) when x?.length\n\ncheck = ( numbers... ) ->\n    return no for x in numbers when isNaN x\n    return no for x in numbers when not ( -1000 < x < 1000 )\n    yes\n\nprompt = ->\n    display 'Please enter two integers between -1000 and 1000, separated by a space:'\n    stdin.once 'data', ( data ) ->\n        [ a, b ] = parse data\n        if check a, b\n            display \"#{ a } + #{ b } = #{ sum a, b }\"\n        else\n            display \"Invalid input: #{ a }, #{ b }\"\n        do prompt\n        return\n\n# Resume input and set the incoming encoding.\nstdin.resume()\nstdin.setEncoding 'utf8'\n\n# Start the main loop.\ndo prompt\n"
                }
            ],
            [
                {
                    "language": "SQL-PL",
                    "solution": "CREATE OR REPLACE FUNCTION splitadd (instring VARCHAR(255))\n\tRETURNS INTEGER\n\tNO EXTERNAL ACTION\nF1: BEGIN ATOMIC\n\n\tdeclare first INTEGER;\n\tdeclare second INTEGER;\n\t\n\tset first = REGEXP_SUBSTR(instring, '[0-9]+',1,1);\n\tset second = REGEXP_SUBSTR(instring, '[0-9]+',1,2);\n\n\treturn first + second;\nEND\n"
                },
                {
                    "language": "TI-83-BASIC",
                    "solution": ":Prompt A,B\n:Disp A+B\n"
                }
            ],
            [
                {
                    "language": "Order",
                    "solution": "#define ORDER_PP_DEF_1int_is_positive \\\n    ORDER_PP_FN(8fn(8X, 8is_0(8tuple_at_0(8X))))\n\n#define ORDER_PP_DEF_1int_get_unsigned \\\n    ORDER_PP_FN(8fn(8X, 8tuple_at_1(8X)))\n\n#define ORDER_PP_DEF_1int_add_impl \\\n    ORDER_PP_FN(8fn(8A, 8B, 8S, 8int(8S, 8add(8A, 8B))))\n\n#define ORDER_PP_DEF_1int_sub_impl \\\n    ORDER_PP_FN(8fn(8A, 8B, \\\n                    8if(8greater(8A, 8B), \\\n                        8int(0, 8sub(8A, 8B)), \\\n                        8int(1, 8sub(8B, 8A)))))\n\n#define ORDER_PP_DEF_8int_add \\\n    ORDER_PP_FN(8fn(8A, 8B, \\\n                    8cond((8and(1int_is_positive(8A), 1int_is_positive(8B)), \\\n                                1int_add_impl(1int_get_unsigned(8A), 1int_get_unsigned(8B), 0)) \\\n                          (8and(1int_is_positive(8A), 8not(1int_is_positive(8B))), \\\n                                1int_sub_impl(1int_get_unsigned(8A), 1int_get_unsigned(8B))) \\\n                          (8and(8not(1int_is_positive(8A)), 1int_is_positive(8B)), \\\n                                1int_sub_impl(1int_get_unsigned(8B), 1int_get_unsigned(8A))) \\\n                          (8and(8not(1int_is_positive(8A)), 8not(1int_is_positive(8B))), \\\n                                1int_add_impl(1int_get_unsigned(8A), 1int_get_unsigned(8B), 1)))))\n\n#define ORDER_PP_DEF_8int_to_lit \\\n    ORDER_PP_FN(8fn(8X, \\\n                    8if(1int_is_positive(8X), \\\n                        8to_lit(1int_get_unsigned(8X)), \\\n                        8adjacent(8(-), 8to_lit(1int_get_unsigned(8X))))))\n\n#define ORDER_PP_DEF_8int \\\n    ORDER_PP_FN(8fn(8S, 8N, 8pair(8S, 8N)))\n\nORDER_PP(8int_to_lit(8int_add(A, B)))\n"
                },
                {
                    "language": "R",
                    "solution": "sum(scan(\"\", numeric(0), 2))\n"
                }
            ],
            [
                {
                    "language": "V-(Vlang)",
                    "solution": "import os\n\nfn main() {\n    mut a := 0\n    mut b := 0\n\n    text := os.get_raw_line()\n\n    values := text.split(' ')\n\n    a = values[0].int()\n    b = values[1].int()\n\n    println('$a + $b = ${a+b}')\n}\n"
                },
                {
                    "language": "Julia",
                    "solution": "julia> println(parse(Int, readuntil(stdin, ' ')) + parse(Int, readuntil(stdin, '\\n')))\n1 2\n3\n"
                }
            ]
        ]
    },
    {
        "task_name": "Abbreviations-automatic",
        "task_description": "The use of &nbsp; abbreviations &nbsp;  (also sometimes called synonyms, nicknames, AKAs, or aliases) &nbsp;  can be an\n<br>easy way to add flexibility when specifying or using commands, sub\u2500commands, options, etc.\n\n<!--\n(AKA =  also known as)\n!-->\n\nIt would make a list of words easier to maintain &nbsp; (as words are added, changed, and/or deleted) &nbsp; if\nthe minimum abbreviation length of that list could be automatically (programmatically) determined.\n\n\nFor this task, use the list (below) of the days-of-the-week names that are expressed in about a hundred languages &nbsp; (note that there is a blank line in the list).\n<pre style=\"height:45ex\">\nSunday Monday Tuesday Wednesday Thursday Friday Saturday\nSondag Maandag Dinsdag Woensdag Donderdag Vrydag Saterdag\nE_djel\u00eb E_h\u00ebn\u00eb E_mart\u00eb E_m\u00ebrkur\u00eb E_enjte E_premte E_shtun\u00eb\nEhud Segno Maksegno Erob Hamus Arbe Kedame\nAl_Ahad Al_Ithinin Al_Tholatha'a Al_Arbia'a Al_Kamis Al_Gomia'a Al_Sabit\nGuiragui Yergou_shapti Yerek_shapti Tchorek_shapti Hink_shapti Ourpat Shapat\ndomingu llunes martes mi\u00e9rcoles xueves vienres s\u00e1badu\nBazar_g\u00dcn\u00dc Birinci_g\u00dcn \u00c7kinci_g\u00dcn \u00dc\u00e7\u00dcnc\u00dc_g\u00dcn D\u00d6rd\u00dcnc\u00dc_g\u00dcn Bes,inci_g\u00dcn Alt\u00f2nc\u00f2_g\u00dcn\nIgande Astelehen Astearte Asteazken Ostegun Ostiral Larunbat\nRobi_bar Shom_bar Mongal_bar Budhh_bar BRihashpati_bar Shukro_bar Shoni_bar\nNedjelja Ponedeljak Utorak Srijeda Cxetvrtak Petak Subota\nDisul Dilun Dimeurzh Dimerc'her Diriaou Digwener Disadorn\nnedelia ponedelnik vtornik sriada chetvartak petak sabota\nsing_kei_yaht sing_kei_yat sing_kei_yee sing_kei_saam sing_kei_sie sing_kei_ng sing_kei_luk\nDiumenge Dilluns Dimarts Dimecres Dijous Divendres Dissabte\nDzeenkk-eh Dzeehn_kk-ehreh Dzeehn_kk-ehreh_nah_kay_dzeeneh Tah_neesee_dzeehn_neh Deehn_ghee_dzee-neh Tl-oowey_tts-el_dehlee Dzeentt-ahzee\ndy_Sul dy_Lun dy_Meurth dy_Mergher dy_You dy_Gwener dy_Sadorn\nDimanch Lendi Madi M\u00e8kredi Jedi Vandredi Samdi\nnedjelja ponedjeljak utorak srijeda cxetvrtak petak subota\nnede^le ponde^l\u00ed \u00fater\u00ff str^eda c^tvrtek p\u00e1tek sobota\nSondee Mondee Tiisiday Walansedee TOOsedee Feraadee Satadee\ns0ndag mandag tirsdag onsdag torsdag fredag l0rdag\nzondag maandag dinsdag woensdag donderdag vrijdag zaterdag\nDiman^co Lundo Mardo Merkredo ^Ja\u00f9do Vendredo Sabato\np\u00dchap\u00e4ev esmasp\u00e4ev teisip\u00e4ev kolmap\u00e4ev neljap\u00e4ev reede laup\u00e4ev\n\nDiu_prima Diu_sequima Diu_tritima Diu_quartima Diu_quintima Diu_sextima Diu_sabbata\nsunnudagur m\u00e1nadagur t\u00ffsdaguy mikudagur h\u00f3sdagur friggjadagur leygardagur\nYek_Sham'beh Do_Sham'beh Seh_Sham'beh Cha'har_Sham'beh Panj_Sham'beh Jom'eh Sham'beh\nsunnuntai maanantai tiistai keskiviiko torsktai perjantai lauantai\ndimanche lundi mardi mercredi jeudi vendredi samedi\nSnein Moandei Tiisdei Woansdei Tonersdei Freed Sneon\nDomingo Segunda_feira Martes M\u00e9rcores Joves Venres S\u00e1bado\nk'vira orshabati samshabati otkhshabati khutshabati p'arask'evi shabati\nSonntag Montag Dienstag Mittwoch Donnerstag Freitag Samstag\nKiriaki' Defte'ra Tri'ti Teta'rti Pe'mpti Paraskebi' Sa'bato\nravivaar somvaar mangalvaar budhvaar guruvaar shukravaar shanivaar\np\u00f3pule p\u00f3`akahi p\u00f3`alua p\u00f3`akolu p\u00f3`ah\u00e1 p\u00f3`alima p\u00f3`aono\nYom_rishon Yom_sheni Yom_shlishi Yom_revi'i Yom_chamishi Yom_shishi Shabat\nravivara somavar mangalavar budhavara brahaspativar shukravara shanivar\nvas\u00e1rnap h\u00e9tf\u00f6 kedd szerda cs\u00fct\u00f6rt\u00f6k p\u00e9ntek szombat\nSunnudagur M\u00e1nudagur \u255eri\u03b4judagur Mi\u03b4vikudagar Fimmtudagur F\u00d6studagur Laugardagur\nsundio lundio mardio merkurdio jovdio venerdio saturdio\nMinggu Senin Selasa Rabu Kamis Jumat Sabtu\nDominica Lunedi Martedi Mercuridi Jovedi Venerdi Sabbato\nD\u00e9_Domhnaigh D\u00e9_Luain D\u00e9_M\u00e1irt D\u00e9_Ceadaoin D\u00e9_ardaoin D\u00e9_hAoine D\u00e9_Sathairn\ndomenica luned\u00ed marted\u00ed mercoled\u00ed gioved\u00ed venerd\u00ed sabato\nNichiyou_bi Getzuyou_bi Kayou_bi Suiyou_bi Mokuyou_bi Kin'you_bi Doyou_bi\nIl-yo-il Wol-yo-il Hwa-yo-il Su-yo-il Mok-yo-il Kum-yo-il To-yo-il\nDies_Dominica Dies_Lun\u00e6 Dies_Martis Dies_Mercurii Dies_Iovis Dies_Veneris Dies_Saturni\nsve-tdien pirmdien otrdien tresvdien ceturtdien piektdien sestdien\nSekmadienis Pirmadienis Antradienis Trec^iadienis Ketvirtadienis Penktadienis S^es^tadienis\nWangu Kazooba Walumbe Mukasa Kiwanuka Nnagawonye Wamunyi\nxing-_qi-_r\u00ec xing-_qi-_yi-. xing-_qi-_\u00e8r xing-_qi-_san-. xing-_qi-_s\u00ec xing-_qi-_wuv. xing-_qi-_li\u00f9\nJedoonee Jelune Jemayrt Jecrean Jardaim Jeheiney Jesam\nJabot Manre Juje Wonje Taije Balaire Jarere\ngeminrongo min\u00f2mishi m\u00e1rtes mi\u00e8rkoles misheushi b\u00e8rnashi mish\u00e1baro\nAhad Isnin Selasa Rabu Khamis Jumaat Sabtu\ns\u03c6ndag mandag tirsdag onsdag torsdag fredag l\u03c6rdag\nlo_dimenge lo_diluns lo_dimar\u00e7 lo_dim\u00e8rcres lo_dij\u00f2us lo_divendres lo_dissabte\ndjadomingo djaluna djamars djarason djaweps djabi\u00e8rna djasabra\nNiedziela Poniedzial/ek Wtorek S,roda Czwartek Pia,tek Sobota\nDomingo segunda-feire ter\u00e7a-feire quarta-feire quinta-feire sexta-feira s\u00e5bado\nDomingo Lunes martes Miercoles Jueves Viernes Sabado\nDuminic\u00aa Luni Mart'i Miercuri Joi Vineri S\u00e2mb\u00aat\u00aa\nvoskresenie ponedelnik vtornik sreda chetverg pyatnitsa subbota\nSunday Di-luain Di-m\u00e0irt Di-ciadain Di-ardaoin Di-haoine Di-sathurne\nnedjelja ponedjeljak utorak sreda cxetvrtak petak subota\nSontaha Mmantaha Labobedi Laboraro Labone Labohlano Moqebelo\nIridha- Sandhudha- Anga.haruwa-dha- Badha-dha- Brahaspa.thindha- Sikura-dha- Sena.sura-dha-\nnedel^a pondelok utorok streda s^tvrtok piatok sobota\nNedelja Ponedeljek Torek Sreda Cxetrtek Petek Sobota\ndomingo lunes martes mi\u00e9rcoles jueves viernes s\u00e1bado\nsonde mundey tude-wroko dride-wroko fode-wroko freyda Saturday\nJumapili Jumatatu Jumanne Jumatano Alhamisi Ijumaa Jumamosi\ns\u00f6ndag m\u00e5ndag tisdag onsdag torsdag fredag lordag\nLinggo Lunes Martes Miyerkoles Huwebes Biyernes Sabado\nL\u00e9-p\u00e0i-j\u00edt P\u00e0i-it P\u00e0i-j\u00ef P\u00e0i-sa\u00f1 P\u00e0i-s\u00ec P\u00e0i-g\u00d6. P\u00e0i-l\u00e1k\nwan-ar-tit wan-tjan wan-ang-kaan wan-phoet wan-pha-ru-hat-sa-boh-die wan-sook wan-sao\nTshipi Mosupologo Labobedi Laboraro Labone Labotlhano Matlhatso\nPazar Pazartesi Sali \u00c7ar,samba Per,sembe Cuma Cumartesi\nnedilya ponedilok vivtorok sereda chetver pyatnytsya subota\nChu?_Nh\u00e2.t Th\u00fa*_Hai Th\u00fa*_Ba Th\u00fa*_Tu* Th\u00fa*_Na'm Th\u00fa*_S\u00e1u Th\u00fa*_Ba?y\ndydd_Sul dyds_Llun dydd_Mawrth dyds_Mercher dydd_Iau dydd_Gwener dyds_Sadwrn\nDibeer Altine Talaata Allarba Al_xebes Aljuma Gaaw\niCawa uMvulo uLwesibini uLwesithathu uLuwesine uLwesihlanu uMgqibelo\nzuntik montik dinstik mitvokh donershtik fraytik shabes\niSonto uMsombuluko uLwesibili uLwesithathu uLwesine uLwesihlanu uMgqibelo\nDies_Dominica Dies_Lun\u00e6 Dies_Martis Dies_Mercurii Dies_Iovis Dies_Veneris Dies_Saturni\nBazar_g\u00dcn\u00dc Bazar_\u00e6rt\u00e6si \u00c7\u00e6rs,\u00e6nb\u00e6_axs,am\u00f2 \u00c7\u00e6rs,\u00e6nb\u00e6_g\u00dcn\u00dc C\u00dcm\u00e6_axs,am\u00f2 C\u00dcm\u00e6_g\u00dcn\u00dc C\u00dcm\u00e6_Senb\u00e6\nSun Moon Mars Mercury Jove Venus Saturn\nzondag maandag dinsdag woensdag donderdag vrijdag zaterdag\nKoseEraa GyoOraa BenEraa Kuoraa YOwaaraa FeEraa Memenaa\nSonntag Montag Dienstag Mittwoch Donnerstag Freitag Sonnabend\nDomingo Luns Terza_feira Corta_feira Xoves Venres S\u00e1bado\nDies_Solis Dies_Lunae Dies_Martis Dies_Mercurii Dies_Iovis Dies_Veneris Dies_Sabbatum\nxing-_qi-_ti\u00e0n xing-_qi-_yi-. xing-_qi-_\u00e8r xing-_qi-_san-. xing-_qi-_s\u00ec xing-_qi-_wuv. xing-_qi-_li\u00f9\ndjadomingu djaluna djamars djarason djaweps djabi\u00e8rn\u00e8 djasabra\nKillachau Atichau Quoyllurchau Illapachau Chaskachau Kuychichau Intichau\n</pre>\n''Caveat: &nbsp; The list (above) most surely contains errors (or, at the least, differences) of what the actual (or true) names for the days-of-the-week.''\n\n\nTo make this Rosetta Code task page as small as possible, if processing the complete list, read the days-of-the-week from a file (that is created from the above list).\n\n\nNotes concerning the above list of words\n::* &nbsp; each line has a list of days-of-the-week for a language, separated by at least one blank\n::* &nbsp; the words on each line happen to be in order, from Sunday \u2500\u2500\u25ba Saturday\n::* &nbsp; most lines have words in mixed case and some have all manner of accented words and other characters\n::* &nbsp; some words were translated to the nearest character that was available to ''code page'' &nbsp; '''437'''\n::* &nbsp; the characters in the words are not restricted except that they may not have imbedded blanks\n::* &nbsp; for this example, the use of an underscore (<big>'''_'''</big>) was used to indicate a blank in a word\n\n\n;Task:\n::* &nbsp; The list of words &nbsp; (days of the week) &nbsp; needn't be verified/validated.\n::* &nbsp; Write a function to find the (numeric) minimum length abbreviation for each line that would make abbreviations unique.\n::* &nbsp; A blank line &nbsp; (or a null line) &nbsp; should return a null string.\n::* &nbsp; Process and show the output for <u>at least</u> the first '''five''' lines of the file.\n::* &nbsp; Show all output here.\n\n{{Template:Strings}}\n<br><br>\n",
        "solution_pairs": [
            [
                {
                    "language": "C++",
                    "solution": "#include <iomanip>\n#include <iostream>\n#include <fstream>\n#include <map>\n#include <sstream>\n#include <string>\n#include <vector>\n\nstd::vector<std::string> split(const std::string& str, char delimiter) {\n    std::vector<std::string> tokens;\n    std::string token;\n    std::istringstream tokenStream(str);\n    while (std::getline(tokenStream, token, delimiter)) {\n        tokens.push_back(token);\n    }\n    return tokens;\n}\n\nint main() {\n    using namespace std;\n    string line;\n    int i = 0;\n\n    ifstream in(\"days_of_week.txt\");\n    if (in.is_open()) {\n        while (getline(in, line)) {\n            i++;\n            if (line.empty()) {\n                continue;\n            }\n\n            auto days = split(line, ' ');\n            if (days.size() != 7) {\n                throw std::runtime_error(\"There aren't 7 days in line \" + i);\n            }\n\n            map<string, int> temp;\n            for (auto& day : days) {\n                if (temp.find(day) != temp.end()) {\n                    cerr << \" \u00e2\u02c6\u017e  \" << line << '\\n';\n                    continue;\n                }\n                temp[day] = 1;\n            }\n\n            int len = 1;\n            while (true) {\n                temp.clear();\n                for (auto& day : days) {\n                    string key = day.substr(0, len);\n                    if (temp.find(key) != temp.end()) {\n                        break;\n                    }\n                    temp[key] = 1;\n                }\n                if (temp.size() == 7) {\n                    cout << setw(2) << len << \"  \" << line << '\\n';\n                    break;\n                }\n                len++;\n            }\n        }\n    }\n\n    return 0;\n}\n"
                },
                {
                    "language": "Common-Lisp",
                    "solution": "(defun max-mismatch (list)\n  (if (cdr list)\n    (max (apply #'max (mapcar #'(lambda (w2) (mismatch (car list) w2)) (cdr list))) (max-mismatch (cdr list)))\n    0 ))\n\n(with-open-file (f \"days-of-the-week.txt\" :direction :input)\n  (do* ((row (read-line f nil nil) (read-line f nil nil)))\n       ((null row) t)\n    (format t \"~d ~a~%\" (1+ (max-mismatch (SPLIT-SEQUENCE:split-sequence #\\Space row))) row) ))\n"
                }
            ],
            [
                {
                    "language": "Python",
                    "solution": "import operator\nfrom itertools import (accumulate,\n                       repeat)\nfrom pathlib import Path\nfrom typing import (Iterator,\n                    List,\n                    Tuple)\n\n\nFILEPATH = Path('days_of_week.txt')\n\n\ndef read_lines(path: Path) -> Iterator[str]:\n    with path.open() as file:\n        yield from file\n\n\ndef cumulative_letters(word: str) -> Iterator[str]:\n    \"\"\"For a word 'foo' yields 'f', 'fo', 'foo', 'foo', 'foo', ...\"\"\"\n    yield from accumulate(word, operator.add)\n    yield from repeat(word)\n\n\ndef words_cumulative_letters(words: List[str]) -> Iterator[Tuple[str, ...]]:\n    \"\"\"Yields cumulative letters for several words at the same time\"\"\"\n    yield from zip(*map(cumulative_letters, words))\n\n\ndef longest_string_length(strings: Tuple[str, ...]) -> int:\n    return max(map(len, strings))\n\n\ndef min_abbreviation_length(words: List[str]) -> int:\n    def are_unique(abbreviations: Tuple[str, ...]) -> bool:\n        return len(set(abbreviations)) == len(words)\n\n    unique_abbreviations = filter(are_unique, words_cumulative_letters(words))\n\n    return longest_string_length(next(unique_abbreviations))\n\n\ndef main():\n    for line in read_lines(FILEPATH):\n        words = line.split()\n        if not words:\n            print()\n            continue\n\n        count = min_abbreviation_length(words)\n        print(f'{count} {line}', end='')\n\n\nif __name__ == '__main__':\n    main()\n"
                },
                {
                    "language": "FutureBasic",
                    "solution": "include \"NSLog.incl\"\ninclude resources \"DaysOfWeek.txt\"\n\nlocal fn DaysOfWeek as CFArrayRef\n  CFURLRef    url\n  CFStringRef string\n  CFArrayRef  weeks = NULL\n\n  url = fn BundleURLForResource( fn BundleMain, @\"DaysOfWeek\", @\"txt\", NULL )\n  string = fn StringWithContentsOfURL( url, NSUTF8StringEncoding, NULL )\n  if ( string )\n    weeks = fn StringComponentsSeparatedByCharactersInSet( string, fn CharacterSetNewlineSet )\n  end if\nend fn = weeks\n\nlocal fn MinAbbreviationLength( week as CFStringRef ) as long\n  CFArrayRef  days\n  CFStringRef day1, day2, abbr\n  long        count, length, minLen, index1, index2\n\n  minLen = 1\n  days = fn StringComponentsSeparatedByString( week, @\" \" )\n  if ( len( days ) == 7 )\n    count = len( days )\n    for index1 = 0 to count - 1\n      day1 = days[index1]\n      length = len( day1 )\n      abbr = left( day1, minLen )\n      for index2 = 0 to count - 1\n        if ( index2 == index1 ) then continue\n        day2 = days[index2]\n        while ( fn StringHasPrefix( day2, abbr ) )\n          minLen++\n          if ( minLen > length ) then break\n          abbr = left( day1, minLen )\n        wend\n      next\n    next\n  end if\nend fn = minLen\n\nvoid local fn Abbreviations\n  CFArrayRef  weeks\n  CFStringRef week\n\n  weeks = fn DaysOfWeek\n  if ( weeks )\n    for week in weeks\n      if ( len(week) )\n        NSLog(@\"%ld\\t%@\",fn MinAbbreviationLength( week ),week)\n      else\n        NSLog(@\"NULL\")\n      end if\n    next\n  end if\nend fn\n\nfn Abbreviations\n\nHandleEvents\n"
                }
            ],
            [
                {
                    "language": "Ada",
                    "solution": "with Ada.Containers.Indefinite_Vectors;\nwith Ada.Strings.Fixed;\nwith Ada.Strings.Maps;\nwith Ada.Text_IO;\n\nprocedure Abbreviations is\n\n   package String_Vectors is\n     new Ada.Containers.Indefinite_Vectors (Index_Type   => Positive,\n                                            Element_Type => String);\n   use Ada.Text_IO, String_Vectors;\n\n   function Split (Line : String) return Vector is\n      Result : Vector;\n      First  : Natural;\n      Last   : Natural := Line'First - 1;\n   begin\n      while Last + 1 in Line'Range loop\n         Ada.Strings.Fixed.Find_Token\n           (Line, Ada.Strings.Maps.To_Set (\" \"), Last + 1,\n            Ada.Strings.Outside, First, Last);\n         exit when Last = 0;\n         Append (Result, Line (First .. Last));\n      end loop;\n      return Result;\n   end Split;\n\n   function Abbrev_Length (Items : Vector) return Natural is\n      use type Ada.Containers.Count_Type;\n      Max     : Natural := 0;\n      Abbrevs : Vector;\n   begin\n      for Item of Items loop\n         Max := Natural'Max (Max, Item'Length);\n      end loop;\n\n      for Length in 1 .. Max loop\n         Abbrevs := Empty_Vector;\n         for Item of Items loop\n            declare\n               Last : constant Natural\n                 := Natural'Min (Item'Last, Item'First + Length - 1);\n\n               Abbrev : String renames Item (Item'First .. Last);\n            begin\n               exit when Abbrevs.Contains (Abbrev);\n               Abbrevs.Append (Abbrev);\n            end;\n         end loop;\n         if Abbrevs.Length = Items.Length then\n            return Length;\n         end if;\n      end loop;\n      return 0;\n   end Abbrev_Length;\n\n   procedure Process (Line : String) is\n      package Natural_IO is new Ada.Text_IO.Integer_IO (Natural);\n      Words  : constant Vector  := Split (Line);\n      Length : constant Natural := Abbrev_Length (Words);\n   begin\n      Natural_IO.Put (Length, Width => 2);\n      Put (\" \");\n      Put_Line (Line);\n   end Process;\n\nbegin\n   while not End_Of_File loop\n      Process (Get_Line);\n   end loop;\nend Abbreviations;\n"
                },
                {
                    "language": "J",
                    "solution": "NB. y is words in boxes\nabbreviation_length =: monad define\n N =. # y\n for_i. i. >: >./ #&> y do.\n  NB. if the length of the set of length i prefixes matches the length of the row\n  if. N -: # ~. i ({. &>) y do.\n   i return.\n  end.\n end.\n)\n\nNB. use: auto_abbreviate DAY_NAMES\nauto_abbreviate =: 3 :0\n y =. y -. CR\n lines =. [;._2 y\n a =. <@([: <;._2 ,&' ');._2 y\n L =. abbreviation_length&> a\n ((' ',~\":)&> L) ,\"1 lines\n)\n"
                }
            ],
            [
                {
                    "language": "Wren",
                    "solution": "import \"io\" for File\nimport \"./pattern\" for Pattern\nimport \"./seq\" for Lst\nimport \"./fmt\" for Fmt\n\nvar p = Pattern.new(\"+1/s\")\nvar lines = File.read(\"days_of_week.txt\").split(\"\\n\").map { |l| l.trim() }\nvar i = 1\nfor (line in lines) {\n    if (line == \"\") {\n        if (i != lines.count) System.print()\n    } else {\n        var days = p.splitAll(line)\n        if (days.count != 7) Fiber.abort(\"There aren't seven days in line %(i).\")\n        if (Lst.distinct(days).count < 7) { // implies some days have the same name\n            System.print(\" \u00e2\u02c6\u017e  %(line)\")\n        } else {\n            var len = 1\n            while (true) {\n                if (Lst.distinct(days.map { |d| d.take(len).join() }.toList).count == 7) {\n                    Fmt.print(\"$2d $s\", len, line)\n                    break\n                }\n                len = len + 1\n            }\n        }\n    }\n    i = i + 1\n}\n"
                },
                {
                    "language": "FutureBasic",
                    "solution": "include \"NSLog.incl\"\ninclude resources \"DaysOfWeek.txt\"\n\nlocal fn DaysOfWeek as CFArrayRef\n  CFURLRef    url\n  CFStringRef string\n  CFArrayRef  weeks = NULL\n\n  url = fn BundleURLForResource( fn BundleMain, @\"DaysOfWeek\", @\"txt\", NULL )\n  string = fn StringWithContentsOfURL( url, NSUTF8StringEncoding, NULL )\n  if ( string )\n    weeks = fn StringComponentsSeparatedByCharactersInSet( string, fn CharacterSetNewlineSet )\n  end if\nend fn = weeks\n\nlocal fn MinAbbreviationLength( week as CFStringRef ) as long\n  CFArrayRef  days\n  CFStringRef day1, day2, abbr\n  long        count, length, minLen, index1, index2\n\n  minLen = 1\n  days = fn StringComponentsSeparatedByString( week, @\" \" )\n  if ( len( days ) == 7 )\n    count = len( days )\n    for index1 = 0 to count - 1\n      day1 = days[index1]\n      length = len( day1 )\n      abbr = left( day1, minLen )\n      for index2 = 0 to count - 1\n        if ( index2 == index1 ) then continue\n        day2 = days[index2]\n        while ( fn StringHasPrefix( day2, abbr ) )\n          minLen++\n          if ( minLen > length ) then break\n          abbr = left( day1, minLen )\n        wend\n      next\n    next\n  end if\nend fn = minLen\n\nvoid local fn Abbreviations\n  CFArrayRef  weeks\n  CFStringRef week\n\n  weeks = fn DaysOfWeek\n  if ( weeks )\n    for week in weeks\n      if ( len(week) )\n        NSLog(@\"%ld\\t%@\",fn MinAbbreviationLength( week ),week)\n      else\n        NSLog(@\"NULL\")\n      end if\n    next\n  end if\nend fn\n\nfn Abbreviations\n\nHandleEvents\n"
                }
            ],
            [
                {
                    "language": "Jq",
                    "solution": "def trim: sub(\"^  *\";\"\") | sub(\"  $\";\"\");\n\n# Each item in the stream should be a string with $n names\ndef minimum_abbreviation_lengths(stream; $n):\n  foreach (stream|trim) as $line ({i: 0};\n    .i+=1\n    | if $line == \"\" then .emit = \"\"\n      else [$line|splits(\"  *\")] as $days\n      | if ($days|length != $n) then .emit = \"WARNING: line \\(.i) does not have \\($n) tokens\"\n        elif ($days|unique|length < $n)  # some days have the same name\n        then .emit = \"\u00e2\u02c6\u017e: \\($line)\"\n        else .len = 1\n\t| .emit = false\n        | until(.emit;\n\t    .len as $len\n            | if ($days|map(.[:$len])|unique|length == $n)\n              then .emit = \"\\($len): \\($line)\"\n              else .len += 1\n\t      end)\n\tend\n      end;\n      .emit) ;\n\nminimum_abbreviation_lengths(inputs; 7)\n"
                },
                {
                    "language": "Nim",
                    "solution": "import sets\nimport unicode\n\ntype Runes = seq[Rune]\n\nvar linenum = 0\nfor line in lines(\"days.txt\"):\n  inc linenum\n  if line.len > 0:\n\n    # Extract the day names and store them in a sorted list of sequences of runes.\n    var days: seq[Runes]\n    for day in line.splitWhitespace():\n      days.add(day.toLower.toRunes)\n    if days.len != 7:\n      echo \"Wrong number of days at line \", linenum\n\n    # Build the abbreviations and store them in a set.\n    var index = 0\n    while true:\n      var abbrevs: HashSet[seq[Rune]]\n      for day in days:\n        abbrevs.incl(day[0..min(index, day.high)])\n      if abbrevs.card == 7:\n        # All abbreviations are different: fine!\n        break\n      inc index\n    echo index + 1, \" \", line\n\n  else:\n    echo line\n"
                }
            ]
        ]
    },
    {
        "task_name": "Abbreviations-easy",
        "task_description": "This task is an easier (to code) variant of the Rosetta Code task: <big> &nbsp; [[Abbreviations, simple]]</big>.\n\n\nFor this task, the following &nbsp; ''command table'' &nbsp; will be used:\n    Add ALTer  BAckup Bottom  CAppend Change SCHANGE  CInsert CLAst COMPress COpy\n    COUnt COVerlay CURsor DELete CDelete Down DUPlicate Xedit EXPand EXTract Find\n    NFind NFINDUp NFUp CFind FINdup FUp FOrward GET Help HEXType Input POWerinput\n    Join SPlit SPLTJOIN  LOAD  Locate CLocate  LOWercase UPPercase  LPrefix MACRO\n    MErge MODify MOve MSG Next Overlay PARSE PREServe PURge PUT PUTD  Query  QUIT\n    READ  RECover REFRESH RENum REPeat  Replace CReplace  RESet  RESTore  RGTLEFT\n    RIght LEft  SAVE  SET SHift SI  SORT  SOS  STAck STATus  TOP TRAnsfer Type Up\n\n<!--\nThe unsorted list (above) was constructed to help ensure that program entries don't get tripped up by performing a left-to-right string comparison.\n!-->\n\n<!--\nFor the curious amongst you (and pack-rats of old publications, this is an old XEDIT command table; the sub-commands were extracted from:\n                                                         Virtual Machine/\n                                                         System Product\n\n                                                         System Product\n                                                         SP Editor\n                                                         Command\n                                                         Language\n                                                         Reference\n                                                         Summary\n\n                                                         Release 4\n\n                                                         SX24-5122-3\n\n\n\n                                                         Fourth Edition (December 1984)\n\n                                                         Information herein is extracted from\n                                                         Virtual Machine/System Product System Product Editor Command and Macro Reference, SC24-5221.\n\n\nThis old version does  not  have some of the newer commands like  QQuit  and  PQUIT,  for instance,\nand those commands that deal with  DBCS  (double-byte character set).\n!-->\n\nNotes concerning the above &nbsp; ''command table'':\n::* &nbsp; it can be thought of as one long literal string &nbsp; (with blanks at end-of-lines)\n::* &nbsp; it may have superfluous blanks\n::* &nbsp; it may be in any case (lower/upper/mixed)\n::* &nbsp; the order of the words in the &nbsp; ''command table'' &nbsp; must be preserved as shown\n::* &nbsp; the user input(s) may be in any case (upper/lower/mixed)\n::* &nbsp; commands will be restricted to the Latin alphabet &nbsp; (A \u2500\u2500\u25ba Z, &nbsp; a \u2500\u2500\u25ba z)\n::* &nbsp; A valid abbreviation is a word that has:\n:::* &nbsp; at least the minimum length of the number of capital letters of the word in the ''command table''\n:::* &nbsp; compares equal (regardless of case) to the leading characters of the word in the ''command table''\n:::* &nbsp; a length <u>not</u> longer than the word in the ''command table''\n::::* &nbsp; '''ALT''', &nbsp; '''aLt''', &nbsp; '''ALTE''', &nbsp; and &nbsp; '''ALTER''' &nbsp; are all abbreviations of &nbsp; '''ALTer'''\n::::* &nbsp; '''AL''', &nbsp; '''ALF''', &nbsp; '''ALTERS''', &nbsp; '''TER''', &nbsp; and &nbsp; '''A''' &nbsp;  <u>aren't</u> valid abbreviations of &nbsp; '''ALTer'''\n::::* &nbsp; The number of capital letters in &nbsp; '''ALTer''' &nbsp; indicates that any abbreviation for &nbsp; '''ALTer''' &nbsp; must be at least three letters\n::::* &nbsp; Any word longer than five characters <u>can't</u> be an abbreviation for &nbsp; '''ALTer'''\n::::* &nbsp; '''o''',  &nbsp; '''ov''',  &nbsp; '''oVe''',  &nbsp; '''over''',  &nbsp; '''overL''',  &nbsp; '''overla''' &nbsp; are all acceptable abbreviations for &nbsp; '''Overlay'''\n::* &nbsp; if there isn't any lowercase letters in the word in the ''command table'', &nbsp; then there isn't an abbreviation permitted\n\n<!--\n::* &nbsp; a Latin alphabet is used for this Rosetta Code task because it behaves well when letters are uppercased\n!-->\n\n;Task:\n::* &nbsp; The command table needn't be verified/validated.\n::* &nbsp; Write a function to validate if the user \"words\" &nbsp; (given as input) &nbsp; are valid &nbsp; (in the ''command table'').\n::* &nbsp; If the word &nbsp; is &nbsp; valid, &nbsp; then return the full uppercase version of that \"word\".\n::* &nbsp; If the word        isn't     valid, &nbsp; then return the lowercase string: &nbsp; <big> '''*error*''' </big> &nbsp; &nbsp; &nbsp; (7 characters).\n::* &nbsp; A blank input &nbsp; (or a null input) &nbsp; should return a null string.\n::* &nbsp; Show all output here.\n\n\n;An example test case to be used for this task:\nFor a user string of:\n  riG   rePEAT copies  put mo   rest    types   fup.    6       poweRin\nthe computer program should return the string:\n  RIGHT REPEAT *error* PUT MOVE RESTORE *error* *error* *error* POWERINPUT\n\n{{Template:Strings}}\n<br><br>\n",
        "solution_pairs": [
            [
                {
                    "language": "Picat",
                    "solution": "import util.\n\ncommand_table(\"Add ALTer  BAckup Bottom  CAppend Change SCHANGE  CInsert CLAst COMPress COpy\nCOUnt COVerlay CURsor DELete CDelete Down DUPlicate Xedit EXPand EXTract Find\nNFind NFINDUp NFUp CFind FINdup FUp FOrward GET Help HEXType Input POWerinput\nJoin SPlit SPLTJOIN  LOAD  Locate CLocate  LOWercase UPPercase  LPrefix MACRO\nMErge MODify MOve MSG Next Overlay PARSE PREServe PURge PUT PUTD  Query  QUIT\nREAD  RECover REFRESH RENum REPeat  Replace CReplace  RESet  RESTore  RGTLEFT\nRIght LEft  SAVE  SET SHift SI  SORT  SOS  STAck STATus  TOP TRAnsfer Type Up\").\n\nvalidate(\"\", _, Result) ?=>\n    Result = \"\".\n\nvalidate(Word, Commands, Result), Word \\= \"\" ?=>\n    member(Command, Commands),\n    append(Prefix, Suffix, Command),\n    Prefix == to_uppercase(Prefix),\n    Suffix == to_lowercase(Suffix),\n    LowWord = to_lowercase(Word),\n    LowPrefix = to_lowercase(Prefix),\n    append(LowPrefix, Other, LowWord),\n    LowCommand = to_lowercase(Command),\n    append(LowWord, _, LowCommand),\n    Result = to_uppercase(Command).\n\nvalidate(Word, _, Result), Word \\= \"\" =>\n    Result = \"*error*\".\n\nmain(Args) =>\n    command_table(Table),\n    Commands = split(Table),\n    foreach (Word in Args)\n        validate(Word, Commands, Result),\n        printf(\"%w \", Result)\n    end,\n    nl.\n"
                },
                {
                    "language": "PHP",
                    "solution": "// note this is php 7.x\n$commands = 'Add ALTer  BAckup Bottom  CAppend Change SCHANGE  CInsert CLAst COMPress COpy\n   COUnt COVerlay CURsor DELete CDelete Down DUPlicate Xedit EXPand EXTract Find\n   NFind NFINDUp NFUp CFind FINdup FUp FOrward GET Help HEXType Input POWerinput\n   Join SPlit SPLTJOIN  LOAD  Locate CLocate  LOWercase UPPercase  LPrefix MACRO\n   MErge MODify MOve MSG Next Overlay PARSE PREServe PURge PUT PUTD  Query  QUIT\n   READ  RECover REFRESH RENum REPeat  Replace CReplace  RESet  RESTore  RGTLEFT\n   RIght LEft  SAVE  SET SHift SI  SORT  SOS  STAck STATus  TOP TRAnsfer Type Up';\n\n$input = 'riG   rePEAT copies  put mo   rest    types   fup.    6       poweRin';\n$expect = 'RIGHT REPEAT *error* PUT MOVE RESTORE *error* *error* *error* POWERINPUT';\n$table = makeCommandTable($commands);\n$table_keys = array_keys($table);\n\n$inputTable = processInput($input);\n\nforeach ($inputTable as $word) {\n    $rs = searchCommandTable($word, $table);\n    if ($rs) {\n        $output[] = $rs;\n    } else {\n        $output[] = '*error*';\n    }\n\n}\necho 'Input: '. $input. PHP_EOL;\necho 'Output: '. implode(' ', $output). PHP_EOL;\n\nfunction searchCommandTable($search, $table) {\n    foreach ($table as $key => $value) {\n        if ((strtoupper(substr($value['word'], 0, strlen($search))) === strtoupper($search)) && (strlen($search) >= $value['min_length'])) {\n            return $key;\n        }\n    }\n    return false;\n}\n\nfunction processInput($input) {\n    $input = preg_replace('!\\s+!', ' ', $input);\n    $pieces = explode(' ', trim($input));\n    return $pieces;\n}\n\nfunction makeCommandTable($commands) {\n    $commands = preg_replace('!\\s+!', ' ', $commands);\n    $pieces = explode(' ', trim($commands));\n    foreach ($pieces as $word) {\n        $rs[strtoupper($word)] = ['word'=>$word, 'min_length' => preg_match_all(\"/[A-Z]/\", $word)];\n    }\n    return $rs;\n}\n"
                }
            ],
            [
                {
                    "language": "R",
                    "solution": "library(stringi)\n\ncmds_block <- \"\nAdd ALTer  BAckup Bottom  CAppend Change SCHANGE  CInsert CLAst COMPress COpy\nCOUnt COVerlay CURsor DELete CDelete Down DUPlicate Xedit EXPand EXTract Find\nNFind NFINDUp NFUp CFind FINdup FUp FOrward GET Help HEXType Input POWerinput\nJoin SPlit SPLTJOIN  LOAD  Locate CLocate  LOWercase UPPercase  LPrefix MACRO\nMErge MODify MOve MSG Next Overlay PARSE PREServe PURge PUT PUTD  Query  QUIT\nREAD  RECover REFRESH RENum REPeat  Replace CReplace  RESet  RESTore  RGTLEFT\nRIght LEft  SAVE  SET SHift SI  SORT  SOS  STAck STATus  TOP TRAnsfer Type Up\"\n\ncmds <- cmds_block %>% trimws() %>% stri_split_regex(\"\\\\s+\") %>% unlist()\n\ncheck_word <- function(inputw,comw) {\n  inputl  <- nchar(inputw)\n  coml    <- nchar(comw)\n  cap_cnt <- stri_count_regex(comw,\"[A-Z]\")\n\n  ifelse(cap_cnt != 0 && inputl >= cap_cnt && inputl <= coml &&\n           stri_startswith_fixed(toupper(comw),toupper(inputw)),T,F)\n}\n\n# Inputs\nintstr_list <- \"riG   rePEAT copies  put mo   rest    types   fup.    6       poweRin\" %>%\n  stri_split_regex(\"\\\\s+\") %>% unlist()\n\n# Results\nresults <- sapply(intstr_list,\\(y) {\n  matc <- cmds[sapply(cmds,\\(x) check_word(y,x))]\n  ifelse(length(matc) != 0,toupper(matc[1]),\"*error*\")\n})\n\nprint(results)\n"
                },
                {
                    "language": "Ruby",
                    "solution": "#!/usr/bin/env ruby\n\ncmd_table = File.read(ARGV[0]).split\nuser_str = File.read(ARGV[1]).split\n\nuser_str.each do |abbr|\n  candidate = cmd_table.find do |cmd|\n    cmd.count('A-Z') <= abbr.length && abbr.casecmp(cmd[0...abbr.length]).zero?\n  end\n\n  print candidate.nil? ? '*error*' : candidate.upcase\n\n  print ' '\nend\n\nputs\n"
                }
            ],
            [
                {
                    "language": "Vedit-macro-language",
                    "solution": "// Command table:\nBuf_Switch(#10=Buf_Free)\nIns_Text(\"\n   Add ALTer  BAckup Bottom  CAppend Change SCHANGE  CInsert CLAst COMPress COpy\n   COUnt COVerlay CURsor DELete CDelete Down DUPlicate Xedit EXPand EXTract Find\n   NFind NFINDUp NFUp CFind FINdup FUp FOrward GET Help HEXType Input POWerinput\n   Join SPlit SPLTJOIN  LOAD  Locate CLocate  LOWercase UPPercase  LPrefix MACRO\n   MErge MODify MOve MSG Next Overlay PARSE PREServe PURge PUT PUTD  Query  QUIT\n   READ  RECover REFRESH RENum REPeat  Replace CReplace  RESet  RESTore  RGTLEFT\n   RIght LEft  SAVE  SET SHift SI  SORT  SOS  STAck STATus  TOP TRAnsfer Type Up\n\")\n\n// Example input:\nBuf_Switch(#11=Buf_Free)\nIns_Text(\"riG rePEAT copies  put mo   rest    types   fup.    6       poweRin \")\nBOF\n\n// Main program\n#20 = Reg_Free()\t\t\t// Text register for the word to be converted\nRepeat(ALL) {\n    Buf_Switch(#11)\t\t\t// Buffer for example input\n    Search(\"|!|X\", ERRBREAK)\t\t// Find next non-space character\n    #30 = Cur_Pos\t\t\t// #30 = begin of a word\n    Search(\"|X\", NOERR+NORESTORE)\t// Find whitespace (end of the word)\n    Reg_Copy_Block(#20, #30, Cur_Pos)\t// Get the word to text register #20\n    Call(\"acronym_to_word\")\t\t// Convert acronym to full word\n    Reg_Type(#20)\t\t\t// Display the full word\n    Type_Char(' ')\t\t\t// Display a space character\n}\nBuf_Switch(#10) Buf_Quit(OK)\t\t// Clean-up\nBuf_Switch(#11) Buf_Quit(OK)\nReg_Empty(#20)\nReturn\n\n// Convert an acronym to full word in uppercase\n// Input:  @(#20) = the acronym\n// Return: @(#20) = the full word\n//\n:acronym_to_word:\nif (Reg_Size(#20) == 0) {\t\t// If zero length input,\n    return\t\t\t\t// return zero length string\n}\nBuf_Switch(#10)\t\t\t\t// Switch to command table\nBOF\nWhile (!At_EOF) {\n    if (Search(\"|S|@(#20)\", NOERR)) {\t\t// Find (the first part of) the word\n\tChar\t\t\t\t\t// Skip the separator\n\t#31 = Cur_Pos\t\t\t\t// #31 = Begin of the acronym\n\tChar(Reg_Size(#20))\t\t\t// Check if the acronym is log enough\n\tif (Cur_Char < 'A' || Cur_Char > 'Z') {\t// Not a capital letter, verified\n\t    Search(\"|X\")\t\t\t// Find the end of the word\n\t    Reg_Copy_Block(#20, #31, Cur_Pos)\t// Get the word into text register #20\n\t    Buf_Switch(Buf_Free)\t\t// Convert to upper case using tmp buffer\n\t    Reg_Ins(#20)\n\t    Case_Upper_Block(0, Cur_Pos)\n\t    Reg_Copy_Block(#20, 0, Cur_Pos)\n\t    Buf_Quit(OK)\n\t    break\t\t\t\t// Word found, exit loop\n\t}\n    } else {\t\t\t\t\t// Not found\n\tReg_Set(#20, \"*error*\")\n\tbreak\n    }\n}\nReturn\n"
                },
                {
                    "language": "V-(Vlang)",
                    "solution": "import encoding.utf8\n\nfn validate(commands []string, words []string, min_len []int) []string {\n    mut results := []string{}\n    if words.len == 0 {\n        return results\n    }\n    for word in words {\n        mut match_found := false\n        wlen := word.len\n        for i, command in commands {\n            if min_len[i] == 0 || wlen < min_len[i] || wlen > command.len {\n                continue\n            }\n            c := utf8.to_upper(command)\n            w := utf8.to_upper(word)\n            if c.index(w) or {-1} ==0 {\n                results << c\n                match_found = true\n                break\n            }\n        }\n        if !match_found {\n            results << \"*error*\"\n        }\n    }\n    return results\n}\n\nfn main() {\nmut table := \"Add ALTer  BAckup Bottom  CAppend Change SCHANGE  CInsert CLAst COMPress COpy \" +\n    \"COUnt COVerlay CURsor DELete CDelete Down DUPlicate Xedit EXPand EXTract Find \" +\n    \"NFind NFINDUp NFUp CFind FINdup FUp FOrward GET Help HEXType Input POWerinput \" +\n     \"Join SPlit SPLTJOIN  LOAD  Locate CLocate  LOWercase UPPercase  LPrefix MACRO \" +\n    \"MErge MODify MOve MSG Next Overlay PARSE PREServe PURge PUT PUTD  Query  QUIT \" +\n    \"READ  RECover REFRESH RENum REPeat  Replace CReplace  RESet  RESTore  RGTLEFT \" +\n    \"RIght LEft  SAVE  SET SHift SI  SORT  SOS  STAck STATus  TOP TRAnsfer Type Up \"\n    table = table.trim_space()\n    commands := table.fields()\n    clen := commands.len\n    mut min_len := []int{len: clen}\n    for i in 0..clen {\n        mut count := 0\n        for c in commands[i].split('') {\n            if c >= 'A' && c <= 'Z' {\n                count++\n            }\n        }\n        min_len[i] = count\n    }\n    sentence :=  \"riG   rePEAT copies  put mo   rest    types   fup.    6       poweRin\"\n    words := sentence.fields()\n    results := validate(commands, words, min_len)\n    for j in 0..words.len {\n        print(\"${words[j]} \")\n    }\n    print(\"\\nfull words:  \")\n    println(results.join(\" \"))\n}\n"
                }
            ],
            [
                {
                    "language": "Free-Pascal-Lazarus",
                    "solution": "program Abbreviations_Easy;\n{$IFDEF WINDOWS}\n  {$APPTYPE CONSOLE}\n{$ENDIF}\n{$IFDEF FPC}\n  {$MODE DELPHI}\n  uses\n    SysUtils;\n{$ELSE}\n uses\n    System.SysUtils;\n{$ENDIF}\n\nconst\n  _TABLE_ =\n    'Add ALTer  BAckup Bottom  CAppend Change SCHANGE  CInsert CLAst COMPress COpy ' +\n    'COUnt COVerlay CURsor DELete CDelete Down DUPlicate Xedit EXPand EXTract Find ' +\n    'NFind NFINDUp NFUp CFind FINdup FUp FOrward GET Help HEXType Input POWerinput ' +\n    'Join SPlit SPLTJOIN  LOAD  Locate CLocate  LOWercase UPPercase  LPrefix MACRO ' +\n    'MErge MODify MOve MSG Next Overlay PARSE PREServe PURge PUT PUTD  Query  QUIT ' +\n    'READ  RECover REFRESH RENum REPeat  Replace CReplace  RESet  RESTore  RGTLEFT ' +\n    'RIght LEft  SAVE  SET SHift SI  SORT  SOS  STAck STATus  TOP TRAnsfer Type Up ';\n\nfunction validate(commands, words: TArray<string>; minLens: TArray<Integer>):\n  TArray<string>;\nvar\n  wd,c,command,w : String;\n  wdIdx,wlen,i : integer;\n  matchFound : boolean;\n\nbegin\n  SetLength(result, 0);\n  if Length(words) = 0 then\n    exit;\n  for wdIdx := Low(words) to High(words) do\n  begin\n    wd := words[wdIdx];\n    matchFound := false;\n    wlen := wd.Length;\n    for i := 0 to High(commands) do\n    begin\n      command := commands[i];\n      if (minLens[i] = 0) or (wlen < minLens[i]) or (wlen > length(command)) then\n        continue;\n\n      c := command.ToUpper;\n      w := wd.ToUpper;\n      if c.StartsWith(w) then\n      begin\n        SetLength(result, Length(result) + 1);\n        result[High(result)] := c;\n        matchFound := True;\n        Break;\n      end;\n    end;\n\n    if not matchFound then\n    begin\n      SetLength(result, Length(result) + 1);\n      result[High(result)] := 'error*';\n    end;\n  end;\nend;\nvar\n  results,commands,words :TArray<string>;\n  table,sentence :String;\n  minLens: TArray<integer>;\n  cLen,i,j,count : integer;\n  c:char;\nbegin\n  table := _TABLE_.Trim;\n  commands := table.Split([' '], TStringSplitOptions.ExcludeEmpty);\n  clen := Length(commands);\n  SetLength(minLens, clen);\n  for i := 0 to clen - 1 do\n  begin\n    count := 0;\n    For j := length(commands[i]) downto 1 do\n    begin\n      c := commands[i][j];\n      if (c >= 'A') and (c <= 'Z') then\n        inc(count);\n    end;\n    minLens[i] := count;\n  end;\n\n  sentence := 'riG   rePEAT copies  put mo   rest    types   fup.    6       poweRin';\n  words := sentence.Split([' '], TStringSplitOptions.ExcludeEmpty);\n  results := validate(commands, words, minLens);\n  Write('user words: ');\n  for j := 0 to Length(words) - 1 do\n    Write(words[j].PadRight(1 + length(results[j])));\n  Write(#10, 'full words: ');\n// FOr fpc 3.0.4 on TIO.RUN\n  for j := 0 to Length(words) - 1 do\n    Write(results[j],' ');\n// fpc 3.2.2 will do\n//  Writeln(string.Join(' ', results));\n  {$IFDEF WINDOWS}\n  Readln;\n  {$ENDIF}\nend.\n"
                },
                {
                    "language": "Raku",
                    "solution": "<\nAdd ALTer  BAckup Bottom  CAppend Change SCHANGE  CInsert CLAst COMPress COpy\nCOUnt COVerlay CURsor DELete CDelete Down DUPlicate Xedit EXPand EXTract Find\nNFind NFINDUp NFUp CFind FINdup FUp FOrward GET Help HEXType Input POWerinput\nJoin SPlit SPLTJOIN  LOAD  Locate CLocate  LOWercase UPPercase  LPrefix MACRO\nMErge MODify MOve MSG Next Overlay PARSE PREServe PURge PUT PUTD  Query  QUIT\nREAD  RECover REFRESH RENum REPeat  Replace CReplace  RESet  RESTore  RGTLEFT\nRIght LEft  SAVE  SET SHift SI  SORT  SOS  STAck STATus  TOP TRAnsfer Type Up\n> ~~ m:g/ ((<.:Lu>+) <.:Ll>*) /;\n\nmy %abr = '' => '', |$/.map: {\n    my $abbrv = .[0].Str.fc;\n    |map { $abbrv.substr( 0, $_ ) => $abbrv.uc },\n    .[0][0].Str.chars .. $abbrv.chars\n};\n\nsub abbr-easy ( $str ) { %abr{$str.trim.fc} // '*error*' }\n\n# Testing\nfor 'riG   rePEAT copies  put mo   rest    types   fup.    6       poweRin', '' -> $str {\n    put ' Input: ', $str;\n    put 'Output: ', join ' ', $str.words.map: &abbr-easy;\n}\n"
                }
            ],
            [
                {
                    "language": "Tcl",
                    "solution": "proc appendCmd {word} {\n  # Procedure to append the correct command from the global list ::cmds\n  # for the word given as parameter to the global list ::result.\n  # If a matching word has been found and appended to ::result, this procedure\n  # behaves like a \"continue\" statement, causing the loop containing it to\n  # jump over the rest of the body.\n  set candidates [lsearch -inline -all -nocase -glob $::cmds \"${word}*\"]\n  foreach cand $candidates {\n    if {[string length $word] >= $::minLen($cand)} {\n      lappend ::result [string toupper $cand]\n      return -code continue\n    }\n  }\n}\n\nset cmds {Add ALTer  BAckup Bottom  CAppend Change SCHANGE  CInsert CLAst COMPress COpy\n   COUnt COVerlay CURsor DELete CDelete Down DUPlicate Xedit EXPand EXTract Find\n   NFind NFINDUp NFUp CFind FINdup FUp FOrward GET Help HEXType Input POWerinput\n   Join SPlit SPLTJOIN  LOAD  Locate CLocate  LOWercase UPPercase  LPrefix MACRO\n   MErge MODify MOve MSG Next Overlay PARSE PREServe PURge PUT PUTD  Query  QUIT\n   READ  RECover REFRESH RENum REPeat  Replace CReplace  RESet  RESTore  RGTLEFT\n   RIght LEft  SAVE  SET SHift SI  SORT  SOS  STAck STATus  TOP TRAnsfer Type Up}\n\n# Find the minimum lengths necessary for each command.\nforeach c $cmds {\n  regexp {^[A-Z]+} $c match\n  set minLen($c) [string length $match]\n}\n\nset words {riG   rePEAT copies  put mo   rest    types   fup.    6       poweRin}\nset result {}\n\nforeach w $words {\n  appendCmd $w\n  lappend result *error*\n}\n\nputs $result\n"
                },
                {
                    "language": "Vedit-macro-language",
                    "solution": "// Command table:\nBuf_Switch(#10=Buf_Free)\nIns_Text(\"\n   Add ALTer  BAckup Bottom  CAppend Change SCHANGE  CInsert CLAst COMPress COpy\n   COUnt COVerlay CURsor DELete CDelete Down DUPlicate Xedit EXPand EXTract Find\n   NFind NFINDUp NFUp CFind FINdup FUp FOrward GET Help HEXType Input POWerinput\n   Join SPlit SPLTJOIN  LOAD  Locate CLocate  LOWercase UPPercase  LPrefix MACRO\n   MErge MODify MOve MSG Next Overlay PARSE PREServe PURge PUT PUTD  Query  QUIT\n   READ  RECover REFRESH RENum REPeat  Replace CReplace  RESet  RESTore  RGTLEFT\n   RIght LEft  SAVE  SET SHift SI  SORT  SOS  STAck STATus  TOP TRAnsfer Type Up\n\")\n\n// Example input:\nBuf_Switch(#11=Buf_Free)\nIns_Text(\"riG rePEAT copies  put mo   rest    types   fup.    6       poweRin \")\nBOF\n\n// Main program\n#20 = Reg_Free()\t\t\t// Text register for the word to be converted\nRepeat(ALL) {\n    Buf_Switch(#11)\t\t\t// Buffer for example input\n    Search(\"|!|X\", ERRBREAK)\t\t// Find next non-space character\n    #30 = Cur_Pos\t\t\t// #30 = begin of a word\n    Search(\"|X\", NOERR+NORESTORE)\t// Find whitespace (end of the word)\n    Reg_Copy_Block(#20, #30, Cur_Pos)\t// Get the word to text register #20\n    Call(\"acronym_to_word\")\t\t// Convert acronym to full word\n    Reg_Type(#20)\t\t\t// Display the full word\n    Type_Char(' ')\t\t\t// Display a space character\n}\nBuf_Switch(#10) Buf_Quit(OK)\t\t// Clean-up\nBuf_Switch(#11) Buf_Quit(OK)\nReg_Empty(#20)\nReturn\n\n// Convert an acronym to full word in uppercase\n// Input:  @(#20) = the acronym\n// Return: @(#20) = the full word\n//\n:acronym_to_word:\nif (Reg_Size(#20) == 0) {\t\t// If zero length input,\n    return\t\t\t\t// return zero length string\n}\nBuf_Switch(#10)\t\t\t\t// Switch to command table\nBOF\nWhile (!At_EOF) {\n    if (Search(\"|S|@(#20)\", NOERR)) {\t\t// Find (the first part of) the word\n\tChar\t\t\t\t\t// Skip the separator\n\t#31 = Cur_Pos\t\t\t\t// #31 = Begin of the acronym\n\tChar(Reg_Size(#20))\t\t\t// Check if the acronym is log enough\n\tif (Cur_Char < 'A' || Cur_Char > 'Z') {\t// Not a capital letter, verified\n\t    Search(\"|X\")\t\t\t// Find the end of the word\n\t    Reg_Copy_Block(#20, #31, Cur_Pos)\t// Get the word into text register #20\n\t    Buf_Switch(Buf_Free)\t\t// Convert to upper case using tmp buffer\n\t    Reg_Ins(#20)\n\t    Case_Upper_Block(0, Cur_Pos)\n\t    Reg_Copy_Block(#20, 0, Cur_Pos)\n\t    Buf_Quit(OK)\n\t    break\t\t\t\t// Word found, exit loop\n\t}\n    } else {\t\t\t\t\t// Not found\n\tReg_Set(#20, \"*error*\")\n\tbreak\n    }\n}\nReturn\n"
                }
            ]
        ]
    },
    {
        "task_name": "Abbreviations-simple",
        "task_description": "The use of &nbsp; abbreviations &nbsp;  (also sometimes called synonyms, nicknames, AKAs, or aliases) &nbsp;  can be an \n<br>easy way to add flexibility when specifying or using commands, sub\u2500commands, options, etc.\n\n<!--\n(AKA =  also known as)\n!-->\n\nFor this task, the following &nbsp; ''command table'' &nbsp; will be used:\n    add 1  alter 3  backup 2  bottom 1  Cappend 2  change 1  Schange  Cinsert 2  Clast 3\n    compress 4 copy 2 count 3 Coverlay 3 cursor 3  delete 3 Cdelete 2  down 1  duplicate\n    3 xEdit 1 expand 3 extract 3  find 1 Nfind 2 Nfindup 6 NfUP 3 Cfind 2 findUP 3 fUP 2\n    forward 2  get  help 1 hexType 4  input 1 powerInput 3  join 1 split 2 spltJOIN load\n    locate 1 Clocate 2 lowerCase 3 upperCase 3 Lprefix 2  macro  merge 2 modify 3 move 2\n    msg  next 1 overlay 1 parse preserve 4 purge 3 put putD query 1 quit  read recover 3\n    refresh renum 3 repeat 3 replace 1 Creplace 2 reset 3 restore 4 rgtLEFT right 2 left\n    2  save  set  shift 2  si  sort  sos  stack 3 status 4 top  transfer 3  type 1  up 1\n\n<!--\nThe unsorted list (above) was constructed to help ensure that program entries don't get tripped up by performing a straight left-to-right string comparison.\n!-->\n\n<!--\nFor the curious amongst you (and pack-rats of old publications, this is an old XEDIT command table; the sub-commands were extracted from:\n                                                         Virtual Machine/\n                                                         System Product\n\n                                                         System Product\n                                                         SP Editor\n                                                         Command\n                                                         Language\n                                                         Reference\n                                                         Summary\n\n                                                         Release 4\n\n                                                         SX24-5122-3\n\n\n\n                                                         Fourth Edition (December 1984)\n\n                                                         Information herein is extracted from\n                                                         Virtual Machine/System Product System Product Editor Command and Macro Reference, SC24-5221.\n\n\nThis old version does  not  have some of the newer commands like  QQuit  and  PQUIT,  for instance,\nand those commands that deal with  DBCS  (double-byte character set).\n!-->\n\nNotes concerning the above &nbsp; ''command table'':\n::* &nbsp; it can be thought of as one long literal string &nbsp; (with blanks at end-of-lines)\n::* &nbsp; it may have superfluous blanks\n::* &nbsp; it may be in any case (lower/upper/mixed)\n::* &nbsp; the order of the words in the &nbsp; ''command table'' &nbsp; must be preserved as shown\n::* &nbsp; the user input(s) may be in any case (upper/lower/mixed)\n::* &nbsp; commands will be restricted to the Latin alphabet &nbsp; (A \u2500\u2500\u25ba Z, &nbsp; a \u2500\u2500\u25ba z)\n::* &nbsp; a command is followed by an optional number, which indicates the minimum abbreviation\n::* &nbsp; A valid abbreviation is a word that has:\n:::* &nbsp; at least the minimum length of the word's minimum number in the ''command table''\n:::* &nbsp; compares equal (regardless of case) to the leading characters of the word in the ''command table''\n:::* &nbsp; a length <u>not</u> longer than the word in the ''command table''\n::::* &nbsp; '''ALT''', &nbsp; '''aLt''', &nbsp; '''ALTE''', &nbsp; and &nbsp; '''ALTER''' &nbsp; are all abbreviations of &nbsp; '''ALTER 3'''\n::::* &nbsp; '''AL''', &nbsp; '''ALF''', &nbsp; '''ALTERS''', &nbsp; '''TER''', &nbsp; and &nbsp; '''A''' &nbsp;  <u>aren't</u> valid abbreviations of &nbsp; '''ALTER 3'''\n::::* &nbsp; The &nbsp; '''3''' &nbsp; indicates that any abbreviation for &nbsp; '''ALTER''' &nbsp; must be at least three characters\n::::* &nbsp; Any word longer than five characters <u>can't</u> be an abbreviation for &nbsp; '''ALTER'''\n::::* &nbsp; '''o''',  &nbsp; '''ov''',  &nbsp; '''oVe''',  &nbsp; '''over''',  &nbsp; '''overL''',  &nbsp; '''overla''' &nbsp; are all acceptable abbreviations for &nbsp; '''overlay 1'''\n::* &nbsp; if there isn't a number after the command, &nbsp; then there isn't an abbreviation permitted\n\n<!--\n::* &nbsp; a Latin alphabet is used for this Rosetta Code task because it behaves well when letters are uppercased\n!-->\n\n;Task:\n::* &nbsp; The command table needn't be verified/validated.\n::* &nbsp; Write a function to validate if the user \"words\" &nbsp; (given as input) &nbsp; are valid &nbsp; (in the ''command table'').\n::* &nbsp; If the word &nbsp; is &nbsp; valid, &nbsp; then return the full uppercase version of that \"word\".\n::* &nbsp; If the word        isn't     valid, &nbsp; then return the lowercase string: &nbsp; <big> '''*error*''' </big> &nbsp; &nbsp; &nbsp; (7 characters).\n::* &nbsp; A blank input &nbsp; (or a null input) &nbsp; should return a null string.\n::* &nbsp; Show all output here.\n\n\n;An example test case to be used for this task:\nFor a user string of:\n  riG   rePEAT copies  put mo   rest    types   fup.    6       poweRin\nthe computer program should return the string:\n  RIGHT REPEAT *error* PUT MOVE RESTORE *error* *error* *error* POWERINPUT\n\n{{Template:Strings}}\n<br><br>\n\n",
        "solution_pairs": [
            [
                {
                    "language": "Scala",
                    "solution": "object Main extends App {\n    implicit class StrOps(i: String) {\n        def isAbbreviationOf(target: String, targetMinLength: Int): Boolean = {\n            @scala.annotation.tailrec\n            def checkPAsPrefixOfM(p: List[Char], m: List[Char]): Boolean = (p, m) match {\n                case (Nil, _) => true //prefix empty\n                case (_, Nil) => false //main string empty\n                case (ph :: pt, mh :: mt) if ph.toUpper == mh.toUpper => checkPAsPrefixOfM(pt, mt) //case insensitive match of head characters\n                case _ => false\n            }\n            i.length >= targetMinLength && checkPAsPrefixOfM(i.toList, target.toList)\n        }\n    }\n\n    val commands = \"\"\"\n         add 1  alter 3  backup 2  bottom 1  Cappend 2  change 1  Schange  Cinsert 2  Clast 3\n         compress 4 copy 2 count 3 Coverlay 3 cursor 3  delete 3 Cdelete 2  down 1  duplicate\n         3 xEdit 1 expand 3 extract 3  find 1 Nfind 2 Nfindup 6 NfUP 3 Cfind 2 findUP 3 fUP 2\n         forward 2  get  help 1 hexType 4  input 1 powerInput 3  join 1 split 2 spltJOIN load\n         locate 1 Clocate 2 lowerCase 3 upperCase 3 Lprefix 2  macro  merge 2 modify 3 move 2\n         msg  next 1 overlay 1 parse preserve 4 purge 3 put putD query 1 quit  read recover 3\n         refresh renum 3 repeat 3 replace 1 Creplace 2 reset 3 restore 4 rgtLEFT right 2 left\n         2  save  set  shift 2  si  sort  sos  stack 3 status 4 top  transfer 3  type 1  up 1\n      \"\"\".stripMargin.replace(\"\\n\", \" \").trim.split(\" \")\n\n    val commandWithMinLengths = commands.sliding(2, 1)\n                                       .filter{ window =>\n                                           window.length > 1 && Try(window(0).toInt).toOption.isEmpty\n                                       }\n                                       .map{ w =>\n                                           (\n                                               w(0),\n                                               Try(w(1).toInt).toOption.getOrElse(0)\n                                           )\n                                       }\n                                       .toList\n\n    val input = \"riG   rePEAT copies  put mo   rest    types   fup.    6       poweRin\".split(\" \").filter(!_.isEmpty)\n\n    val resultLine = input.map{ i =>\n        commandWithMinLengths.find{case (c, l) => i.isAbbreviationOf(c, l)}.map(_._1.toUpperCase).getOrElse(\"*error*\")\n    }.mkString(\" \")\n\n    println(resultLine)\n}\n"
                },
                {
                    "language": "Python",
                    "solution": "'''Simple abbreviations'''\n\nfrom functools import reduce\nimport re\n\n\n# withExpansions :: [(String, Int)] -> String -> String\ndef withExpansions(table):\n    '''A string in which all words are either\n       expanded (if they match abbreviations in\n       a supplied table), or replaced with an\n       '*error*' string.\n    '''\n    return lambda s: unwords(map(\n        expanded(table), words(s)\n    ))\n\n\n# expanded :: [(String, Int)] -> String -> String\ndef expanded(table):\n    '''An abbreviation (or error string) for\n       a given word, based on a table of full\n       strings and minimum abbreviation lengths.\n    '''\n    def expansion(k):\n        u = k.upper()\n        lng = len(k)\n\n        def p(wn):\n            w, n = wn\n            return w.startswith(u) and lng >= n\n        return find(p)(table) if k else Just(('', 0))\n\n    return lambda s: maybe('*error*')(fst)(expansion(s))\n\n\n# cmdsFromString :: String -> [(String, Int)]\ndef cmdsFromString(s):\n    '''A simple rule-base consisting of a\n       list of tuples [(\n          upper case expansion string,\n          minimum character count of abbreviation\n       )],\n       obtained by a parse of single input string.\n    '''\n    def go(a, x):\n        xs, n = a\n        return (xs, int(x)) if x.isdigit() else (\n            ([(x.upper(), n)] + xs, 0)\n        )\n    return fst(reduce(\n        go,\n        reversed(re.split(r'\\s+', s)),\n        ([], 0)\n    ))\n\n\n# TEST -------------------------------------------------\ndef main():\n    '''Tests of abbreviation expansions'''\n\n    # table :: [(String, Int)]\n    table = cmdsFromString(\n        '''add 1  alter 3  backup 2  bottom 1  Cappend 2  change 1\n            Schange Cinsert 2  Clast 3 compress 4 copy 2 count 3 Coverlay 3\n            cursor 3  delete 3 Cdelete 2  down 1  duplicate 3 xEdit 1 expand 3\n            extract 3  find 1 Nfind 2 Nfindup 6 NfUP 3 Cfind 2 findUP 3 fUP 2\n            forward 2  get  help 1 hexType 4 input 1 powerInput 3  join 1\n            split 2 spltJOIN load locate 1 Clocate 2 lowerCase 3 upperCase 3\n            Lprefix 2  macro  merge 2 modify 3 move 2 msg  next 1 overlay 1\n            parse preserve 4 purge 3 put putD query 1 quit read recover 3\n            refresh renum 3 repeat 3 replace 1 Creplace 2 reset 3 restore 4\n            rgtLEFT right 2 left 2  save  set  shift 2  si  sort  sos stack 3\n            status 4 top  transfer 3  type 1  up 1'''\n    )\n\n    # tests :: [String]\n    tests = [\n        'riG   rePEAT copies  put mo   rest    types   fup.    6      poweRin',\n        ''\n    ]\n\n    print(\n        fTable(__doc__ + ':\\n')(lambda s: \"'\" + s + \"'\")(\n            lambda s: \"\\n\\t'\" + s + \"'\"\n        )(withExpansions(table))(tests)\n    )\n\n\n# GENERIC -------------------------------------------------\n\n# compose (<<<) :: (b -> c) -> (a -> b) -> a -> c\ndef compose(g):\n    '''Right to left function composition.'''\n    return lambda f: lambda x: g(f(x))\n\n\n# Just :: a -> Maybe a\ndef Just(x):\n    '''Constructor for an inhabited Maybe (option type) value.'''\n    return {'type': 'Maybe', 'Nothing': False, 'Just': x}\n\n\n# Nothing :: Maybe a\ndef Nothing():\n    '''Constructor for an empty Maybe (option type) value.'''\n    return {'type': 'Maybe', 'Nothing': True}\n\n\n# find :: (a -> Bool) -> [a] -> Maybe a\ndef find(p):\n    '''Just the first element in the list that matches p,\n       or Nothing if no elements match.'''\n    def go(xs):\n        for x in xs:\n            if p(x):\n                return Just(x)\n        return Nothing()\n    return lambda xs: go(xs)\n\n\n# fst :: (a, b) -> a\ndef fst(tpl):\n    '''First member of a pair.'''\n    return tpl[0]\n\n\n# fTable :: String -> (a -> String)\n#                  -> (b -> String) -> (a -> b) -> [a] -> String\ndef fTable(s):\n    '''Heading -> x display function ->\n                 fx display function ->\n          f -> value list -> tabular string.'''\n    def go(xShow, fxShow, f, xs):\n        w = max(map(compose(len)(xShow), xs))\n        return s + '\\n' + '\\n'.join([\n            xShow(x).rjust(w, ' ') + (' -> ') + fxShow(f(x))\n            for x in xs\n        ])\n    return lambda xShow: lambda fxShow: lambda f: lambda xs: go(\n        xShow, fxShow, f, xs\n    )\n\n\n# maybe :: b -> (a -> b) -> Maybe a -> b\ndef maybe(v):\n    '''Either the default value v, if m is Nothing,\n       or the application of f to x,\n       where m is Just(x).'''\n    return lambda f: lambda m: v if m.get('Nothing') else (\n        f(m.get('Just'))\n    )\n\n\n# unwords :: [String] -> String\ndef unwords(xs):\n    '''A space-separated string derived from\n       a list of words.'''\n    return ' '.join(xs)\n\n\n# words :: String -> [String]\ndef words(s):\n    '''A list of words delimited by characters\n       representing white space.'''\n    return re.split(r'\\s+', s)\n\n\n# MAIN ---\nif __name__ == '__main__':\n    main()\n"
                }
            ],
            [
                {
                    "language": "SNOBOL4",
                    "solution": "* Program: abbr_simple.sbl\n* To run: sbl abbr_simple.sbl\n* Description: Abbreviations, simple\n* Comment: Tested using the Spitbol for Linux version of SNOBOL4\n\n\tcommands =\n+   \"add 1  alter 3  backup 2  bottom 1  Cappend 2  change 1  Schange  Cinsert 2  Clast 3 \"\n+   \"compress 4 copy 2 count 3 Coverlay 3 cursor 3  delete 3 Cdelete 2  down 1  duplicate \"\n+   \"3 xEdit 1 expand 3 extract 3  find 1 Nfind 2 Nfindup 6 NfUP 3 Cfind 2 findUP 3 fUP 2 \"\n+   \"forward 2  get  help 1 hexType 4  input 1 powerInput 3  join 1 split 2 spltJOIN load \"\n+   \"locate 1 Clocate 2 lowerCase 3 upperCase 3 Lprefix 2  macro  merge 2 modify 3 move 2 \"\n+   \"msg  next 1 overlay 1 parse preserve 4 purge 3 put putD query 1 quit  read recover 3 \"\n+   \"refresh renum 3 repeat 3 replace 1 Creplace 2 reset 3 restore 4 rgtLEFT right 2 left \"\n+   \"2  save  set  shift 2  si  sort  sos  stack 3 status 4 top  transfer 3  type 1  up 1 \"\n\n\tcommands = replace(commands,&lcase,&ucase)\n\tnumerals = '0123456789'\n\n\n* Function filltable will fill the command abbreviations table\n\tdefine(\"filltable(s,n)slen,i\")\n\t\tct = table(300, ,\"*error*\") :f(errr);* command abbreviations table\n\t:(filltable_end)\nfilltable\n\tslen = size(s)\n\tct[s] = s\n\teq(n,slen) :s(filltable3)\n\ti = n - 1\nfilltable2\n\ti = lt(i,slen - 1) i + 1 :f(filltable3)\n\tct[substr(s,1,i)] = s\n\t:(filltable2)\nfilltable3\n\tfilltable = \"\"\n\t:(return)\nfilltable_end\n\n\nx0\n* Populate command abbreviations table\n\tcommands ? (span(' ') | \"\") breakx(&ucase) span(&ucase) . c\n+\t\tspan(' ') (span(numerals) | \"\") . ablen = \"\" :f(x1)\n\tablen = ident(ablen) size(c)\n\tret = filltable(c,ablen)\n    :(x0)\nx1\n* Process user string\n\tuserstring = \"riG   rePEAT copies  put mo   rest    types   fup.    6       poweRin\"\n\toutput = \"Original user string:\"\n\toutput = userstring\n\tuserstring = replace(userstring,&lcase,&ucase)\nx2\n\tuserstring ? (span(' ') | \"\") (break(' ') | (len(1) rem)) . c = \"\" :f(x3)\n\tuser_commands = (gt(size(user_commands),0) user_commands ' ' ct[c], ct[c])\n\t:(x2)\nx3\n\toutput = \"\"\n\toutput = \"User string with abbreviations expanded:\"\n\toutput = user_commands\n\nEND\n"
                },
                {
                    "language": "REXX",
                    "solution": "/*REXX program validates a user  \"word\"  against a  \"command table\"  with abbreviations.*/\nParse Arg uw                                     /*obtain optional arguments from the CL*/\nIf uw='' Then uw= 'riG   rePEAT copies  put mo   rest    types   fup.    6       poweRin'\nSay 'user words: '   uw\n\nkeyws= 'add 1  alter 3  backup 2  bottom 1  Cappend 2  change 1  Schange  Cinsert 2  Clast 3',\n   'compress 4 copy 2 count 3 Coverlay 3 cursor 3  delete 3 Cdelete 2  down 1  duplicate',\n   '3 xEdit 1 expand 3 extract 3  find 1 Nfind 2 Nfindup 6 NfUP 3 Cfind 2 findUP 3 fUP 2',\n   'forward 2  get  help 1 hexType 4  input 1 powerInput 3  join 1 split 2 spltJOIN load',\n   'locate 1 Clocate 2 lowerCase 3 upperCase 3 Lprefix 2  macro  merge 2 modify 3 move 2',\n   'msg  next 1 overlay 1 Parse preserve 4 purge 3 put putD query 1 quit  read recover 3',\n   'refresh renum 3 repeat 3 replace 1 Creplace 2 reset 3 restore 4 rgtLEFT right 2 left',\n   '2  save  set  shift 2  si  sort  sos  stack 3 status 4 top  transfer 3  type 1  up 1'\n\nSay 'full words: ' validate(uw)                /*display the result(s) to the terminal*/\nExit                                             /*stick a fork in it,  we're all done. */\n/*--------------------------------------------------------------------------------------*/\nvalidate: Procedure Expose keyws\n  keyws=translate(keyws)\n  Arg userwords                              /*ARG   capitalizes all the userwords. */\n  res=''                                     /*initialize the Return string to null.*/\n  Do j=1 to words(userwords)                 /* loop over userwords                 */\n    uword=word(userwords,j)                  /*obtain a word from the userword list.*/\n    Do k=1 to words(keyws)                   /* loop over keywords                  */\n      kw=word(keyws,k)                    /*get a legitmate command name from keyws.*/\n      L=word(keyws,k+1)                       /*\u00b7\u00b7\u00b7 and maybe get its abbrev length.*/\n      If datatype(L,'W') Then                 /* it's a number - an abbrev length.  */\n        k=k + 1                               /* skip it for next kw                */\n      Else                                    /* otherwise                          */\n        L=length(kw)                           /*    it can't be abbreviated.        */\n      If abbrev(kw,uword,L) Then Do           /* is valid abbreviation              */\n        res=res kw                            /* add to result string               */\n        Iterate j                             /* proceed with next userword         */\n        End\n      End\n    res=res '*error*'                         /*processed the whole list, not valid */\n    End\n  Return strip(res)                           /* elide superfluous leading blank.   */\n"
                }
            ],
            [
                {
                    "language": "Jq",
                    "solution": "def table:\n    \"add 1  alter 3  backup 2  bottom 1  Cappend 2  change 1  Schange  Cinsert 2  Clast 3 \" +\n    \"compress 4 copy 2 count 3 Coverlay 3 cursor 3  delete 3 Cdelete 2  down 1  duplicate \" +\n    \"3 xEdit 1 expand 3 extract 3  find 1 Nfind 2 Nfindup 6 NfUP 3 Cfind 2 findUP 3 fUP 2 \" +\n    \"forward 2  get  help 1 hexType 4  input 1 powerInput 3  join 1 split 2 spltJOIN load \" +\n    \"locate 1 Clocate 2 lowerCase 3 upperCase 3 Lprefix 2  macro  merge 2 modify 3 move 2 \" +\n    \"msg  next 1 overlay 1 parse preserve 4 purge 3 put putD query 1 quit  read recover 3 \" +\n    \"refresh renum 3 repeat 3 replace 1 Creplace 2 reset 3 restore 4 rgtLEFT right 2 left \" +\n    \"2  save  set  shift 2  si  sort  sos  stack 3 status 4 top  transfer 3  type 1  up 1\"\n;\n\n# Input: {commands, minLens}\n# Output: array of expansions or error markers corresponding to $words\ndef validate($words):\n  .commands as $commands\n  | .minLens as $minLens\n  | [ $words[] as $word\n     | ($word|length) as $wlen\n     | first( range(0; $commands|length) as $i\n         | $commands[$i]\n         | select($minLens[$i] != 0 and $wlen >= $minLens[$i] and $wlen <= length)\n         | ascii_upcase\n         | select(startswith(($word|ascii_upcase))) )\n       // \"*error*\" ];\n\n\n# Output: {commands, minLens} corresponding to the $table string\ndef commands($table):\n  [$table|splits(\"  *\")] as $split_table\n  | ($split_table|length) as $slen\n  | {commands:[], minLens:[], i:0}\n  | until(.found;\n      .commands += [ $split_table[.i] ]\n      | ($split_table[.i]|length) as $len\n      | if (.i == $slen - 1)\n        then .minLens += [$len]\n        | .found = true\n        else .\n        end\n      | .i += 1\n      | ($split_table[.i] | try (tonumber) // null) as $num\n      | if ($num != null)\n        then .minLens += [ if ($num < $len) then $num else $len end ]\n        | .i += 1\n        | if (.i == $slen) then .found = true else . end\n        else .minLens += [$len]\n        end );\n\ndef lpad($len): tostring | ($len - length) as $l | (\" \" * $l)[:$l] + .;\n\ndef task($sentence):\n  [$sentence | splits(\"  *\")] as $words\n  | commands(table)\n  | validate($words)\n  | $words, .\n  | map(lpad(10))\n  | join(\" \") ;\n\ntask(\"riG   rePEAT copies  put mo   rest    types   fup.    6       poweRin\")\n"
                },
                {
                    "language": "ALGOL-68",
                    "solution": "# \"Simple\" abbreviations                                               #\n\n# returns the next word from text, updating pos                        #\nPRIO NEXTWORD = 1;\nOP   NEXTWORD = ( REF INT pos, STRING text )STRING:\n     BEGIN\n        # skip spaces #\n        WHILE IF pos > UPB text THEN FALSE ELSE text[ pos ] = \" \" FI DO pos +:= 1 OD;\n        # get the word #\n        STRING word := \"\";\n        WHILE IF pos > UPB text THEN FALSE ELSE text[ pos ] /= \" \" FI DO\n            word +:= text[ pos ];\n            pos +:= 1\n        OD;\n        word\n     END # NEXTWORD # ;\n# returns text converted to upper case                                 #\nOP   TOUPPER  = ( STRING text )STRING:\n     BEGIN\n        STRING result := text;\n        FOR ch pos FROM LWB result TO UPB result DO\n            IF is lower( result[ ch pos ] ) THEN result[ ch pos ] := to upper( result[ ch pos ] ) FI\n        OD;\n        result\n     END # TOUPPER # ;\n# returns text converted to an INT or -1 if text is not a number         #\nOP   TOINT    = ( STRING text )INT:\n     BEGIN\n        INT  result     := 0;\n        BOOL is numeric := TRUE;\n        FOR ch pos FROM UPB text BY -1 TO LWB text WHILE is numeric DO\n            CHAR c = text[ ch pos ];\n            is numeric := ( c >= \"0\" AND c <= \"9\" );\n            IF is numeric THEN ( result *:= 10 ) +:= ABS c - ABS \"0\" FI\n        OD;\n        IF is numeric THEN result ELSE -1 FI\n     END # TOINT # ;\n# returns the length of word                                             #\nOP LENGTH = ( STRING word )INT: 1 + ( UPB word - LWB word );\n# counts the number of commands in commands                              #\nPROC count commands = ( STRING commands )INT:\n     BEGIN\n        INT    result         := 0;\n        INT    pos            := LWB commands;\n        WHILE  STRING command := pos NEXTWORD commands; command /= \"\" DO\n            IF TOINT command < 0 THEN\n                # not an abbreviation length                             #\n                result +:= 1\n            FI\n        OD;\n        result\n     END # count commands # ;\n\n# list of \"commands\" -  the words are optionally followed by the minimum #\n#                       length of abbreviation - if there isn't a number #\n#                       the command can only appear in full              #\nSTRING commands\n   = \"add 1  alter 3  backup 2  bottom 1  Cappend 2  change 1  Schange  Cinsert 2  Clast 3 \"\n   + \"compress 4 copy 2 count 3 Coverlay 3 cursor 3  delete 3 Cdelete 2  down 1  duplicate \"\n   + \"3 xEdit 1 expand 3 extract 3  find 1 Nfind 2 Nfindup 6 NfUP 3 Cfind 2 findUP 3 fUP 2 \"\n   + \"forward 2  get  help 1 hexType 4  input 1 powerInput 3  join 1 split 2 spltJOIN load \"\n   + \"locate 1 Clocate 2 lowerCase 3 upperCase 3 Lprefix 2  macro  merge 2 modify 3 move 2 \"\n   + \"msg  next 1 overlay 1 parse preserve 4 purge 3 put putD query 1 quit  read recover 3 \"\n   + \"refresh renum 3 repeat 3 replace 1 Creplace 2 reset 3 restore 4 rgtLEFT right 2 left \"\n   + \"2  save  set  shift 2  si  sort  sos  stack 3 status 4 top  transfer 3  type 1  up 1 \"\n   ;\n# build the tables of the commands and their minimum lengths             #\nPROC load commands = ( STRING commands )VOID:\n     BEGIN\n        INT    cmd pos        := 0;\n        INT    pos            := LWB command table;\n        WHILE  STRING command := pos NEXTWORD commands; command /= \"\" DO\n            INT len := TOINT command;\n            IF len >= 0 THEN\n                # have an abbreviation length                            #\n                IF cmd pos > 0 THEN min abbreviation[ cmd pos ] := len FI\n            ELSE\n                # new command                                            #\n                cmd pos +:= 1;\n                command table[    cmd pos ] := TOUPPER command;\n                min abbreviation[ cmd pos ] := LENGTH  command\n            FI\n        OD\n     END # load commands # ;\n# searches for word in command table and returns the full command      #\n# matching the possible abbreviation or *error* if there is no match   #\nOP   EXPAND  = ( STRING word )STRING:\n     IF word = \"\"\n     THEN # empty word #\n        \"\"\n     ELSE # non-empty word #\n        INT    word len    = LENGTH word;\n        STRING upper word := TOUPPER word;\n        STRING result     := \"*error*\";\n        FOR cmd pos FROM LWB command table TO UPB command table\n        WHILE  STRING command := command table[ cmd pos ];\n               IF word len < min abbreviation[ cmd pos ] OR word len > LENGTH command\n               THEN # word is too short or too long - try the next command #\n                   TRUE\n               ELIF upper word = command[ LWB command : ( LWB command - 1 ) + word len ]\n               THEN # found the command #\n                   result := command;\n                   FALSE\n               ELSE # word doexn't match - try the next command #\n                   TRUE\n               FI\n        DO SKIP OD;\n        result\n     FI # EXPAND # ;\n\n# tests the EXPAND operator                                            #\nPROC test expand = ( STRING words )VOID:\n     BEGIN\n        STRING results := \"\", separator := \"\";\n        INT    pos   := LWB words;\n        WHILE STRING word = pos NEXTWORD words; word /= \"\" DO\n            results +:= separator + EXPAND word;\n            separator := \" \"\n        OD;\n        print( ( \"Input:  \", words, newline ) );\n        print( ( \"Output: \", results, newline ) )\n     END # test expand # ;\n\n# build the command table                                              #\n[ 1 : count commands( commands ) ]STRING command table;\n[ 1 : UPB command table          ]INT    min abbreviation;\nload commands( commands );\n\n# task test cases                                                      #\ntest expand( \"riG   rePEAT copies  put mo   rest    types   fup.    6       poweRin\" )\n"
                }
            ],
            [
                {
                    "language": "Ada",
                    "solution": "with Ada.Characters.Handling;\nwith Ada.Containers.Vectors;\nwith Ada.Strings.Fixed;\nwith Ada.Strings.Maps.Constants;\nwith Ada.Strings.Unbounded;\nwith Ada.Text_IO;\n\nprocedure Abbreviations_Simple is\n\n   use Ada.Strings.Unbounded;\n   subtype Ustring is Unbounded_String;\n\n   type Word_Entry is record\n      Word : Ustring;\n      Min  : Natural;\n   end record;\n\n   package Command_Vectors\n   is new Ada.Containers.Vectors (Index_Type   => Positive,\n                                  Element_Type => Word_Entry);\n\n   Commands      : Command_Vectors.Vector;\n   Last_Word     : Ustring;\n   Last_Was_Word : Boolean := False;\n\n   procedure Append (Word_List : String) is\n      use Ada.Strings;\n\n      function Is_Word (Item : String) return Boolean\n      is (Fixed.Count (Item, Maps.Constants.Letter_Set) /= 0);\n\n      procedure Process (Token : String) is\n      begin\n         if Is_Word (Token) then\n            if Last_Was_Word then\n               Commands.Append ((Word => Last_Word,\n                                 Min  => Length (Last_Word)));\n            end if;\n            Last_Word     := To_Unbounded_String (Token);\n            Last_Was_Word := True;\n\n         else  -- Token is expected to be decimal\n            Commands.Append ((Word => Last_Word,\n                              Min  => Natural'Value (Token)));\n            Last_Was_Word := False;\n         end if;\n      end Process;\n\n      Token_First : Positive := Word_List'First;\n      Token_Last  : Natural;\n   begin\n      while Token_First in Word_List'Range loop\n\n         Fixed.Find_Token (Word_List, Maps.Constants.Alphanumeric_Set,\n                           Token_First, Inside,\n                           Token_First, Token_Last);\n         exit when Token_Last = 0;\n\n         Process (Word_List (Token_First .. Token_Last));\n\n         Token_First := Token_Last + 1;\n      end loop;\n   end Append;\n\n   function Match (Word : String) return String is\n      use Ada.Characters.Handling;\n      use Ada.Strings.Fixed;\n      Result : Ustring := To_Unbounded_String (\"*error*\");\n      Min    : Natural := 0;\n      Upper_Word : constant String := To_Upper (Word);\n   begin\n      if Upper_Word = \"\" then\n         return \"\";\n      end if;\n\n      for Candidate of Commands loop\n         declare\n            Upper_Cand : constant String  := To_Upper (To_String (Candidate.Word));\n            Length     : constant Natural := Natural'Max (Candidate.Min,\n                                                          Upper_Word'Length);\n            Upper_Abbrev_Cand : constant String := Head (Upper_Cand, Length);\n            Upper_Abbrev_Word : constant String := Head (Upper_Word, Length);\n         begin\n            if Upper_Word = Upper_Cand\n              and then Upper_Word'Length > Min\n            then\n               Result := To_Unbounded_String (Upper_Cand);\n               Min    := Upper_Word'Length;\n            elsif Upper_Abbrev_Word = Upper_Abbrev_Cand\n              and then Upper_Abbrev_Word'Length > Min\n            then\n               Result := To_Unbounded_String (Upper_Cand);\n               Min    := Upper_Abbrev_Word'Length;\n            end if;\n         end;\n      end loop;\n      return To_String (Result);\n   end Match;\n\n   procedure Put_Match (To : String) is\n      use Ada.Text_IO;\n   begin\n      Put (\"Match to '\");  Put (To);\n      Put (\"' is '\");      Put (Match (To));\n      Put_Line (\"'\");\n   end Put_Match;\n\n   procedure A (Item : String) renames Append;\nbegin\n   A (\"add 1  alter 3  backup 2  bottom 1  Cappend 2  change 1  Schange  Cinsert 2  Clast 3\");\n   A (\"compress 4 copy 2 count 3 Coverlay 3 cursor 3  delete 3 Cdelete 2  down 1  duplicate\");\n   A (\"3 xEdit 1 expand 3 extract 3  find 1 Nfind 2 Nfindup 6 NfUP 3 Cfind 2 findUP 3 fUP 2\");\n   A (\"forward 2  get  help 1 hexType 4  input 1 powerInput 3  join 1 split 2 spltJOIN load\");\n   A (\"locate 1 Clocate 2 lowerCase 3 upperCase 3 Lprefix 2  macro  merge 2 modify 3 move 2\");\n   A (\"msg  next 1 overlay 1 parse preserve 4 purge 3 put putD query 1 quit  read recover 3\");\n   A (\"refresh renum 3 repeat 3 replace 1 Creplace 2 reset 3 restore 4 rgtLEFT right 2 left\");\n   A (\"2  save  set  shift 2  si  sort  sos  stack 3 status 4 top  transfer 3  type 1  up 1\");\n\n   Put_Match (\"riG\");\n   Put_Match (\"rePEAT\");\n   Put_Match (\"copies\");\n   Put_Match (\"put\");\n   Put_Match (\"mo\");\n   Put_Match (\"rest\");\n   Put_Match (\"types\");\n   Put_Match (\"fup.\");\n   Put_Match (\"6\");\n   Put_Match (\"poweRin\");\n   Put_Match (\"\");\nend Abbreviations_Simple;\n"
                },
                {
                    "language": "Raku",
                    "solution": "<\nadd 1  alter 3  backup 2  bottom 1  Cappend 2  change 1  Schange  Cinsert 2  Clast 3\ncompress 4 copy 2 count 3 Coverlay 3 cursor 3  delete 3 Cdelete 2  down 1  duplicate\n3 xEdit 1 expand 3 extract 3  find 1 Nfind 2 Nfindup 6 NfUP 3 Cfind 2 findUP 3 fUP 2\nforward 2  get  help 1 hexType 4  input 1 powerInput 3  join 1 split 2 spltJOIN load\nlocate 1 Clocate 2 lowerCase 3 upperCase 3 Lprefix 2  macro  merge 2 modify 3 move 2\nmsg  next 1 overlay 1 parse preserve 4 purge 3 put putD query 1 quit  read recover 3\nrefresh renum 3 repeat 3 replace 1 Creplace 2 reset 3 restore 4 rgtLEFT right 2 left\n2  save  set  shift 2  si  sort  sos  stack 3 status 4 top  transfer 3  type 1  up 1\n> ~~ m:g/ (<.alpha>+) \\s* (\\d*) /;\n\nmy %abr = '' => '', |$/.map: {\n    my $abbrv = .[0].Str.fc;\n    |map { $abbrv.substr( 0, $_ ) => $abbrv.uc },\n    +(.[1].Str || .[0].Str.chars) .. .[0].Str.chars;\n};\n\nsub abbr-simple ( $str ) { %abr{$str.trim.fc} // '*error*' }\n\n# Testing\nfor 'riG   rePEAT copies  put mo   rest    types   fup.    6       poweRin', '' -> $str {\n    put ' Input: ', $str;\n    put 'Output: ', join ' ', $str.words.map: &abbr-simple;\n}\n"
                }
            ],
            [
                {
                    "language": "ALGOL-68",
                    "solution": "# \"Simple\" abbreviations                                               #\n\n# returns the next word from text, updating pos                        #\nPRIO NEXTWORD = 1;\nOP   NEXTWORD = ( REF INT pos, STRING text )STRING:\n     BEGIN\n        # skip spaces #\n        WHILE IF pos > UPB text THEN FALSE ELSE text[ pos ] = \" \" FI DO pos +:= 1 OD;\n        # get the word #\n        STRING word := \"\";\n        WHILE IF pos > UPB text THEN FALSE ELSE text[ pos ] /= \" \" FI DO\n            word +:= text[ pos ];\n            pos +:= 1\n        OD;\n        word\n     END # NEXTWORD # ;\n# returns text converted to upper case                                 #\nOP   TOUPPER  = ( STRING text )STRING:\n     BEGIN\n        STRING result := text;\n        FOR ch pos FROM LWB result TO UPB result DO\n            IF is lower( result[ ch pos ] ) THEN result[ ch pos ] := to upper( result[ ch pos ] ) FI\n        OD;\n        result\n     END # TOUPPER # ;\n# returns text converted to an INT or -1 if text is not a number         #\nOP   TOINT    = ( STRING text )INT:\n     BEGIN\n        INT  result     := 0;\n        BOOL is numeric := TRUE;\n        FOR ch pos FROM UPB text BY -1 TO LWB text WHILE is numeric DO\n            CHAR c = text[ ch pos ];\n            is numeric := ( c >= \"0\" AND c <= \"9\" );\n            IF is numeric THEN ( result *:= 10 ) +:= ABS c - ABS \"0\" FI\n        OD;\n        IF is numeric THEN result ELSE -1 FI\n     END # TOINT # ;\n# returns the length of word                                             #\nOP LENGTH = ( STRING word )INT: 1 + ( UPB word - LWB word );\n# counts the number of commands in commands                              #\nPROC count commands = ( STRING commands )INT:\n     BEGIN\n        INT    result         := 0;\n        INT    pos            := LWB commands;\n        WHILE  STRING command := pos NEXTWORD commands; command /= \"\" DO\n            IF TOINT command < 0 THEN\n                # not an abbreviation length                             #\n                result +:= 1\n            FI\n        OD;\n        result\n     END # count commands # ;\n\n# list of \"commands\" -  the words are optionally followed by the minimum #\n#                       length of abbreviation - if there isn't a number #\n#                       the command can only appear in full              #\nSTRING commands\n   = \"add 1  alter 3  backup 2  bottom 1  Cappend 2  change 1  Schange  Cinsert 2  Clast 3 \"\n   + \"compress 4 copy 2 count 3 Coverlay 3 cursor 3  delete 3 Cdelete 2  down 1  duplicate \"\n   + \"3 xEdit 1 expand 3 extract 3  find 1 Nfind 2 Nfindup 6 NfUP 3 Cfind 2 findUP 3 fUP 2 \"\n   + \"forward 2  get  help 1 hexType 4  input 1 powerInput 3  join 1 split 2 spltJOIN load \"\n   + \"locate 1 Clocate 2 lowerCase 3 upperCase 3 Lprefix 2  macro  merge 2 modify 3 move 2 \"\n   + \"msg  next 1 overlay 1 parse preserve 4 purge 3 put putD query 1 quit  read recover 3 \"\n   + \"refresh renum 3 repeat 3 replace 1 Creplace 2 reset 3 restore 4 rgtLEFT right 2 left \"\n   + \"2  save  set  shift 2  si  sort  sos  stack 3 status 4 top  transfer 3  type 1  up 1 \"\n   ;\n# build the tables of the commands and their minimum lengths             #\nPROC load commands = ( STRING commands )VOID:\n     BEGIN\n        INT    cmd pos        := 0;\n        INT    pos            := LWB command table;\n        WHILE  STRING command := pos NEXTWORD commands; command /= \"\" DO\n            INT len := TOINT command;\n            IF len >= 0 THEN\n                # have an abbreviation length                            #\n                IF cmd pos > 0 THEN min abbreviation[ cmd pos ] := len FI\n            ELSE\n                # new command                                            #\n                cmd pos +:= 1;\n                command table[    cmd pos ] := TOUPPER command;\n                min abbreviation[ cmd pos ] := LENGTH  command\n            FI\n        OD\n     END # load commands # ;\n# searches for word in command table and returns the full command      #\n# matching the possible abbreviation or *error* if there is no match   #\nOP   EXPAND  = ( STRING word )STRING:\n     IF word = \"\"\n     THEN # empty word #\n        \"\"\n     ELSE # non-empty word #\n        INT    word len    = LENGTH word;\n        STRING upper word := TOUPPER word;\n        STRING result     := \"*error*\";\n        FOR cmd pos FROM LWB command table TO UPB command table\n        WHILE  STRING command := command table[ cmd pos ];\n               IF word len < min abbreviation[ cmd pos ] OR word len > LENGTH command\n               THEN # word is too short or too long - try the next command #\n                   TRUE\n               ELIF upper word = command[ LWB command : ( LWB command - 1 ) + word len ]\n               THEN # found the command #\n                   result := command;\n                   FALSE\n               ELSE # word doexn't match - try the next command #\n                   TRUE\n               FI\n        DO SKIP OD;\n        result\n     FI # EXPAND # ;\n\n# tests the EXPAND operator                                            #\nPROC test expand = ( STRING words )VOID:\n     BEGIN\n        STRING results := \"\", separator := \"\";\n        INT    pos   := LWB words;\n        WHILE STRING word = pos NEXTWORD words; word /= \"\" DO\n            results +:= separator + EXPAND word;\n            separator := \" \"\n        OD;\n        print( ( \"Input:  \", words, newline ) );\n        print( ( \"Output: \", results, newline ) )\n     END # test expand # ;\n\n# build the command table                                              #\n[ 1 : count commands( commands ) ]STRING command table;\n[ 1 : UPB command table          ]INT    min abbreviation;\nload commands( commands );\n\n# task test cases                                                      #\ntest expand( \"riG   rePEAT copies  put mo   rest    types   fup.    6       poweRin\" )\n"
                },
                {
                    "language": "Delphi",
                    "solution": "program Abraviation_simple;\n\n{$APPTYPE CONSOLE}\n\nuses\n  System.SysUtils;\n\ntype\n  TCommand = record\n    value: string;\n    len: integer;\n  end;\n\nfunction ReadTable(table: string): TArray<TCommand>;\nbegin\n  var fields := table.Split([' '], TStringSplitOptions.ExcludeEmpty);\n  var i := 0;\n  var max := Length(fields);\n  while i < max do\n  begin\n    var cmd := fields[i];\n    var cmdLen := cmd.Length;\n    inc(i);\n\n    if i < max then\n    begin\n      var num: Integer;\n      if TryStrToInt(fields[i], num) and (1 <= num) and (num < cmdLen) then\n      begin\n        cmdLen := num;\n        inc(i);\n      end;\n    end;\n\n    SetLength(result, Length(result) + 1);\n    with result[High(result)] do\n    begin\n      value := cmd;\n      len := cmdLen;\n    end;\n  end;\nend;\n\nfunction ValidateCommands(Commands: TArray<TCommand>; Words: TArray<string>):\n  TArray<string>;\nbegin\n  SetLength(result, 0);\n  for var wd in Words do\n  begin\n    var matchFound := false;\n    var wLen := wd.Length;\n    for var i := 0 to High(Commands) do\n    begin\n      var command := Commands[i];\n      if (command.len = 0) or (wLen < command.len) or (wLen > command.value.Length) then\n        Continue;\n      var c := command.value.ToUpper;\n      var w := wd.ToUpper;\n      if c.StartsWith(w) then\n      begin\n        SetLength(result, Length(result) + 1);\n        result[High(result)] := c;\n        matchFound := true;\n        Break;\n      end;\n    end;\n    if not matchFound then\n    begin\n      SetLength(result, Length(result) + 1);\n      result[High(result)] := '*error*';\n    end;\n  end;\nend;\n\nprocedure PrintResults(words, results: TArray<string>);\nbegin\n  Writeln('user words:');\n  for var w in words do\n    write(^I, w);\n  Writeln(#10, 'full words:'^I, string.join(^I, results));\nend;\n\nconst\n  table = '' +\n    'add 1  alter 3  backup 2  bottom 1  Cappend 2  change 1  Schange  Cinsert 2  Clast 3 ' +\n    'compress 4 copy 2 count 3 Coverlay 3 cursor 3  delete 3 Cdelete 2  down 1  duplicate ' +\n    '3 xEdit 1 expand 3 extract 3  find 1 Nfind 2 Nfindup 6 NfUP 3 Cfind 2 findUP 3 fUP 2 ' +\n    'forward 2  get  help 1 hexType 4  input 1 powerInput 3  join 1 split 2 spltJOIN load ' +\n    'locate 1 Clocate 2 lowerCase 3 upperCase 3 Lprefix 2  macro  merge 2 modify 3 move 2 ' +\n    'msg  next 1 overlay 1 parse preserve 4 purge 3 put putD query 1 quit  read recover 3 ' +\n    'refresh renum 3 repeat 3 replace 1 Creplace 2 reset 3 restore 4 rgtLEFT right 2 left ' +\n    '2  save  set  shift 2  si  sort  sos  stack 3 status 4 top  transfer 3  type 1  up 1 ';\n\nconst\n  SENTENCE = 'riG   rePEAT copies  put mo   rest    types   fup.    6       poweRin';\n\nbegin\n  var Commands := ReadTable(table);\n  var Words := SENTENCE.Split([' '], TStringSplitOptions.ExcludeEmpty);\n\n  var results := ValidateCommands(Commands, Words);\n\n  PrintResults(Words, results);\n\n  Readln;\nend.\n"
                }
            ]
        ]
    },
    {
        "task_name": "ABC-problem",
        "task_description": "You are given a collection of ABC blocks &nbsp; (maybe like the ones you had when you were a kid).  \n\nThere are twenty blocks with two letters on each block. \n\nA complete alphabet is guaranteed amongst all sides of the blocks. \n\nThe sample collection of blocks: \n  (B O)\n  (X K)\n  (D Q)\n  (C P)\n  (N A)\n  (G T)\n  (R E)\n  (T G)\n  (Q D)\n  (F S)\n  (J W)\n  (H U)\n  (V I)\n  (A N)\n  (O B)\n  (E R)\n  (F S)\n  (L Y)\n  (P C)\n  (Z M)\n\n\n;Task:\nWrite a function that takes a string (word) and determines whether the word can be spelled with the given collection of blocks. \n\n\nThe rules are simple:\n::# &nbsp; Once a letter on a block is used that block cannot be used again\n::# &nbsp; The function should be case-insensitive\n::# &nbsp; Show the output on this page for the following 7 words in the following example\n\n\n;Example:\n<syntaxhighlight lang=\"python\">    >>> can_make_word(\"A\")\n    True\n    >>> can_make_word(\"BARK\")\n    True\n    >>> can_make_word(\"BOOK\")\n    False\n    >>> can_make_word(\"TREAT\")\n    True\n    >>> can_make_word(\"COMMON\")\n    False\n    >>> can_make_word(\"SQUAD\")\n    True\n    >>> can_make_word(\"CONFUSE\")\n    True</syntaxhighlight>\n\n{{Template:Strings}}\n<br><br>\n\n",
        "solution_pairs": [
            [
                {
                    "language": "UTFool",
                    "solution": "\u00b7\u00b7\u00b7\nhttp://rosettacode.org/wiki/ABC_Problem\n\u00b7\u00b7\u00b7\nimport java.util.Arrays\nimport java.util.Collections\nimport java.util.List\n\u25a0 ABC\n  \u00a7 static\n    \u25b6 main\n    \u2022 args\u2982   String[]\n      blocks\u2982 List\u27e8String\u27e9:\n              Arrays.asList \"BO\", \"XK\", \"DQ\", \"CP\", \"NA\",\n                            \"GT\", \"RE\", \"TG\", \"QD\", \"FS\",\n                            \"JW\", \"HU\", \"VI\", \"AN\", \"OB\",\n                            \"ER\", \"FS\", \"LY\", \"PC\", \"ZM\"\n      words\u2982  List\u27e8String\u27e9:\n              Arrays.asList \"A\", \"BARK\", \"BOOK\", \"TREAT\",\n                            \"COMMON\", \"SQUAD\", \"CONFUSE\"\n      for each word in words\n        System.out.println \"\u2e28word\u2e29: \u2e28canMakeWord word, blocks\u2e29\"\n\n    \u25b6 canMakeWord\u2982 boolean\n    \u2022 word\u2982 String\n    \u2022 blocks\u2982 List\u27e8String\u27e9\n      if word.isEmpty\u00b0\n         return true\n      for each block #i in blocks\u2982 String\n          if 0 \u2264 block.indexOf word.charAt 0\n             Collections.swap blocks, 0, i\n             if canMakeWord (word.substring 1),\n                             blocks.subList 1, blocks.size\u00b0\n                return true\n             Collections.swap blocks, 0, i\n      return false\n"
                },
                {
                    "language": "PureBasic",
                    "solution": "#LETTERS = \"BO XK DQ CP NA GT RE TG QD FS JW HU VI AN OB ER FS LY PC ZM \"\n\nMacro test(t)\n  Print(t+#TAB$+#TAB$+\"= \") : If can_make_word(t) : PrintN(\"True\") : Else : PrintN(\"False\") : EndIf\nEndMacro\n\nProcedure.s residue(s$,n.i)\n  ProcedureReturn Left(s$,Int(n/3)*3)+Mid(s$,Int(n/3)*3+4)\nEndProcedure\n\nProcedure.b can_make_word(word$,letters$=#LETTERS)\n  n=FindString(letters$,Left(word$,1),1,#PB_String_NoCase)\n  If Len(word$) And n : ProcedureReturn can_make_word(Mid(word$,2),residue(letters$,n)) : EndIf\n  If Not Len(word$)   : ProcedureReturn #True : Else : ProcedureReturn #False           : EndIf\nEndProcedure\n\nOpenConsole()\ntest(\"a\")         : test(\"BaRK\")      : test(\"BOoK\")      : test(\"TREAt\")\ntest(\"cOMMON\")    : test(\"SqUAD\")     : test(\"COnFUSE\")\nInput()\n"
                }
            ],
            [
                {
                    "language": "BASIC256",
                    "solution": "arraybase 1\nblocks$   = \"BO,XK,DQ,CP,NA,GT,RE,TG,QD,FS,JW,HU,VI,AN,OB,ER,FS,LY,PC,ZM\"\nmakeWord$ = \"A,BARK,BOOK,TREAT,COMMON,SQUAD,Confuse\"\nb         = int((length(blocks$) /3) +  1)\ndim blk$(b)\n\nfor i = 1 to length(makeWord$)\n\twrd$ = word$(makeWord$,i,\",\")\n\tdim hit(b)\n\tn = 0\n\tif wrd$ = \"\" then exit for\n\tfor k = 1 to length(wrd$)\n\t\tw$ = upper(mid(wrd$,k,1))\n\t\tfor j = 1 to b\n\t\t\tif hit[j] = 0 then\n\t\t\t\tif w$ = left(word$(blocks$,j,\",\"),1) or w$ = right(word$(blocks$,j,\",\"),1) then\n\t\t\t\t\thit[j] = 1\n\t\t\t\t\tn += 1\n\t\t\t\t\texit for\n\t\t\t\tend if\n\t\t\tend if\n\t\tnext j\n\tnext k\n\tprint wrd$; chr(9);\n\tif n = length(wrd$) then print \" True\" else print \" False\"\nnext i\nend\n\nfunction word$(sr$, wn, delim$)\n\tj = wn\n\tif j = 0 then j += 1\n\tres$ = \"\" : s$ = sr$ : d$ = delim$\n\tif d$ = \"\" then d$ = \" \"\n\tsd = length(d$) : sl = length(s$)\n\twhile true\n\t\tn = instr(s$,d$) : j -= 1\n\t\tif j = 0 then\n\t\t\tif n = 0 then res$ = s$ else res$ = mid(s$,1,n-1)\n\t\t\treturn res$\n\t\tend if\n\t\tif n = 0 then return res$\n\t\tif n = sl - sd then res$ = \"\" : return res$\n\t\tsl2 = sl-n : s$ = mid(s$,n+1,sl2) : sl = sl2\n\tend while\n\treturn res$\nend function\n"
                },
                {
                    "language": "Raku",
                    "solution": "multi can-spell-word(Str $word, @blocks) {\n    my @regex = @blocks.map({ my @c = .comb; rx/<@c>/ }).grep: { .ACCEPTS($word.uc) }\n    can-spell-word $word.uc.comb.list, @regex;\n}\n\nmulti can-spell-word([$head,*@tail], @regex) {\n    for @regex -> $re {\n        if $head ~~ $re {\n            return True unless @tail;\n            return False if @regex == 1;\n            return True if can-spell-word @tail, list @regex.grep: * !=== $re;\n        }\n    }\n    False;\n}\n\nmy @b = <BO XK DQ CP NA GT RE TG QD FS JW HU VI AN OB ER FS LY PC ZM>;\n\nfor <A BaRK BOoK tREaT COmMOn SqUAD CoNfuSE> {\n    say \"$_     &can-spell-word($_, @b)\";\n}\n"
                }
            ],
            [
                {
                    "language": "Java",
                    "solution": "import java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class ABC {\n\n    public static void main(String[] args) {\n        List<String> blocks = Arrays.asList(\n                \"BO\", \"XK\", \"DQ\", \"CP\", \"NA\",\n                \"GT\", \"RE\", \"TG\", \"QD\", \"FS\",\n                \"JW\", \"HU\", \"VI\", \"AN\", \"OB\",\n                \"ER\", \"FS\", \"LY\", \"PC\", \"ZM\");\n\n        for (String word : Arrays.asList(\"\", \"A\", \"BARK\", \"BOOK\", \"TREAT\", \"COMMON\", \"SQUAD\", \"CONFUSE\")) {\n            System.out.printf(\"%s: %s%n\", word.isEmpty() ? \"\\\"\\\"\" : word, canMakeWord(word, blocks));\n        }\n    }\n\n    public static boolean canMakeWord(String word, List<String> blocks) {\n        if (word.isEmpty())\n            return true;\n\n        char c = word.charAt(0);\n        for (int i = 0; i < blocks.size(); i++) {\n            String b = blocks.get(i);\n            if (b.charAt(0) != c && b.charAt(1) != c)\n                continue;\n            Collections.swap(blocks, 0, i);\n            if (canMakeWord(word.substring(1), blocks.subList(1, blocks.size())))\n                return true;\n            Collections.swap(blocks, 0, i);\n        }\n\n        return false;\n    }\n}\n"
                },
                {
                    "language": "Dyalect",
                    "solution": "func blockable(str) {\n    var blocks = [\n        \"BO\", \"XK\", \"DQ\", \"CP\", \"NA\", \"GT\", \"RE\", \"TG\", \"QD\", \"FS\",\n        \"JW\", \"HU\", \"VI\", \"AN\", \"OB\", \"ER\", \"FS\", \"LY\", \"PC\", \"ZM\" ]\n\n    var strUp = str.Upper()\n    var fin = \"\"\n\n    for c in strUp {\n        for j in blocks.Indices() {\n            if blocks[j].StartsWith(c) || blocks[j].EndsWith(c) {\n                fin += c\n                blocks[j] = \"\"\n                break\n            }\n        }\n    }\n\n    return fin == strUp\n}\n\nfunc canOrNot(can) => can ? \"can\" : \"cannot\"\n\nfor str in [ \"A\", \"BARK\", \"BooK\", \"TrEaT\", \"comMON\", \"sQuAd\", \"Confuse\" ] {\n    print(\"\\\"\\(str)\\\" \\(canOrNot(blockable(str))) be spelled with blocks.\")\n}\n"
                }
            ],
            [
                {
                    "language": "Harbour",
                    "solution": "PROCEDURE Main()\n\n   LOCAL cStr\n\n   FOR EACH cStr IN { \"A\", \"BARK\", \"BooK\", \"TrEaT\", \"comMON\", \"sQuAd\", \"Confuse\" }\n      ? PadL( cStr, 10 ), iif( Blockable( cStr ), \"can\", \"cannot\" ), \"be spelled with blocks.\"\n   NEXT\n\n   RETURN\n\nSTATIC FUNCTION Blockable( cStr )\n\n   LOCAL blocks := { ;\n      \"BO\", \"XK\", \"DQ\", \"CP\", \"NA\", \"GT\", \"RE\", \"TG\", \"QD\", \"FS\", ;\n      \"JW\", \"HU\", \"VI\", \"AN\", \"OB\", \"ER\", \"FS\", \"LY\", \"PC\", \"ZM\" }\n\n   LOCAL cFinal := \"\"\n   LOCAL i, j\n\n   cStr := Upper( cStr )\n\n   FOR i := 1 TO Len( cStr )\n      FOR EACH j IN blocks\n         IF SubStr( cStr, i, 1 ) $ j\n            cFinal += SubStr( cStr, i, 1 )\n            j := \"\"\n            EXIT\n         ENDIF\n      NEXT\n   NEXT\n\n   RETURN cFinal == cStr\n"
                },
                {
                    "language": "Bracmat",
                    "solution": "(\n  ( can-make-word\n  =   ABC blocks\n    .       (B O)\n          + (X K)\n          + (D Q)\n          + (C P)\n          + (N A)\n          + (G T)\n          + (R E)\n          + (T G)\n          + (Q D)\n          + (F S)\n          + (J W)\n          + (H U)\n          + (V I)\n          + (A N)\n          + (O B)\n          + (E R)\n          + (F S)\n          + (L Y)\n          + (P C)\n          + (Z M)\n        : ?blocks\n      & ( ABC\n        =   letter blocks A Z\n          .   !arg:(.?)\n            |   !arg:(@(?:%?letter ?arg).?blocks)\n              &   !blocks\n                :   ?\n                  + ?*(? !letter ?:?block)\n                  + (?&ABC$(!arg.!blocks+-1*!block))\n        )\n      &   out\n        $ ( !arg\n            ( ABC$(upp$!arg.!blocks)&yes\n            | no\n            )\n          )\n  )\n& can-make-word'A\n& can-make-word'BARK\n& can-make-word'BOOK\n& can-make-word'TREAT\n& can-make-word'COMMON\n& can-make-word'SQUAD\n& can-make-word'CONFUSE\n);\n"
                }
            ],
            [
                {
                    "language": "Ceylon",
                    "solution": "module rosetta.abc \"1.0.0\" {}\n"
                },
                {
                    "language": "Lang",
                    "solution": "fp.canMakeWord = ($word, $blocks) -> {\n\tif(!$word) {\n\t\treturn 1\n\t}\n\t\n\t$word = fn.toLower($word)\n\t\n\t$c $= $word[0]\n\t$i = 0\n\twhile($i < @$blocks) {\n\t\t$block $= fn.toLower($blocks[$i])\n\t\t\n\t\tif($block[0] != $c && $block[1] != $c) {\t\n\t\t\t$i += 1\n\t\t\t\n\t\t\tcon.continue\n\t\t}\n\t\t\n\t\t$blocksCopy $= ^$blocks\n\t\tfn.listRemoveAt($blocksCopy, $i)\n\t\t\n\t\tif(fp.canMakeWord(fn.substring($word, 1), $blocksCopy)) {\n\t\t\treturn 1\n\t\t}\n\t\t\n\t\t$i += 1\n\t}\n\t\n\treturn 0\n}\n\n$blocks = fn.listOf(BO, XK, DQ, CP, NA, GT, RE, TG, QD, FS, JW, HU, VI, AN, OB, ER, FS, LY, PC, ZM)\n\n$word\nforeach($[word], [\\e, A, BARK, BOOK, TREAT, COMMON, SQUAD, CONFUSE, Treat, cOmMoN]) {\n\tfn.printf(%s: %s%n, $word, fp.canMakeWord($word, $blocks))\n}\n"
                }
            ]
        ]
    },
    {
        "task_name": "Abelian-sandpile-model",
        "task_description": "<br>\nImplement the '''Abelian sandpile model''' also known as '''Bak\u2013Tang\u2013Wiesenfeld model'''. Its history, mathematical definition and properties can be found under its [https://en.wikipedia.org/wiki/Abelian_sandpile_model wikipedia article].\n\nThe task requires the creation of a 2D grid of arbitrary size on which \"piles of sand\" can be placed. Any \"pile\" that has 4 or more sand particles on it ''collapses'', resulting in '''four particles being subtracted from the pile''' and '''distributed among its neighbors.'''\n\nIt is recommended to display the output in some kind of image format, as terminal emulators are usually too small to display images larger than a few dozen characters tall. As an example of how to accomplish this, see the [https://rosettacode.org/wiki/Bitmap/Write_a_PPM_file Bitmap/Write a PPM file] task.<BR>\n[http://www.math.cmu.edu/~wes/sand.html Examples up to 2^30, wow!]<BR>\n[http://www.natureincode.com/code/various/sandpile.html javascript running on web]<BR>\n'''Examples:'''\n\n<pre>\n0 0 0 0 0    0 0 0 0 0\n0 0 0 0 0    0 0 1 0 0\n0 0 4 0 0 -> 0 1 0 1 0\n0 0 0 0 0    0 0 1 0 0\n0 0 0 0 0    0 0 0 0 0\n\n0 0 0 0 0    0 0 0 0 0\n0 0 0 0 0    0 0 1 0 0\n0 0 6 0 0 -> 0 1 2 1 0\n0 0 0 0 0    0 0 1 0 0\n0 0 0 0 0    0 0 0 0 0\n\n0  0 0  0  0    0 0 1 0 0\n0  0 0  0  0    0 2 1 2 0\n0  0 16 0  0 -> 1 1 0 1 1\n0  0 0  0  0    0 2 1 2 0\n0  0 0  0  0    0 0 1 0 0\n</pre>\n",
        "solution_pairs": [
            [
                {
                    "language": "Python",
                    "solution": "[[0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]\n [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]\n [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]\n [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]\n [0. 0. 0. 0.64. 0. 0. 0. 0. 0.]\n [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]\n [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]\n [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]\n [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]\n [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]]\n"
                },
                {
                    "language": "Python",
                    "solution": "import numpy as np\nimport matplotlib.pyplot as plt\n\n\ndef iterate(grid):\n    changed = False\n    for ii, arr in enumerate(grid):\n        for jj, val in enumerate(arr):\n            if val > 3:\n                grid[ii, jj] -= 4\n                if ii > 0:\n                    grid[ii - 1, jj] += 1\n                if ii < len(grid)-1:\n                    grid[ii + 1, jj] += 1\n                if jj > 0:\n                    grid[ii, jj - 1] += 1\n                if jj < len(grid)-1:\n                    grid[ii, jj + 1] += 1\n                changed = True\n    return grid, changed\n\n\ndef simulate(grid):\n    while True:\n        grid, changed = iterate(grid)\n        if not changed:\n            return grid\n\n\nif __name__ == '__main__':\n    start_grid = np.zeros((10, 10))\n    start_grid[4:5, 4:5] = 64\n    final_grid = simulate(start_grid.copy())\n    plt.figure()\n    plt.gray()\n    plt.imshow(start_grid)\n    plt.figure()\n    plt.gray()\n    plt.imshow(final_grid)\n"
                }
            ],
            [
                {
                    "language": "OCaml",
                    "solution": "module Make =\n  functor (M : sig val m : int val n : int end)\n  -> struct\n\n    let grid = Array.init M.m (fun _ -> Array.make M.n 0)\n\n    let print () =\n      for i = 0 to M.m - 1\n      do for j = 0 to M.n - 1\n         do Printf.printf \"%d \" grid.(i).(j)\n         done\n       ; print_newline ()\n       done\n\n    let unstable = Hashtbl.create 10\n\n    let add_grain x y\n      = grid.(x).(y) <- grid.(x).(y) + 1\n      ; if grid.(x).(y) >= 4 then\n          Hashtbl.replace unstable (x,y) () (* Use Hashtbl.replace for uniqueness *)\n\n    let topple x y\n      = grid.(x).(y) <- grid.(x).(y) - 4\n      ; if grid.(x).(y) < 4\n        then Hashtbl.remove unstable (x,y)\n      ; match (x,y) with\n        (* corners *)\n        | (0,0) -> add_grain 1 0\n                 ; add_grain 0 1\n        | (0,n) when n = M.n - 1\n          -> add_grain 1 n\n           ; add_grain 0 (n-1)\n        | (m,0) when m = M.m - 1\n          -> add_grain m 1\n           ; add_grain (m-1) 0\n        | (m,n) when m = M.m - 1 && n = M.n - 1\n          -> add_grain ( m ) (n-1)\n           ; add_grain (m-1) ( n )\n        (* sides *)\n        | (0,y) -> add_grain 1 y\n                 ; add_grain 0 (y+1)\n                 ; add_grain 0 (y-1)\n        | (m,y) when m = M.m - 1\n          -> add_grain ( m ) (y-1)\n           ; add_grain ( m ) (y+1)\n           ; add_grain (m-1) ( y )\n        | (x,0) -> add_grain (x+1) 0\n                 ; add_grain (x-1) 0\n                 ; add_grain ( x ) 1\n        | (x,n) when n = M.n - 1\n          -> add_grain (x-1) ( n )\n           ; add_grain (x+1) ( n )\n           ; add_grain ( x ) (n-1)\n        (* else *)\n        | (x,y) -> add_grain ( x ) (y+1)\n                 ; add_grain ( x ) (y-1)\n                 ; add_grain (x+1) ( y )\n                 ; add_grain (x-1) ( y )\n\n    let add_sand n x y\n      = for i = 1 to n\n        do add_grain x y\n        done\n\n    let avalanche ()\n      = while Hashtbl.length unstable > 0\n        do\n         let unstable' = Hashtbl.fold  (fun (x,y) () r -> (x,y) :: r) unstable []\n         in List.iter (fun (x,y) -> topple x y ) unstable'\n        done\n  end\n\n(* testing *)\n\nlet ()\n  = let module S = Make (struct let m = 11 let n = 11 end)\n    in S.add_sand 500 5 5\n     ; S.avalanche ()\n     ; S.print ()\n"
                },
                {
                    "language": "Python",
                    "solution": "''' Python 3.6.5 code using Tkinter graphical user\n    interface (Canvas widget) to display final results.'''\nfrom tkinter import *\n\n# given a grid, display it on a tkinter Canvas:\nclass Sandpile:\n    def __init__(self, wn, grid):\n        self.window = wn\n        self.grid = grid\n        self.canvas = Canvas(wn, bg='lemon chiffon')\n        self.canvas.pack(fill=BOTH, expand=1)\n\n        colors = {0:'dodger blue',\n                  1:'red',\n                  2:'green',\n                  3:'lemon chiffon'}\n\n        x = 10\n        y = 10\n        d = 5\n\n        for row in self.grid:\n            for value in row:\n                clr = colors[value]\n                self.canvas.create_rectangle(\n                    x, y, x+d, y+d,\n                    outline=clr,\n                    fill = clr)\n                x += 5\n            x = 10\n            y += 5\n\nclass Grid:\n    def __init__(self, size, center):\n        self.size = size        # rows/cols in (best if odd)\n        self.center = center    # start value at center of grid\n        self.grid = [[0]*self.size for i in range(self.size)]\n        self.grid[self.size // 2][self.size // 2] = self.center\n\n    # print the grid:\n    def show(self, msg):\n        print('  ' + msg + ':')\n        for row in self.grid:\n            print(' '.join(str(x) for x in row))\n        print()\n        return\n\n    # dissipate piles of sand as required:\n    def abelian(self):\n        while True:\n            found = False\n            for r in range(self.size):\n                for c in range(self.size):\n                    if self.grid[r][c] > 3:\n                        self.distribute(self.grid[r][c], r, c)\n                        found = True\n            if not found:\n                return\n\n    # distribute sand from a single pile to its neighbors:\n    def distribute(self, nbr, row, col):\n        qty, remain = divmod(nbr, 4)\n        self.grid[row][col] = remain\n        for r, c in [(row+1, col),\n                     (row-1, col),\n                     (row, col+1),\n                     (row, col-1)]:\n            self.grid[r][c] += qty\n        return\n\n    # display the grid using tkinter:\n    def display(self):\n        root = Tk()\n        root.title('Sandpile')\n        root.geometry('700x700+100+50')\n        sp = Sandpile(root, self.grid)\n        root.mainloop()\n\n# execute program for size, center value pair:\n# just print results for a small grid\ng = Grid(9,17)\ng.show('BEFORE')\ng.abelian()          # scatter the sand\ng.show('AFTER')\n\n# just show results in tkinter for a large grid\n# I wish there was a way to attach a screen shot\n# of the tkinter result here\ng = Grid(131,25000)\ng.abelian()          # scatter the sand\ng.display()          # display result using tkinter\n\n##  OUTPUT:\n##\n##      BEFORE:\n##    0 0 0 0 0 0 0 0 0\n##    0 0 0 0 0 0 0 0 0\n##    0 0 0 0 0 0 0 0 0\n##    0 0 0 0 0 0 0 0 0\n##    0 0 0 0 17 0 0 0 0\n##    0 0 0 0 0 0 0 0 0\n##    0 0 0 0 0 0 0 0 0\n##    0 0 0 0 0 0 0 0 0\n##    0 0 0 0 0 0 0 0 0\n##\n##      AFTER:\n##    0 0 0 0 0 0 0 0 0\n##    0 0 0 0 0 0 0 0 0\n##    0 0 0 0 1 0 0 0 0\n##    0 0 0 2 1 2 0 0 0\n##    0 0 1 1 1 1 1 0 0\n##    0 0 0 2 1 2 0 0 0\n##    0 0 0 0 1 0 0 0 0\n##    0 0 0 0 0 0 0 0 0\n##    0 0 0 0 0 0 0 0 0\n"
                }
            ],
            [
                {
                    "language": "Rust",
                    "solution": "// This is the main algorithm.\n//\n// It loops over the current state of the sandpile and updates it on-the-fly.\nfn advance(field: &mut Vec<Vec<usize>>, boundary: &mut [usize; 4]) -> bool\n{\n    // This variable is used to check whether we changed anything in the array. If no, the loop terminates.\n    let mut done = false;\n\n    for y in boundary[0]..boundary[2]\n    {\n        for x in boundary[1]..boundary[3]\n        {\n            if field[y][x] >= 4\n            {\n                // This part was heavily inspired by the Pascal version. We subtract 4 as many times as we can\n                // and distribute it to the neighbors. Also, in case we have outgrown the current boundary, we\n                // update it to once again contain the entire sandpile.\n\n                // The amount that gets added to the neighbors is the amount here divided by four and (implicitly) floored.\n                // The remaining sand is just current modulo 4.\n                let rem: usize = field[y][x] / 4;\n                field[y][x] %= 4;\n\n                // The isize casts are necessary because usize can not go below 0.\n                // Also, the reason why x and y are compared to boundary[2]-1 and boundary[3]-1 is because for loops in\n                // Rust are upper bound exclusive. This means a loop like 0..5 will only go over 0,1,2,3 and 4.\n                if y as isize - 1 >= 0 {field[y-1][x] += rem; if y == boundary[0] {boundary[0]-=1;}}\n                if x as isize - 1 >= 0 {field[y][x-1] += rem; if x == boundary[1] {boundary[1]-=1;}}\n                if y+1 < field.len() {field[y+1][x] += rem; if x == boundary[2]-1 {boundary[2]+=1;}}\n                if x+1 < field.len() {field[y][x+1] += rem; if y == boundary[3]-1 {boundary[3]+=1;}}\n\n                done = true;\n            }\n        }\n    }\n\n    done\n}\n\n// This function can be used to display the sandpile in the console window.\n//\n// Each row is mapped onto chars and those characters are then collected into a string.\n// These are then printed to the console.\n//\n// Eg.: [0,1,1,2,3,0] -> [' ','\u2591','\u2591','\u2592','\u2593',' ']-> \" \u2591\u2591\u2592\u2593 \"\nfn display(field: &Vec<Vec<usize>>)\n{\n    for row in field\n    {\n        let char_row = {\n            row.iter().map(|c| {match c {\n                0 => ' ',\n                1 => '\u2591',\n                2 => '\u2592',\n                3 => '\u2593',\n                _ => '\u2588'\n            }}).collect::<String>()\n        };\n        println!(\"{}\", char_row);\n    }\n}\n\n// This function writes the end result to a file called \"output.ppm\".\n//\n// PPM is a very simple image format, however, it entirely uncompressed which leads to huge image sizes.\n// Even so, for demonstrative purposes it's perfectly good to use. For something more robust, look into PNG libraries.\n//\n// Read more about the format here: http://netpbm.sourceforge.net/doc/ppm.html\nfn write_pile(pile: &Vec<Vec<usize>>) {\n    use std::fs::File;\n    use std::io::Write;\n\n    // We first create the file (or erase its contents if it already existed).\n    let mut file = File::create(\"./output.ppm\").unwrap();\n\n    // Then we add the image signature, which is \"P3 <newline>[width of image] [height of image]<newline>[maximum value of color]<newline>\".\n    write!(file, \"P3\\n{} {}\\n255\\n\", pile.len(), pile.len()).unwrap();\n\n    for row in pile {\n        // For each row, we create a new string which has more or less enough capacity to hold the entire row.\n        // This is for performance purposes, but shouldn't really matter much.\n        let mut line = String::with_capacity(row.len() * 14);\n\n        // We map each value in the field to a color.\n        // These are just simple RGB values, 0 being the background, the rest being the \"sand\" itself.\n        for elem in row {\n            line.push_str(match elem {\n                0 => \"100 40 15 \",\n                1 => \"117 87 30 \",\n                2 => \"181 134 47 \",\n                3 => \"245 182 66 \",\n                _ => unreachable!(),\n            });\n        }\n\n        // Finally we write this string into the file.\n        write!(file, \"{}\\n\", line).unwrap();\n    }\n}\n\nfn main() {\n    // This is how big the final image will be. Currently the end result would be a 16x16 picture.\n    let field_size = 16;\n    let mut playfield = vec![vec![0; field_size]; field_size];\n\n    // We put the initial sand in the exact middle of the field.\n    // This isn't necessary per se, but it ensures that sand can fully topple.\n    //\n    // The boundary is initially just the single tile which has the sand in it, however, as the algorithm\n    // progresses, this will grow larger too.\n    let mut boundary = [field_size/2-1, field_size/2-1, field_size/2, field_size/2];\n    playfield[field_size/2 - 1][field_size/2 - 1] = 16;\n\n    // This is the main loop. We update the field until it returns false, signalling that the pile reached its\n    // final state.\n    while advance(&mut playfield, &mut boundary) {};\n\n    // Once this happens, we simply display the result. Uncomment the line below to write it to a file.\n    // Calling display with large field sizes is not recommended as it can easily become too large for the console.\n    display(&playfield);\n    //write_pile(&playfield);\n}\n"
                },
                {
                    "language": "Perl",
                    "solution": "use strict;\nuse warnings;\nuse feature 'bitwise';\n\nmy ($high, $wide) = split ' ', qx(stty size);\nmy $mask = \"\\0\" x $wide . (\"\\0\" . \"\\177\" x ($wide - 2) . \"\\0\") x ($high - 5) .\n  \"\\0\" x $wide;\nmy $pile = $mask =~ s/\\177/ rand() < 0.02 ? chr 64 + rand 20 : \"\\0\" /ger;\n\nfor (1 .. 1e6)\n  {\n  print \"\\e[H\", $pile =~ tr/\\0-\\177/ 1-~/r, \"\\n$_\";\n  my $add = $pile =~ tr/\\1-\\177/\\0\\0\\0\\200/r; # set high bit for >=4\n  $add =~ /\\200/ or last;\n  $pile =~ tr/\\4-\\177/\\0-\\173/; # subtract 4 if >=4\n  for (\"\\0$add\", \"\\0\" x $wide . $add, substr($add, 1), substr $add, $wide)\n    {\n    $pile |.= $_;\n    $pile =~ tr/\\200-\\377/\\1-\\176/; # add one to each neighbor of >=4\n    $pile &.= $mask;\n    }\n  select undef, undef, undef, 0.1; # comment out for full speed\n  }\n"
                }
            ],
            [
                {
                    "language": "MiniScript",
                    "solution": "colors = [color.black, color.yellow, color.orange,\n          color.brown, color.red, color.fuchsia,\n          color.purple, color.blue, color.navy]\n\nrows = 48; rowRange = range(0, rows-1)\ncols = 72; colRange = range(0, cols-1)\nparticlesOfSand = rows * cols\ndivBase = particlesOfSand / (colors.len - 4)\ndeltas = [[0,-1],[-1, 0], [1, 0],[0, 1]]\n\ndisplayGrid = function(grid, td)\n\tfor y in globals.rowRange\n\t\tfor x in globals.colRange\n\t\t\tcolorIx = grid[y][x]\n\t\t\t// determine the rest of the colors if > 3 by division\n\t\t\tif colorIx > 3 then colorIx = (colorIx - 3) / divBase + 4\n\t\t\ttd.setCell x,y, colorIx\n\t\tend for\n\tend for\nend function\n\nclear\n\n// Prepare a tile display\n// Generate image used for the tiles from the defined above.\n// The colors are to indicate height of a sand pile.\nimg = Image.create(colors.len, 1);\nfor i in range(0, colors.len - 1)\n\timg.setPixel(i, 0, colors[i])\nend for\n\ngrid = []\nfor y in rowRange\n\trow = []\n\tfor x in colRange\n\t\trow.push(0)\n\tend for\n\tgrid.push(row)\nend for\n\ngrid[rows/2][cols/2] = particlesOfSand\n\ndisplay(4).mode = displayMode.tile\ntd = display(4)\ntd.cellSize = 640/48   // size of cells on screen\ntd.extent = [cols, rows]\ntd.overlap = 0   // adds a small gap between cells\ntd.tileSet = img; td.tileSetTileSize = 1\ntd.clear 0\n\ntoTopple = []\nfor y in rowRange\n\tfor x in colRange\n\t\tif grid[y][x] > 3 and toTopple.indexOf([x,y]) == null then toTopple.push([x,y])\n\tend for\nend for\ntt = time\nwhile toTopple.len > 0\n\tnextGen = []\n\tfor cell in toTopple\n\t\tx = cell[0]; y = cell[1]\n\t\tgrid[y][x] -= 4\n\t\tfor delta in deltas\n\t\t\tx1 = (x + delta[0]) % cols; y1 = (y + delta[1]) % rows\n\t\t\tgrid[y1][x1] += 1\n\t\tend for\n\tend for\n\tfor y in rowRange\n\t\tfor x in colRange\n\t\t\tif grid[y][x] > 3 and nextGen.indexOf([x,y]) == null then nextGen.push([x,y])\n\t\tend for\n\tend for\n\ttoTopple = nextGen\n\tdisplayGrid(grid, td)\nend while\nkey.get()\n"
                },
                {
                    "language": "Python",
                    "solution": "import numpy as np\nimport matplotlib.pyplot as plt\n\n\ndef iterate(grid):\n    changed = False\n    for ii, arr in enumerate(grid):\n        for jj, val in enumerate(arr):\n            if val > 3:\n                grid[ii, jj] -= 4\n                if ii > 0:\n                    grid[ii - 1, jj] += 1\n                if ii < len(grid)-1:\n                    grid[ii + 1, jj] += 1\n                if jj > 0:\n                    grid[ii, jj - 1] += 1\n                if jj < len(grid)-1:\n                    grid[ii, jj + 1] += 1\n                changed = True\n    return grid, changed\n\n\ndef simulate(grid):\n    while True:\n        grid, changed = iterate(grid)\n        if not changed:\n            return grid\n\n\nif __name__ == '__main__':\n    start_grid = np.zeros((10, 10))\n    start_grid[4:5, 4:5] = 64\n    final_grid = simulate(start_grid.copy())\n    plt.figure()\n    plt.gray()\n    plt.imshow(start_grid)\n    plt.figure()\n    plt.gray()\n    plt.imshow(final_grid)\n"
                }
            ],
            [
                {
                    "language": "Go",
                    "solution": "package main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"os\"\n    \"strings\"\n)\n\nconst dim = 16 // image size\n\nfunc check(err error) {\n    if err != nil {\n        log.Fatal(err)\n    }\n}\n\n// Outputs the result to the terminal using UTF-8 block characters.\nfunc drawPile(pile [][]uint) {\n    chars:= []rune(\" \u2591\u2593\u2588\")\n    for _, row := range pile {\n        line := make([]rune, len(row))\n        for i, elem := range row {\n            if elem > 3 { // only possible when algorithm not yet completed.\n                elem = 3\n            }\n            line[i] = chars[elem]\n        }\n        fmt.Println(string(line))\n    }\n}\n\n// Creates a .ppm file in the current directory, which contains\n// a colored image of the pile.\nfunc writePile(pile [][]uint) {\n    file, err := os.Create(\"output.ppm\")\n    check(err)\n    defer file.Close()\n    // Write the signature, image dimensions and maximum color value to the file.\n    fmt.Fprintf(file, \"P3\\n%d %d\\n255\\n\", dim, dim)\n    bcolors := []string{\"125 0 25 \", \"125 80 0 \", \"186 118 0 \", \"224 142 0 \"}\n    var line strings.Builder\n    for _, row := range pile {\n        for _, elem := range row {\n            line.WriteString(bcolors[elem])\n        }\n        file.WriteString(line.String() + \"\\n\")\n        line.Reset()\n    }\n}\n\n// Main part of the algorithm, a simple, recursive implementation of the model.\nfunc handlePile(x, y uint, pile [][]uint) {\n    if pile[y][x] >= 4 {\n        pile[y][x] -= 4\n        // Check each neighbor, whether they have enough \"sand\" to collapse and if they do,\n        // recursively call handlePile on them.\n        if y > 0 {\n            pile[y-1][x]++\n            if pile[y-1][x] >= 4 {\n                handlePile(x, y-1, pile)\n            }\n        }\n        if x > 0 {\n            pile[y][x-1]++\n            if pile[y][x-1] >= 4 {\n                handlePile(x-1, y, pile)\n            }\n        }\n        if y < dim-1 {\n            pile[y+1][x]++\n            if pile[y+1][x] >= 4 {\n                handlePile(x, y+1, pile)\n            }\n        }\n        if x < dim-1 {\n            pile[y][x+1]++\n            if pile[y][x+1] >= 4 {\n                handlePile(x+1, y, pile)\n            }\n        }\n\n        // Uncomment this line to show every iteration of the program.\n        // Not recommended with large input values.\n        // drawPile(pile)\n\n        // Finally call the function on the current cell again,\n        // in case it had more than 4 particles.\n        handlePile(x, y, pile)\n    }\n}\n\nfunc main() {\n    // Create 2D grid and set size using the 'dim' constant.\n    pile := make([][]uint, dim)\n    for i := 0; i < dim; i++ {\n        pile[i] = make([]uint, dim)\n    }\n\n    // Place some sand particles in the center of the grid and start the algorithm.\n    hdim := uint(dim/2 - 1)\n    pile[hdim][hdim] = 16\n    handlePile(hdim, hdim, pile)\n    drawPile(pile)\n\n    // Uncomment this to save the final image to a file\n    // after the recursive algorithm has ended.\n    // writePile(pile)\n}\n"
                },
                {
                    "language": "Raku",
                    "solution": "use NativeCall;\nuse SDL2::Raw;\n\nmy ($width, $height) = 900, 900;\n\nunit sub MAIN ($stack = 10000);\n\nmy int ($w, $h) = 160, 160;\n\nmy $buf = $w * $h;\nmy @buffer = 0 xx $buf;\n\n@buffer[$w * ($h div 2) + ($w div 2) - 1] = $stack;\n\n\nSDL_Init(VIDEO);\n\nmy SDL_Window $window = SDL_CreateWindow(\n    \"Abelian sandpile - Raku\",\n    SDL_WINDOWPOS_CENTERED_MASK, SDL_WINDOWPOS_CENTERED_MASK,\n    $width, $height,\n    RESIZABLE\n);\n\nmy SDL_Renderer $renderer = SDL_CreateRenderer( $window, -1, ACCELERATED +| TARGETTEXTURE );\n\nmy $asp_texture = SDL_CreateTexture($renderer, %PIXELFORMAT<RGB332>, STREAMING, $w, $h);\n\nmy $pixdatabuf = CArray[int64].new(0, $w, $h, $w);\n\nmy @color = 0x00, 0xDE, 0x14, 0xAA, 0xFF;\n\nsub render {\n    my int $pitch;\n    my int $cursor;\n\n    # work-around to pass the pointer-pointer.\n    my $pixdata = nativecast(Pointer[int64], $pixdatabuf);\n    SDL_LockTexture($asp_texture, SDL_Rect, $pixdata, $pitch);\n\n    $pixdata = nativecast(CArray[int8], Pointer.new($pixdatabuf[0]));\n\n    loop (my int $row; $row < $h; $row = $row + 1) {\n        my int $rs = $row * $w; # row start\n        my int $re = $rs  + $w; # row end\n        loop (my int $idx = $rs; $idx < $re; $idx = $idx + 1) {\n            $pixdata[$idx] =  @buffer[$idx] < 4 ?? @color[@buffer[$idx]] !! @color[4];\n            if @buffer[$idx] >= 4 {\n                my $grains = floor @buffer[$idx] / 4;\n                @buffer[ $idx - $w ] += $grains if $row > 0;\n                @buffer[ $idx - 1  ] += $grains if $idx - 1 >= $rs;\n                @buffer[ $idx + $w ] += $grains if $row < $h - 1;\n                @buffer[ $idx + 1  ] += $grains if $idx + 1 < $re;\n                @buffer[ $idx ] %= 4;\n            }\n        }\n    }\n\n    SDL_UnlockTexture($asp_texture);\n\n    SDL_RenderCopy($renderer, $asp_texture, SDL_Rect, SDL_Rect.new(:x(0), :y(0), :w($width), :h($height)));\n    SDL_RenderPresent($renderer);\n}\n\nmy $event = SDL_Event.new;\n\nmain: loop {\n\n    while SDL_PollEvent($event) {\n        my $casted_event = SDL_CastEvent($event);\n\n        given $casted_event {\n            when *.type == QUIT {\n                last main;\n            }\n        }\n    }\n\n    render();\n    print fps;\n}\n\nsay '';\n\nsub fps {\n    state $fps-frames = 0;\n    state $fps-now    = now;\n    state $fps        = '';\n    $fps-frames++;\n    if now - $fps-now >= 1 {\n        $fps = [~] \"\\b\" x 40, ' ' x 20, \"\\b\" x 20 ,\n            sprintf \"FPS: %5.2f  \", ($fps-frames / (now - $fps-now)).round(.01);\n        $fps-frames = 0;\n        $fps-now = now;\n    }\n    $fps\n}\n"
                }
            ]
        ]
    },
    {
        "task_name": "Abelian-sandpile-model-Identity",
        "task_description": "Our sandpiles are based on a 3 by 3 rectangular grid giving nine areas that \ncontain a number from 0 to 3 inclusive. (The numbers are said to represent \ngrains of sand in each area of the sandpile).\n\nE.g. <code>s1</code> =\n<pre>    \n    1 2 0\n    2 1 1\n    0 1 3\n</pre>\n\nand <code>s2</code> =\n<pre>\n    2 1 3\n    1 0 1\n    0 1 0\n</pre> \n\nAddition on sandpiles is done by adding numbers in corresponding grid areas,\nso for the above:\n<pre>\n              1 2 0     2 1 3     3 3 3\n    s1 + s2 = 2 1 1  +  1 0 1  =  3 1 2\n              0 1 3     0 1 0     0 2 3\n</pre>\n\nIf the addition would result in more than 3 \"grains of sand\" in any area then \nthose areas cause the whole sandpile to become \"unstable\" and the sandpile \nareas are \"toppled\" in an \"avalanche\" until the \"stable\" result is obtained.\n\nAny unstable area (with a number >= 4), is \"toppled\" by loosing one grain of \nsand to each of its four horizontal or vertical neighbours. Grains are lost \nat the edge of the grid, but otherwise increase the number in neighbouring \ncells by one, whilst decreasing the count in the toppled cell by four in each \ntoppling.\n\nA toppling may give an adjacent area more than four grains of sand leading to\na chain of topplings called an \"avalanche\".\nE.g.\n<pre>    \n    4 3 3     0 4 3     1 0 4     1 1 0     2 1 0\n    3 1 2 ==> 4 1 2 ==> 4 2 2 ==> 4 2 3 ==> 0 3 3\n    0 2 3     0 2 3     0 2 3     0 2 3     1 2 3\n</pre>\n\nThe final result is the stable sandpile on the right. \n\n'''Note:''' The order in which cells are toppled does not affect the final result.\n\n;Task:\n* Create a class or datastructure and functions to represent and operate on sandpiles. \n* Confirm the result of the avalanche of topplings shown above\n* Confirm that s1 + s2 == s2 + s1  # Show the stable results\n* If s3 is the sandpile with number 3 in every grid area, and s3_id is the following sandpile:\n<pre>\n    2 1 2  \n    1 0 1  \n    2 1 2\n</pre>\n\n* Show that <code>s3 + s3_id == s3</code>\n* Show that <code>s3_id + s3_id == s3_id</code>\n\n\nShow confirming output here, with your examples.\n\n\n;References:\n*    https://www.youtube.com/watch?v=1MtEUErz7Gg\n*    https://en.wikipedia.org/wiki/Abelian_sandpile_model\n<br><br>\n\n",
        "solution_pairs": [
            [
                {
                    "language": "Ruby",
                    "solution": "class Sandpile\n\n  def initialize(ar) = @grid = ar\n\n  def to_a = @grid.dup\n\n  def + (other)\n    res = self.to_a.zip(other.to_a).map{|row1, row2| row1.zip(row2).map(&:sum) }\n    Sandpile.new(res)\n  end\n\n  def stable? = @grid.flatten.none?{|v| v > 3}\n\n  def avalanche\n    topple until stable?\n    self\n  end\n\n  def == (other) = self.avalanche.to_a == other.avalanche.to_a\n\n  def topple\n    a = @grid\n    a.each_index do |row|\n       a[row].each_index do |col|\n        next if a[row][col] < 4\n        a[row+1][col] += 1 unless row == a.size-1\n        a[row-1][col] += 1 if row > 0\n        a[row][col+1] += 1 unless col == a.size-1\n        a[row][col-1] += 1 if col > 0\n        a[row][col]   -= 4\n      end\n    end\n    self\n  end\n\n  def to_s = \"\\n\" + @grid.map {|row| row.join(\" \") }.join(\"\\n\")\n\nend\n\nputs \"Sandpile:\"\nputs demo = Sandpile.new( [[4,3,3], [3,1,2],[0,2,3]] )\nputs \"\\nAfter the avalanche:\"\nputs demo.avalanche\nputs \"_\" * 30,\"\"\n\ns1 = Sandpile.new([[1, 2, 0], [2, 1, 1], [0, 1, 3]] )\nputs \"s1: #{s1}\"\ns2 = Sandpile.new([[2, 1, 3], [1, 0, 1], [0, 1, 0]] )\nputs \"\\ns2: #{s2}\"\nputs \"\\ns1 + s2 == s2 + s1: #{s1 + s2 == s2 + s1}\"\nputs \"_\" * 30,\"\"\n\ns3    = Sandpile.new([[3, 3, 3], [3, 3, 3], [3, 3, 3]] )\ns3_id = Sandpile.new([[2, 1, 2], [1, 0, 1], [2, 1, 2]] )\nputs \"s3 + s3_id == s3: #{s3 + s3_id == s3}\"\nputs \"s3_id + s3_id == s3_id: #{s3_id + s3_id == s3_id}\"\n"
                },
                {
                    "language": "Lua",
                    "solution": "sandpile.__index = sandpile\nsandpile.new = function(self, vals)\n  local inst = setmetatable({},sandpile)\n  inst.cell, inst.dim = {}, #vals\n  for r = 1, inst.dim do\n    inst.cell[r] = {}\n    for c = 1, inst.dim do\n      inst.cell[r][c] = vals[r][c]\n    end\n  end\n  return inst\nend\nsandpile.add = function(self, other)\n  local vals = {}\n  for r = 1, self.dim do\n    vals[r] = {}\n    for c = 1, self.dim do\n      vals[r][c] = self.cell[r][c] + other.cell[r][c]\n    end\n  end\n  local inst = sandpile:new(vals)\n  inst:iter()\n  return inst\nend\n\nlocal s1 = sandpile:new{{1,2,0},{2,1,1},{0,1,3}}\nlocal s2 = sandpile:new{{2,1,3},{1,0,1},{0,1,0}}\nprint(\"s1 =\")  s1:draw()\nprint(\"\\ns2 =\")  s2:draw()\nlocal s1ps2 = s1:add(s2)\nprint(\"\\ns1 + s2 =\")  s1ps2:draw()\nlocal s2ps1 = s2:add(s1)\nprint(\"\\ns2 + s1 =\")  s2ps1:draw()\nlocal topple = sandpile:new{{4,3,3},{3,1,2},{0,2,3}}\nprint(\"\\ntopple, before =\")  topple:draw()\ntopple:iter()\nprint(\"\\ntopple, after =\")  topple:draw()\nlocal s3 = sandpile:new{{3,3,3},{3,3,3},{3,3,3}}\nprint(\"\\ns3 =\")  s3:draw()\nlocal s3_id = sandpile:new{{2,1,2},{1,0,1},{2,1,2}}\nprint(\"\\ns3_id =\") s3_id:draw()\nlocal s3ps3_id = s3:add(s3_id)\nprint(\"\\ns3 + s3_id =\")  s3ps3_id:draw()\nlocal s3_idps3_id = s3_id:add(s3_id)\nprint(\"\\ns3_id + s3_id =\")  s3_idps3_id:draw()\n"
                }
            ],
            [
                {
                    "language": "ARM-Assembly",
                    "solution": "/* ARM assembly Raspberry PI  or android 32 bits */\n/*  program abelianSum.s   */\n\n/* REMARK 1 : this program use routines in a include file\n   see task Include a file language arm assembly\n   for the routine affichageMess conversion10\n   see at end of this program the instruction include */\n/* for constantes see task include a file in arm assembly */\n/************************************/\n/* Constantes                       */\n/************************************/\n.include \"../constantes.inc\"\n.equ MAXI, 3\n\n/*********************************/\n/* Initialized data              */\n/*********************************/\n.data\nszMessValue:        .asciz \"@ \"\nszMessAdd1:         .asciz \"Add sandpile 1 to sandpile 2  \\n\"\nszMessAdd2:         .asciz \"Add sandpile 2 to sandpile 1  \\n\"\nszMessAdd2A:        .asciz \"Add sandpile 2A to sandpile result  \\n\"\nszMessAdd3:         .asciz \"Add sandpile 3 to sandpile 3ID  \\n\"\nszMessAdd3ID:       .asciz \"Add sandpile 3ID to sandpile 3ID  \\n\"\n\nszMessFin:          .asciz \"End display :\\n\"\nszCarriageReturn:   .asciz \"\\n\"\n\niSandPile1:    .int 1,2,0\n               .int 2,1,1\n               .int 0,1,3\n\niSandPile2:    .int 2,1,3\n               .int 1,0,1\n               .int 0,1,0\n\niSandPile2A:    .int 1,0,0\n               .int 0,0,0\n               .int 0,0,0\n\niSandPile3:    .int 3,3,3\n               .int 3,3,3\n               .int 3,3,3\n\niSandPile3ID:  .int 2,1,2\n               .int 1,0,1\n               .int 2,1,2\n/*********************************/\n/* UnInitialized data            */\n/*********************************/\n.bss\nsZoneConv:        .skip 24\niSandPileR1:      .skip 4 * MAXI * MAXI\niSandPileR2:      .skip 4 * MAXI * MAXI\n/*********************************/\n/*  code section                 */\n/*********************************/\n.text\n.global main\nmain:                            @ entry of program\n\n    ldr r0,iAdriSandPile1        @ sandpile1 address\n    ldr r1,iAdriSandPile2        @ sandpile2 address\n    ldr r2,iAdriSandPileR1       @ sandpile result address\n    bl addSandPile\n\n    ldr r0,iAdrszMessAdd1        @ display message\n    bl affichageMess\n    ldr r0,iAdriSandPileR1       @ display sandpile\n    bl displaySandPile\n\n    ldr r0,iAdriSandPile2        @ sandpile2 address\n    ldr r1,iAdriSandPile1        @ sandpile1 address\n    ldr r2,iAdriSandPileR1       @ sandpile result address\n    bl addSandPile\n\n    ldr r0,iAdrszMessAdd2\n    bl affichageMess\n    ldr r0,iAdriSandPileR1\n    bl displaySandPile\n\n    ldr r0,iAdriSandPileR1        @ sandpile1 address\n    ldr r1,iAdriSandPile2A        @ sandpile2A address\n    ldr r2,iAdriSandPileR2        @ sandpile result address\n    bl addSandPile\n\n    ldr r0,iAdrszMessAdd2A\n    bl affichageMess\n    ldr r0,iAdriSandPileR2\n    bl displaySandPile\n\n    ldr r0,iAdriSandPile3          @ sandpile3 address\n    ldr r1,iAdriSandPile3ID        @ sandpile3ID address\n    ldr r2,iAdriSandPileR2         @ sandpile result address\n    bl addSandPile\n\n    ldr r0,iAdrszMessAdd3\n    bl affichageMess\n    ldr r0,iAdriSandPileR2\n    bl displaySandPile\n\n    ldr r0,iAdriSandPile3ID        @ sandpile3 address\n    ldr r1,iAdriSandPile3ID        @ sandpile3ID address\n    ldr r2,iAdriSandPileR2         @ sandpile result address\n    bl addSandPile\n\n    ldr r0,iAdrszMessAdd3ID\n    bl affichageMess\n    ldr r0,iAdriSandPileR2\n    bl displaySandPile\n100:                               @ standard end of the program\n    mov r0, #0                     @ return code\n    mov r7, #EXIT                  @ request to exit program\n    svc #0                         @ perform the system call\n\niAdrszCarriageReturn:     .int szCarriageReturn\niAdrsZoneConv:            .int sZoneConv\niAdrszMessFin:            .int szMessFin\niAdrszMessAdd1:           .int szMessAdd1\niAdrszMessAdd2:           .int szMessAdd2\niAdrszMessAdd2A:          .int szMessAdd2A\niAdrszMessAdd3:           .int szMessAdd3\niAdrszMessAdd3ID:         .int szMessAdd3ID\niAdriSandPile1:           .int iSandPile1\niAdriSandPileR1:          .int iSandPileR1\niAdriSandPileR2:          .int iSandPileR2\niAdriSandPile2:           .int iSandPile2\niAdriSandPile2A:          .int iSandPile2A\niAdriSandPile3:           .int iSandPile3\niAdriSandPile3ID:         .int iSandPile3ID\n/***************************************************/\n/*     add two  sandpile               */\n/***************************************************/\n// r0 contains address to sandpile 1\n// r1 contains address to sandpile 2\n// r2 contains address to sandpile result\naddSandPile:\n    push {r1-r7,lr}           @ save  registers\n    mov r6,r1                 @ save addresse sandpile2\n    mov r1,r2                 @ and copy sandpile 1 to sandpile result\n    bl copySandPile\n    mov r0,r2                 @ sanspile result\n    mov r2,#0                 @ indice y\n    mov r4,#MAXI\n1:\n    mov r1,#0                  @ indice x\n2:\n    mla r5,r2,r4,r1            @ compute offset\n    ldr r7,[r0,r5,lsl #2]      @ load value at pos x,y sanspile result\n    ldr r3,[r6,r5,lsl #2]      @ load value at pos x,y sandpile 2\n    add r7,r3\n    str r7,[r0,r5,lsl #2]      @ store sum on sandpile result\n    bl avalancheRisk\n    add r1,r1,#1\n    cmp r1,#MAXI\n    blt 2b\n    add r2,r2,#1\n    cmp r2,#MAXI\n    blt 1b\n100:\n    pop {r1-r7,lr}             @ restaur registers\n    bx lr                      @ return\n/***************************************************/\n/*     copy sandpile                               */\n/***************************************************/\n// r0 contains address to sandpile\n// r1 contains address to sandpile result\ncopySandPile:\n    push {r1-r6,lr}           @ save  registers\n    mov r2,#0                 @ indice y\n    mov r3,#MAXI\n1:\n    mov r4,#0                   @ indice x\n2:\n    mla r5,r2,r3,r4            @ compute offset\n    ldr r6,[r0,r5,lsl #2]      @ load value at pos x,y sanspile\n    str r6,[r1,r5,lsl #2]      @ store value at pos x,y sandpile result\n    add r4,r4,#1\n    cmp r4,#MAXI\n    blt 2b\n    add r2,r2,#1\n    cmp r2,#MAXI\n    blt 1b\n100:\n    pop {r1-r6,lr}             @ restaur registers\n    bx lr                      @ return\n/***************************************************/\n/*     display  sandpile               */\n/***************************************************/\n// r0 contains address to sandpile\ndisplaySandPile:\n    push {r1-r6,lr}             @ save  registers\n    mov r6,r0\n    mov r3,#0                   @ indice y\n    mov r4,#MAXI\n1:\n    mov r2,#0                   @ indice x\n2:\n    mul r5,r3,r4\n    add r5,r2                   @ compute offset\n    ldr r0,[r6,r5,lsl #2]       @ load value at pos x,y\n    ldr r1,iAdrsZoneConv\n    bl conversion10             @ call decimal conversion\n    add r1,#1\n    mov r7,#0\n    strb r7,[r1,r0]\n    ldr r0,iAdrszMessValue\n    ldr r1,iAdrsZoneConv        @ insert value conversion in message\n    bl strInsertAtCharInc\n    bl affichageMess\n    add r2,#1\n    cmp r2,#MAXI\n    blt 2b\n    ldr r0,iAdrszCarriageReturn\n    bl affichageMess\n    add r3,#1\n    cmp r3,#MAXI\n    blt 1b\n\n100:\n    pop {r1-r6,lr}             @ restaur registers\n    bx lr                      @ return\niAdrszMessValue:       .int szMessValue\n/***************************************************/\n/*     avalanche risk              */\n/***************************************************/\n// r0 contains address to sanspile\n// r1 contains position x\n// r2 contains position y\navalancheRisk:\n    push {r1-r5,lr}             @ save  registers\n    mov r3,#MAXI\n    mul r4,r3,r2\n    add r4,r1\n    ldr r5,[r0,r4,lsl #2]\n1:\n    cmp r5,#4                   @ 4 grains ?\n    blt 100f\n    sub r5,#4                   @ yes sustract\n    str r5,[r0,r4,lsl #2]\n    cmp r1,#MAXI-1              @ right position ok ?\n    beq 2f\n    add r1,#1                   @ yes\n    bl add1Sand                 @ add 1 grain\n    bl avalancheRisk                  @ and compute new pile\n    sub r1,#1\n2:\n    cmp r1,#0                   @ left position ok ?\n    beq 3f\n    sub r1,#1\n    bl add1Sand\n    bl avalancheRisk\n    add r1,#1\n3:\n    cmp r2,#0                   @ higt position ok ?\n    beq 4f\n    sub r2,#1\n    bl add1Sand\n    bl avalancheRisk\n    add r2,#1\n4:\n    cmp r2,#MAXI-1               @ low position ok ?\n    beq 5f\n    add r2,#1\n    bl add1Sand\n    bl avalancheRisk\n    sub r2,#1\n5:\n   ldr r5,[r0,r4,lsl #2]       @ reload value\n   b 1b                        @ and loop\n100:\n    pop {r1-r5,lr}             @ restaur registers\n    bx lr                      @ return\n/***************************************************/\n/*     add 1 grain of sand              */\n/***************************************************/\n// r0 contains address to sanspile\n// r1 contains position x\n// r2 contains position y\nadd1Sand:\n    push {r3-r5,lr}           @ save  registers\n    mov r3,#MAXI\n    mul r4,r3,r2\n    add r4,r1                 @ compute offset\n    ldr r5,[r0,r4,lsl #2]     @ load value at pos x,y\n    add r5,#1\n    str r5,[r0,r4,lsl #2]     @ and store\n100:\n    pop {r3-r5,lr}            @ restaur registers\n    bx lr                     @ return\n/***************************************************/\n/*      ROUTINES INCLUDE                           */\n/***************************************************/\n.include \"../affichage.inc\"\n"
                },
                {
                    "language": "Java",
                    "solution": "import java.util.ArrayList;\nimport java.util.List;\n\npublic final class AbelianSandpileModel {\n\n\tpublic static void main(String[] aArgs) {\n\t\tSandpile avalanche = new Sandpile(List.of( 4, 3, 3, 3, 1, 2, 0, 2, 3 ));\n\t\tSystem.out.println(\"Avalanche reduction to stable state:\");\n\t\tavalanche.display();\n\t\tSystem.out.println(\" ==> \");\n\t\tavalanche.stabilise();\n\t\tavalanche.display();\n\t\t\n\t\tSandpile s1 = new Sandpile(List.of( 1, 2, 0, 2, 1, 1, 0, 1, 3 ));\n\t\tSandpile s2 = new Sandpile(List.of( 2, 1, 3, 1, 0, 1, 0, 1, 0 ));\n\t\tSandpile sum1 = s1.add(s2);\n\t\tSandpile sum2 = s2.add(s1);\n\t\tSystem.out.println(System.lineSeparator() + \"Commutativity of addition\" + System.lineSeparator());\n\t\tSystem.out.println(\"Sandpile1 + Sandpile2:\");\n\t\tsum1.display();\n\t\tSystem.out.println(\"Sandpile2 + Sandpile1:\");\n\t\tsum2.display();\n\t\tSystem.out.println(\"Sandpile1 + Sandpile2 = Sandpile2 + Sandpile1: \" + sum1.equals(sum2));\n\t\t\n\t\tSandpile s3 = new Sandpile(List.of( 3, 3, 3, 3, 3, 3, 3, 3, 3 ));\n\t\tSandpile s3_id = new Sandpile(List.of( 2, 1, 2, 1, 0, 1, 2, 1, 2 ));\n\t\tSandpile sum3 = s3.add(s3_id);\n\t\tSandpile sum4 = s3_id.add(s3_id);\n\t\tSystem.out.println(System.lineSeparator() + \"Identity Sandpile\" + System.lineSeparator());\n\t\tSystem.out.println(\"Sandpile3 + Sandpile3_id:\");\n\t\tsum3.display();\n\t\tSystem.out.println(\"Sandpile3_id + Sandpile3_id:\");\n\t\tsum4.display();\t\t\n\t}\n\n}\n\nfinal class Sandpile {\n\t\n    public Sandpile(List<Integer> aList) {\n    \tif ( aList.size() != CELL_COUNT ) {\n    \t\tthrow new IllegalArgumentException(\"Initialiser list must contain \" + CELL_COUNT + \" elements\");\n    \t}    \t\n    \tcells = new ArrayList<Integer>(aList);    \t\n    }\n\n    public void stabilise() {\n    \twhile ( ! isStable() ) {\n            topple();\n    \t}\n    }\n\n    public boolean isStable() {\n    \treturn cells.stream().noneMatch( i -> i >= CELL_LIMIT );\n    }\n\n    public void topple() {\n    \tfor ( int i = 0; i < CELL_COUNT; i++ ) {\n    \t\tif ( cells.get(i) >= CELL_LIMIT ) {\n\t            cells.set(i, cells.get(i) - CELL_LIMIT);\n\t            final int row = rowIndex(i);\n\t            final int col = colIndex(i);\n\t            if ( row > 0 ) {\n\t            \tincrement(row - 1, col);\n\t            }\n\t            if ( row + 1 < ROW_COUNT ) {\n\t                increment(row + 1, col);\n\t            }\n\t            if ( col > 0 ) {\n\t                increment(row, col - 1);\n\t            }\n\t            if ( col + 1 < COL_COUNT ) {\n\t                increment(row, col + 1);\n\t            }\n    \t\t}\n\t    }\n    }\n\n    public Sandpile add(Sandpile aOther) {\n    \tList<Integer> list = new ArrayList<Integer>();\n    \tfor ( int i = 0; i < CELL_COUNT; i++ ) {\n            list.add(cells.get(i) + aOther.cells.get(i));\n    \t}\n    \tSandpile result = new Sandpile(list);\n        result.stabilise();\n        return result;\n    }\n\n    public boolean equals(Sandpile aOther) {\n    \treturn cells.equals(aOther.cells);\n    }\n\n    public void display() {\n    \tfor ( int i = 0; i < CELL_COUNT; i++ ) {\n    \t\tSystem.out.print(cells.get(i));\n    \t\tSystem.out.print( ( colIndex(i + 1) == 0 ) ? System.lineSeparator() : \" \");\n    \t}\n    }\n\n\tprivate void increment(int aRow, int aCol) {\n\t\tfinal int index = cellIndex(aRow, aCol);\n\t\tcells.set(index, cells.get(index) + 1);\n\t}\n\n    private static int cellIndex(int aRow, int aCol) {\n        return aRow * COL_COUNT + aCol;\n    }\n\n    private static int rowIndex(int aCellIndex) {\n        return aCellIndex / COL_COUNT;\n    }\n\n    private static int colIndex(int aCellIndex) {\n        return aCellIndex % COL_COUNT;\n    }\n\t\n    private List<Integer> cells;\n\n\tprivate static final int ROW_COUNT = 3;\n\tprivate static final int COL_COUNT = 3;\n\tprivate static final int CELL_COUNT = ROW_COUNT * COL_COUNT;\n\tprivate static final int CELL_LIMIT = 4;\n\t\n}\n"
                }
            ],
            [
                {
                    "language": "Java",
                    "solution": "import java.util.ArrayList;\nimport java.util.List;\n\npublic final class AbelianSandpileModel {\n\n\tpublic static void main(String[] aArgs) {\n\t\tSandpile avalanche = new Sandpile(List.of( 4, 3, 3, 3, 1, 2, 0, 2, 3 ));\n\t\tSystem.out.println(\"Avalanche reduction to stable state:\");\n\t\tavalanche.display();\n\t\tSystem.out.println(\" ==> \");\n\t\tavalanche.stabilise();\n\t\tavalanche.display();\n\t\t\n\t\tSandpile s1 = new Sandpile(List.of( 1, 2, 0, 2, 1, 1, 0, 1, 3 ));\n\t\tSandpile s2 = new Sandpile(List.of( 2, 1, 3, 1, 0, 1, 0, 1, 0 ));\n\t\tSandpile sum1 = s1.add(s2);\n\t\tSandpile sum2 = s2.add(s1);\n\t\tSystem.out.println(System.lineSeparator() + \"Commutativity of addition\" + System.lineSeparator());\n\t\tSystem.out.println(\"Sandpile1 + Sandpile2:\");\n\t\tsum1.display();\n\t\tSystem.out.println(\"Sandpile2 + Sandpile1:\");\n\t\tsum2.display();\n\t\tSystem.out.println(\"Sandpile1 + Sandpile2 = Sandpile2 + Sandpile1: \" + sum1.equals(sum2));\n\t\t\n\t\tSandpile s3 = new Sandpile(List.of( 3, 3, 3, 3, 3, 3, 3, 3, 3 ));\n\t\tSandpile s3_id = new Sandpile(List.of( 2, 1, 2, 1, 0, 1, 2, 1, 2 ));\n\t\tSandpile sum3 = s3.add(s3_id);\n\t\tSandpile sum4 = s3_id.add(s3_id);\n\t\tSystem.out.println(System.lineSeparator() + \"Identity Sandpile\" + System.lineSeparator());\n\t\tSystem.out.println(\"Sandpile3 + Sandpile3_id:\");\n\t\tsum3.display();\n\t\tSystem.out.println(\"Sandpile3_id + Sandpile3_id:\");\n\t\tsum4.display();\t\t\n\t}\n\n}\n\nfinal class Sandpile {\n\t\n    public Sandpile(List<Integer> aList) {\n    \tif ( aList.size() != CELL_COUNT ) {\n    \t\tthrow new IllegalArgumentException(\"Initialiser list must contain \" + CELL_COUNT + \" elements\");\n    \t}    \t\n    \tcells = new ArrayList<Integer>(aList);    \t\n    }\n\n    public void stabilise() {\n    \twhile ( ! isStable() ) {\n            topple();\n    \t}\n    }\n\n    public boolean isStable() {\n    \treturn cells.stream().noneMatch( i -> i >= CELL_LIMIT );\n    }\n\n    public void topple() {\n    \tfor ( int i = 0; i < CELL_COUNT; i++ ) {\n    \t\tif ( cells.get(i) >= CELL_LIMIT ) {\n\t            cells.set(i, cells.get(i) - CELL_LIMIT);\n\t            final int row = rowIndex(i);\n\t            final int col = colIndex(i);\n\t            if ( row > 0 ) {\n\t            \tincrement(row - 1, col);\n\t            }\n\t            if ( row + 1 < ROW_COUNT ) {\n\t                increment(row + 1, col);\n\t            }\n\t            if ( col > 0 ) {\n\t                increment(row, col - 1);\n\t            }\n\t            if ( col + 1 < COL_COUNT ) {\n\t                increment(row, col + 1);\n\t            }\n    \t\t}\n\t    }\n    }\n\n    public Sandpile add(Sandpile aOther) {\n    \tList<Integer> list = new ArrayList<Integer>();\n    \tfor ( int i = 0; i < CELL_COUNT; i++ ) {\n            list.add(cells.get(i) + aOther.cells.get(i));\n    \t}\n    \tSandpile result = new Sandpile(list);\n        result.stabilise();\n        return result;\n    }\n\n    public boolean equals(Sandpile aOther) {\n    \treturn cells.equals(aOther.cells);\n    }\n\n    public void display() {\n    \tfor ( int i = 0; i < CELL_COUNT; i++ ) {\n    \t\tSystem.out.print(cells.get(i));\n    \t\tSystem.out.print( ( colIndex(i + 1) == 0 ) ? System.lineSeparator() : \" \");\n    \t}\n    }\n\n\tprivate void increment(int aRow, int aCol) {\n\t\tfinal int index = cellIndex(aRow, aCol);\n\t\tcells.set(index, cells.get(index) + 1);\n\t}\n\n    private static int cellIndex(int aRow, int aCol) {\n        return aRow * COL_COUNT + aCol;\n    }\n\n    private static int rowIndex(int aCellIndex) {\n        return aCellIndex / COL_COUNT;\n    }\n\n    private static int colIndex(int aCellIndex) {\n        return aCellIndex % COL_COUNT;\n    }\n\t\n    private List<Integer> cells;\n\n\tprivate static final int ROW_COUNT = 3;\n\tprivate static final int COL_COUNT = 3;\n\tprivate static final int CELL_COUNT = ROW_COUNT * COL_COUNT;\n\tprivate static final int CELL_LIMIT = 4;\n\t\n}\n"
                },
                {
                    "language": "Ada",
                    "solution": "with Ada.Text_Io; use Ada.Text_IO;\n\npackage body Abelian_Sandpile is\n\n   ---------------\n   -- Stabalize --\n   ---------------\n\n   procedure Stabalize (Pile : in out Sandpile) is\n   begin\n      while not Is_Stable(Pile) loop\n         Topple(Pile);\n      end loop;\n   end Stabalize;\n\n   ---------------\n   -- Is_Stable --\n   ---------------\n\n   function Is_Stable (Pile : in Sandpile) return Boolean is\n   begin\n     return (for all E of Pile => E < Limit);\n   end Is_Stable;\n\n   ------------\n   -- Topple --\n   ------------\n\n   procedure Topple (Pile : in out Sandpile) is\n   begin\n      outer:\n      for Row in Pile'Range(1) loop\n         for Col in Pile'Range(2) loop\n            if Pile(Row, Col) >= Limit then\n               Pile(Row, Col) := Pile(Row, Col) - Limit;\n               if Row > 0 then\n                  Pile(Row - 1, Col) := Pile(Row -1, Col) + 1;\n               end if;\n               if Row < Pile'Last(1) then\n                  Pile(Row + 1, Col) := Pile(Row + 1, Col) + 1;\n               end if;\n               if Col > 0 then\n                  Pile(Row, Col - 1) := Pile(Row, Col - 1) + 1;\n               end if;\n               if Col < Pile'Last(2) then\n                  Pile(Row, Col + 1) := Pile(Row, Col + 1) + 1;\n               end if;\n\n               exit outer;\n            end if;\n         end loop;\n      end loop outer;\n   end Topple;\n\n   ---------\n   -- \"+\" --\n   ---------\n\n   function \"+\" (Left, Right : Sandpile) return Sandpile is\n      Result : Sandpile;\n   begin\n      for I in Sandpile'Range(1) loop\n         for J in Sandpile'Range(2) loop\n            Result(I, J) := Left(I, J) + Right(I, J);\n         end loop;\n      end loop;\n      Stabalize(Result);\n      return Result;\n   end \"+\";\n\n   -----------\n   -- Print --\n   -----------\n\n   procedure Print(Pile : in Sandpile) is\n   begin\n      for row in Pile'Range(1) loop\n         for col in Pile'Range(2) loop\n            Put(Integer'Image(Pile(row, col)));\n         end loop;\n         New_Line;\n      end loop;\n      New_Line;\n   end Print;\nend Abelian_Sandpile;\n"
                }
            ],
            [
                {
                    "language": "ARM-Assembly",
                    "solution": "/* ARM assembly Raspberry PI  or android 32 bits */\n/*  program abelianSum.s   */\n\n/* REMARK 1 : this program use routines in a include file\n   see task Include a file language arm assembly\n   for the routine affichageMess conversion10\n   see at end of this program the instruction include */\n/* for constantes see task include a file in arm assembly */\n/************************************/\n/* Constantes                       */\n/************************************/\n.include \"../constantes.inc\"\n.equ MAXI, 3\n\n/*********************************/\n/* Initialized data              */\n/*********************************/\n.data\nszMessValue:        .asciz \"@ \"\nszMessAdd1:         .asciz \"Add sandpile 1 to sandpile 2  \\n\"\nszMessAdd2:         .asciz \"Add sandpile 2 to sandpile 1  \\n\"\nszMessAdd2A:        .asciz \"Add sandpile 2A to sandpile result  \\n\"\nszMessAdd3:         .asciz \"Add sandpile 3 to sandpile 3ID  \\n\"\nszMessAdd3ID:       .asciz \"Add sandpile 3ID to sandpile 3ID  \\n\"\n\nszMessFin:          .asciz \"End display :\\n\"\nszCarriageReturn:   .asciz \"\\n\"\n\niSandPile1:    .int 1,2,0\n               .int 2,1,1\n               .int 0,1,3\n\niSandPile2:    .int 2,1,3\n               .int 1,0,1\n               .int 0,1,0\n\niSandPile2A:    .int 1,0,0\n               .int 0,0,0\n               .int 0,0,0\n\niSandPile3:    .int 3,3,3\n               .int 3,3,3\n               .int 3,3,3\n\niSandPile3ID:  .int 2,1,2\n               .int 1,0,1\n               .int 2,1,2\n/*********************************/\n/* UnInitialized data            */\n/*********************************/\n.bss\nsZoneConv:        .skip 24\niSandPileR1:      .skip 4 * MAXI * MAXI\niSandPileR2:      .skip 4 * MAXI * MAXI\n/*********************************/\n/*  code section                 */\n/*********************************/\n.text\n.global main\nmain:                            @ entry of program\n\n    ldr r0,iAdriSandPile1        @ sandpile1 address\n    ldr r1,iAdriSandPile2        @ sandpile2 address\n    ldr r2,iAdriSandPileR1       @ sandpile result address\n    bl addSandPile\n\n    ldr r0,iAdrszMessAdd1        @ display message\n    bl affichageMess\n    ldr r0,iAdriSandPileR1       @ display sandpile\n    bl displaySandPile\n\n    ldr r0,iAdriSandPile2        @ sandpile2 address\n    ldr r1,iAdriSandPile1        @ sandpile1 address\n    ldr r2,iAdriSandPileR1       @ sandpile result address\n    bl addSandPile\n\n    ldr r0,iAdrszMessAdd2\n    bl affichageMess\n    ldr r0,iAdriSandPileR1\n    bl displaySandPile\n\n    ldr r0,iAdriSandPileR1        @ sandpile1 address\n    ldr r1,iAdriSandPile2A        @ sandpile2A address\n    ldr r2,iAdriSandPileR2        @ sandpile result address\n    bl addSandPile\n\n    ldr r0,iAdrszMessAdd2A\n    bl affichageMess\n    ldr r0,iAdriSandPileR2\n    bl displaySandPile\n\n    ldr r0,iAdriSandPile3          @ sandpile3 address\n    ldr r1,iAdriSandPile3ID        @ sandpile3ID address\n    ldr r2,iAdriSandPileR2         @ sandpile result address\n    bl addSandPile\n\n    ldr r0,iAdrszMessAdd3\n    bl affichageMess\n    ldr r0,iAdriSandPileR2\n    bl displaySandPile\n\n    ldr r0,iAdriSandPile3ID        @ sandpile3 address\n    ldr r1,iAdriSandPile3ID        @ sandpile3ID address\n    ldr r2,iAdriSandPileR2         @ sandpile result address\n    bl addSandPile\n\n    ldr r0,iAdrszMessAdd3ID\n    bl affichageMess\n    ldr r0,iAdriSandPileR2\n    bl displaySandPile\n100:                               @ standard end of the program\n    mov r0, #0                     @ return code\n    mov r7, #EXIT                  @ request to exit program\n    svc #0                         @ perform the system call\n\niAdrszCarriageReturn:     .int szCarriageReturn\niAdrsZoneConv:            .int sZoneConv\niAdrszMessFin:            .int szMessFin\niAdrszMessAdd1:           .int szMessAdd1\niAdrszMessAdd2:           .int szMessAdd2\niAdrszMessAdd2A:          .int szMessAdd2A\niAdrszMessAdd3:           .int szMessAdd3\niAdrszMessAdd3ID:         .int szMessAdd3ID\niAdriSandPile1:           .int iSandPile1\niAdriSandPileR1:          .int iSandPileR1\niAdriSandPileR2:          .int iSandPileR2\niAdriSandPile2:           .int iSandPile2\niAdriSandPile2A:          .int iSandPile2A\niAdriSandPile3:           .int iSandPile3\niAdriSandPile3ID:         .int iSandPile3ID\n/***************************************************/\n/*     add two  sandpile               */\n/***************************************************/\n// r0 contains address to sandpile 1\n// r1 contains address to sandpile 2\n// r2 contains address to sandpile result\naddSandPile:\n    push {r1-r7,lr}           @ save  registers\n    mov r6,r1                 @ save addresse sandpile2\n    mov r1,r2                 @ and copy sandpile 1 to sandpile result\n    bl copySandPile\n    mov r0,r2                 @ sanspile result\n    mov r2,#0                 @ indice y\n    mov r4,#MAXI\n1:\n    mov r1,#0                  @ indice x\n2:\n    mla r5,r2,r4,r1            @ compute offset\n    ldr r7,[r0,r5,lsl #2]      @ load value at pos x,y sanspile result\n    ldr r3,[r6,r5,lsl #2]      @ load value at pos x,y sandpile 2\n    add r7,r3\n    str r7,[r0,r5,lsl #2]      @ store sum on sandpile result\n    bl avalancheRisk\n    add r1,r1,#1\n    cmp r1,#MAXI\n    blt 2b\n    add r2,r2,#1\n    cmp r2,#MAXI\n    blt 1b\n100:\n    pop {r1-r7,lr}             @ restaur registers\n    bx lr                      @ return\n/***************************************************/\n/*     copy sandpile                               */\n/***************************************************/\n// r0 contains address to sandpile\n// r1 contains address to sandpile result\ncopySandPile:\n    push {r1-r6,lr}           @ save  registers\n    mov r2,#0                 @ indice y\n    mov r3,#MAXI\n1:\n    mov r4,#0                   @ indice x\n2:\n    mla r5,r2,r3,r4            @ compute offset\n    ldr r6,[r0,r5,lsl #2]      @ load value at pos x,y sanspile\n    str r6,[r1,r5,lsl #2]      @ store value at pos x,y sandpile result\n    add r4,r4,#1\n    cmp r4,#MAXI\n    blt 2b\n    add r2,r2,#1\n    cmp r2,#MAXI\n    blt 1b\n100:\n    pop {r1-r6,lr}             @ restaur registers\n    bx lr                      @ return\n/***************************************************/\n/*     display  sandpile               */\n/***************************************************/\n// r0 contains address to sandpile\ndisplaySandPile:\n    push {r1-r6,lr}             @ save  registers\n    mov r6,r0\n    mov r3,#0                   @ indice y\n    mov r4,#MAXI\n1:\n    mov r2,#0                   @ indice x\n2:\n    mul r5,r3,r4\n    add r5,r2                   @ compute offset\n    ldr r0,[r6,r5,lsl #2]       @ load value at pos x,y\n    ldr r1,iAdrsZoneConv\n    bl conversion10             @ call decimal conversion\n    add r1,#1\n    mov r7,#0\n    strb r7,[r1,r0]\n    ldr r0,iAdrszMessValue\n    ldr r1,iAdrsZoneConv        @ insert value conversion in message\n    bl strInsertAtCharInc\n    bl affichageMess\n    add r2,#1\n    cmp r2,#MAXI\n    blt 2b\n    ldr r0,iAdrszCarriageReturn\n    bl affichageMess\n    add r3,#1\n    cmp r3,#MAXI\n    blt 1b\n\n100:\n    pop {r1-r6,lr}             @ restaur registers\n    bx lr                      @ return\niAdrszMessValue:       .int szMessValue\n/***************************************************/\n/*     avalanche risk              */\n/***************************************************/\n// r0 contains address to sanspile\n// r1 contains position x\n// r2 contains position y\navalancheRisk:\n    push {r1-r5,lr}             @ save  registers\n    mov r3,#MAXI\n    mul r4,r3,r2\n    add r4,r1\n    ldr r5,[r0,r4,lsl #2]\n1:\n    cmp r5,#4                   @ 4 grains ?\n    blt 100f\n    sub r5,#4                   @ yes sustract\n    str r5,[r0,r4,lsl #2]\n    cmp r1,#MAXI-1              @ right position ok ?\n    beq 2f\n    add r1,#1                   @ yes\n    bl add1Sand                 @ add 1 grain\n    bl avalancheRisk                  @ and compute new pile\n    sub r1,#1\n2:\n    cmp r1,#0                   @ left position ok ?\n    beq 3f\n    sub r1,#1\n    bl add1Sand\n    bl avalancheRisk\n    add r1,#1\n3:\n    cmp r2,#0                   @ higt position ok ?\n    beq 4f\n    sub r2,#1\n    bl add1Sand\n    bl avalancheRisk\n    add r2,#1\n4:\n    cmp r2,#MAXI-1               @ low position ok ?\n    beq 5f\n    add r2,#1\n    bl add1Sand\n    bl avalancheRisk\n    sub r2,#1\n5:\n   ldr r5,[r0,r4,lsl #2]       @ reload value\n   b 1b                        @ and loop\n100:\n    pop {r1-r5,lr}             @ restaur registers\n    bx lr                      @ return\n/***************************************************/\n/*     add 1 grain of sand              */\n/***************************************************/\n// r0 contains address to sanspile\n// r1 contains position x\n// r2 contains position y\nadd1Sand:\n    push {r3-r5,lr}           @ save  registers\n    mov r3,#MAXI\n    mul r4,r3,r2\n    add r4,r1                 @ compute offset\n    ldr r5,[r0,r4,lsl #2]     @ load value at pos x,y\n    add r5,#1\n    str r5,[r0,r4,lsl #2]     @ and store\n100:\n    pop {r3-r5,lr}            @ restaur registers\n    bx lr                     @ return\n/***************************************************/\n/*      ROUTINES INCLUDE                           */\n/***************************************************/\n.include \"../affichage.inc\"\n"
                },
                {
                    "language": "Red",
                    "solution": "Red [Purpose: \"implement Abelian sandpile model\"]\n\nsadd: make object! [\n\tcomb: function [pile1 [series!] pile2 [series!]] [\n\t\trepeat r 3 [\n\t\t\trepeat c 3 [\n\t\t\t\tpile2/:r/:c: pile2/:r/:c + pile1/:r/:c\n\t\t\t]\n\t\t]\n\t\tcheck pile2\n\t]\n\tcheck: func [pile [series!]] [\n\t\tstable: true row: col: none\n\t\trepeat r 3[\n\t\t\trepeat c 3[\n\t\t\t\tif pile/:r/:c >= 4 [\n\t\t\t\t\tstable: false\n\t\t\t\t\tpile/:r/:c: pile/:r/:c - 4\n\t\t\t\t\trow: r col: c\n\t\t\t\t\tbreak]\n\t\t\t]\n\t\t\tif stable = false [break]\n\t\t]\n\t\tunless stable = false [print trim/with mold/only pile \"[]\" exit]\n\t\tspill pile row col\n\t]\n\tspill: func [pile [series!] r [integer!] c [integer!]] [\n\t\tneigh: reduce [\n\t\t\tright: reduce [r c - 1] up: reduce [r + 1 c]\n\t\t\tleft: reduce [r c + 1] down: reduce [r - 1 c]\t\n\t\t]\n\t\tforeach n neigh [\n\t\t\tunless any [(pile/(n/1) = none) (pile/(n/1)/(n/2) = none)] [\n\t\t\t\tpile/(n/1)/(n/2): pile/(n/1)/(n/2) + 1\n\t\t\t]\n\t\t]\n\t\tcheck pile\n\t]\n]\n\ns1: [\n\t[1 2 0]\n\t[2 1 1]\n\t[0 1 3]\n]\n\ns2: [\n\t[2 1 3]\n\t[1 0 1]\n\t[0 1 0]\n]\n\ns3: [\n\t[3 3 3]\n\t[3 3 3]\n\t[3 3 3]\n]\n\ns3_id: [\n\t[2 1 2]\n\t[1 0 1]\n\t[2 1 2]\n]\n\nex: [\n\t[4 3 3]\n\t[3 1 2]\n\t[0 2 3]\n]\n\nsadd/check copy/deep ex\nsadd/comb copy/deep s1 copy/deep s2\nsadd/comb copy/deep s2 copy/deep s1\nsadd/comb copy/deep s3 copy/deep s3_id\nsadd/comb copy/deep s3_id copy/deep s3_id\n"
                }
            ],
            [
                {
                    "language": "ARM-Assembly",
                    "solution": "/* ARM assembly Raspberry PI  or android 32 bits */\n/*  program abelianSum.s   */\n\n/* REMARK 1 : this program use routines in a include file\n   see task Include a file language arm assembly\n   for the routine affichageMess conversion10\n   see at end of this program the instruction include */\n/* for constantes see task include a file in arm assembly */\n/************************************/\n/* Constantes                       */\n/************************************/\n.include \"../constantes.inc\"\n.equ MAXI, 3\n\n/*********************************/\n/* Initialized data              */\n/*********************************/\n.data\nszMessValue:        .asciz \"@ \"\nszMessAdd1:         .asciz \"Add sandpile 1 to sandpile 2  \\n\"\nszMessAdd2:         .asciz \"Add sandpile 2 to sandpile 1  \\n\"\nszMessAdd2A:        .asciz \"Add sandpile 2A to sandpile result  \\n\"\nszMessAdd3:         .asciz \"Add sandpile 3 to sandpile 3ID  \\n\"\nszMessAdd3ID:       .asciz \"Add sandpile 3ID to sandpile 3ID  \\n\"\n\nszMessFin:          .asciz \"End display :\\n\"\nszCarriageReturn:   .asciz \"\\n\"\n\niSandPile1:    .int 1,2,0\n               .int 2,1,1\n               .int 0,1,3\n\niSandPile2:    .int 2,1,3\n               .int 1,0,1\n               .int 0,1,0\n\niSandPile2A:    .int 1,0,0\n               .int 0,0,0\n               .int 0,0,0\n\niSandPile3:    .int 3,3,3\n               .int 3,3,3\n               .int 3,3,3\n\niSandPile3ID:  .int 2,1,2\n               .int 1,0,1\n               .int 2,1,2\n/*********************************/\n/* UnInitialized data            */\n/*********************************/\n.bss\nsZoneConv:        .skip 24\niSandPileR1:      .skip 4 * MAXI * MAXI\niSandPileR2:      .skip 4 * MAXI * MAXI\n/*********************************/\n/*  code section                 */\n/*********************************/\n.text\n.global main\nmain:                            @ entry of program\n\n    ldr r0,iAdriSandPile1        @ sandpile1 address\n    ldr r1,iAdriSandPile2        @ sandpile2 address\n    ldr r2,iAdriSandPileR1       @ sandpile result address\n    bl addSandPile\n\n    ldr r0,iAdrszMessAdd1        @ display message\n    bl affichageMess\n    ldr r0,iAdriSandPileR1       @ display sandpile\n    bl displaySandPile\n\n    ldr r0,iAdriSandPile2        @ sandpile2 address\n    ldr r1,iAdriSandPile1        @ sandpile1 address\n    ldr r2,iAdriSandPileR1       @ sandpile result address\n    bl addSandPile\n\n    ldr r0,iAdrszMessAdd2\n    bl affichageMess\n    ldr r0,iAdriSandPileR1\n    bl displaySandPile\n\n    ldr r0,iAdriSandPileR1        @ sandpile1 address\n    ldr r1,iAdriSandPile2A        @ sandpile2A address\n    ldr r2,iAdriSandPileR2        @ sandpile result address\n    bl addSandPile\n\n    ldr r0,iAdrszMessAdd2A\n    bl affichageMess\n    ldr r0,iAdriSandPileR2\n    bl displaySandPile\n\n    ldr r0,iAdriSandPile3          @ sandpile3 address\n    ldr r1,iAdriSandPile3ID        @ sandpile3ID address\n    ldr r2,iAdriSandPileR2         @ sandpile result address\n    bl addSandPile\n\n    ldr r0,iAdrszMessAdd3\n    bl affichageMess\n    ldr r0,iAdriSandPileR2\n    bl displaySandPile\n\n    ldr r0,iAdriSandPile3ID        @ sandpile3 address\n    ldr r1,iAdriSandPile3ID        @ sandpile3ID address\n    ldr r2,iAdriSandPileR2         @ sandpile result address\n    bl addSandPile\n\n    ldr r0,iAdrszMessAdd3ID\n    bl affichageMess\n    ldr r0,iAdriSandPileR2\n    bl displaySandPile\n100:                               @ standard end of the program\n    mov r0, #0                     @ return code\n    mov r7, #EXIT                  @ request to exit program\n    svc #0                         @ perform the system call\n\niAdrszCarriageReturn:     .int szCarriageReturn\niAdrsZoneConv:            .int sZoneConv\niAdrszMessFin:            .int szMessFin\niAdrszMessAdd1:           .int szMessAdd1\niAdrszMessAdd2:           .int szMessAdd2\niAdrszMessAdd2A:          .int szMessAdd2A\niAdrszMessAdd3:           .int szMessAdd3\niAdrszMessAdd3ID:         .int szMessAdd3ID\niAdriSandPile1:           .int iSandPile1\niAdriSandPileR1:          .int iSandPileR1\niAdriSandPileR2:          .int iSandPileR2\niAdriSandPile2:           .int iSandPile2\niAdriSandPile2A:          .int iSandPile2A\niAdriSandPile3:           .int iSandPile3\niAdriSandPile3ID:         .int iSandPile3ID\n/***************************************************/\n/*     add two  sandpile               */\n/***************************************************/\n// r0 contains address to sandpile 1\n// r1 contains address to sandpile 2\n// r2 contains address to sandpile result\naddSandPile:\n    push {r1-r7,lr}           @ save  registers\n    mov r6,r1                 @ save addresse sandpile2\n    mov r1,r2                 @ and copy sandpile 1 to sandpile result\n    bl copySandPile\n    mov r0,r2                 @ sanspile result\n    mov r2,#0                 @ indice y\n    mov r4,#MAXI\n1:\n    mov r1,#0                  @ indice x\n2:\n    mla r5,r2,r4,r1            @ compute offset\n    ldr r7,[r0,r5,lsl #2]      @ load value at pos x,y sanspile result\n    ldr r3,[r6,r5,lsl #2]      @ load value at pos x,y sandpile 2\n    add r7,r3\n    str r7,[r0,r5,lsl #2]      @ store sum on sandpile result\n    bl avalancheRisk\n    add r1,r1,#1\n    cmp r1,#MAXI\n    blt 2b\n    add r2,r2,#1\n    cmp r2,#MAXI\n    blt 1b\n100:\n    pop {r1-r7,lr}             @ restaur registers\n    bx lr                      @ return\n/***************************************************/\n/*     copy sandpile                               */\n/***************************************************/\n// r0 contains address to sandpile\n// r1 contains address to sandpile result\ncopySandPile:\n    push {r1-r6,lr}           @ save  registers\n    mov r2,#0                 @ indice y\n    mov r3,#MAXI\n1:\n    mov r4,#0                   @ indice x\n2:\n    mla r5,r2,r3,r4            @ compute offset\n    ldr r6,[r0,r5,lsl #2]      @ load value at pos x,y sanspile\n    str r6,[r1,r5,lsl #2]      @ store value at pos x,y sandpile result\n    add r4,r4,#1\n    cmp r4,#MAXI\n    blt 2b\n    add r2,r2,#1\n    cmp r2,#MAXI\n    blt 1b\n100:\n    pop {r1-r6,lr}             @ restaur registers\n    bx lr                      @ return\n/***************************************************/\n/*     display  sandpile               */\n/***************************************************/\n// r0 contains address to sandpile\ndisplaySandPile:\n    push {r1-r6,lr}             @ save  registers\n    mov r6,r0\n    mov r3,#0                   @ indice y\n    mov r4,#MAXI\n1:\n    mov r2,#0                   @ indice x\n2:\n    mul r5,r3,r4\n    add r5,r2                   @ compute offset\n    ldr r0,[r6,r5,lsl #2]       @ load value at pos x,y\n    ldr r1,iAdrsZoneConv\n    bl conversion10             @ call decimal conversion\n    add r1,#1\n    mov r7,#0\n    strb r7,[r1,r0]\n    ldr r0,iAdrszMessValue\n    ldr r1,iAdrsZoneConv        @ insert value conversion in message\n    bl strInsertAtCharInc\n    bl affichageMess\n    add r2,#1\n    cmp r2,#MAXI\n    blt 2b\n    ldr r0,iAdrszCarriageReturn\n    bl affichageMess\n    add r3,#1\n    cmp r3,#MAXI\n    blt 1b\n\n100:\n    pop {r1-r6,lr}             @ restaur registers\n    bx lr                      @ return\niAdrszMessValue:       .int szMessValue\n/***************************************************/\n/*     avalanche risk              */\n/***************************************************/\n// r0 contains address to sanspile\n// r1 contains position x\n// r2 contains position y\navalancheRisk:\n    push {r1-r5,lr}             @ save  registers\n    mov r3,#MAXI\n    mul r4,r3,r2\n    add r4,r1\n    ldr r5,[r0,r4,lsl #2]\n1:\n    cmp r5,#4                   @ 4 grains ?\n    blt 100f\n    sub r5,#4                   @ yes sustract\n    str r5,[r0,r4,lsl #2]\n    cmp r1,#MAXI-1              @ right position ok ?\n    beq 2f\n    add r1,#1                   @ yes\n    bl add1Sand                 @ add 1 grain\n    bl avalancheRisk                  @ and compute new pile\n    sub r1,#1\n2:\n    cmp r1,#0                   @ left position ok ?\n    beq 3f\n    sub r1,#1\n    bl add1Sand\n    bl avalancheRisk\n    add r1,#1\n3:\n    cmp r2,#0                   @ higt position ok ?\n    beq 4f\n    sub r2,#1\n    bl add1Sand\n    bl avalancheRisk\n    add r2,#1\n4:\n    cmp r2,#MAXI-1               @ low position ok ?\n    beq 5f\n    add r2,#1\n    bl add1Sand\n    bl avalancheRisk\n    sub r2,#1\n5:\n   ldr r5,[r0,r4,lsl #2]       @ reload value\n   b 1b                        @ and loop\n100:\n    pop {r1-r5,lr}             @ restaur registers\n    bx lr                      @ return\n/***************************************************/\n/*     add 1 grain of sand              */\n/***************************************************/\n// r0 contains address to sanspile\n// r1 contains position x\n// r2 contains position y\nadd1Sand:\n    push {r3-r5,lr}           @ save  registers\n    mov r3,#MAXI\n    mul r4,r3,r2\n    add r4,r1                 @ compute offset\n    ldr r5,[r0,r4,lsl #2]     @ load value at pos x,y\n    add r5,#1\n    str r5,[r0,r4,lsl #2]     @ and store\n100:\n    pop {r3-r5,lr}            @ restaur registers\n    bx lr                     @ return\n/***************************************************/\n/*      ROUTINES INCLUDE                           */\n/***************************************************/\n.include \"../affichage.inc\"\n"
                },
                {
                    "language": "Python",
                    "solution": "'''Abelian Sandpile \u00e2\u20ac\u201c Identity'''\n\nfrom operator import add, eq\n\n\n# -------------------------- TEST --------------------------\n# main :: IO ()\ndef main():\n    '''Tests of cascades and additions'''\n    s0 = [[4, 3, 3], [3, 1, 2], [0, 2, 3]]\n    s1 = [[1, 2, 0], [2, 1, 1], [0, 1, 3]]\n    s2 = [[2, 1, 3], [1, 0, 1], [0, 1, 0]]\n    s3 = [[3, 3, 3], [3, 3, 3], [3, 3, 3]]\n    s3_id = [[2, 1, 2], [1, 0, 1], [2, 1, 2]]\n\n    series = list(cascadeSeries(s0))\n    for expr in [\n            'Cascade:',\n            showSandPiles(\n                [(' ', series[0])] + [\n                    (':', xs) for xs in series[1:]\n                ]\n            ),\n            '',\n            f's1 + s2 == s2 + s1 -> {addSand(s1)(s2) == addSand(s2)(s1)}',\n            showSandPiles([\n                (' ', s1),\n                ('+', s2),\n                ('=', addSand(s1)(s2))\n            ]),\n            '',\n            showSandPiles([\n                (' ', s2),\n                ('+', s1),\n                ('=', addSand(s2)(s1))\n            ]),\n            '',\n            f's3 + s3_id == s3 -> {addSand(s3)(s3_id) == s3}',\n            showSandPiles([\n                (' ', s3),\n                ('+', s3_id),\n                ('=', addSand(s3)(s3_id))\n            ]),\n            '',\n            f's3_id + s3_id == s3_id -> {addSand(s3_id)(s3_id) == s3_id}',\n            showSandPiles([\n                (' ', s3_id),\n                ('+', s3_id),\n                ('=', addSand(s3_id)(s3_id))\n            ]),\n\n    ]:\n        print(expr)\n\n\n# ----------------------- SANDPILES ------------------------\n\n# addSand :: [[Int]] -> [[Int]] -> [[Int]]\ndef addSand(xs):\n    '''The stabilised sum of two sandpiles.\n    '''\n    def go(ys):\n        return cascadeSeries(\n            chunksOf(len(xs))(\n                map(\n                    add,\n                    concat(xs),\n                    concat(ys)\n                )\n            )\n        )[-1]\n    return go\n\n\n# cascadeSeries :: [[Int]] -> [[[Int]]]\ndef cascadeSeries(rows):\n    '''The sequence of states from a given\n       sand pile to a stable condition.\n    '''\n    xs = list(rows)\n    w = len(xs)\n    return [\n        list(chunksOf(w)(x)) for x\n        in convergence(eq)(\n            iterate(nextState(w))(\n                concat(xs)\n            )\n        )\n    ]\n\n\n# convergence :: (a -> a -> Bool) -> [a] -> [a]\ndef convergence(p):\n    '''All items of xs to the point where the binary\n       p returns True over two successive values.\n    '''\n    def go(xs):\n        def conv(prev, ys):\n            y = next(ys)\n            return [prev] + (\n                [] if p(prev, y) else conv(y, ys)\n            )\n        return conv(next(xs), xs)\n    return go\n\n\n# nextState Int -> Int -> [Int] -> [Int]\ndef nextState(w):\n    '''The next state of a (potentially unstable)\n       flattened sand-pile matrix of row length w.\n    '''\n    def go(xs):\n        def tumble(i):\n            neighbours = indexNeighbours(w)(i)\n            return [\n                1 + k if j in neighbours else (\n                    k - (1 + w) if j == i else k\n                ) for (j, k) in enumerate(xs)\n            ]\n        return maybe(xs)(tumble)(\n            findIndex(lambda x: w < x)(xs)\n        )\n    return go\n\n\n# indexNeighbours :: Int -> Int -> [Int]\ndef indexNeighbours(w):\n    '''Indices vertically and horizontally adjoining the\n       given index in a flattened matrix of dimension w.\n    '''\n    def go(i):\n        lastCol = w - 1\n        iSqr = (w * w)\n        col = i % w\n        return [\n            j for j in [i - w, i + w]\n            if -1 < j < iSqr\n        ] + ([i - 1] if 0 != col else []) + (\n            [1 + i] if lastCol != col else []\n        )\n    return go\n\n\n# ------------------------ DISPLAY -------------------------\n\n# showSandPiles :: [(String, [[Int]])] -> String\ndef showSandPiles(pairs):\n    '''Indented multi-line representation\n       of a sequence of matrices, delimited\n       by preceding operators or indents.\n    '''\n    return '\\n'.join([\n        ' '.join([' '.join(map(str, seq)) for seq in tpl])\n        for tpl in zip(*[\n            zip(\n                *[list(str(pfx).center(len(rows)))]\n                + list(zip(*rows))\n            )\n            for (pfx, rows) in pairs\n        ])\n    ])\n\n\n# ------------------------ GENERIC -------------------------\n\n# chunksOf :: Int -> [a] -> [[a]]\ndef chunksOf(n):\n    '''A series of lists of length n, subdividing the\n       contents of xs. Where the length of xs is not evenly\n       divible, the final list will be shorter than n.\n    '''\n    def go(xs):\n        ys = list(xs)\n        return (\n            ys[i:n + i] for i in range(0, len(ys), n)\n        ) if 0 < n else None\n    return go\n\n\n# concat :: [[a]] -> [a]\ndef concat(xs):\n    '''The concatenation of all\n       elements in a list.\n    '''\n    return [x for lst in xs for x in lst]\n\n\n# findIndex :: (a -> Bool) -> [a] -> Maybe Int\ndef findIndex(p):\n    '''Just the first index at which an\n       element in xs matches p,\n       or Nothing if no elements match.\n    '''\n    def go(xs):\n        return next(\n            (i for (i, x) in enumerate(xs) if p(x)),\n            None\n        )\n    return go\n\n\n# iterate :: (a -> a) -> a -> Gen [a]\ndef iterate(f):\n    '''An infinite list of repeated\n       applications of f to x.\n    '''\n    def go(x):\n        v = x\n        while True:\n            yield v\n            v = f(v)\n    return go\n\n\n# maybe :: b -> (a -> b) -> Maybe a -> b\ndef maybe(v):\n    '''Either the default value v, if x is None,\n       or the application of f to x.\n    '''\n    def go(f):\n        def g(x):\n            return v if None is x else f(x)\n        return g\n    return go\n\n\n# MAIN ---\nif __name__ == '__main__':\n    main()\n"
                }
            ]
        ]
    },
    {
        "task_name": "Abstract-type",
        "task_description": "'''Abstract type''' is a type without instances or without definition.\n\nFor example in [[object-oriented programming]] using some languages, abstract types can be partial implementations of other types, which are to be derived there-from. An abstract type may provide implementation of some operations and/or components. Abstract types without any implementation are called '''interfaces'''. In the languages that do not support multiple [[inheritance]] ([[Ada]], [[Java]]), classes can, nonetheless, inherit from multiple interfaces. The languages with multiple inheritance (like [[C++]]) usually make no distinction between partially implementable abstract types and interfaces. Because the abstract type's implementation is incomplete, [[object-oriented programming | OO]] languages normally prevent instantiation from them  (instantiation must derived from one of their descendant classes).\n\nThe term '''abstract datatype''' also may denote a type, with an implementation provided by the programmer rather than directly by the language (a '''built-in''' or an inferred type). Here the word ''abstract'' means that the implementation is abstracted away, irrelevant for the user of the type. Such implementation can and should be hidden if the language supports separation of implementation and specification. This hides complexity while allowing the implementation to change without repercussions on the usage. The corresponding software design practice is said to follow the [[wp:Information_hiding|information hiding principle]].\n\nIt is important not to confuse this ''abstractness'' (of implementation) with one of the '''abstract type'''. The latter is abstract in the sense that the set of its values is empty. In the sense of implementation abstracted away, all user-defined types are abstract.\n\nIn some languages, like for example in Objective Caml which is strongly statically typed, it is also possible to have '''abstract types''' that are not OO related and are not an abstractness too. These are ''pure abstract types'' without any definition even in the implementation and can be used for example for the type algebra, or for some consistence of the type inference. For example in this area, an abstract type can be used as a phantom type to augment another type as its parameter. <!-- An OCaml Guru would explain this better than me, a poor beginner... -->\n\n'''Task''': show how an abstract type can be declared in the language. If the language makes a distinction between interfaces and partially implemented types illustrate both.\n\n\n",
        "solution_pairs": [
            [
                {
                    "language": "Ada",
                    "solution": "type Scheduler is task interface;\nprocedure Plan (Manager : in out Scheduler; Activity : in out Job) is abstract;\n"
                },
                {
                    "language": "OoRexx",
                    "solution": "  -- Example showing a class that defines an interface in ooRexx\n  -- shape is the interface class that defines the methods a shape instance\n  -- is expected to implement as abstract methods.  Instances of the shape\n  -- class need not directly subclass the interface, but can use multiple\n  -- inheritance to mark itself as implementing the interface.\n\n  r=.rectangle~new(5,2)\n  say r\n  -- check for instance of\n  if r~isa(.shape) then say \"a\" r~name \"is a shape\"\n  say \"r~area:\" r~area\n  say\n\n  c=.circle~new(2)\n  say c\n  -- check for instance of shape works even if inherited\n  if c~isa(.shape) then say \"a\" c~name \"is a shape\"\n  say \"c~area:\" c~area\n  say\n\n  -- a mixin is still a class and can be instantiated.  The abstract methods\n  -- will give an error if invoked\n  g=.shape~new\n  say g\n  say g~name\n  say \"g~area:\" g~area -- invoking abstract method results in a runtime error.\n\n  -- the \"MIXINCLASS\" tag makes this avaiable for multiple inhertance\n  ::class shape MIXINCLASS Object\n    ::method area abstract\n    ::method name abstract\n\n  -- directly subclassing the the interface\n  ::class rectangle subclass shape\n\n    ::method init\n      expose length width\n      use strict arg length=0, width=0\n\n    ::method area\n      expose length width\n      return length*width\n\n    ::method name\n      return \"Rectangle\"\n\n  -- inherits the shape methods\n  ::class circle subclass object inherit shape\n\n    ::method init\n      expose radius\n      use strict arg radius=0\n\n    ::method area\n      expose radius\n      numeric digits 20\n      return radius*radius*3.14159265358979323846\n\n    ::method name\n      return \"Circle\"\n"
                }
            ],
            [
                {
                    "language": "REBOL",
                    "solution": "REBOL [\n\tTitle: \"Abstract Type\"\n\tURL: http://rosettacode.org/wiki/Abstract_type\n]\n\n; The \"shape\" class is an abstract class -- it defines the \"pen\"\n; property and \"line\" method, but \"size\" and \"draw\" are undefined and\n; unimplemented.\n\nshape: make object! [\n\tpen:  \"X\"\n\tsize: none\n\n\tline: func [count][loop count [prin self/pen]  prin crlf]\n\tdraw: does [none]\n]\n\n; The \"box\" class inherits from \"shape\" and provides the missing\n; information for drawing boxes.\n\nbox: make shape [\n\tsize: 10\n\tdraw: does [loop self/size [line self/size]]\n]\n\n; \"rectangle\" also inherits from \"shape\", but handles the\n; implementation very differently.\n\nrectangle: make shape [\n\tsize: 20x10\n\tdraw: does [loop self/size/y [line self/size/x]]\n]\n\n; Unlike some languages discussed, REBOL has absolutely no qualms\n; about instantiating an \"abstract\" class -- that's how I created the\n; derived classes of \"rectangle\" and \"box\", after all.\n\ns: make shape []  s/draw ; Nothing happens.\n\nprint \"A box:\"\nb: make box [pen: \"O\" size: 5]  b/draw\n\nprint [crlf \"A rectangle:\"]\nr: make rectangle [size: 32x5]  r/draw\n"
                },
                {
                    "language": "OoRexx",
                    "solution": "  -- Example showing an abstract type in ooRexx\n  -- shape is the abstract class that defines the abstract method area\n  -- which is then implemented by its two subclasses, rectangle and circle\n  -- name is the method inherited by the subclasses.\n  -- author:         Rony G. Flatscher, 2012-05-26\n  -- changed/edited: Walter Pachl, 2012-05-28 28\n  -- highlighting:   to come\n\n  r=.rectangle~new(5,2)\n  say r\n  say r~name\n  say \"r~area:\" r~area\n  say\n\n  c=.circle~new(2)\n  say c\n  say c~name\n  say \"c~area:\" c~area\n  say\n\n  g=.shape~new\n  say g\n  say g~name\n  say \"g~area:\" g~area -- invoking abstract method results in a runtime error.\n\n  ::class shape\n    ::method area abstract\n    ::method name\n      return \"self~class~id:\" self~class~id\n\n\n  ::class rectangle subclass shape\n\n    ::method init\n      expose length width\n      use strict arg length=0, width=0\n\n    ::method area\n      expose length width\n      return length*width\n\n  ::class circle subclass shape\n\n    ::method init\n      expose radius\n      use strict arg radius=0\n\n    ::method area\n      expose radius\n      numeric digits 20\n      return radius*radius*3.14159265358979323846\n"
                }
            ],
            [
                {
                    "language": "Julia",
                    "solution": "abstract type Number end\nabstract type Real          <: Number end\nabstract type FloatingPoint <: Real end\nabstract type Integer       <: Real end\nabstract type Signed        <: Integer end\nabstract type Unsigned      <: Integer end\n"
                },
                {
                    "language": "11l",
                    "solution": "T AbstractQueue\n   F.virtual.abstract enqueue(Int item) -> N\n\nT PrintQueue(AbstractQueue)\n   F.virtual.assign enqueue(Int item) -> N\n      print(item)\n"
                }
            ],
            [
                {
                    "language": "F-Sharp",
                    "solution": "type Shape =\n  abstract Perimeter: unit -> float\n  abstract Area: unit -> float\n\ntype Rectangle(width, height) =\n  interface Shape with\n    member x.Perimeter() = 2.0 * width + 2.0 * height\n    member x.Area() = width * height\n"
                },
                {
                    "language": "Jq",
                    "solution": "def Beast::new($kind; $name): {\n   superclass: \"Beast\",\n   class: null,\n   $kind,\n   $name,\n   cry: \"unspecified\"\n};\n\ndef Ape::new($kind; $name):\n  Beast::new($kind; $name)\n  | .class = \"Ape\"\n  | .cry = \"Hoot\";\n\ndef Cat::new($kind; $name):\n  Beast::new($kind; $name)\n  | .class = \"Cat\"\n  | .cry = \"Meow\";\n\ndef Dog::new($kind; $name):\n  Beast::new($kind; $name)\n  | .class = \"Dog\"\n  | .cry = \"Woof\";\n\n\ndef print:\n  def a($noun):\n    $noun\n    | if .[0:1] | test(\"[aeio]\") then \"an \\(.)\" else \"a \\(.)\" end;\n\n  if .class == null\n  then \"\\(.name) is \\(a(.kind)), which is an unknown type of \\(.superclass).\"\n  else \"\\(.name) is \\(a(.kind)), a type of \\(.class), and cries: \\(.cry).\"\n  end;\n\nBeast::new(\"sasquatch\"; \"Bigfoot\"),\nApe::new(\"chimpanzee\"; \"Nim Chimsky\"),\nDog::new(\"labrador\"; \"Max\"),\nCat::new(\"siamese\"; \"Sammy\")\n| print\n"
                }
            ],
            [
                {
                    "language": "PHP",
                    "solution": "interface Inter {\n\tpublic function method1($value);\n\tpublic function method2($name);\n\tpublic function add($a, $b);\n}\n"
                },
                {
                    "language": "Genyris",
                    "solution": "tag StackInterface (XYZstack(.new))\n"
                }
            ]
        ]
    },
    {
        "task_name": "Abundant-deficient-and-perfect-number-classifications",
        "task_description": "These define three classifications of positive integers based on their &nbsp; [[Proper divisors|proper divisors]].\n\nLet &nbsp; P(n) &nbsp; be the sum of the proper divisors of &nbsp; '''n''' &nbsp; where the proper divisors are all positive divisors of &nbsp; '''n''' &nbsp; other than &nbsp; '''n''' &nbsp; itself. \n    if   <code> P(n) <  n </code>   then  '''n'''  is classed as  '''deficient'''  ([https://oeis.org/A005100 OEIS A005100]).\n    if   <code> P(n) == n </code>   then  '''n'''  is classed as  '''perfect'''    ([https://oeis.org/A000396 OEIS A000396]).\n    if   <code> P(n) >  n </code>   then  '''n'''  is classed as  '''abundant'''   ([https://oeis.org/A005101 OEIS A005101]).\n\n\n;Example:\n'''6''' &nbsp; has proper divisors of &nbsp; '''1''', &nbsp; '''2''', &nbsp; and &nbsp; '''3'''. \n\n'''1 + 2 + 3 = 6''', &nbsp; so &nbsp; '''6''' &nbsp;  is classed as a perfect number.\n\n\n;Task:\nCalculate how many of the integers &nbsp; '''1''' &nbsp; to &nbsp; '''20,000''' &nbsp; (inclusive) are in each of the three classes.\n\nShow the results here.\n\n\n;Related tasks:\n* &nbsp; [[Aliquot sequence classifications]]. &nbsp; (The whole series from which this task is a subset.)\n* &nbsp; [[Proper divisors]]\n* &nbsp; [[Amicable pairs]]\n<br><br>\n\n",
        "solution_pairs": [
            [
                {
                    "language": "PowerShell",
                    "solution": "function Get-ProperDivisorSum ( [int]$N )\n    {\n    If ( $N -lt 2 ) { return 0 }\n\n    $Sum = 1\n    If ( $N -gt 3 )\n        {\n        $SqrtN = [math]::Sqrt( $N )\n        ForEach ( $Divisor in 2..$SqrtN )\n            {\n            If ( $N % $Divisor -eq 0 ) { $Sum += $Divisor + $N / $Divisor }\n            }\n        If ( $N % $SqrtN -eq 0 ) { $Sum -= $SqrtN }\n        }\n    return $Sum\n    }\n\n\n$Deficient = $Perfect = $Abundant = 0\n\nForEach ( $N in 1..20000 )\n    {\n    Switch ( [math]::Sign( ( Get-ProperDivisorSum $N ) - $N ) )\n        {\n        -1 { $Deficient++ }\n         0 { $Perfect++   }\n         1 { $Abundant++  }\n        }\n    }\n\n\"Deficient: $Deficient\"\n\"Perfect  : $Perfect\"\n\"Abundant : $Abundant\"\n"
                },
                {
                    "language": "K",
                    "solution": "/Classification of numbers into abundant, perfect and deficient\n/ numclass.k\n\n/return 0,1 or -1 if perfect or abundant or deficient respectively\nnumclass: {s:(+/&~x!'!1+x)-x; :[s>x;:1;:[s<x;:-1;:0]]}\n/classify numbers from 1 to 20000 into respective groups\nc: =numclass' 1+!20000\n/print statistics\n`0: ,\"Deficient = \", $(#c[0])\n`0: ,\"Perfect   = \", $(#c[1])\n`0: ,\"Abundant  = \", $(#c[2])\n"
                }
            ],
            [
                {
                    "language": "ARM-Assembly",
                    "solution": "/* ARM assembly Raspberry PI  */\n/* program numberClassif.s   */\n\n /* REMARK 1 : this program use routines in a include file\n   see task Include a file language arm assembly\n   for the routine affichageMess conversion10\n   see at end of this program the instruction include */\n/* for constantes see task include a file in arm assembly */\n/************************************/\n/* Constantes                       */\n/************************************/\n.include \"../constantes.inc\"\n\n.equ NBDIVISORS,             1000\n\n/*******************************************/\n/* Initialized data                        */\n/*******************************************/\n.data\nszMessStartPgm:          .asciz \"Program start \\n\"\nszMessEndPgm:            .asciz \"Program normal end.\\n\"\nszMessErrorArea:         .asciz \"\\033[31mError : area divisors too small.\\n\"\nszMessError:             .asciz \"\\033[31mError  !!!\\n\"\nszMessErrGen:            .asciz \"Error end program.\\n\"\nszMessNbPrem:            .asciz \"This number is prime !!!.\\n\"\nszMessResultFact:        .asciz \"@ \"\n\nszCarriageReturn:        .asciz \"\\n\"\n\n/* datas message display */\nszMessResult:            .asciz \"Number d\u00e9ficients : @ perfects : @ abundants : @ \\n\"\n\n/*******************************************/\n/* UnInitialized data                      */\n/*******************************************/\n.bss\n.align 4\nsZoneConv:               .skip 24\ntbZoneDecom:             .skip 4 * NBDIVISORS       // facteur 4 octets\n/*******************************************/\n/*  code section                           */\n/*******************************************/\n.text\n.global main\nmain:                               @ program start\n    ldr r0,iAdrszMessStartPgm       @ display start message\n    bl affichageMess\n\n    mov r4,#1\n    mov r3,#0\n    mov r6,#0\n    mov r7,#0\n    mov r8,#0\n    ldr r9,iNBMAX\n1:\n    mov r0,r4                       @  number\n    //=================================\n    ldr r1,iAdrtbZoneDecom\n    bl decompFact                @ create area of divisors\n    cmp r0,#0                    @ error ?\n    blt 2f\n    lsl r5,r4,#1                 @ number * 2\n    cmp r5,r1                    @ compare number and sum\n    addeq r7,r7,#1               @ perfect\n    addgt r6,r6,#1               @ deficient\n    addlt r8,r8,#1               @ abundant\n\n2:\n    add r4,r4,#1\n    cmp r4,r9\n    ble 1b\n\n    //================================\n\n    mov r0,r6                        @ deficient\n    ldr r1,iAdrsZoneConv\n    bl conversion10                  @ convert ascii string\n    ldr r0,iAdrszMessResult\n    ldr r1,iAdrsZoneConv\n    bl strInsertAtCharInc               @ and put in message\n    mov r5,r0\n    mov r0,r7                        @ perfect\n    ldr r1,iAdrsZoneConv\n    bl conversion10                  @ convert ascii string\n    mov r0,r5\n    ldr r1,iAdrsZoneConv\n    bl strInsertAtCharInc               @ and put in message\n    mov r5,r0\n    mov r0,r8                        @ abundant\n    ldr r1,iAdrsZoneConv\n    bl conversion10                  @ convert ascii string\n    mov r0,r5\n    ldr r1,iAdrsZoneConv\n    bl strInsertAtCharInc               @ and put in message\n    bl affichageMess\n\n\n    ldr r0,iAdrszMessEndPgm         @ display end message\n    bl affichageMess\n    b 100f\n99:                                 @ display error message\n    ldr r0,iAdrszMessError\n    bl affichageMess\n100:                                @ standard end of the program\n    mov r0, #0                      @ return code\n    mov r7, #EXIT                   @ request to exit program\n    svc 0                           @ perform system call\niAdrszMessStartPgm:        .int szMessStartPgm\niAdrszMessEndPgm:          .int szMessEndPgm\niAdrszMessError:           .int szMessError\niAdrszCarriageReturn:      .int szCarriageReturn\niAdrtbZoneDecom:           .int tbZoneDecom\n\niAdrszMessResult:          .int szMessResult\niAdrsZoneConv:             .int sZoneConv\n\niNBMAX:                    .int 20000\n\n\n/******************************************************************/\n/*     factor decomposition                                               */\n/******************************************************************/\n/* r0 contains number */\n/* r1 contains address of divisors area */\n/* r0 return divisors items in table */\n/* r1 return the sum of divisors  */\ndecompFact:\n    push {r3-r12,lr}              @ save  registers\n    cmp r0,#1\n    moveq r1,#1\n    beq 100f\n    mov r5,r1\n    mov r8,r0                    @ save number\n    bl isPrime                   @ prime ?\n    cmp r0,#1\n    beq 98f                      @ yes is prime\n    mov r1,#1\n    str r1,[r5]                  @ first factor\n    mov r12,#1                   @ divisors sum\n    mov r10,#1                   @ indice divisors table\n    mov r9,#2                    @ first divisor\n    mov r6,#0                    @ previous divisor\n    mov r7,#0                    @ number of same divisors\n\n    /*  division loop  */\n2:\n    mov r0,r8                    @ dividende\n    mov r1,r9                    @ divisor\n    bl division                  @ r2 quotient r3 remainder\n    cmp r3,#0\n    beq 3f                       @ if remainder  zero  ->  divisor\n\n        /* not divisor -> increment next divisor */\n    cmp r9,#2                    @ if divisor = 2 -> add 1\n    addeq r9,#1\n    addne r9,#2                  @ else add 2\n    b 2b\n\n       /* divisor   compute the new factors of number */\n3:\n    mov r8,r2                    @ else quotient -> new dividende\n    cmp r9,r6                    @ same divisor ?\n    beq 4f                       @ yes\n\n    mov r0,r5                    @ table address\n    mov r1,r10                   @ number factors in table\n    mov r2,r9                    @ divisor\n    mov r3,r12                   @ somme\n    mov r4,#0\n    bl computeFactors\n    mov r10,r1\n    mov r12,r0\n    mov r6,r9                    @ new divisor\n    b 7f\n\n4:                               @ same divisor\n    sub r7,r10,#1\n5:                              @ search in table the first use of divisor\n    ldr r3,[r5,r7,lsl #2 ]\n    cmp r3,r9\n    subne r7,#1\n    bne 5b\n                                 @ and compute new factors after factors\n    sub r4,r10,r7                @ start indice\n    mov r0,r5\n    mov r1,r10\n    mov r2,r9                    @ divisor\n    mov r3,r12\n    bl computeFactors\n    mov r12,r0\n    mov r10,r1\n\n\n    /* divisor -> test if new dividende is prime */\n7:\n    cmp r8,#1                    @ dividende = 1 ? -> end\n    beq 10f\n    mov r0,r8                    @ new dividende is prime ?\n    mov r1,#0\n    bl isPrime                   @ the new dividende is prime ?\n    cmp r0,#1\n    bne 10f                      @ the new dividende is not prime\n\n    cmp r8,r6                    @ else dividende is same divisor ?\n    beq 8f                       @ yes\n\n    mov r0,r5\n    mov r1,r10\n    mov r2,r8\n    mov r3,r12\n    mov r4,#0\n    bl computeFactors\n    mov r12,r0\n    mov r10,r1\n    mov r7,#0\n    b 11f\n8:\n    sub r7,r10,#1\n9:\n    ldr r3,[r5,r7,lsl #2 ]\n    cmp r3,r8\n    subne r7,#1\n    bne 9b\n\n    mov r0,r5\n    mov r1,r10\n    sub r4,r10,r7\n    mov r2,r8\n    mov r3,r12\n    bl computeFactors\n    mov r12,r0\n    mov r10,r1\n\n    b 11f\n\n10:\n    cmp r9,r8                    @ current divisor  > new dividende ?\n    ble 2b                       @ no -> loop\n\n    /* end decomposition */\n11:\n    mov r0,r10                  @ return number of table items\n    mov r1,r12                  @ return sum\n    mov r3,#0\n    str r3,[r5,r10,lsl #2]      @ store z\u00e9ro in last table item\n    b 100f\n\n\n98:                             @ prime number\n    //ldr r0,iAdrszMessNbPrem\n    //bl   affichageMess\n    add r1,r8,#1\n    mov r0,#0                   @ return code\n    b 100f\n99:\n    ldr r0,iAdrszMessError\n    bl   affichageMess\n    mov r0,#-1                  @ error code\n    b 100f\n100:\n    pop {r3-r12,lr}             @ restaur registers\n    bx lr\niAdrszMessNbPrem:           .int szMessNbPrem\n\n/*   r0 table factors address */\n/*   r1 number factors in table */\n/*   r2 new divisor */\n/*   r3 sum  */\n/*   r4 start indice */\n/*   r0 return sum */\n/*   r1 return number factors in table */\ncomputeFactors:\n    push {r2-r6,lr}              @ save registers\n    mov r6,r1                    @ number factors in table\n1:\n    ldr r5,[r0,r4,lsl #2 ]       @ load one factor\n    mul r5,r2,r5                 @ multiply\n    str r5,[r0,r1,lsl #2]        @ and store in the table\n\n    add r3,r5\n    add r1,r1,#1                 @ and increment counter\n    add r4,r4,#1\n    cmp r4,r6\n    blt 1b\n    mov r0,r3\n100:                             @ fin standard de la fonction\n    pop {r2-r6,lr}               @ restaur des registres\n    bx lr                        @ retour de la fonction en utilisant lr\n/***************************************************/\n/*   check if a number is prime              */\n/***************************************************/\n/* r0 contains the number            */\n/* r0 return 1 if prime  0 else */\n@2147483647\n@4294967297\n@131071\nisPrime:\n    push {r1-r6,lr}    @ save registers\n    cmp r0,#0\n    beq 90f\n    cmp r0,#17\n    bhi 1f\n    cmp r0,#3\n    bls 80f            @ for 1,2,3 return prime\n    cmp r0,#5\n    beq 80f            @ for 5 return prime\n    cmp r0,#7\n    beq 80f            @ for 7 return prime\n    cmp r0,#11\n    beq 80f            @ for 11 return prime\n    cmp r0,#13\n    beq 80f            @ for 13 return prime\n    cmp r0,#17\n    beq 80f            @ for 17 return prime\n1:\n    tst r0,#1          @ even ?\n    beq 90f            @ yes -> not prime\n    mov r2,r0          @ save number\n    sub r1,r0,#1       @ exposant n - 1\n    mov r0,#3          @ base\n    bl moduloPuR32     @ compute base power n - 1 modulo n\n    cmp r0,#1\n    bne 90f            @ if <> 1  -> not prime\n\n    mov r0,#5\n    bl moduloPuR32\n    cmp r0,#1\n    bne 90f\n\n    mov r0,#7\n    bl moduloPuR32\n    cmp r0,#1\n    bne 90f\n\n    mov r0,#11\n    bl moduloPuR32\n    cmp r0,#1\n    bne 90f\n\n    mov r0,#13\n    bl moduloPuR32\n    cmp r0,#1\n    bne 90f\n\n    mov r0,#17\n    bl moduloPuR32\n    cmp r0,#1\n    bne 90f\n80:\n    mov r0,#1        @ is prime\n    b 100f\n90:\n    mov r0,#0        @ no prime\n100:                 @ fin standard de la fonction\n    pop {r1-r6,lr}   @ restaur des registres\n    bx lr            @ retour de la fonction en utilisant lr\n/********************************************************/\n/*   Calcul modulo de b puissance e modulo m  */\n/*    Exemple 4 puissance 13 modulo 497 = 445         */\n/*                                             */\n/********************************************************/\n/* r0  nombre  */\n/* r1 exposant */\n/* r2 modulo   */\n/* r0 return result  */\nmoduloPuR32:\n    push {r1-r7,lr}    @ save registers\n    cmp r0,#0          @ verif <> zero\n    beq 100f\n    cmp r2,#0          @ verif <> zero\n    beq 100f           @ TODO: v\u9ca9fier les cas d erreur\n1:\n    mov r4,r2          @ save modulo\n    mov r5,r1          @ save exposant\n    mov r6,r0          @ save base\n    mov r3,#1          @ start result\n\n    mov r1,#0          @ division de r0,r1 par r2\n    bl division32R\n    mov r6,r2          @ base <- remainder\n2:\n    tst r5,#1          @  exposant even or odd\n    beq 3f\n    umull r0,r1,r6,r3\n    mov r2,r4\n    bl division32R\n    mov r3,r2          @ result <- remainder\n3:\n    umull r0,r1,r6,r6\n    mov r2,r4\n    bl division32R\n    mov r6,r2          @ base <- remainder\n\n    lsr r5,#1          @ left shift 1 bit\n    cmp r5,#0          @ end ?\n    bne 2b\n    mov r0,r3\n100:                   @ fin standard de la fonction\n    pop {r1-r7,lr}     @ restaur des registres\n    bx lr              @ retour de la fonction en utilisant lr\n\n/***************************************************/\n/*   division number 64 bits in 2 registers by number 32 bits */\n/***************************************************/\n/* r0 contains lower part dividende   */\n/* r1 contains upper part dividende   */\n/* r2 contains divisor   */\n/* r0 return lower part quotient    */\n/* r1 return upper part quotient    */\n/* r2 return remainder               */\ndivision32R:\n    push {r3-r9,lr}    @ save registers\n    mov r6,#0          @ init upper upper part remainder  !!\n    mov r7,r1          @ init upper part remainder with upper part dividende\n    mov r8,r0          @ init lower part remainder with lower part dividende\n    mov r9,#0          @ upper part quotient\n    mov r4,#0          @ lower part quotient\n    mov r5,#32         @ bits number\n1:                     @ begin loop\n    lsl r6,#1          @ shift upper upper part remainder\n    lsls r7,#1         @ shift upper  part remainder\n    orrcs r6,#1\n    lsls r8,#1         @ shift lower  part remainder\n    orrcs r7,#1\n    lsls r4,#1         @ shift lower part quotient\n    lsl r9,#1          @ shift upper part quotient\n    orrcs r9,#1\n                       @ divisor sustract  upper  part remainder\n    subs r7,r2\n    sbcs  r6,#0        @ and substract carry\n    bmi 2f             @ n\u99e1tive ?\n\n                       @ positive or equal\n    orr r4,#1          @ 1 -> right bit quotient\n    b 3f\n2:                     @ negative\n    orr r4,#0          @ 0 -> right bit quotient\n    adds r7,r2         @ and restaur remainder\n    adc  r6,#0\n3:\n    subs r5,#1         @ decrement bit size\n    bgt 1b             @ end ?\n    mov r0,r4          @ lower part quotient\n    mov r1,r9          @ upper part quotient\n    mov r2,r7          @ remainder\n100:                   @ function end\n    pop {r3-r9,lr}     @ restaur registers\n    bx lr\n\n/***************************************************/\n/*      ROUTINES INCLUDE                 */\n/***************************************************/\n.include \"../affichage.inc\"\n"
                },
                {
                    "language": "ZX-Spectrum-Basic",
                    "solution": "  10 LET abundant=0: LET deficient=0: LET perfect=0\n  20 FOR j=1 TO 20000\n  30 GO SUB 120\n  40 IF sump<j THEN LET deficient=deficient+1: GO TO 70\n  50 IF sump=j THEN LET perfect=perfect+1: GO TO 70\n  60 LET abundant=abundant+1\n  70 NEXT j\n  80 PRINT \"Perfect: \";perfect\n  90 PRINT \"Abundant: \";abundant\n 100 PRINT \"Deficient: \";deficient\n 110 STOP\n 120 IF j=1 THEN LET sump=0: RETURN\n 130 LET sum=1\n 140 LET root=SQR j\n 150 FOR i=2 TO root\n 160 IF j/i=INT (j/i) THEN LET sum=sum+i: IF (i*i)<>j THEN LET sum=sum+j/i\n 170 NEXT i\n 180 LET sump=sum\n 190 RETURN\n"
                }
            ],
            [
                {
                    "language": "Ring",
                    "solution": "n = 30\nperfect(n)\n\nfunc perfect n\nfor i = 1 to n\n    sum = 0\n    for j = 1 to i - 1\n        if i % j = 0 sum = sum + j ok\n    next\n    see i\n    if sum = i see \" is a perfect number\" + nl\n    but sum < i see \" is a deficient number\" + nl\n    else see \" is a abundant number\" + nl ok\nnext\n"
                },
                {
                    "language": "Phix",
                    "solution": "(phixonline)-->\n <span style=\"color: #004080;\">integer</span> <span style=\"color: #000000;\">deficient</span><span style=\"color: #0000FF;\">=</span><span style=\"color: #000000;\">0</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #000000;\">perfect</span><span style=\"color: #0000FF;\">=</span><span style=\"color: #000000;\">0</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #000000;\">abundant</span><span style=\"color: #0000FF;\">=</span><span style=\"color: #000000;\">0</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #000000;\">N</span>\n <span style=\"color: #008080;\">for</span> <span style=\"color: #000000;\">i</span><span style=\"color: #0000FF;\">=</span><span style=\"color: #000000;\">1</span> <span style=\"color: #008080;\">to</span> <span style=\"color: #000000;\">20000</span> <span style=\"color: #008080;\">do</span>\n     <span style=\"color: #000000;\">N</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">sum</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #7060A8;\">factors</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">i</span><span style=\"color: #0000FF;\">))+(</span><span style=\"color: #000000;\">i</span><span style=\"color: #0000FF;\">!=</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #008080;\">if</span> <span style=\"color: #000000;\">N</span><span style=\"color: #0000FF;\">=</span><span style=\"color: #000000;\">i</span> <span style=\"color: #008080;\">then</span>\n         <span style=\"color: #000000;\">perfect</span> <span style=\"color: #0000FF;\">+=</span> <span style=\"color: #000000;\">1</span>\n     <span style=\"color: #008080;\">elsif</span> <span style=\"color: #000000;\">N</span><span style=\"color: #0000FF;\"><</span><span style=\"color: #000000;\">i</span> <span style=\"color: #008080;\">then</span>\n         <span style=\"color: #000000;\">deficient</span> <span style=\"color: #0000FF;\">+=</span> <span style=\"color: #000000;\">1</span>\n     <span style=\"color: #008080;\">else</span>\n         <span style=\"color: #000000;\">abundant</span> <span style=\"color: #0000FF;\">+=</span> <span style=\"color: #000000;\">1</span>\n     <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">if</span>\n <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">for</span>\n <span style=\"color: #7060A8;\">printf</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #008000;\">\"deficient:%d, perfect:%d, abundant:%d\\n\"</span><span style=\"color: #0000FF;\">,{</span><span style=\"color: #000000;\">deficient</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #000000;\">perfect</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #000000;\">abundant</span><span style=\"color: #0000FF;\">})</span>\n<!--\n"
                }
            ],
            [
                {
                    "language": "Rust",
                    "solution": "fn main() {\n    // deficient starts at 1 because 1 is deficient but proper_divisors returns\n    // and empty Vec\n    let (mut abundant, mut deficient, mut perfect) = (0u32, 1u32, 0u32);\n    for i in 1..20_001 {\n        if let Some(divisors) = i.proper_divisors() {\n            let sum: u64 = divisors.iter().sum();\n            if sum < i {\n                deficient += 1\n            } else if sum > i {\n                abundant += 1\n            } else {\n                perfect += 1\n            }\n        }\n    }\n    println!(\"deficient:\\t{:5}\\nperfect:\\t{:5}\\nabundant:\\t{:5}\",\n             deficient, perfect, abundant);\n}\n"
                },
                {
                    "language": "JavaScript",
                    "solution": "for (var dpa=[1,0,0], n=2; n<=20000; n+=1) {\n    for (var ds=0, d=1, e=n/2+1; d<e; d+=1) if (n%d==0) ds+=d\n    dpa[ds<n ? 0 : ds==n ? 1 : 2]+=1\n}\ndocument.write('Deficient:',dpa[0], ', Perfect:',dpa[1], ', Abundant:',dpa[2], '<br>' )\n"
                }
            ],
            [
                {
                    "language": "Forth",
                    "solution": "CREATE A 0 ,\n: SLOT ( x y -- 0|1|2)  OVER OVER < -ROT > -  1+ ;\n: CLASSIFY ( n -- n')  \\ 0 == deficient, 1 == perfect, 2 == abundant\n   DUP A !  \\ we'll be accessing this often, so save somewhere convenient\n   2 / >R   \\ upper bound\n   1        \\ starting sum, 1 is always a divisor\n   2        \\ current check\n   BEGIN DUP R@ < WHILE\n     A @ OVER /MOD SWAP ( s c d m)\n     IF DROP ELSE\n       R> DROP DUP >R  ( R: d n)\n       OVER TUCK OVER <> * -  ( s c c+?d)\n       ROT + SWAP ( s' c)\n     THEN 1+\n   REPEAT  DROP R> DROP A @  ( sum n)  SLOT ;\nCREATE COUNTS 0 , 0 , 0 ,\n: INIT   COUNTS 3 CELLS ERASE  1 COUNTS ! ;\n: CLASSIFY-NUMBERS ( n --)  INIT\n   BEGIN DUP WHILE\n     1 OVER CLASSIFY  CELLS COUNTS + +!  1-\n   REPEAT  DROP ;\n: .COUNTS\n   .\" Deficient : \" [ COUNTS ]L           @ . CR\n   .\" Perfect   : \" [ COUNTS 1 CELLS + ]L @ . CR\n   .\" Abundant  : \" [ COUNTS 2 CELLS + ]L @ . CR ;\n20000 CLASSIFY-NUMBERS .COUNTS BYE\n"
                },
                {
                    "language": "REXX",
                    "solution": "/* REXX */\nCall time 'R'\ncnt.=0\nDo x=1 To 20000\n  pd=proper_divisors(x)\n  sumpd=sum(pd)\n  Select\n    When x<sumpd Then cnt.abundant =cnt.abundant +1\n    When x=sumpd Then cnt.perfect  =cnt.perfect  +1\n    Otherwise         cnt.deficient=cnt.deficient+1\n    End\n  Select\n    When npd>hi Then Do\n      list.npd=x\n      hi=npd\n      End\n    When npd=hi Then\n      list.hi=list.hi x\n    Otherwise\n      Nop\n    End\n  End\n\nSay 'In the range 1 - 20000'\nSay format(cnt.abundant ,5) 'numbers are abundant  '\nSay format(cnt.perfect  ,5) 'numbers are perfect   '\nSay format(cnt.deficient,5) 'numbers are deficient '\nSay time('E') 'seconds elapsed'\nExit\n\nproper_divisors: Procedure\nParse Arg n\nPd=''\nIf n=1 Then Return ''\nIf n//2=1 Then  /* odd number  */\n  delta=2\nElse            /* even number */\n  delta=1\nDo d=1 To n%2 By delta\n  If n//d=0 Then\n    pd=pd d\n  End\nReturn space(pd)\n\nsum: Procedure\nParse Arg list\nsum=0\nDo i=1 To words(list)\n  sum=sum+word(list,i)\n  End\nReturn sum\n"
                }
            ]
        ]
    },
    {
        "task_name": "Abundant-odd-numbers",
        "task_description": "An [[wp:Abundant_number|Abundant number]] is a number '''n''' for which the &nbsp; ''sum of divisors'' &nbsp; '''\u00cf\u0192(n) > 2n''',\n<br>or, &nbsp; equivalently, &nbsp; the &nbsp; ''sum of proper divisors'' &nbsp; (or aliquot sum) &nbsp; &nbsp; &nbsp; '''s(n) > n'''.\n\n\n;E.G.:\n'''12''' &nbsp; is abundant, it has the proper divisors &nbsp; &nbsp; '''1,2,3,4 <small>&</small> 6''' &nbsp; &nbsp; which sum to &nbsp; '''16''' &nbsp; ( > '''12''' or '''n'''); \n<br>&nbsp; &nbsp; &nbsp;&nbsp; or alternately, &nbsp; has the sigma sum of &nbsp; '''1,2,3,4,6 <small>&</small> 12''' &nbsp; which sum to &nbsp; '''28''' &nbsp; ( > '''24''' or '''2n''').\n\n\nAbundant numbers are common, though '''even''' abundant numbers seem to be much more common than '''odd''' abundant numbers. \n\nTo make things more interesting, this task is specifically about finding &nbsp; ''odd abundant numbers''.\n\n\n;Task\n*Find and display here: at least the first 25 abundant odd numbers and either their proper divisor sum or sigma sum.\n*Find and display here: the one thousandth abundant odd number and either its proper divisor sum or sigma sum.\n*Find and display here: the first abundant odd number greater than one billion (10<sup>9</sup>) and either its proper divisor sum or sigma sum.\n\n\n;References:\n:* &nbsp; [[oeis:A005231|OEIS:A005231: Odd abundant numbers (odd numbers n whose sum of divisors exceeds 2n)]]\n:* &nbsp; American Journal of Mathematics, Vol. 35, No. 4 (Oct., 1913), pp. 413-422 - Finiteness of the Odd Perfect and Primitive Abundant Numbers with n Distinct Prime Factors (LE Dickson)\n<br><br>\n\n",
        "solution_pairs": [
            [
                {
                    "language": "XPL0",
                    "solution": "int Cnt, Num, Div, Sum, Quot;\n[Cnt:= 0;\nNum:= 3;        \\find odd abundant numbers\nloop    [Div:= 1;\n        Sum:= 0;\n        loop    [Quot:= Num/Div;\n                if Div > Quot then quit;\n                if rem(0) = 0 then\n                    [Sum:= Sum + Div;\n                    if Div # Quot then Sum:= Sum + Quot;\n                    ];\n                Div:= Div+2;\n                ];\n        if Sum > 2*Num then\n                [Cnt:= Cnt+1;\n                if Cnt<=25 or Cnt>=1000 then\n                    [IntOut(0, Num);  ChOut(0, 9);\n                    IntOut(0, Sum);  CrLf(0);\n                    if Cnt = 1000 then Num:= 1_000_000_001 - 2;\n                    if Num > 1_000_000_000 then quit;\n                    ];\n                ];\n        Num:= Num+2;\n        ];\n]\n"
                },
                {
                    "language": "Mathematica",
                    "solution": "ClearAll[AbundantQ]\nAbundantQ[n_] := TrueQ[Greater[Total @ Most @ Divisors @ n, n]]\nres = {};\ni = 1;\nWhile[Length[res] < 25,\n  If[AbundantQ[i],\n   AppendTo[res, {i, Total @ Most @ Divisors @ i}];\n   ];\n  i += 2;\n  ];\nres\n\nres = {};\ni = 1;\nWhile[Length[res] < 1000,\n  If[AbundantQ[i],\n   AppendTo[res, {i, Total @ Most @ Divisors @ i}];\n   ];\n  i += 2;\n  ];\nres[[-1]]\n\nres = {};\ni = 1000000001;\nWhile[Length[res] < 1,\n  If[AbundantQ[i],\n   AppendTo[res, {i, Total @ Most @ Divisors @ i}];\n   ];\n  i += 2;\n  ];\nres\n"
                }
            ],
            [
                {
                    "language": "AutoHotkey",
                    "solution": "output := \"First 25 abundant odd numbers:`n\"\nwhile (count<1000)\n{\n\toddNum := 2*A_Index-1\n\tif (str := Abundant(oddNum))\n\t{\n\t\tcount++\n\t\tif (count<=25)\n\t\t\toutput .= oddNum \" \" str \"`n\"\n\t\tif (count = 1000)\n\t\t\toutput .= \"`nOne thousandth abundant odd number:`n\" oddNum \" \" str \"`n\"\n\t}\n}\ncount := 0\nwhile !count\n{\n\tnum := 2*A_Index -1 + 1000000000\n\tif (str := Abundant(num))\n\t{\n\t\tcount++\n\t\toutput .= \"`nFirst abundant odd number greater than one billion:`n\" num \" \" str \"`n\"\n\t}\n}\nMsgBox % output\nreturn\n"
                },
                {
                    "language": "Quackery",
                    "solution": " [ 0 swap factors witheach + ] is sigmasum ( n --> n )\n\n  0 -1 [ 2 +\n         dup sigmasum\n         over 2 * over < iff\n           [ over echo sp\n             echo cr\n             dip 1+ ]\n         else drop\n         over 25 = until ]\n  2drop\n  cr\n  0 -1\n  [ 2 + dup sigmasum\n    over 2 * > if [ dip 1+ ]\n    over 1000 = until ]\n  dup echo sp sigmasum echo cr\n  drop\n  cr\n  999999999\n  [ 2 + dup sigmasum\n    over 2 * > until ]\n  dup echo sp sigmasum echo cr\n"
                }
            ],
            [
                {
                    "language": "360-Assembly",
                    "solution": "*        Abundant odd numbers      18/09/2019\nABUNODDS CSECT\n         USING  ABUNODDS,R13       base register\n         B      72(R15)            skip savearea\n         DC     17F'0'             savearea\n         SAVE   (14,12)            save previous context\n         ST     R13,4(R15)         link backward\n         ST     R15,8(R13)         link forward\n         LR     R13,R15            set addressability\n         LA     R8,0               n=0\n         LA     R6,3               i=3\n       DO WHILE=(C,R8,LT,NN1)      do i=3 by 2 until n>=nn1\n         BAL    R14,SIGMA            s=sigma(i)\n       IF    CR,R9,GT,R6 THEN        if s>i then\n         LA     R8,1(R8)               n++\n         BAL    R14,PRINT              print results\n       ENDIF    ,                    endif\n         LA     R6,2(R6)             i+=2\n       ENDDO    ,                  enddo i\n         LA     R8,0               n=0\n         LA     R6,3               i=3\n         XR     R1,R1              f=false\n       DO WHILE=(C,R1,EQ,=F'0')    do i=3 by 2 while not f\n         BAL    R14,SIGMA            s=sigma(i)\n       IF    CR,R9,GT,R6 THEN        if s>i then\n         LA     R8,1(R8)               n++\n       IF      C,R8,GE,NN2 THEN        if n>=nn2 then\n         BAL    R14,PRINT                print results\n         LA     R1,1                     f=true\n       ENDIF    ,                      endif\n       ENDIF    ,                    endif\n         LA     R6,2(R6)             i+=2\n       ENDDO    ,                  enddo i\n         LA     R8,0               n=0\n         L      R6,NN3             i=mm3\n         LA     R6,1(R6)           +1\n         XR     R1,R1              f=false\n       DO WHILE=(C,R1,EQ,=F'0')    do i=nn3+1 by 2 while not f\n         BAL    R14,SIGMA            s=sigma(i)\n       IF    CR,R9,GT,R6 THEN        if s>i then\n         BAL    R14,PRINT              print results\n         LA     R1,1                   f=true\n       ENDIF    ,                    endif\n         LA     R6,2(R6)             i+=2\n       ENDDO    ,                  enddo i\n         L      R13,4(0,R13)       restore previous savearea pointer\n         RETURN (14,12),RC=0       restore registers from calling save\nSIGMA    CNOP   0,4                ---- subroutine sigma\n         LA     R9,1               s=1\n         LA     R7,3               j=3\n         LR     R5,R7              j\n         MR     R4,R7              j*j\n       DO WHILE=(CR,R5,LT,R6)      do j=3 by 2 while j*j<i\n         LR     R4,R6                i\n         SRDA   R4,32                ~\n         DR     R4,R7                i/j\n       IF   LTR,R4,Z,R4 THEN         if mod(i,j)=0 then\n         AR     R9,R7                  s+j\n         LR     R4,R6                  i\n         SRDA   R4,32                  ~\n         DR     R4,R7                  i/j\n         AR     R9,R5                  s=s+j+i/j\n       ENDIF    ,                    endif\n         LA     R7,2(R7)             j+=2\n         LR     R5,R7                j\n         MR     R4,R7                j*j\n       ENDDO    ,                  enddo j\n       IF    CR,R5,EQ,R6 THEN      if j*j=i then\n         AR     R9,R7              s=s+j\n       ENDIF    ,                  endif\n         BR     R14                ---- end of subroutine sigma\nPRINT    CNOP   0,4                ---- subroutine print\n         XDECO  R8,XDEC            edit n\n         MVC    BUF(4),XDEC+8      output n\n         XDECO  R6,BUF+14          edit & output i\n         XDECO  R9,BUF+33          edit & output s\n         XPRNT  BUF,L'BUF          print buffer\n         BR     R14                ---- end of subroutine print\nNN1      DC     F'25'              nn1=25\nNN2      DC     F'1000'            nn2=1000\nNN3      DC     F'1000000000'      nn3=1000000000\nBUF      DC     CL80'.... - number=............ sigma=............'\nXDEC     DS     CL12               temp for edit\n         REGEQU                    equate registers\n         END    ABUNODDS\n"
                },
                {
                    "language": "PicoLisp",
                    "solution": "(de accud (Var Key)\n   (if (assoc Key (val Var))\n      (con @ (inc (cdr @)))\n      (push Var (cons Key 1)) )\n   Key )\n(de **sum (L)\n   (let S 1\n      (for I (cdr L)\n         (inc 'S (** (car L) I)) )\n      S ) )\n(de factor-sum (N)\n   (if (=1 N)\n      0\n      (let\n         (R NIL\n            D 2\n            L (1 2 2 . (4 2 4 2 4 6 2 6 .))\n            M (sqrt N)\n            N1 N\n            S 1 )\n         (while (>= M D)\n            (if (=0 (% N1 D))\n               (setq M\n                  (sqrt (setq N1 (/ N1 (accud 'R D)))) )\n               (inc 'D (pop 'L)) ) )\n         (accud 'R N1)\n         (for I R\n            (setq S (* S (**sum I))) )\n         (- S N) ) ) )\n(de factor-list NIL\n   (let (N 1  C 0)\n      (make\n         (loop\n            (when (> (setq @@ (factor-sum N)) N)\n               (link (cons N @@))\n               (inc 'C) )\n            (inc 'N 2)\n            (T (= C 1000)) ) ) ) )\n(let L (factor-list)\n   (for N 25\n      (println N (++ L)) )\n   (println 1000 (last L))\n   (println\n      '****\n      1000000575\n      (factor-sum 1000000575) ) )\n"
                }
            ],
            [
                {
                    "language": "Lobster",
                    "solution": "// Note that the following function is for odd numbers only\n// Use \"for (unsigned i = 2; i*i <= n; i++)\" for even and odd numbers\n\ndef sum_proper_divisors_of_odd(n: int) -> int:\n    var sum = 1\n    var i = 3\n    let limit = sqrt(n) + 1\n    while i < limit:\n        if n % i == 0:\n            sum += i\n            let j = n / i\n            if i != j:\n                sum += j\n        i += 2\n    return sum\n\ndef abundant_odd_numbers():\n    var n = 1\n    var c = 0\n    print \"index: number proper_sum\"\n    while c < 25:\n        let s = sum_proper_divisors_of_odd(n)\n        if n < s:\n            c += 1\n            print concat_string([string(c), \": \", string(n), \", \", string(s)], \"\")\n        n += 2\n    var s = 1\n    while c < 1000:\n        s = sum_proper_divisors_of_odd(n)\n        if n < s:\n            c += 1\n        n += 2\n    print concat_string([\"1000: \", string(n), \", \", string(s)], \"\")\n    n =  999999999\n    while n >= s:\n        n += 2\n        s = sum_proper_divisors_of_odd(n)\n    print concat_string([\"The first abundant odd number above one billion is: \", string(n), \", \", string(s)], \"\")\n\n\nabundant_odd_numbers()\n"
                },
                {
                    "language": "360-Assembly",
                    "solution": "*        Abundant odd numbers      18/09/2019\nABUNODDS CSECT\n         USING  ABUNODDS,R13       base register\n         B      72(R15)            skip savearea\n         DC     17F'0'             savearea\n         SAVE   (14,12)            save previous context\n         ST     R13,4(R15)         link backward\n         ST     R15,8(R13)         link forward\n         LR     R13,R15            set addressability\n         LA     R8,0               n=0\n         LA     R6,3               i=3\n       DO WHILE=(C,R8,LT,NN1)      do i=3 by 2 until n>=nn1\n         BAL    R14,SIGMA            s=sigma(i)\n       IF    CR,R9,GT,R6 THEN        if s>i then\n         LA     R8,1(R8)               n++\n         BAL    R14,PRINT              print results\n       ENDIF    ,                    endif\n         LA     R6,2(R6)             i+=2\n       ENDDO    ,                  enddo i\n         LA     R8,0               n=0\n         LA     R6,3               i=3\n         XR     R1,R1              f=false\n       DO WHILE=(C,R1,EQ,=F'0')    do i=3 by 2 while not f\n         BAL    R14,SIGMA            s=sigma(i)\n       IF    CR,R9,GT,R6 THEN        if s>i then\n         LA     R8,1(R8)               n++\n       IF      C,R8,GE,NN2 THEN        if n>=nn2 then\n         BAL    R14,PRINT                print results\n         LA     R1,1                     f=true\n       ENDIF    ,                      endif\n       ENDIF    ,                    endif\n         LA     R6,2(R6)             i+=2\n       ENDDO    ,                  enddo i\n         LA     R8,0               n=0\n         L      R6,NN3             i=mm3\n         LA     R6,1(R6)           +1\n         XR     R1,R1              f=false\n       DO WHILE=(C,R1,EQ,=F'0')    do i=nn3+1 by 2 while not f\n         BAL    R14,SIGMA            s=sigma(i)\n       IF    CR,R9,GT,R6 THEN        if s>i then\n         BAL    R14,PRINT              print results\n         LA     R1,1                   f=true\n       ENDIF    ,                    endif\n         LA     R6,2(R6)             i+=2\n       ENDDO    ,                  enddo i\n         L      R13,4(0,R13)       restore previous savearea pointer\n         RETURN (14,12),RC=0       restore registers from calling save\nSIGMA    CNOP   0,4                ---- subroutine sigma\n         LA     R9,1               s=1\n         LA     R7,3               j=3\n         LR     R5,R7              j\n         MR     R4,R7              j*j\n       DO WHILE=(CR,R5,LT,R6)      do j=3 by 2 while j*j<i\n         LR     R4,R6                i\n         SRDA   R4,32                ~\n         DR     R4,R7                i/j\n       IF   LTR,R4,Z,R4 THEN         if mod(i,j)=0 then\n         AR     R9,R7                  s+j\n         LR     R4,R6                  i\n         SRDA   R4,32                  ~\n         DR     R4,R7                  i/j\n         AR     R9,R5                  s=s+j+i/j\n       ENDIF    ,                    endif\n         LA     R7,2(R7)             j+=2\n         LR     R5,R7                j\n         MR     R4,R7                j*j\n       ENDDO    ,                  enddo j\n       IF    CR,R5,EQ,R6 THEN      if j*j=i then\n         AR     R9,R7              s=s+j\n       ENDIF    ,                  endif\n         BR     R14                ---- end of subroutine sigma\nPRINT    CNOP   0,4                ---- subroutine print\n         XDECO  R8,XDEC            edit n\n         MVC    BUF(4),XDEC+8      output n\n         XDECO  R6,BUF+14          edit & output i\n         XDECO  R9,BUF+33          edit & output s\n         XPRNT  BUF,L'BUF          print buffer\n         BR     R14                ---- end of subroutine print\nNN1      DC     F'25'              nn1=25\nNN2      DC     F'1000'            nn2=1000\nNN3      DC     F'1000000000'      nn3=1000000000\nBUF      DC     CL80'.... - number=............ sigma=............'\nXDEC     DS     CL12               temp for edit\n         REGEQU                    equate registers\n         END    ABUNODDS\n"
                }
            ],
            [
                {
                    "language": "Q",
                    "solution": "s:{c where 0=x mod c:1+til x div 2}            / proper divisors\nsd:sum s@                                      / sum of proper divisors\nabundant:{x<sd x}\nFilter:{y where x each y}\n"
                },
                {
                    "language": "Maxima",
                    "solution": "block([k: 0, n: 1, l: []],\n    while k < 25 do\u00c2\u00a0(\n        n: n+2,\n        if divsum(n,-1) > 2 then (\n            k: k+1,\n            l: append(l, [[n,divsum(n)]])\n        )\n    ),\n    return(l)\n);\n"
                }
            ]
        ]
    },
    {
        "task_name": "Accumulator-factory",
        "task_description": "A problem posed by [[wp:Paul Graham|Paul Graham]] is that of creating a function that takes a single (numeric) argument and which returns another function that is an accumulator. The returned accumulator function in turn also takes a single numeric argument, and returns the sum of all the numeric values passed in so far to that accumulator (including the initial value passed when the accumulator was created).\n\n\n;Rules:\nThe detailed rules are at http://paulgraham.com/accgensub.html and are reproduced here for simplicity (with additions in <small>''small italic text''</small>).\n:Before you submit an example, make sure the function\n\n:# Takes a number n and returns a function (lets call it g), that takes a number i, and returns n incremented by the accumulation of i from every call of function g(i).<br><small>Although these exact function and parameter names need not be used</small>\n:# Works for any numeric type-- i.e. can take both ints and floats and returns functions that can take both ints and floats. (It is not enough simply to convert all input to floats. An accumulator that has only seen integers must return integers.) <small>''(i.e., if the language doesn't allow for numeric polymorphism, you have to use overloading or something like that)''</small>\n:# Generates functions that return the sum of every number ever passed to them, not just the most recent. <small>''(This requires a piece of state to hold the accumulated value, which in turn means that pure functional languages can't be used for this task.)''</small>\n:# Returns a real function, meaning something that you can use wherever you could use a function you had defined in the ordinary way in the text of your program. <small>''(Follow your language's conventions here.)''</small>\n:# Doesn't store the accumulated value or the returned functions in a way that could cause them to be inadvertently modified by other code. <small>''(No global variables or other such things.)''</small>\n: E.g. if after the example, you added the following code (in a made-up language) <small>''where the factory function is called foo''</small>:\n:: <syntaxhighlight lang=\"pseudocode\">x = foo(1); \nx(5); \nfoo(3);\nprint x(2.3);</syntaxhighlight>\n: It should print <tt>8.3</tt>. <small>''(There is no need to print the form of the accumulator function returned by <tt>foo(3)</tt>; it's not part of the task at all.)''</small>\n\n\n;Task:\nCreate a function that implements the described rules. \n\n\nIt need not handle any special error cases not described above. The simplest way to implement the task as described is typically to use a [[Closures|closure]], providing the language supports them.\n\nWhere it is not possible to hold exactly to the constraints above, describe the deviations.\n<br><br>\n\n",
        "solution_pairs": [
            [
                {
                    "language": "ActionScript",
                    "solution": "//Throw an error if a non-number argument is used. (typeof evaluates to\n// \"number\" for both integers and reals)\nfunction checkType(obj:Object):void {\n    if(typeof obj != \"number\")\n\tthrow new ArgumentError(\"Expected integer or float argument. Recieved \" + typeof obj);\n}\nfunction accumulator(sum:Object):Function {\n    checkType(sum);\n    return function(n:Object):Object {checkType(n); return sum += n};\n}\nvar acc:Function=accumulator(2);\ntrace(acc(10));\ntrace(acc(4));\ntrace(acc(\"123\")); //This causes an ArgumentError to be thrown.\n"
                },
                {
                    "language": "M2000-Interpreter",
                    "solution": "\\\\ M2000 Interpreter\n\\\\ accumulator factory\nfoo=lambda acc=0 (n as double=0) -> {\n      \\\\ interpreter place this: read n as double=0 as first line of lambda function\n      if n=0 then =acc : exit\n      acc+=n\n      \\\\ acc passed as a closuer to lambda (a copy of acc in the result lambda function)\n      =lambda acc -> {\n            ' if stack of values is empty then return a copy of acc\n            if empty then =acc : exit\n            read x\n            \\\\ x has no type here, can be any numeric type (also can be an object too)\n            \\\\ accumulator is double, and is a closure (a copy of acc in foo)\n            acc+=x\n            \\\\ any variable in M2000 hold  first type\n            \\\\ if x is an object then we get error, except if object use this operator\n            x=acc\n            \\\\ so we return x type\n            =x\n      }\n}\nx=foo(1&)   ' 1& is long type (32bit)\ncall void x(5) ' 5 is double type (the default type for M2000)\ncall void foo(3#)   ' void tell to interpreter to throw result, 3# is Currency type\nprint x(2.3@) ' print 8.3,   2.3@ is Decimal type\nprint foo()=4 ' print true\ndef ExpType$(z)=type$(z)\nprint ExpType$(foo())=\"Double\"\nprint ExpType$(x(0&))=\"Long\"\nprint ExpType$(x(0@))=\"Decimal\"\nprint ExpType$(x())=\"Double\"\nprint ExpType$(foo(20))=\"lambda\"\n"
                }
            ],
            [
                {
                    "language": "Dart",
                    "solution": "makeAccumulator(s) => (n) => s += n;\n"
                },
                {
                    "language": "Python",
                    "solution": "def accumulator(sum):\n  def f(n):\n    nonlocal sum\n    sum += n\n    return sum\n  return f\n\nx = accumulator(1)\nx(5)\nprint(accumulator(3))\nprint(x(2.3))\n"
                }
            ],
            [
                {
                    "language": "AppleScript",
                    "solution": "on run\n    set x to foo(1)\n\n    x's |\u4f4d|(5)\n\n    foo(3)\n\n    x's |\u4f4d|(2.3)\nend run\n\n-- foo :: Int -> Script\non foo(sum)\n    script\n        on |\u4f4d|(n)\n            set sum to sum + n\n        end |\u4f4d|\n    end script\nend foo\n"
                },
                {
                    "language": "Nim",
                    "solution": "type\n\n  # Kind of numbers. We limit this example to \"int\" and \"float\".\n  NumberKind = enum kInt, kFloat\n\n  # Customized number type (using variants).\n  Number = object\n    case kind: NumberKind\n    of kInt:\n      ival: int\n    of kFloat:\n      fval: float\n\n# The converters allow transparent conversion from int or float to Number.\nconverter toNumber(n: int): Number = Number(kind: kInt, ival: n)\nconverter toNumber(n: float): Number = Number(kind: kFloat, fval: n)\n\n#---------------------------------------------------------------------------------------------------\n\nproc accumulator[T: int|float](x: T): auto =\n  ## Factory procedure.\n\n  # Allocate the accumulator storage.\n  when T is int:\n    var sum = Number(kind: kInt, ival: x)\n  elif T is float:\n    var sum = Number(kind: kFloat, fval: x)\n\n  # Create the accumulator procedure.\n  result = proc (n: Number): Number =\n    # Create the accumulator procedure.\n  result = proc (n: Number): Number =\n             case sum.kind\n             of kInt:\n               case n.kind\n               of kInt:\n                 # Add an int to an int.\n                 sum.ival += n.ival\n               of kFloat:\n                 # Add a float to an int => change the kind of accumulator to float.\n                 sum = Number(kind: kFloat, fval: sum.ival.toFloat + n.fval)\n             of kFloat:\n               case n.kind\n               of kInt:\n                 # Add an int to a float.\n                 sum.fval += n.ival.toFloat\n               of kFloat:\n                 # Add a float to a float.\n                 sum.fval += n.fval\n             result = sum\n\n#---------------------------------------------------------------------------------------------------\n\nproc `$`(n: Number): string =\n  ## Display the accumulator contents as an int or a float depending of its kind.\n  case n.kind\n  of kInt: $n.ival\n  of kFloat: $n.fval\n\n#---------------------------------------------------------------------------------------------------\n\nlet acc = accumulator(1)\necho acc(5)             # 6\ndiscard accumulator(3)  # Create another accumulator.\necho acc(2.3)           # 8.3\n"
                }
            ],
            [
                {
                    "language": "Argile",
                    "solution": "use std, array\n\nlet A = accumulator 42\nprint(A 0)\nprint(A 1)\nprint(A 10)\nprint(A 100)\n\nlet B = accumulator 4.2\nprint(B 0)\nprint(B 1)\nprint(B 10.0)\nprint(B 100.4)\n\n~A ; ~B\n(: use dbg; check mem leak :)\n\n(: accumulator call :)\n=: <accumulator a> <num x> := -> (a.t)\n   call ((a.func) as function(any)(a.t)->(a.t)) with (a.data) ((Cgen x) as a.t)\n\n(: accumulator constructors :)\n.: accumulator <int x> :. -> int accumulator\n   (val (int accumulator) A).init(x)\n   (A as Accumulator).func = ( .:<int& accu, int x>:. ->int {accu += x; accu} )\n   A\n\n.: accumulator <real x> :. -> real accumulator\n   (val (real accumulator) A).init(x)\n   (A as Accumulator).func = ( .:<real&accu,real x>:. ->real{accu += x; accu} )\n   A\n\n=: <accumulator& a>.init <num x> :=\n   a = new (Accumulator)\n   a.data = (new array of 1 a.t)\n   *(a.data as (a.t*)) = Cgen x\n\n(: accumulator destructor :)\n.: del Accumulator <Accumulator a>:.\n   free a.data\n   free a\n=: ~ <accumulator a> := {del Accumulator a}\n\n(: accumulator type :)\nclass Accumulator\n  function\tfunc\n  any\t\tdata\n\n=: [<type t=(int)>] accumulator := -> type\n   Accumulator.prefix\n   Accumulator.suffix\n\nautocast accumulator<->Accumulator\n"
                },
                {
                    "language": "Jsish",
                    "solution": "/* Accumulator factory, in Jsish */\nfunction accumulator(sum) {\n    return function(n) {\n        return sum += n;\n    };\n}\n\nprovide('accumulatorFactory', '0.6');\n\nif (Interp.conf('unitTest')) {\nvar x,y;\n;x = accumulator(1);\n;accumulator;\n;x;\n;x(5);\n;accumulator(3);\n;x(2.3);\n\n;y = accumulator(0);\n;y;\n;x(1);\n;y(2);\n;x(3);\n;y(4);\n;x(5);\n}\n\n/*\n=!EXPECTSTART!=\nx = accumulator(1) ==> \"function(n) {\\n        return sum += n;\\n    }\"\naccumulator ==> \"function accumulator(sum) {\\n    return function(n) {\\n        return sum += n;\\n    };\\n}\"\nx ==> \"function(n) {\\n        return sum += n;\\n    }\"\nx(5) ==> 6\naccumulator(3) ==> \"function(n) {\\n        return sum += n;\\n    }\"\nx(2.3) ==> 8.3\ny = accumulator(0) ==> \"function(n) {\\n        return sum += n;\\n    }\"\ny ==> \"function(n) {\\n        return sum += n;\\n    }\"\nx(1) ==> 9.3\ny(2) ==> 2\nx(3) ==> 12.3\ny(4) ==> 6\nx(5) ==> 17.3\n=!EXPECTEND!=\n*/\n"
                }
            ],
            [
                {
                    "language": "LFE",
                    "solution": "(defun loop (m)\n  (receive\n    (`#(,caller ,n)\n     (let ((sum (+ m n)))\n       (! caller sum)\n       (loop sum)))))\n\n(defun accum (m)\n  (let ((loop-pid (spawn (lambda () (loop m)))))\n    (lambda (n)\n      (! loop-pid `#(,(self) ,n))\n      (receive\n        (sum sum)))))\n"
                },
                {
                    "language": "C++",
                    "solution": "// still inside struct Accumulator_\n\t// various operator() implementations provide a de facto multimethod\n\tAccumulator_& operator()(int more)\n\t{\n\t\tif (auto i = CoerceInt(*val_))\n\t\t\tSet(+i + more);\n\t\telse if (auto d = CoerceDouble(*val_))\n\t\t\tSet(+d + more);\n\t\telse\n\t\t\tTHROW(\"Accumulate(int) failed\");\n\t\treturn *this;\n\t}\n\tAccumulator_& operator()(double more)\n\t{\n\t\tif (auto d = CoerceDouble(*val_))\n\t\t\tSet(+d + more);\n\t\telse\n\t\t\tTHROW(\"Accumulate(double) failed\");\n\t\treturn *this;\n\t}\n\tAccumulator_& operator()(const String_& more)\n\t{\n\t\tif (auto s = CoerceString(*val_))\n\t\t\tSet(+s + more);\n\t\telse\n\t\t\tTHROW(\"Accumulate(string) failed\");\n\t\treturn *this;\n\t}\n};\n"
                }
            ]
        ]
    },
    {
        "task_name": "Achilles-numbers",
        "task_description": "An '''Achilles number''' is a number that is powerful but imperfect. ''Named after Achilles, a hero of the Trojan war, who was also powerful but imperfect.''\n\n\nA positive integer '''n''' is a powerful number if, for every prime factor '''p''' of '''n''', '''p<sup>2</sup>''' is also a divisor.\n\nIn other words, every prime factor appears at least squared in the factorization.\n\nAll '''Achilles numbers''' are powerful. However, not all powerful numbers are '''Achilles numbers''': only those that cannot be represented as '''m<sup>k</sup>''', where '''m''' and '''k''' are positive integers greater than '''1'''.\n\n\nA '''''strong'' Achilles number''' is an '''Achilles number''' whose '''Euler totient (\uf8ff\u00f9\u00fa\u00eb)''' is also an '''Achilles number'''.\n\n\n\n;E.G.\n\n'''108''' is a powerful number. Its prime factorization is '''2<sup>2</sup> \u221a\u00f3 3<sup>3</sup>''', and thus its prime factors are '''2''' and '''3'''. Both '''2<sup>2</sup> = 4''' and  '''3<sup>2</sup> = 9''' are divisors of '''108'''. However, '''108''' cannot be represented as '''m<sup>k</sup>''', where '''m''' and '''k''' are positive integers greater than '''1''', so '''108''' is an '''Achilles number'''.\n\n'''360''' is ''not'' an '''Achilles number''' because it is not powerful. One of its prime factors is '''5''' but '''360''' is not divisible by '''5<sup>2</sup> = 25'''.\n\nFinally, '''784''' is ''not'' an '''Achilles number'''. It is a powerful number, because not only are '''2''' and '''7''' its only prime factors, but also '''2<sup>2</sup> = 4''' and '''7<sup>2</sup> = 49''' are divisors of it. Nonetheless, it is a perfect power; its square root is an even integer, so it is ''not'' an '''Achilles number'''.\n\n\n'''500 = 2<sup>2</sup> \u221a\u00f3 5<sup>3</sup>''' is a '''''strong'' Achilles number''' as its Euler totient, '''\uf8ff\u00f9\u00fa\u00eb(500)''', is '''200 = 2<sup>3</sup> \u221a\u00f3 5<sup>2</sup>''' which is ''also'' an '''Achilles number'''.\n\n\n\n;Task\n\n* Find and show the first 50 '''Achilles numbers'''.\n* Find and show at least the first 20 '''''strong'' Achilles numbers'''.\n* For at least 2 through 5, show the count of '''Achilles numbers''' with that many digits.\n\n\n;See also\n\n;* [[wp:Achilles number|Wikipedia: Achilles number]]\n;* [[oeis:A052486|OEIS:A052486 - Achilles numbers - powerful but imperfect numbers]]\n;* [[oeis:A194085|OEIS:A194085 - Strong Achilles numbers: Achilles numbers m such that phi(m) is also an Achilles number]]\n;* [[Powerful numbers|Related task: Powerful numbers]]\n;* [[Totient function|Related task: Totient function]]\n\n\n",
        "solution_pairs": [
            [
                {
                    "language": "Perl",
                    "solution": "use strict;\nuse warnings;\nuse feature <say current_sub>;\nuse experimental 'signatures';\nuse List::AllUtils <max head>;\nuse ntheory <is_square_free euler_phi>;\nuse Math::AnyNum <:overload idiv is_power iroot ipow is_coprime>;\n\nsub table { my $t = shift() * (my $c = 1 + length max @_); (sprintf(('%' . $c . 'd') x @_, @_)) =~ s/.{1,$t}\\K/\\n/gr }\n\nsub powerful_numbers ($n, $k = 2) {\n    my @powerful;\n    sub ($m, $r) {\n        $r < $k and push @powerful, $m and return;\n        for my $v (1 .. iroot(idiv($n, $m), $r)) {\n            if ($r > $k) { next unless is_square_free($v) and is_coprime($m, $v) }\n            __SUB__->($m * ipow($v, $r), $r - 1);\n        }\n    }->(1, 2 * $k - 1);\n    sort { $a <=> $b } @powerful;\n}\n\nmy (@achilles, %Ahash, @strong);\nmy @P = powerful_numbers(10**9, 2);\n!is_power($_) and push @achilles, $_ and $Ahash{$_}++ for @P;\n$Ahash{euler_phi $_} and push @strong, $_ for @achilles;\n\nsay \"First 50 Achilles numbers:\\n\" . table 10,        head 50, @achilles;\nsay \"First 30 strong Achilles numbers:\\n\" . table 10, head 30, @strong;\nsay \"Number of Achilles numbers with:\\n\";\n\nfor my $l (2 .. 9) {\n    my $c;\n    $l == length and $c++ for @achilles;\n    say \"$l digits: $c\";\n}\n"
                },
                {
                    "language": "J",
                    "solution": "achilles=: (*/ .>&1 * 1 = +./)@(1{__&q:)\"0\nstrong=: achilles@(5&p:)\n"
                }
            ],
            [
                {
                    "language": "Nim",
                    "solution": "import std/[algorithm, sets, math, sequtils, strformat, strutils]\n\nconst MaxDigits = 15\n\nfunc getPerfectPowers(maxExp: int): HashSet[int] =\n  let upper = 10^maxExp\n  for i in 2..int(sqrt(upper.toFloat)):\n    var p = i\n    while p < upper div i:\n      p *= i\n      result.incl p\n\nlet pps = getPerfectPowers(MaxDigits)\n\nproc getAchilles(minExp, maxExp: int): HashSet[int] =\n  let lower = 10^minExp\n  let upper = 10^maxExp\n  for b in 1..int(cbrt(upper.toFloat)):\n    let b3 = b * b * b\n    for a in 1..int(sqrt(upper.toFloat)):\n      let p = b3 * a * a\n      if p >= upper: break\n      if p >= lower:\n        if p notin pps: result.incl p\n\n\n### Part 1 ###\n\nlet achillesSet = getAchilles(1, 6)\nlet achilles = sorted(achillesSet.toSeq)\n\necho \"First 50 Achilles numbers:\"\nfor i in 0..49:\n  let n = achilles[i]\n  stdout.write &\"{n:>4}\"\n  stdout.write if i mod 10 == 9: '\\n' else: ' '\n\n\n### Part 2 ###\n\nfunc totient(n: int): int =\n  var n = n\n  result = n\n  var i = 2\n  while i * i <= n:\n    if n mod i == 0:\n      while n mod i == 0:\n        n = int(n / i)\n      result -= int(result / i)\n    if i == 2: i = 1\n    inc i, 2\n  if n > 1:\n    result -= int(result / n)\n\necho \"\\nFirst 50 strong Achilles numbers:\"\nvar strongAchilles: seq[int]\nvar count = 0\nfor n in achilles:\n  let tot = totient(n)\n  if tot in achillesSet:\n    strongAchilles.add n\n    inc count\n    if count == 50: break\n\nfor i, n in strongAchilles:\n  stdout.write &\"{n:>6}\"\n  stdout.write if i mod 10 == 9: '\\n' else: ' '\n\n\n### Part 3 ###\n\necho \"\\nNumber of Achilles numbers with:\"\nfor d in 2..MaxDigits:\n  let ac = getAchilles(d - 1, d).len\n  echo &\"{d:>2} digits: {ac}\"\n"
                },
                {
                    "language": "EasyLang",
                    "solution": "func gcd n d .\n   if d = 0\n      return n\n   .\n   return gcd d (n mod d)\n.\nfunc totient n .\n   for m = 1 to n\n      if gcd m n = 1\n         tot += 1\n      .\n   .\n   return tot\n.\nfunc isPowerful m .\n   n = m\n   f = 2\n   l = sqrt m\n   if m <= 1\n      return 0\n   .\n   while 1 = 1\n      q = n div f\n      if n mod f = 0\n         if m mod (f * f) <> 0\n            return 0\n         .\n         n = q\n         if f > n\n            return 1\n         .\n      else\n         f += 1\n         if f > l\n            if m mod (n * n) <> 0\n               return 0\n            .\n            return 1\n         .\n      .\n   .\n.\nfunc isAchilles n .\n   if isPowerful n = 0\n      return 0\n   .\n   m = 2\n   a = m * m\n   repeat\n      repeat\n         if a = n\n            return 0\n         .\n         a *= m\n         until a > n\n      .\n      m += 1\n      a = m * m\n      until a > n\n   .\n   return 1\n.\nprint \"First 50 Achilles numbers:\"\nn = 1\nrepeat\n   if isAchilles n = 1\n      write n & \" \"\n      num += 1\n   .\n   n += 1\n   until num >= 50\n.\nprint \"\"\nprint \"\"\nprint \"First 20 strong Achilles numbers:\"\nnum = 0\nn = 1\nrepeat\n   if isAchilles n = 1 and isAchilles totient n = 1\n      write n & \" \"\n      num += 1\n   .\n   n += 1\n   until num >= 20\n.\nprint \"\"\nprint \"\"\nprint \"Number of Achilles numbers with 2 to 5 digits:\"\na = 10\nb = 100\nfor i = 2 to 5\n   num = 0\n   for n = a to b - 1\n      if isAchilles n = 1\n         num += 1\n      .\n   .\n   write num & \" \"\n   a = b\n   b *= 10\n.\n"
                }
            ],
            [
                {
                    "language": "EasyLang",
                    "solution": "func gcd n d .\n   if d = 0\n      return n\n   .\n   return gcd d (n mod d)\n.\nfunc totient n .\n   for m = 1 to n\n      if gcd m n = 1\n         tot += 1\n      .\n   .\n   return tot\n.\nfunc isPowerful m .\n   n = m\n   f = 2\n   l = sqrt m\n   if m <= 1\n      return 0\n   .\n   while 1 = 1\n      q = n div f\n      if n mod f = 0\n         if m mod (f * f) <> 0\n            return 0\n         .\n         n = q\n         if f > n\n            return 1\n         .\n      else\n         f += 1\n         if f > l\n            if m mod (n * n) <> 0\n               return 0\n            .\n            return 1\n         .\n      .\n   .\n.\nfunc isAchilles n .\n   if isPowerful n = 0\n      return 0\n   .\n   m = 2\n   a = m * m\n   repeat\n      repeat\n         if a = n\n            return 0\n         .\n         a *= m\n         until a > n\n      .\n      m += 1\n      a = m * m\n      until a > n\n   .\n   return 1\n.\nprint \"First 50 Achilles numbers:\"\nn = 1\nrepeat\n   if isAchilles n = 1\n      write n & \" \"\n      num += 1\n   .\n   n += 1\n   until num >= 50\n.\nprint \"\"\nprint \"\"\nprint \"First 20 strong Achilles numbers:\"\nnum = 0\nn = 1\nrepeat\n   if isAchilles n = 1 and isAchilles totient n = 1\n      write n & \" \"\n      num += 1\n   .\n   n += 1\n   until num >= 20\n.\nprint \"\"\nprint \"\"\nprint \"Number of Achilles numbers with 2 to 5 digits:\"\na = 10\nb = 100\nfor i = 2 to 5\n   num = 0\n   for n = a to b - 1\n      if isAchilles n = 1\n         num += 1\n      .\n   .\n   write num & \" \"\n   a = b\n   b *= 10\n.\n"
                },
                {
                    "language": "Wren",
                    "solution": "import \"./set\" for Set\nimport \"./seq\" for Lst\nimport \"./math\" for Int\nimport \"./fmt\" for Fmt\n\nvar pps = Set.new()\n\nvar getPerfectPowers = Fn.new { |maxExp|\n    var upper = 10.pow(maxExp)\n    for (i in 2..upper.sqrt.floor) {\n        var p = i\n        while ((p = p * i) < upper) pps.add(p)\n    }\n}\n\nvar getAchilles = Fn.new { |minExp, maxExp|\n    var lower = 10.pow(minExp)\n    var upper = 10.pow(maxExp)\n    var achilles = Set.new() // avoids duplicates\n    for (b in 1..upper.cbrt.floor) {\n        var b3 = b * b * b\n        for (a in 1..upper.sqrt.floor) {\n            var p = b3 * a * a\n            if (p >= upper) break\n            if (p >= lower) {\n                if (!pps.contains(p)) achilles.add(p)\n            }\n        }\n    }\n    return achilles\n}\n\nvar maxDigits = 15\ngetPerfectPowers.call(maxDigits)\n\nvar achillesSet = getAchilles.call(1, 5) // enough for first 2 parts\nvar achilles = achillesSet.toList\nachilles.sort()\n\nSystem.print(\"First 50 Achilles numbers:\")\nFmt.tprint(\"$4d\", achilles.take(50), 10)\n\nSystem.print(\"\\nFirst 30 strong Achilles numbers:\")\nvar strongAchilles = []\nvar count = 0\nvar n = 0\nwhile (count < 30) {\n    var tot = Int.totient(achilles[n])\n    if (achillesSet.contains(tot)) {\n        strongAchilles.add(achilles[n])\n        count = count + 1\n    }\n    n = n + 1\n}\nFmt.tprint(\"$5d\", strongAchilles, 10)\n\nSystem.print(\"\\nNumber of Achilles numbers with:\")\nfor (d in 2..maxDigits) {\n    var ac = getAchilles.call(d-1, d).count\n    Fmt.print(\"$2d digits: $d\", d, ac)\n}\n"
                }
            ],
            [
                {
                    "language": "XPL0",
                    "solution": "func GCD(N, D);         \\Return the greatest common divisor of N and D\nint  N, D;              \\numerator and denominator\nint  R;\n[if D > N then\n    [R:= D;  D:= N;  N:= R];    \\swap D and N\nwhile D > 0 do\n    [R:= rem(N/D);\n    N:= D;\n    D:= R;\n    ];\nreturn N;\n];      \\GCD\n\nfunc Totient(N);        \\Return the totient of N\nint  N, Phi, M;\n[Phi:= 0;\nfor M:= 1 to N do\n    if GCD(M, N) = 1 then Phi:= Phi+1;\nreturn Phi;\n];\n\nfunc Powerful(N0);      \\Return 'true' if N0 is a powerful number\nint  N0, N, F, Q, L;\n[if N0 <= 1 then return false;\nN:= N0;  F:= 2;\nL:= sqrt(N0);\nloop    [Q:= N/F;\n        if rem(0) = 0 then      \\found a factor\n                [if rem(N0/(F*F)) then return false;\n                N:= Q;\n                if F>N then quit;\n                ]\n        else    [F:= F+1;\n                if F > L then\n                    [if rem(N0/(N*N)) then return false;\n                    quit;\n                    ];\n                ];\n        ];\nreturn true;\n];\n\nfunc Achilles(N);       \\Return 'true' if N is an Achilles number\nint  N, M, A;\n[if not Powerful(N) then return false;\nM:= 2;\nA:= M*M;\nrepeat  loop    [if A = N then return false;\n                if A > N then quit;\n                A:= A*M;\n                ];\n        M:= M+1;\n        A:= M*M;\nuntil   A > N;\nreturn true;\n];\n\nint Cnt, N, Pwr, Start;\n[Cnt:= 0;\nN:= 1;\nloop    [if Achilles(N) then\n            [IntOut(0, N);\n            Cnt:= Cnt+1;\n            if Cnt >= 50 then quit;\n            if rem(Cnt/10) then ChOut(0, 9) else CrLf(0);\n            ];\n        N:= N+1;\n        ];\nCrLf(0);  CrLf(0);\nCnt:= 0;\nN:= 1;\nloop    [if Achilles(N) then\n            if Achilles(Totient(N)) then\n                [IntOut(0, N);\n                Cnt:= Cnt+1;\n                if Cnt >= 20 then quit;\n                if rem(Cnt/10) then ChOut(0, 9) else CrLf(0);\n                ];\n        N:= N+1;\n        ];\nCrLf(0);  CrLf(0);\nfor Pwr:= 1 to 6 do\n    [IntOut(0, Pwr);  Text(0, \": \");\n    Start:= fix(Pow(10.0, float(Pwr-1)));\n    Cnt:= 0;\n    for N:= Start to Start*10-1 do\n        if Achilles(N) then Cnt:= Cnt+1;\n    IntOut(0, Cnt);  CrLf(0);\n    ];\n]\n"
                },
                {
                    "language": "Java",
                    "solution": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic class AchillesNumbers {\n\n    private Map<Integer, Boolean> pps = new HashMap<>();\n\n    public int totient(int n) {\n        int tot = n;\n        int i = 2;\n        while (i * i <= n) {\n            if (n % i == 0) {\n                while (n % i == 0) {\n                    n /= i;\n                }\n                tot -= tot / i;\n            }\n            if (i == 2) {\n                i = 1;\n            }\n            i += 2;\n        }\n        if (n > 1) {\n            tot -= tot / n;\n        }\n        return tot;\n    }\n\n    public void getPerfectPowers(int maxExp) {\n        double upper = Math.pow(10, maxExp);\n        for (int i = 2; i <= Math.sqrt(upper); i++) {\n            double fi = i;\n            double p = fi;\n            while (true) {\n                p *= fi;\n                if (p >= upper) {\n                    break;\n                }\n                pps.put((int) p, true);\n            }\n        }\n    }\n\n    public Map<Integer, Boolean> getAchilles(int minExp, int maxExp) {\n        double lower = Math.pow(10, minExp);\n        double upper = Math.pow(10, maxExp);\n        Map<Integer, Boolean> achilles = new HashMap<>();\n        for (int b = 1; b <= (int) Math.cbrt(upper); b++) {\n            int b3 = b * b * b;\n            for (int a = 1; a <= (int) Math.sqrt(upper); a++) {\n                int p = b3 * a * a;\n                if (p >= (int) upper) {\n                    break;\n                }\n                if (p >= (int) lower) {\n                    if (!pps.containsKey(p)) {\n                        achilles.put(p, true);\n                    }\n                }\n            }\n        }\n        return achilles;\n    }\n\n    public static void main(String[] args) {\n        AchillesNumbers an = new AchillesNumbers();\n\n        int maxDigits = 8;\n        an.getPerfectPowers(maxDigits);\n        Map<Integer, Boolean> achillesSet = an.getAchilles(1, 5);\n        List<Integer> achilles = new ArrayList<>(achillesSet.keySet());\n        Collections.sort(achilles);\n\n        System.out.println(\"First 50 Achilles numbers:\");\n        for (int i = 0; i < 50; i++) {\n            System.out.printf(\"%4d \", achilles.get(i));\n            if ((i + 1) % 10 == 0) {\n                System.out.println();\n            }\n        }\n\n        System.out.println(\"\\nFirst 30 strong Achilles numbers:\");\n        List<Integer> strongAchilles = new ArrayList<>();\n        int count = 0;\n        for (int n = 0; count < 30; n++) {\n            int tot = an.totient(achilles.get(n));\n            if (achillesSet.containsKey(tot)) {\n                strongAchilles.add(achilles.get(n));\n                count++;\n            }\n        }\n        for (int i = 0; i < 30; i++) {\n            System.out.printf(\"%5d \", strongAchilles.get(i));\n            if ((i + 1) % 10 == 0) {\n                System.out.println();\n            }\n        }\n\n        System.out.println(\"\\nNumber of Achilles numbers with:\");\n        for (int d = 2; d <= maxDigits; d++) {\n            int ac = an.getAchilles(d - 1, d).size();\n            System.out.printf(\"%2d digits: %d\\n\", d, ac);\n        }\n    }\n}\n"
                }
            ],
            [
                {
                    "language": "ALGOL-68",
                    "solution": "BEGIN # find Achilles Numbers: numbers whose prime factors p appear at least  #\n      # twice (i.e. if p is a prime factor, so is p^2) and cannot be          #\n      # expressed as m^k for any integer m, k > 1                             #\n      # also find strong Achilles Numbers: Achilles Numbers where the Euler's #\n      # totient of the number is also Achilles                                #\n    # returns the number of integers k where 1 <= k <= n that are mutually    #\n    #         prime to n                                                      #\n    PROC totient = ( INT n )INT:        # algorithm from the second Go sample #\n        IF   n < 3 THEN 1               #        in the Totient Function task #\n        ELIF n = 3 THEN 2\n        ELSE\n            INT result := n;\n            INT v      := n;\n            INT i      := 2;\n            WHILE i * i <= v DO\n                IF v MOD i = 0 THEN\n                    WHILE v MOD i = 0 DO v OVERAB i OD;\n                    result -:= result OVER i\n                FI;\n                IF i = 2 THEN\n                   i := 1\n                FI;\n                i +:= 2\n            OD;\n            IF v > 1 THEN result -:= result OVER v FI;\n            result\n         FI # totient # ;\n    # find the numbers                                                        #\n    INT max number = 1 000 000;                 # max number we will consider #\n    PR read \"primes.incl.a68\" PR                #     include prime utilities #\n    []BOOL prime = PRIMESIEVE max number;       # construct a sieve of primes #\n    # table of numbers, will be set to TRUE for the Achilles Numbers          #\n    [ 1 : max number ]BOOL achiles;\n    FOR a TO UPB achiles DO\n        achiles[ a ] := TRUE\n    OD;\n    # remove the numbers that don't have squared primes as factors            #\n    achiles[ 1 ] := FALSE;\n    FOR a TO UPB achiles DO\n        IF prime[ a ] THEN\n            # have a prime, remove it and every multiple of it that isn't a   #\n            # multiple of a squared                                           #\n            INT a count := 0;\n            FOR j FROM a BY a TO UPB achiles DO\n                a count +:= 1;\n                IF a count = a THEN # have a multiple of i^2, keep the number #\n                    a count := 0\n                ELSE               # not a multiple of i^2, remove the number #\n                    achiles[ j ] := FALSE\n                FI\n            OD\n        FI\n    OD;\n    # achiles now has TRUE for the powerful numbers, remove all m^k (m,k > 1) #\n    FOR m FROM 2 TO UPB achiles DO\n        INT mk    := m;\n        INT max mk = UPB achiles OVER m;    # avoid overflow if INT is 32 bit #\n        WHILE mk <= max mk DO\n            mk           *:= m;\n            achiles[ mk ] := FALSE\n        OD\n    OD;\n    # achiles now has TRUE for imperfect powerful numbers                     #\n    # show the first 50 Achilles Numbers                                      #\n    BEGIN\n        print( ( \"First 50 Achilles Numbers:\", newline ) );\n        INT a count := 0;\n        FOR a WHILE a count < 50 DO\n            IF achiles[ a ] THEN\n                a count +:= 1;\n                print( ( \" \", whole( a, -6 ) ) );\n                IF a count MOD 10 = 0 THEN\n                    print( ( newline ) )\n                FI\n            FI\n        OD\n    END;\n    # show the first 50 Strong Achilles numbers                               #\n    BEGIN\n        print( ( \"First 20 Strong Achilles Numbers:\", newline ) );\n        INT s count := 0;\n        FOR s WHILE s count < 20 DO\n            IF achiles[ s ] THEN\n                IF achiles[ totient( s ) ] THEN\n                    s count +:= 1;\n                    print( ( \" \", whole( s, -6 ) ) );\n                    IF s count MOD 10 = 0 THEN\n                        print( ( newline ) )\n                    FI\n                FI\n            FI\n        OD\n    END;\n    # count the number of Achilles Numbers by their digit counts              #\n    BEGIN\n        INT a count     :=   0;\n        INT power of 10 := 100;\n        INT digit count :=   2;\n        FOR a TO UPB achiles DO\n            IF achiles[ a ] THEN\n                # have an Achilles Number                                     #\n                a count +:= 1\n            FI;\n            IF a = power of 10 THEN\n                # have reached a power of 10                                  #\n                print( ( \"Achilles Numbers with \", whole( digit count, 0 )\n                       , \" digits: \",             whole( a count,    -6 )\n                       , newline\n                       )\n                     );\n                digit count +:=  1;\n                power of 10 *:= 10;\n                a count      :=  0\n            FI\n        OD\n    END\nEND\n"
                },
                {
                    "language": "Phix",
                    "solution": "(phixonline)-->\n <span style=\"color: #008080;\">with</span> <span style=\"color: #008080;\">javascript_semantics</span>\n <span style=\"color: #7060A8;\">requires</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #008000;\">\"1.0.2\"</span><span style=\"color: #0000FF;\">)</span> <span style=\"color: #000080;font-style:italic;\">-- [join_by(fmt)]</span>\n <span style=\"color: #004080;\">atom</span> <span style=\"color: #000000;\">t0</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">time</span><span style=\"color: #0000FF;\">()</span>\n <span style=\"color: #008080;\">constant</span> <span style=\"color: #000000;\">maxDigits</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #008080;\">iff</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #7060A8;\">platform</span><span style=\"color: #0000FF;\">()=</span><span style=\"color: #004600;\">JS</span><span style=\"color: #0000FF;\">?</span><span style=\"color: #000000;\">10</span><span style=\"color: #0000FF;\">:</span><span style=\"color: #000000;\">12</span><span style=\"color: #0000FF;\">)</span>\n <span style=\"color: #004080;\">integer</span> <span style=\"color: #000000;\">pps</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">new_dict</span><span style=\"color: #0000FF;\">()</span>\n\n <span style=\"color: #008080;\">procedure</span> <span style=\"color: #000000;\">getPerfectPowers</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #004080;\">integer</span> <span style=\"color: #000000;\">maxExp</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #004080;\">atom</span> <span style=\"color: #000000;\">hi</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">power</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">10</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #000000;\">maxExp</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #004080;\">integer</span> <span style=\"color: #000000;\">imax</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">floor</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #7060A8;\">sqrt</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">hi</span><span style=\"color: #0000FF;\">))</span>\n     <span style=\"color: #008080;\">for</span> <span style=\"color: #000000;\">i</span><span style=\"color: #0000FF;\">=</span><span style=\"color: #000000;\">2</span> <span style=\"color: #008080;\">to</span> <span style=\"color: #000000;\">imax</span> <span style=\"color: #008080;\">do</span>\n         <span style=\"color: #004080;\">atom</span> <span style=\"color: #000000;\">p</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #000000;\">i</span>\n         <span style=\"color: #008080;\">while</span> <span style=\"color: #004600;\">true</span> <span style=\"color: #008080;\">do</span>\n             <span style=\"color: #000000;\">p</span> <span style=\"color: #0000FF;\">*=</span> <span style=\"color: #000000;\">i</span>\n             <span style=\"color: #008080;\">if</span> <span style=\"color: #000000;\">p</span><span style=\"color: #0000FF;\">>=</span><span style=\"color: #000000;\">hi</span> <span style=\"color: #008080;\">then</span> <span style=\"color: #008080;\">exit</span> <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">if</span>\n             <span style=\"color: #7060A8;\">setd</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">p</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #004600;\">true</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">pps</span><span style=\"color: #0000FF;\">)</span>\n         <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">while</span>\n     <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">for</span>\n <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">procedure</span>\n\n <span style=\"color: #008080;\">function</span> <span style=\"color: #000000;\">get_achilles</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #004080;\">integer</span> <span style=\"color: #000000;\">minExp</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #000000;\">maxExp</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #004080;\">atom</span> <span style=\"color: #000000;\">lo10</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">power</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">10</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">minExp</span><span style=\"color: #0000FF;\">),</span>\n          <span style=\"color: #000000;\">hi10</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">power</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">10</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">maxExp</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #004080;\">integer</span> <span style=\"color: #000000;\">bmax</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">floor</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #7060A8;\">power</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">hi10</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">/</span><span style=\"color: #000000;\">3</span><span style=\"color: #0000FF;\">)),</span>\n             <span style=\"color: #000000;\">amax</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">floor</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #7060A8;\">sqrt</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">hi10</span><span style=\"color: #0000FF;\">))</span>\n     <span style=\"color: #004080;\">sequence</span> <span style=\"color: #000000;\">achilles</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #0000FF;\">{}</span>\n     <span style=\"color: #008080;\">for</span> <span style=\"color: #000000;\">b</span><span style=\"color: #0000FF;\">=</span><span style=\"color: #000000;\">2</span> <span style=\"color: #008080;\">to</span> <span style=\"color: #000000;\">bmax</span> <span style=\"color: #008080;\">do</span>\n         <span style=\"color: #004080;\">atom</span> <span style=\"color: #000000;\">b3</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #000000;\">b</span> <span style=\"color: #0000FF;\">*</span> <span style=\"color: #000000;\">b</span> <span style=\"color: #0000FF;\">*</span> <span style=\"color: #000000;\">b</span>\n         <span style=\"color: #008080;\">for</span> <span style=\"color: #000000;\">a</span><span style=\"color: #0000FF;\">=</span><span style=\"color: #000000;\">2</span> <span style=\"color: #008080;\">to</span> <span style=\"color: #000000;\">amax</span> <span style=\"color: #008080;\">do</span>\n             <span style=\"color: #004080;\">atom</span> <span style=\"color: #000000;\">p</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #000000;\">b3</span> <span style=\"color: #0000FF;\">*</span> <span style=\"color: #000000;\">a</span> <span style=\"color: #0000FF;\">*</span> <span style=\"color: #000000;\">a</span>\n             <span style=\"color: #008080;\">if</span> <span style=\"color: #000000;\">p</span><span style=\"color: #0000FF;\">>=</span><span style=\"color: #000000;\">hi10</span> <span style=\"color: #008080;\">then</span> <span style=\"color: #008080;\">exit</span> <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">if</span>\n             <span style=\"color: #008080;\">if</span> <span style=\"color: #000000;\">p</span><span style=\"color: #0000FF;\">>=</span><span style=\"color: #000000;\">lo10</span> <span style=\"color: #008080;\">then</span>\n                 <span style=\"color: #004080;\">integer</span> <span style=\"color: #000000;\">node</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">getd_index</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">p</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">pps</span><span style=\"color: #0000FF;\">)</span>\n                 <span style=\"color: #008080;\">if</span> <span style=\"color: #000000;\">node</span><span style=\"color: #0000FF;\">=</span><span style=\"color: #004600;\">NULL</span> <span style=\"color: #008080;\">then</span>\n                     <span style=\"color: #000000;\">achilles</span> <span style=\"color: #0000FF;\">&=</span> <span style=\"color: #000000;\">p</span>\n                 <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">if</span>\n             <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">if</span>\n         <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">for</span>\n     <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">for</span>\n     <span style=\"color: #000000;\">achilles</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">unique</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">achilles</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #008080;\">return</span> <span style=\"color: #000000;\">achilles</span>\n <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">function</span>\n\n <span style=\"color: #000000;\">getPerfectPowers</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">maxDigits</span><span style=\"color: #0000FF;\">)</span>\n <span style=\"color: #004080;\">sequence</span> <span style=\"color: #000000;\">achilles</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #000000;\">get_achilles</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">5</span><span style=\"color: #0000FF;\">)</span>\n\n <span style=\"color: #008080;\">function</span> <span style=\"color: #000000;\">strong_achilles</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #004080;\">integer</span> <span style=\"color: #000000;\">n</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #004080;\">integer</span> <span style=\"color: #000000;\">totient</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">sum</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #7060A8;\">sq_eq</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #7060A8;\">apply</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #004600;\">true</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #7060A8;\">gcd</span><span style=\"color: #0000FF;\">,{</span><span style=\"color: #7060A8;\">tagset</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">n</span><span style=\"color: #0000FF;\">),</span><span style=\"color: #000000;\">n</span><span style=\"color: #0000FF;\">}),</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">))</span>\n     <span style=\"color: #008080;\">return</span> <span style=\"color: #7060A8;\">find</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">totient</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">achilles</span><span style=\"color: #0000FF;\">)</span>\n <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">function</span>\n\n <span style=\"color: #004080;\">sequence</span> <span style=\"color: #000000;\">a</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">join_by</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">achilles</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">..</span><span style=\"color: #000000;\">50</span><span style=\"color: #0000FF;\">],</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">10</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #008000;\">\" \"</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">fmt</span><span style=\"color: #0000FF;\">:=</span><span style=\"color: #008000;\">\"%4d\"</span><span style=\"color: #0000FF;\">),</span>\n          <span style=\"color: #000000;\">sa</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">filter</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">achilles</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">strong_achilles</span><span style=\"color: #0000FF;\">)[</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">..</span><span style=\"color: #000000;\">30</span><span style=\"color: #0000FF;\">],</span>\n          <span style=\"color: #000000;\">ssa</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">join_by</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">sa</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">10</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #008000;\">\" \"</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">fmt</span><span style=\"color: #0000FF;\">:=</span><span style=\"color: #008000;\">\"%5d\"</span><span style=\"color: #0000FF;\">)</span>\n\n <span style=\"color: #7060A8;\">printf</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #008000;\">\"First 50 Achilles numbers:\\n%s\\n\"</span><span style=\"color: #0000FF;\">,{</span><span style=\"color: #000000;\">a</span><span style=\"color: #0000FF;\">})</span>\n <span style=\"color: #7060A8;\">printf</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #008000;\">\"First 30 strong Achilles numbers:\\n%s\\n\"</span><span style=\"color: #0000FF;\">,{</span><span style=\"color: #000000;\">ssa</span><span style=\"color: #0000FF;\">})</span>\n <span style=\"color: #008080;\">for</span> <span style=\"color: #000000;\">d</span><span style=\"color: #0000FF;\">=</span><span style=\"color: #000000;\">2</span> <span style=\"color: #008080;\">to</span> <span style=\"color: #000000;\">maxDigits</span> <span style=\"color: #008080;\">do</span>\n     <span style=\"color: #7060A8;\">printf</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #008000;\">\"Achilles numbers with %d digits:%d\\n\"</span><span style=\"color: #0000FF;\">,{</span><span style=\"color: #000000;\">d</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #7060A8;\">length</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">get_achilles</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">d</span><span style=\"color: #0000FF;\">-</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">d</span><span style=\"color: #0000FF;\">))})</span>\n <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">for</span>\n <span style=\"color: #0000FF;\">?</span><span style=\"color: #7060A8;\">elapsed</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #7060A8;\">time</span><span style=\"color: #0000FF;\">()-</span><span style=\"color: #000000;\">t0</span><span style=\"color: #0000FF;\">)</span>\n<!--\n"
                }
            ]
        ]
    },
    {
        "task_name": "Ackermann-function",
        "task_description": "The '''[[wp:Ackermann function|Ackermann function]]''' is a classic example of a recursive function, notable especially because it is not a [[wp:Primitive_recursive_function|primitive recursive function]]. It grows very quickly in value, as does the size of its call tree. \n\n\nThe Ackermann function is usually defined as follows:\n\n<big>\n:<math> A(m, n) =\n \\begin{cases}\n n+1 & \\mbox{if } m = 0 \\\\\n A(m-1, 1) & \\mbox{if } m > 0 \\mbox{ and } n = 0 \\\\\n A(m-1, A(m, n-1)) & \\mbox{if } m > 0 \\mbox{ and } n > 0.\n \\end{cases}\n</math>\n</big>\n\n<!-- <table><tr><td width=12><td><td><math>n+1</math><td>if <math>m=0</math> <tr><td> <td><math>A(m, n) =</math> <td><math>A(m-1, 1)</math> <td>if <math>m>0</math> and <math>n=0</math> <tr><td><td><td><math>A(m-1, A(m, n-1))</math>&nbsp;&nbsp;<td> if <math>m>0</math> and <math>n>0</math></table> -->\n\nIts arguments are never negative and it always terminates.\n\n\n;Task:\nWrite a function which returns the value of <math>A(m, n)</math>. Arbitrary precision is preferred (since the function grows so quickly), but not required.\n\n\n;See also:\n* [[wp:Conway_chained_arrow_notation#Ackermann_function|Conway chained arrow notation]] for the Ackermann function.\n<br><br>\n\n",
        "solution_pairs": [
            [
                {
                    "language": "Lua",
                    "solution": "function ack(M,N)\n    if M == 0 then return N + 1 end\n    if N == 0 then return ack(M-1,1) end\n    return ack(M-1,ack(M, N-1))\nend\n"
                },
                {
                    "language": "Haxe",
                    "solution": "class RosettaDemo\n{\n    static public function main()\n    {\n        Sys.print(ackermann(3, 4));\n    }\n\n    static function ackermann(m : Int, n : Int)\n    {\n        if (m == 0)\n        {\n            return n + 1;\n        }\n        else if (n == 0)\n        {\n            return ackermann(m-1, 1);\n        }\n        return ackermann(m-1, ackermann(m, n-1));\n    }\n}\n"
                }
            ],
            [
                {
                    "language": "Scheme",
                    "solution": "(define (A m n)\n  (letrec ((A-stream\n    (cons-stream\n      (ints-from 1) ;; m = 0\n      (cons-stream\n        (ints-from 2) ;; m = 1\n        (cons-stream\n          ;; m = 2\n          (stream-map (lambda (n)\n                        (1+ (* 2 (1+ n))))\n                      (ints-from 0))\n          (cons-stream\n            ;; m = 3\n            (stream-map (lambda (n)\n                          (- (knuth-up-arrow 2 (- m 2) (+ n 3)) 3))\n                        (ints-from 0))\n             ;; m = 4...\n            (stream-tail A-stream 3)))))))\n    (stream-ref (stream-ref A-stream m) n)))\n\n(define (ints-from n)\n  (letrec ((ints-rec (cons-stream n (stream-map 1+ ints-rec))))\n    ints-rec))\n\n(define (knuth-up-arrow a n b)\n  (let loop ((n n) (b b))\n    (cond ((= b 0) 1)\n          ((= n 1) (expt a b))\n          (else    (loop (-1+ n) (loop n (-1+ b)))))))\n"
                },
                {
                    "language": "OCaml",
                    "solution": "open Big_int\nlet one  = unit_big_int\nlet zero = zero_big_int\nlet succ = succ_big_int\nlet pred = pred_big_int\nlet eq = eq_big_int\n\nlet rec a m n =\n  if eq m zero then (succ n) else\n  if eq n zero then (a (pred m) one) else\n  (a (pred m) (a m (pred n)))\n"
                }
            ],
            [
                {
                    "language": "Bracmat",
                    "solution": "  ( A\n  =     m n value key eq chain\n      , find insert future stack va val\n    .   ( chain\n        =   key future skey\n          .   !arg:(?key.?future)\n            & str$!key:?skey\n            & (cache..insert)$(!skey..!future)\n            &\n        )\n      & (find=.(cache..find)$(str$!arg))\n      & ( insert\n        =   key value future v futureeq futurem skey\n          .   !arg:(?key.?value)\n            & str$!key:?skey\n            & (   (cache..find)$!skey:(?key.?v.?future)\n                & (cache..remove)$!skey\n                & (cache..insert)$(!skey.!value.)\n                & (   !future:(?futurem.?futureeq)\n                    & (!futurem,!value.!futureeq)\n                  |\n                  )\n              | (cache..insert)$(!skey.!value.)&\n              )\n        )\n      & !arg:(?m,?n)\n      & !n+1:?value\n      & :?eq:?stack\n      &   whl\n        ' ( (!m,!n):?key\n          &     (   find$!key:(?.#%?value.?future)\n                  & insert$(!eq.!value) !future\n                |   !m:0\n                  & !n+1:?value\n                  & ( !eq:&insert$(!key.!value)\n                    |   insert$(!key.!value) !stack:?stack\n                      & insert$(!eq.!value)\n                    )\n                |   !n:0\n                  &   (!m+-1,1.!key)\n                      (!eq:|(!key.!eq))\n                |   find$(!m,!n+-1):(?.?val.?)\n                  & (   !val:#%\n                      & (   find$(!m+-1,!val):(?.?va.?)\n                          & !va:#%\n                          & insert$(!key.!va)\n                        |   (!m+-1,!val.!eq)\n                            (!m,!n.!eq)\n                        )\n                    |\n                    )\n                |   chain$(!m,!n+-1.!m+-1.!key)\n                  &   (!m,!n+-1.)\n                      (!eq:|(!key.!eq))\n                )\n                !stack\n            : (?m,?n.?eq) ?stack\n          )\n      & !value\n  )\n& new$hash:?cache\n"
                },
                {
                    "language": "Pure-Data",
                    "solution": "#N canvas 741 265 450 436 10;\n#X obj 83 111 t b l;\n#X obj 115 163 route 0;\n#X obj 115 185 + 1;\n#X obj 83 380 f;\n#X obj 161 186 swap;\n#X obj 161 228 route 0;\n#X obj 161 250 - 1;\n#X obj 161 208 pack;\n#X obj 115 314 t f f;\n#X msg 161 272 \\$1 1;\n#X obj 115 142 t l;\n#X obj 207 250 swap;\n#X obj 273 271 - 1;\n#X obj 207 272 t f f;\n#X obj 207 298 - 1;\n#X obj 207 360 pack;\n#X obj 239 299 pack;\n#X obj 83 77 inlet;\n#X obj 83 402 outlet;\n#X connect 0 0 3 0;\n#X connect 0 1 10 0;\n#X connect 1 0 2 0;\n#X connect 1 1 4 0;\n#X connect 2 0 8 0;\n#X connect 3 0 18 0;\n#X connect 4 0 7 0;\n#X connect 4 1 7 1;\n#X connect 5 0 6 0;\n#X connect 5 1 11 0;\n#X connect 6 0 9 0;\n#X connect 7 0 5 0;\n#X connect 8 0 3 1;\n#X connect 8 1 15 1;\n#X connect 9 0 10 0;\n#X connect 10 0 1 0;\n#X connect 11 0 13 0;\n#X connect 11 1 12 0;\n#X connect 12 0 16 1;\n#X connect 13 0 14 0;\n#X connect 13 1 16 0;\n#X connect 14 0 15 0;\n#X connect 15 0 10 0;\n#X connect 16 0 10 0;\n#X connect 17 0 0 0;\n"
                }
            ],
            [
                {
                    "language": "Ruby",
                    "solution": "(0..3).each do |m|\n  puts (0..6).map { |n| ack(m, n) }.join(' ')\nend\n"
                },
                {
                    "language": "SNUSP",
                    "solution": "   /==!/==atoi=@@@-@-----#\n   |   |                          Ackermann function\n   |   |       /=========\\!==\\!====\\  recursion:\n$,@/>,@/==ack=!\\?\\<+#    |   |     |   A(0,j) -> j+1\n j   i           \\<?\\+>-@/#  |     |   A(i,0) -> A(i-1,1)\n                    \\@\\>@\\->@/@\\<-@/#  A(i,j) -> A(i-1,A(i,j-1))\n                      |  |     |\n            #      #  |  |     |             /+<<<-\\\n            /-<<+>>\\!=/  \\=====|==!/========?\\>>>=?/<<#\n            ?      ?           |   \\<<<+>+>>-/\n            \\>>+<<-/!==========/\n            #      #\n"
                }
            ],
            [
                {
                    "language": "Logtalk",
                    "solution": "ack(0, N, V) :-\n    !,\n    V is N + 1.\nack(M, 0, V) :-\n    !,\n    M2 is M - 1,\n    ack(M2, 1, V).\nack(M, N, V) :-\n    M2 is M - 1,\n    N2 is N - 1,\n    ack(M, N2, V2),\n    ack(M2, V2, V).\n"
                },
                {
                    "language": "Nemerle",
                    "solution": "def ackermann = {\n    def A(m, n) {\n        | (0, n) => n + 1\n        | (m, 0) when m > 0 => A(m - 1, 1)\n        | (m, n) when m > 0 && n > 0 => A(m - 1, A(m, n - 1))\n        | _ => throw Exception(\"invalid inputs\");\n    }\n    A\n}\n"
                }
            ]
        ]
    },
    {
        "task_name": "Active-Directory-Connect",
        "task_description": "The task is to establish a connection to an Active Directory or Lightweight Directory Access Protocol server.\n\n",
        "solution_pairs": [
            [
                {
                    "language": "Racket",
                    "solution": "#lang racket\n(require net/ldap)\n(ldap-authenticate \"ldap.somewhere.com\" 389 \"uid=username,ou=people,dc=somewhere,dc=com\" password)\n"
                },
                {
                    "language": "Java",
                    "solution": "import java.io.IOException;\nimport org.apache.directory.api.ldap.model.exception.LdapException;\nimport org.apache.directory.ldap.client.api.LdapConnection;\nimport org.apache.directory.ldap.client.api.LdapNetworkConnection;\n\npublic class LdapConnectionDemo {\n\n    public static void main(String[] args) throws LdapException, IOException {\n        try (LdapConnection connection = new LdapNetworkConnection(\"localhost\", 10389)) {\n            connection.bind();\n            connection.unBind();\n        }\n    }\n}\n"
                }
            ],
            [
                {
                    "language": "C",
                    "solution": "#include <ldap.h>\n...\nchar *name, *password;\n...\nLDAP *ld = ldap_init(\"ldap.somewhere.com\", 389);\nldap_simple_bind_s(ld, name, password);\n... after done with it...\nldap_unbind(ld);\n"
                },
                {
                    "language": "NetRexx",
                    "solution": "/* NetRexx */\noptions replace format comments java crossref symbols binary\n\nimport org.apache.directory.ldap.client.api.LdapConnection\nimport org.apache.directory.ldap.client.api.LdapNetworkConnection\nimport org.apache.directory.shared.ldap.model.exception.LdapException\nimport org.slf4j.Logger\nimport org.slf4j.LoggerFactory\n\nclass RDirectoryLDAP public\n\n  properties constant\n    log_ = LoggerFactory.getLogger(RDirectoryLDAP.class)\n\n  properties private static\n    connection = LdapConnection null\n\n  method main(args = String[]) public static\n    ldapHostName = String \"localhost\"\n    ldapPort = int 10389\n\n    if log_.isInfoEnabled() then log_.info(\"LDAP Connection to\" ldapHostName \"on port\" ldapPort)\n    connection = LdapNetworkConnection(ldapHostName, ldapPort)\n\n    do\n      if log_.isTraceEnabled() then log_.trace(\"LDAP bind\")\n      connection.bind()\n\n      if log_.isTraceEnabled() then log_.trace(\"LDAP unbind\")\n      connection.unBind()\n    catch lex = LdapException\n      log_.error(\"LDAP Error\", Throwable lex)\n    catch iox = IOException\n      log_.error(\"I/O Error\", Throwable iox)\n    finally\n      do\n      if connection \\= null then connection.close()\n      catch iox = IOException\n        log_.error(\"I/O Error on connection.close()\", Throwable iox)\n      end\n    end\n\n    return\n"
                }
            ],
            [
                {
                    "language": "Wren",
                    "solution": "#include <stdio.h>\n#include <stdio_ext.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ldap.h>\n#include \"wren.h\"\n\n/* C <=> Wren interface functions */\n\nvoid C_ldapAllocate(WrenVM* vm) {\n    LDAP** pldap = (LDAP**)wrenSetSlotNewForeign(vm, 0, 0, sizeof(LDAP*));\n    char *host = (char *)wrenGetSlotString(vm, 1);\n    int port = (int)wrenGetSlotDouble(vm, 2);\n    *pldap = ldap_init(host, port);\n}\n\nvoid C_simpleBindS(WrenVM* vm) {\n    LDAP* ldap = *(LDAP**)wrenGetSlotForeign(vm, 0);\n    const char *name = wrenGetSlotString(vm, 1);\n    const char *password = wrenGetSlotString(vm, 2);\n    ldap_simple_bind_s(ldap, name, password);\n}\n\nvoid C_unbind(WrenVM* vm) {\n    LDAP* ldap = *(LDAP**)wrenGetSlotForeign(vm, 0);\n    ldap_unbind(ldap);\n}\n\nvoid C_getInput(WrenVM* vm) {\n    int maxSize = (int)wrenGetSlotDouble(vm, 1) + 2;\n    char input[maxSize];\n    fgets(input, maxSize, stdin);\n    __fpurge(stdin);\n    input[strcspn(input, \"\\n\")] = 0;\n    wrenSetSlotString(vm, 0, (const char*)input);\n}\n\nWrenForeignClassMethods bindForeignClass(WrenVM* vm, const char* module, const char* className) {\n    WrenForeignClassMethods methods;\n    methods.finalize = NULL;\n    if (strcmp(className, \"LDAP\") == 0) {\n        methods.allocate = C_ldapAllocate;\n    }\n    return methods;\n}\n\nWrenForeignMethodFn bindForeignMethod(\n    WrenVM* vm,\n    const char* module,\n    const char* className,\n    bool isStatic,\n    const char* signature) {\n    if (strcmp(module, \"main\") == 0) {\n        if (strcmp(className, \"LDAP\") == 0) {\n            if (!isStatic && strcmp(signature, \"simpleBindS(_,_)\") == 0) return C_simpleBindS;\n            if (!isStatic && strcmp(signature, \"unbind()\") == 0) return C_unbind;\n        } else if (strcmp(className, \"C\") == 0) {\n            if (isStatic && strcmp(signature, \"getInput(_)\") == 0) return C_getInput;\n        }\n    }\n    return NULL;\n}\n\nstatic void writeFn(WrenVM* vm, const char* text) {\n    printf(\"%s\", text);\n}\n\nvoid errorFn(WrenVM* vm, WrenErrorType errorType, const char* module, const int line, const char* msg) {\n    switch (errorType) {\n        case WREN_ERROR_COMPILE:\n            printf(\"[%s line %d] [Error] %s\\n\", module, line, msg);\n            break;\n        case WREN_ERROR_STACK_TRACE:\n            printf(\"[%s line %d] in %s\\n\", module, line, msg);\n            break;\n        case WREN_ERROR_RUNTIME:\n            printf(\"[Runtime Error] %s\\n\", msg);\n            break;\n    }\n}\n\nchar *readFile(const char *fileName) {\n    FILE *f = fopen(fileName, \"r\");\n    fseek(f, 0, SEEK_END);\n    long fsize = ftell(f);\n    rewind(f);\n    char *script = malloc(fsize + 1);\n    fread(script, 1, fsize, f);\n    fclose(f);\n    script[fsize] = 0;\n    return script;\n}\n\nint main(int argc, char **argv) {\n    WrenConfiguration config;\n    wrenInitConfiguration(&config);\n    config.writeFn = &writeFn;\n    config.errorFn = &errorFn;\n    config.bindForeignClassFn = &bindForeignClass;\n    config.bindForeignMethodFn = &bindForeignMethod;\n    WrenVM* vm = wrenNewVM(&config);\n    const char* module = \"main\";\n    const char* fileName = \"Active_Directory_Connect.wren\";\n    char *script = readFile(fileName);\n    WrenInterpretResult result = wrenInterpret(vm, module, script);\n    switch (result) {\n        case WREN_RESULT_COMPILE_ERROR:\n            printf(\"Compile Error!\\n\");\n            break;\n        case WREN_RESULT_RUNTIME_ERROR:\n            printf(\"Runtime Error!\\n\");\n            break;\n        case WREN_RESULT_SUCCESS:\n            break;\n    }\n    wrenFreeVM(vm);\n    free(script);\n    return 0;\n}\n"
                },
                {
                    "language": "VBScript",
                    "solution": "Set objConn = CreateObject(\"ADODB.Connection\")\nSet objCmd = CreateObject(\"ADODB.Command\")\nobjConn.Provider = \"ADsDSOObject\"\nobjConn.Open\n"
                }
            ],
            [
                {
                    "language": "F-Sharp",
                    "solution": "let ldapServer = new System.DirectoryServices.Protocols.LdapDirectoryIdentifier(\"127.0.0.1\")\nlet connect = new System.DirectoryServices.Protocols.LdapConnection(ldapServer)\nconnect.Bind()\n"
                },
                {
                    "language": "Phix",
                    "solution": "-->\n <span style=\"color: #008080;\">include</span> <span style=\"color: #000000;\">builtins</span><span style=\"color: #0000FF;\">/</span><span style=\"color: #000000;\">ldap</span><span style=\"color: #0000FF;\">.</span><span style=\"color: #000000;\">e</span>\n\n <span style=\"color: #008080;\">constant</span> <span style=\"color: #000000;\">servers</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #0000FF;\">{</span>\n <span style=\"color: #008000;\">\"ldap.somewhere.com\"</span><span style=\"color: #0000FF;\">,</span>\n <span style=\"color: #0000FF;\">}</span>\n <span style=\"color: #000080;font-style:italic;\">--...</span>\n <span style=\"color: #004080;\">string</span> <span style=\"color: #000000;\">name</span><span style=\"color: #0000FF;\">=</span><span style=\"color: #008000;\">\"name\"</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #000000;\">password</span><span style=\"color: #0000FF;\">=</span><span style=\"color: #008000;\">\"passwd\"</span>\n <span style=\"color: #000080;font-style:italic;\">--...</span>\n <span style=\"color: #008080;\">for</span> <span style=\"color: #000000;\">i</span><span style=\"color: #0000FF;\">=</span><span style=\"color: #000000;\">1</span> <span style=\"color: #008080;\">to</span> <span style=\"color: #7060A8;\">length</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">servers</span><span style=\"color: #0000FF;\">)</span> <span style=\"color: #008080;\">do</span>\n     <span style=\"color: #004080;\">atom</span> <span style=\"color: #000000;\">ld</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #000000;\">ldap_init</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">servers</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">i</span><span style=\"color: #0000FF;\">])</span>\n     <span style=\"color: #004080;\">integer</span> <span style=\"color: #000000;\">res</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #000000;\">ldap_simple_bind_s</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">ld</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #000000;\">name</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #000000;\">password</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #7060A8;\">printf</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #008000;\">\"%s: %d [%s]\\n\"</span><span style=\"color: #0000FF;\">,{</span><span style=\"color: #000000;\">servers</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">i</span><span style=\"color: #0000FF;\">],</span><span style=\"color: #000000;\">res</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">ldap_err_desc</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">res</span><span style=\"color: #0000FF;\">)})</span>\n     <span style=\"color: #000080;font-style:italic;\">--... after done with it...</span>\n     <span style=\"color: #000000;\">ldap_unbind</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">ld</span><span style=\"color: #0000FF;\">)</span>\n <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">for</span>\n<!--\n"
                }
            ],
            [
                {
                    "language": "Smart-BASIC",
                    "solution": "PRINT \"Current directory: \";CURRENT_DIR$()\nPRINT\nPRINT \"Folders:\"\nPRINT\nDIR \"/\" LIST DIRS a$,c\nFOR n = 0 TO c-1\nPRINT ,a$(n)\nNEXT n\nPRINT\nPRINT \"Files:\"\nPRINT\nDIR \"/\" LIST FILES a$,c\nFOR n = 0 TO c-1\nPRINT ,a$(n)\nNEXT n\n"
                },
                {
                    "language": "C-sharp",
                    "solution": "// Requires adding a reference to System.DirectoryServices\nvar objDE = new System.DirectoryServices.DirectoryEntry(\"LDAP://DC=onecity,DC=corp,DC=fabrikam,DC=com\");\n"
                }
            ]
        ]
    },
    {
        "task_name": "Active-Directory-Search-for-a-user",
        "task_description": "Make sure you [[Connect to Active Directory]]\n\n",
        "solution_pairs": [
            [
                {
                    "language": "Eiffel",
                    "solution": "feature -- Validation\n\n\tis_user_credential_valid (a_domain, a_username, a_password: READABLE_STRING_GENERAL): BOOLEAN\n\t\t\t-- Is the pair `a_username'/`a_password' a valid credential in `a_domain'?\n\t\tlocal\n\t\t\tl_domain, l_username, l_password: WEL_STRING\n\t\tdo\n\t\t\tcreate l_domain.make (a_domain)\n\t\t\tcreate l_username.make (a_username)\n\t\t\tcreate l_password.make (a_password)\n\t\t\tResult := cwel_is_credential_valid (l_domain.item, l_username.item, l_password.item)\n\t\tend\n"
                },
                {
                    "language": "PicoLisp",
                    "solution": "(de ldapsearch (Sn)\n   (in\n      (list \"ldapsearch\" \"-xH\" \"ldap://db.debian.org\"\n         \"-b\" \"dc=debian,dc=org\"\n         (pack \"sn=\" Sn) )\n      (list\n         (cons 'cn (prog (from \"cn: \") (line T)))\n         (cons 'uid (prog (from \"uid: \") (line T))) ) ) )\n"
                }
            ],
            [
                {
                    "language": "Eiffel",
                    "solution": "\tcwel_is_credential_valid (a_domain, a_username, a_password: POINTER): BOOLEAN\n\t\texternal\n\t\t\t\"C inline use %\"wel_user_validation.h%\"\"\n\t\talias\n\t\t\t\"return cwel_is_credential_valid ((LPTSTR) $a_domain, (LPTSTR) $a_username, (LPTSTR) $a_password);\"\n\t\tend\n"
                },
                {
                    "language": "VBScript",
                    "solution": "If objRS.RecordCount > 0 Then\n  For Each objUser in ObjRS\n    WScript.Echo objRS.Fields(\"DistinguishedName\")\n  Next\nEnd If\n"
                }
            ],
            [
                {
                    "language": "D",
                    "solution": "import openldap;\nimport std.stdio;\n\nvoid main() {\n  // connect to server\n  auto ldap = LDAP(\"ldap://localhost\");\n\n  // search for uid\n  auto r = ldap.search_s(\"dc=example,dc=com\", LDAP_SCOPE_SUBTREE, \"(uid=%s)\".format(\"test\"));\n\n  // show properties\n  writeln(\"Found dn: %s\", r[0].dn);\n  foreach(k, v; r[0].entry)\n    writeln(\"%s = %s\", k, v);\n\n  // bind on found entry\n  int b = ldap.bind_s(r[0].dn, \"password\");\n  scope(exit) ldap.unbind;\n  if (b)\n  {\n    writeln(\"error on binding\");\n    return;\n  }\n\n  // do something\n  ...\n\n}\n"
                },
                {
                    "language": "PowerShell",
                    "solution": "Import-Module ActiveDirectory\n\n$searchData = \"user name\"\n$searchBase = \"DC=example,DC=com\"\n\n#searches by some of the most common unique identifiers\nget-aduser -Filter((DistinguishedName -eq $searchdata) -or (UserPrincipalName -eq $searchdata) -or (SamAccountName -eq $searchdata)) -SearchBase $searchBase\n"
                }
            ],
            [
                {
                    "language": "Wren",
                    "solution": "#include <stdio.h>\n#include <stdio_ext.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ldap.h>\n#include \"wren.h\"\n\n/* C <=> Wren interface functions */\n\nvoid C_ldapMessageAllocate(WrenVM* vm) {\n    wrenSetSlotNewForeign(vm, 0, 0, sizeof(LDAPMessage*));\n}\n\nvoid C_msgfree(WrenVM* vm) {\n    LDAPMessage* msg = *(LDAPMessage**)wrenGetSlotForeign(vm, 0);\n    ldap_msgfree(msg);\n}\n\nvoid C_ldapAllocate(WrenVM* vm) {\n    LDAP** pldap = (LDAP**)wrenSetSlotNewForeign(vm, 0, 0, sizeof(LDAP*));\n    char *host = (char *)wrenGetSlotString(vm, 1);\n    int port = (int)wrenGetSlotDouble(vm, 2);\n    *pldap = ldap_init(host, port);\n}\n\nvoid C_simpleBindS(WrenVM* vm) {\n    LDAP* ldap = *(LDAP**)wrenGetSlotForeign(vm, 0);\n    const char *name = wrenGetSlotString(vm, 1);\n    const char *password = wrenGetSlotString(vm, 2);\n    ldap_simple_bind_s(ldap, name, password);\n}\n\nvoid C_searchS(WrenVM* vm) {\n    LDAP* ldap = *(LDAP**)wrenGetSlotForeign(vm, 0);\n    const char *base = wrenGetSlotString(vm, 1);\n    int scope = (int)(ber_int_t)wrenGetSlotDouble(vm, 2);\n    const char *filter = wrenGetSlotString(vm, 3);\n    // no need to get attrs from slot 4 as we want all of them\n    int attrsonly = (int)wrenGetSlotDouble(vm, 5);\n    LDAPMessage** res = (LDAPMessage**)wrenGetSlotForeign(vm, 6);\n    ldap_search_s(ldap, base, scope, filter, NULL, attrsonly, res);\n}\n\nvoid C_unbind(WrenVM* vm) {\n    LDAP* ldap = *(LDAP**)wrenGetSlotForeign(vm, 0);\n    ldap_unbind(ldap);\n}\n\nvoid C_getInput(WrenVM* vm) {\n    int maxSize = (int)wrenGetSlotDouble(vm, 1) + 2;\n    char input[maxSize];\n    fgets(input, maxSize, stdin);\n    __fpurge(stdin);\n    input[strcspn(input, \"\\n\")] = 0;\n    wrenSetSlotString(vm, 0, (const char*)input);\n}\n\nWrenForeignClassMethods bindForeignClass(WrenVM* vm, const char* module, const char* className) {\n    WrenForeignClassMethods methods;\n    methods.finalize = NULL;\n    if (strcmp(className, \"LDAP\") == 0) {\n        methods.allocate = C_ldapAllocate;\n    } else if (strcmp(className, \"LDAPMessage\") == 0) {\n        methods.allocate = C_ldapMessageAllocate;\n    }\n    return methods;\n}\n\nWrenForeignMethodFn bindForeignMethod(\n    WrenVM* vm,\n    const char* module,\n    const char* className,\n    bool isStatic,\n    const char* signature) {\n    if (strcmp(module, \"main\") == 0) {\n        if (strcmp(className, \"LDAP\") == 0) {\n            if (!isStatic && strcmp(signature, \"simpleBindS(_,_)\") == 0) return C_simpleBindS;\n            if (!isStatic && strcmp(signature, \"searchS(_,_,_,_,_,_)\") == 0) return C_searchS;\n            if (!isStatic && strcmp(signature, \"unbind()\") == 0) return C_unbind;\n        } else if (strcmp(className, \"LDAPMessage\") == 0) {\n            if (!isStatic && strcmp(signature, \"msgfree()\") == 0) return C_msgfree;\n        } else if (strcmp(className, \"C\") == 0) {\n            if (isStatic && strcmp(signature, \"getInput(_)\") == 0) return C_getInput;\n        }\n    }\n    return NULL;\n}\n\nstatic void writeFn(WrenVM* vm, const char* text) {\n    printf(\"%s\", text);\n}\n\nvoid errorFn(WrenVM* vm, WrenErrorType errorType, const char* module, const int line, const char* msg) {\n    switch (errorType) {\n        case WREN_ERROR_COMPILE:\n            printf(\"[%s line %d] [Error] %s\\n\", module, line, msg);\n            break;\n        case WREN_ERROR_STACK_TRACE:\n            printf(\"[%s line %d] in %s\\n\", module, line, msg);\n            break;\n        case WREN_ERROR_RUNTIME:\n            printf(\"[Runtime Error] %s\\n\", msg);\n            break;\n    }\n}\n\nchar *readFile(const char *fileName) {\n    FILE *f = fopen(fileName, \"r\");\n    fseek(f, 0, SEEK_END);\n    long fsize = ftell(f);\n    rewind(f);\n    char *script = malloc(fsize + 1);\n    fread(script, 1, fsize, f);\n    fclose(f);\n    script[fsize] = 0;\n    return script;\n}\n\nint main(int argc, char **argv) {\n    WrenConfiguration config;\n    wrenInitConfiguration(&config);\n    config.writeFn = &writeFn;\n    config.errorFn = &errorFn;\n    config.bindForeignClassFn = &bindForeignClass;\n    config.bindForeignMethodFn = &bindForeignMethod;\n    WrenVM* vm = wrenNewVM(&config);\n    const char* module = \"main\";\n    const char* fileName = \"Active_Directory_Search_for_a_user.wren\";\n    char *script = readFile(fileName);\n    WrenInterpretResult result = wrenInterpret(vm, module, script);\n    switch (result) {\n        case WREN_RESULT_COMPILE_ERROR:\n            printf(\"Compile Error!\\n\");\n            break;\n        case WREN_RESULT_RUNTIME_ERROR:\n            printf(\"Runtime Error!\\n\");\n            break;\n        case WREN_RESULT_SUCCESS:\n            break;\n    }\n    wrenFreeVM(vm);\n    free(script);\n    return 0;\n}\n"
                },
                {
                    "language": "Tcl",
                    "solution": "set result [ldap::search $conn $Base $Filter $Attrs -scope subtree]\n"
                }
            ],
            [
                {
                    "language": "VBScript",
                    "solution": "strUsername = \"TestUser\"\nstrQuery = \"<LDAP://dc=skycityauckland,dc=sceg,dc=com>;\"_\n & \"(&(objectclass=*)(samaccountname=\" & strUsername & \"));distinguishedname;subtree\"\nobjCmd.ActiveConnection = objConn\nobjCmd.Properties(\"Page Size\")=100\nobjCmd.CommandText = strQuery\nSet objRS = objCmd.Execute\n"
                },
                {
                    "language": "Scala",
                    "solution": "import org.apache.directory.api.ldap.model.message.SearchScope\nimport org.apache.directory.ldap.client.api.{LdapConnection, LdapNetworkConnection}\n\nobject LdapSearchDemo extends App {\n\n  class LdapSearch {\n\n    def demonstrateSearch(): Unit = {\n\n      val conn = new LdapNetworkConnection(\"localhost\", 11389)\n      try {\n        conn.bind(\"uid=admin,ou=system\", \"********\")\n        search(conn, \"*mil*\")\n        conn.unBind()\n      } finally if (conn != null) conn.close()\n\n    }\n\n    private def search(connection: LdapConnection, uid: String): Unit = {\n      val baseDn = \"ou=users,o=mojo\"\n      val filter = \"(&(objectClass=person)(&(uid=\" + uid + \")))\"\n      val scope = SearchScope.SUBTREE\n      val attributes = List(\"dn\", \"cn\", \"sn\", \"uid\")\n      var ksearch = 0\n      val cursor = connection.search(baseDn, filter, scope, attributes: _*)\n      while (cursor.next) {\n        ksearch += 1\n        val entry = cursor.get\n        printf(\"Search entry %d = %s%n\", ksearch, entry)\n      }\n    }\n  }\n\n  new LdapSearch().demonstrateSearch()\n\n}\n"
                }
            ]
        ]
    },
    {
        "task_name": "Active-object",
        "task_description": "In [[object-oriented programming]] an object is active when its state depends on clock. Usually an active object encapsulates a [[task]] that updates the object's state. To the outer world the object looks like a normal object with methods that can be called from outside. Implementation of such methods must have a certain synchronization mechanism with the encapsulated task in order to prevent object's state corruption.\n\nA typical instance of an active object is an animation widget. The widget state changes with the time, while as an object it has all properties of a normal widget.\n\n'''The task'''\n\nImplement an active integrator object. The object has an input and output. The input can be set using the method ''Input''. The input is a function of time. The output can be queried using the method ''Output''. The object integrates its input over the time and the result becomes the object's output. So if the input is ''K''(''t'') and the output is ''S'', the object state ''S'' is changed to ''S'' + (''K''(''t''<sub>1</sub>) + ''K''(''t''<sub>0</sub>)) * (''t''<sub>1</sub> - ''t''<sub>0</sub>) / 2, i.e. it integrates ''K'' using the trapeze method. Initially ''K'' is constant 0 and ''S'' is 0.\n\nIn order to test the object:\n# set its input to sin (2\u00cf\u20ac ''f t''), where the frequency ''f''=0.5Hz. The phase is irrelevant.\n# wait 2s\n# set the input to constant 0\n# wait 0.5s\n\nVerify that now the object's output is approximately 0 (the sine has the period of 2s). The accuracy of the result will depend on the [[OS]] scheduler time slicing and the accuracy of the clock.\n\n\n",
        "solution_pairs": [
            [
                {
                    "language": "Kotlin",
                    "solution": "// version 1.2.0\n\nimport kotlin.math.*\n\ntypealias Function = (Double) -> Double\n\n/**\n * Integrates input function K over time\n * S + (t1 - t0) * (K(t1) + K(t0)) / 2\n */\nclass Integrator {\n    private val start: Long\n    private @Volatile var running = false\n    private lateinit var func: Function\n    private var t0 = 0.0\n    private var v0 = 0.0\n    private var sum = 0.0\n\n    constructor(func: Function) {\n        start = System.nanoTime()\n        setFunc(func)\n        Thread(this::integrate).start()\n    }\n\n    fun setFunc(func: Function) {\n        this.func = func\n        v0 = func(0.0)\n        t0 = 0.0\n    }\n\n    fun getOutput() = sum\n\n    fun stop() {\n        running = false\n    }\n\n    private fun integrate() {\n        running = true\n        while (running) {\n            try {\n                Thread.sleep(1)\n                update()\n            }\n            catch(e: InterruptedException) {\n                return\n            }\n        }\n    }\n\n    private fun update() {\n        val t1 = (System.nanoTime() - start) / 1.0e9\n        val v1 = func(t1)\n        val rect = (t1 - t0) * (v0 + v1) / 2.0\n        sum  += rect\n        t0 = t1\n        v0 = v1\n    }\n}\n\nfun main(args: Array<String>) {\n    val integrator = Integrator( { sin(PI * it) } )\n    Thread.sleep(2000)\n\n    integrator.setFunc( { 0.0 } )\n    Thread.sleep(500)\n\n    integrator.stop()\n    println(integrator.getOutput())\n}\n"
                },
                {
                    "language": "Wren",
                    "solution": "import \"scheduler\" for Scheduler\nimport \"timer\" for Timer\n\nvar Interval = 0\n\nclass Integrator {\n    construct new() {\n        _sum = 0\n    }\n\n    input(k) {\n        _k = k\n        _v0 = k.call(0)\n        _t = 0\n        _running = true\n        integrate_()\n    }\n\n    output { _sum }\n\n    stop() {\n        _running = false\n    }\n\n    integrate_() {\n        while (_running) {\n            Timer.sleep(1)\n            update_()\n        }\n    }\n\n    update_() {\n        _t = _t + Interval\n        var v1 = _k.call(_t)\n        var trap = Interval * (_v0 + v1) / 2\n        _sum = _sum + trap\n        _v0 = v1\n    }\n}\n\nvar integrator = Integrator.new()\nScheduler.add {\n    Interval = 2 / 1550  // machine specific value\n    integrator.input(Fn.new { |t| (Num.pi * t).sin })\n}\nTimer.sleep(2000)\n\nScheduler.add {\n    Interval = 0.5 / 775 // machine specific value\n    integrator.input(Fn.new { |t| 0 })\n}\nTimer.sleep(500)\n\nintegrator.stop()\nSystem.print(integrator.output)\n"
                }
            ],
            [
                {
                    "language": "Nim",
                    "solution": "# Active object.\n# Compile with \"nim c --threads:on\".\n\nimport locks\nimport os\nimport std/monotimes\n\ntype\n\n  # Function to use for integration.\n  TimeFunction = proc (t: float): float {.gcsafe.}\n\n  # Integrator object.\n  Integrator = ptr TIntegrator\n  TIntegrator = object\n    k: TimeFunction                 # The function to integrate.\n    dt: int                         # Time interval in milliseconds.\n    thread: Thread[Integrator]      # Thread which does the computation.\n    s: float                        # Computed value.\n    lock: Lock                      # Lock to manage concurrent accesses.\n    isRunning: bool                 # True if integrator is running.\n\n#---------------------------------------------------------------------------------------------------\n\nproc newIntegrator(f: TimeFunction; dt: int): Integrator =\n  ## Create an integrator.\n\n  result = cast[Integrator](allocShared(sizeof(TIntegrator)))\n  result.k = f\n  result.dt = dt\n  result.s = 0\n  result.lock.initLock()\n  result.isRunning = false\n\n#---------------------------------------------------------------------------------------------------\n\nproc process(integrator: Integrator) {.thread, gcsafe.} =\n  ## Do the integration.\n\n  integrator.isRunning = true\n  let start = getMonotime().ticks\n  var t0: float = 0\n  var k0 = integrator.k(0)\n  while true:\n    sleep(integrator.dt)\n    withLock integrator.lock:\n      if not integrator.isRunning:\n        break\n      let t1 = float(getMonoTime().ticks - start) / 1e9\n      let k1 = integrator.k(t1)\n      integrator.s += (k1 + k0) * (t1 - t0) / 2\n      t0 = t1\n      k0 = k1\n\n#---------------------------------------------------------------------------------------------------\n\nproc start(integrator: Integrator) =\n  ## Start the integrator by launching a thread to do the computation.\n  integrator.thread.createThread(process, integrator)\n\n#---------------------------------------------------------------------------------------------------\n\nproc stop(integrator: Integrator) =\n  ## Stop the integrator.\n\n  withLock integrator.lock:\n    integrator.isRunning = false\n  integrator.thread.joinThread()\n\n#---------------------------------------------------------------------------------------------------\n\nproc setInput(integrator: Integrator; f: TimeFunction) =\n  ## Set the function.\n  withLock integrator.lock:\n    integrator.k = f\n\n#---------------------------------------------------------------------------------------------------\n\nproc output(integrator: Integrator): float =\n  ## Return the current output.\n  withLock integrator.lock:\n    result = integrator.s\n\n#---------------------------------------------------------------------------------------------------\n\nproc destroy(integrator: Integrator) =\n  ## Destroy an integrator, freing the resources.\n\n  if integrator.isRunning:\n    integrator.stop()\n  integrator.lock.deinitLock()\n  integrator.deallocShared()\n\n#---------------------------------------------------------------------------------------------------\n\nfrom math import PI, sin\n\n# Create the integrator and start it.\nlet integrator = newIntegrator(proc (t: float): float {.gcsafe.} = sin(PI * t), 1)\nintegrator.start()\necho \"Integrator started.\"\nsleep(2000)\necho \"Value after 2 seconds: \", integrator.output()\n\n# Change the function to use.\nintegrator.setInput(proc (t: float): float {.gcsafe.} = 0)\necho \"K function changed.\"\nsleep(500)\n\n# Stop the integrator and display the computed value.\nintegrator.stop()\necho \"Value after 0.5 more second: \", integrator.output()\nintegrator.destroy()\n"
                },
                {
                    "language": "Phix",
                    "solution": "-->\n <span style=\"color: #004080;\">sequence</span> <span style=\"color: #000000;\">x</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #0000FF;\">{}</span>\n <span style=\"color: #008080;\">enum</span> <span style=\"color: #000000;\">TERMINATE</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #000000;\">INTERVAL</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #000000;\">KFUN</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #000000;\">VALUE</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #000000;\">T0</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #000000;\">K0</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #000000;\">ID</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #000000;\">ISIZE</span><span style=\"color: #0000FF;\">=$</span>\n <span style=\"color: #004080;\">integer</span> <span style=\"color: #000000;\">xlock</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #000000;\">init_cs</span><span style=\"color: #0000FF;\">()</span>\n\n <span style=\"color: #008080;\">function</span> <span style=\"color: #000000;\">zero</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #004080;\">atom</span> <span style=\"color: #000080;font-style:italic;\">/*t*/</span><span style=\"color: #0000FF;\">)</span> <span style=\"color: #008080;\">return</span> <span style=\"color: #000000;\">0</span> <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">function</span>\n <span style=\"color: #008080;\">function</span> <span style=\"color: #000000;\">sine</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #004080;\">atom</span> <span style=\"color: #000000;\">t</span><span style=\"color: #0000FF;\">)</span> <span style=\"color: #008080;\">return</span> <span style=\"color: #7060A8;\">sin</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">2</span><span style=\"color: #0000FF;\">*</span><span style=\"color: #004600;\">PI</span><span style=\"color: #0000FF;\">*</span><span style=\"color: #000000;\">0.5</span><span style=\"color: #0000FF;\">*</span><span style=\"color: #000000;\">t</span><span style=\"color: #0000FF;\">)</span> <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">function</span>\n\n <span style=\"color: #008080;\">procedure</span> <span style=\"color: #000000;\">update</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #004080;\">integer</span> <span style=\"color: #000000;\">dx</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #7060A8;\">enter_cs</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">xlock</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #004080;\">atom</span> <span style=\"color: #000000;\">t1</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">time</span><span style=\"color: #0000FF;\">(),</span>\n          <span style=\"color: #000000;\">k1</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">call_func</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">x</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">dx</span><span style=\"color: #0000FF;\">][</span><span style=\"color: #000000;\">KFUN</span><span style=\"color: #0000FF;\">],{</span><span style=\"color: #000000;\">t1</span><span style=\"color: #0000FF;\">})</span>\n     <span style=\"color: #000000;\">x</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">dx</span><span style=\"color: #0000FF;\">][</span><span style=\"color: #000000;\">VALUE</span><span style=\"color: #0000FF;\">]</span> <span style=\"color: #0000FF;\">+=</span> <span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">k1</span> <span style=\"color: #0000FF;\">+</span> <span style=\"color: #000000;\">x</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">dx</span><span style=\"color: #0000FF;\">][</span><span style=\"color: #000000;\">K0</span><span style=\"color: #0000FF;\">])</span> <span style=\"color: #0000FF;\">*</span> <span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">t1</span> <span style=\"color: #0000FF;\">-</span> <span style=\"color: #000000;\">x</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">dx</span><span style=\"color: #0000FF;\">][</span><span style=\"color: #000000;\">T0</span><span style=\"color: #0000FF;\">])</span> <span style=\"color: #0000FF;\">/</span> <span style=\"color: #000000;\">2</span>\n     <span style=\"color: #000000;\">x</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">dx</span><span style=\"color: #0000FF;\">][</span><span style=\"color: #000000;\">T0</span><span style=\"color: #0000FF;\">]</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #000000;\">t1</span>\n     <span style=\"color: #000000;\">x</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">dx</span><span style=\"color: #0000FF;\">][</span><span style=\"color: #000000;\">K0</span><span style=\"color: #0000FF;\">]</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #000000;\">k1</span>\n     <span style=\"color: #7060A8;\">leave_cs</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">xlock</span><span style=\"color: #0000FF;\">)</span>\n <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">procedure</span>\n\n <span style=\"color: #008080;\">procedure</span> <span style=\"color: #000000;\">tick</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #004080;\">integer</span> <span style=\"color: #000000;\">dx</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #008080;\">while</span> <span style=\"color: #008080;\">not</span> <span style=\"color: #000000;\">x</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">dx</span><span style=\"color: #0000FF;\">][</span><span style=\"color: #000000;\">TERMINATE</span><span style=\"color: #0000FF;\">]</span> <span style=\"color: #008080;\">do</span>\n         <span style=\"color: #7060A8;\">sleep</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">x</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">dx</span><span style=\"color: #0000FF;\">][</span><span style=\"color: #000000;\">INTERVAL</span><span style=\"color: #0000FF;\">])</span>\n         <span style=\"color: #000000;\">update</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">dx</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">while</span>\n <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">procedure</span>\n\n <span style=\"color: #008080;\">function</span> <span style=\"color: #000000;\">new_integrator</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #004080;\">integer</span> <span style=\"color: #000000;\">rid</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #004080;\">atom</span> <span style=\"color: #000000;\">interval</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #000000;\">x</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">append</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">x</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #7060A8;\">repeat</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">0</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">ISIZE</span><span style=\"color: #0000FF;\">))</span>\n     <span style=\"color: #004080;\">integer</span> <span style=\"color: #000000;\">dx</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">length</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">x</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #000000;\">x</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">dx</span><span style=\"color: #0000FF;\">][</span><span style=\"color: #000000;\">TERMINATE</span><span style=\"color: #0000FF;\">]</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #004600;\">false</span>\n     <span style=\"color: #000000;\">x</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">dx</span><span style=\"color: #0000FF;\">][</span><span style=\"color: #000000;\">INTERVAL</span><span style=\"color: #0000FF;\">]</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #000000;\">interval</span>\n     <span style=\"color: #000000;\">x</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">dx</span><span style=\"color: #0000FF;\">][</span><span style=\"color: #000000;\">KFUN</span><span style=\"color: #0000FF;\">]</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #000000;\">rid</span>\n     <span style=\"color: #000000;\">x</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">dx</span><span style=\"color: #0000FF;\">][</span><span style=\"color: #000000;\">T0</span><span style=\"color: #0000FF;\">]</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">time</span><span style=\"color: #0000FF;\">()</span>\n     <span style=\"color: #000000;\">update</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">dx</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #000000;\">x</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">dx</span><span style=\"color: #0000FF;\">][</span><span style=\"color: #000000;\">ID</span><span style=\"color: #0000FF;\">]</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #000000;\">create_thread</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">tick</span><span style=\"color: #0000FF;\">,{</span><span style=\"color: #000000;\">dx</span><span style=\"color: #0000FF;\">})</span>\n     <span style=\"color: #008080;\">return</span> <span style=\"color: #000000;\">dx</span>\n <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">function</span>\n\n <span style=\"color: #008080;\">procedure</span> <span style=\"color: #000000;\">set_input</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #004080;\">integer</span> <span style=\"color: #000000;\">dx</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #000000;\">rid</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #7060A8;\">enter_cs</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">xlock</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #000000;\">x</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">dx</span><span style=\"color: #0000FF;\">][</span><span style=\"color: #000000;\">KFUN</span><span style=\"color: #0000FF;\">]</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #000000;\">rid</span>\n     <span style=\"color: #000000;\">x</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">dx</span><span style=\"color: #0000FF;\">][</span><span style=\"color: #000000;\">K0</span><span style=\"color: #0000FF;\">]</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #000000;\">0</span>\n     <span style=\"color: #7060A8;\">leave_cs</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">xlock</span><span style=\"color: #0000FF;\">)</span>\n <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">procedure</span>\n\n <span style=\"color: #008080;\">function</span> <span style=\"color: #000000;\">get_output</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #004080;\">integer</span> <span style=\"color: #000000;\">dx</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #7060A8;\">enter_cs</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">xlock</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #004080;\">atom</span> <span style=\"color: #000000;\">v</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #000000;\">x</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">dx</span><span style=\"color: #0000FF;\">][</span><span style=\"color: #000000;\">VALUE</span><span style=\"color: #0000FF;\">]</span>\n     <span style=\"color: #7060A8;\">leave_cs</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">xlock</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #008080;\">return</span> <span style=\"color: #000000;\">v</span>\n <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">function</span>\n\n <span style=\"color: #008080;\">procedure</span> <span style=\"color: #000000;\">stop_integrator</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #004080;\">integer</span> <span style=\"color: #000000;\">dx</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #000000;\">x</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">dx</span><span style=\"color: #0000FF;\">][</span><span style=\"color: #000000;\">TERMINATE</span><span style=\"color: #0000FF;\">]</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #004600;\">true</span>\n     <span style=\"color: #000000;\">wait_thread</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">x</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">dx</span><span style=\"color: #0000FF;\">][</span><span style=\"color: #000000;\">ID</span><span style=\"color: #0000FF;\">])</span>\n <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">procedure</span>\n\n <span style=\"color: #7060A8;\">puts</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #008000;\">\"\"</span><span style=\"color: #0000FF;\">)</span>\n <span style=\"color: #004080;\">integer</span> <span style=\"color: #000000;\">dx</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #000000;\">new_integrator</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">sine</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">0.01</span><span style=\"color: #0000FF;\">)</span>\n <span style=\"color: #7060A8;\">sleep</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">2</span><span style=\"color: #0000FF;\">)</span>\n <span style=\"color: #7060A8;\">printf</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #008000;\">\"%f\\n\"</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">get_output</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">dx</span><span style=\"color: #0000FF;\">))</span>\n <span style=\"color: #000000;\">set_input</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">dx</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">zero</span><span style=\"color: #0000FF;\">)</span>\n <span style=\"color: #7060A8;\">sleep</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">0.5</span><span style=\"color: #0000FF;\">)</span>\n <span style=\"color: #7060A8;\">printf</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #008000;\">\"%f\\n\"</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">get_output</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">dx</span><span style=\"color: #0000FF;\">))</span>\n <span style=\"color: #000000;\">stop_integrator</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">dx</span><span style=\"color: #0000FF;\">)</span>\n<!--\n"
                }
            ],
            [
                {
                    "language": "Nim",
                    "solution": "# Active object.\n# Compile with \"nim c --threads:on\".\n\nimport locks\nimport os\nimport std/monotimes\n\ntype\n\n  # Function to use for integration.\n  TimeFunction = proc (t: float): float {.gcsafe.}\n\n  # Integrator object.\n  Integrator = ptr TIntegrator\n  TIntegrator = object\n    k: TimeFunction                 # The function to integrate.\n    dt: int                         # Time interval in milliseconds.\n    thread: Thread[Integrator]      # Thread which does the computation.\n    s: float                        # Computed value.\n    lock: Lock                      # Lock to manage concurrent accesses.\n    isRunning: bool                 # True if integrator is running.\n\n#---------------------------------------------------------------------------------------------------\n\nproc newIntegrator(f: TimeFunction; dt: int): Integrator =\n  ## Create an integrator.\n\n  result = cast[Integrator](allocShared(sizeof(TIntegrator)))\n  result.k = f\n  result.dt = dt\n  result.s = 0\n  result.lock.initLock()\n  result.isRunning = false\n\n#---------------------------------------------------------------------------------------------------\n\nproc process(integrator: Integrator) {.thread, gcsafe.} =\n  ## Do the integration.\n\n  integrator.isRunning = true\n  let start = getMonotime().ticks\n  var t0: float = 0\n  var k0 = integrator.k(0)\n  while true:\n    sleep(integrator.dt)\n    withLock integrator.lock:\n      if not integrator.isRunning:\n        break\n      let t1 = float(getMonoTime().ticks - start) / 1e9\n      let k1 = integrator.k(t1)\n      integrator.s += (k1 + k0) * (t1 - t0) / 2\n      t0 = t1\n      k0 = k1\n\n#---------------------------------------------------------------------------------------------------\n\nproc start(integrator: Integrator) =\n  ## Start the integrator by launching a thread to do the computation.\n  integrator.thread.createThread(process, integrator)\n\n#---------------------------------------------------------------------------------------------------\n\nproc stop(integrator: Integrator) =\n  ## Stop the integrator.\n\n  withLock integrator.lock:\n    integrator.isRunning = false\n  integrator.thread.joinThread()\n\n#---------------------------------------------------------------------------------------------------\n\nproc setInput(integrator: Integrator; f: TimeFunction) =\n  ## Set the function.\n  withLock integrator.lock:\n    integrator.k = f\n\n#---------------------------------------------------------------------------------------------------\n\nproc output(integrator: Integrator): float =\n  ## Return the current output.\n  withLock integrator.lock:\n    result = integrator.s\n\n#---------------------------------------------------------------------------------------------------\n\nproc destroy(integrator: Integrator) =\n  ## Destroy an integrator, freing the resources.\n\n  if integrator.isRunning:\n    integrator.stop()\n  integrator.lock.deinitLock()\n  integrator.deallocShared()\n\n#---------------------------------------------------------------------------------------------------\n\nfrom math import PI, sin\n\n# Create the integrator and start it.\nlet integrator = newIntegrator(proc (t: float): float {.gcsafe.} = sin(PI * t), 1)\nintegrator.start()\necho \"Integrator started.\"\nsleep(2000)\necho \"Value after 2 seconds: \", integrator.output()\n\n# Change the function to use.\nintegrator.setInput(proc (t: float): float {.gcsafe.} = 0)\necho \"K function changed.\"\nsleep(500)\n\n# Stop the integrator and display the computed value.\nintegrator.stop()\necho \"Value after 0.5 more second: \", integrator.output()\nintegrator.destroy()\n"
                },
                {
                    "language": "Perl",
                    "solution": "#!/usr/bin/perl\n\nuse strict;\nuse 5.10.0;\n\npackage Integrator;\nuse threads;\nuse threads::shared;\n\nsub new {\n\tmy $cls = shift;\n\tmy $obj = bless {\tt\t=> 0,\n\t\t\t\tsum\t=> 0,\n\t\t\t\tref $cls ? %$cls : (),\n\t\t\t\tstop\t=> 0,\n\t\t\t\ttid\t=> 0,\n\t\t\t\tfunc\t=> shift,\n\t\t\t}, ref $cls || $cls;\n\n\tshare($obj->{sum});\n\tshare($obj->{stop});\n\n\t$obj->{tid} = async {\n\t\tmy $upd = 0.1; # update every 0.1 second\n\t\twhile (!$obj->{stop}) {\n\t\t\t{\n\t\t\t\tmy $f = $obj->{func};\n\t\t\t\tmy $t = $obj->{t};\n\n\t\t\t\t$obj->{sum} += ($f->($t) + $f->($t + $upd))* $upd/ 2;\n\t\t\t\t$obj->{t} += $upd;\n\t\t\t}\n\t\t\tselect(undef, undef, undef, $upd);\n\t\t}\n\t#\tsay \"stopping $obj\";\n\t};\n\t$obj\n}\n\nsub output { shift->{sum} }\n\nsub delete {\n\tmy $obj = shift;\n\t$obj->{stop} = 1;\n\t$obj->{tid}->join;\n}\n\nsub setinput {\n\t# This is surprisingly difficult because of the perl sharing model.\n\t# Func refs can't be shared, thus can't be replaced by another thread.\n\t# Have to create a whole new object... there must be a better way.\n\tmy $obj = shift;\n\t$obj->delete;\n\t$obj->new(shift);\n}\n\npackage main;\n\nmy $x = Integrator->new(sub { sin(atan2(1, 1) * 8 * .5 * shift) });\n\nsleep(2);\nsay \"sin after 2 seconds: \", $x->output;\n\n$x = $x->setinput(sub {0});\n\nselect(undef, undef, undef, .5);\nsay \"0 after .5 seconds: \", $x->output;\n\n$x->delete;\n"
                }
            ],
            [
                {
                    "language": "Swift",
                    "solution": "// For NSObject, NSTimeInterval and NSThread\nimport Foundation\n// For PI and sin\nimport Darwin\n\nclass ActiveObject:NSObject {\n\n    let sampling = 0.1\n    var K: (t: NSTimeInterval) -> Double\n    var S: Double\n    var t0, t1: NSTimeInterval\n    var thread = NSThread()\n\n    func integrateK() {\n        t0 = t1\n        t1 += sampling\n        S += (K(t:t1) + K(t: t0)) * (t1 - t0) / 2\n    }\n\n    func updateObject() {\n        while true {\n            integrateK()\n            usleep(100000)\n        }\n    }\n\n    init(function: (NSTimeInterval) -> Double) {\n        S = 0\n        t0 = 0\n        t1 = 0\n        K = function\n        super.init()\n        thread = NSThread(target: self, selector: \"updateObject\", object: nil)\n        thread.start()\n    }\n\n    func Input(function: (NSTimeInterval) -> Double) {\n        K = function\n\n    }\n\n    func Output() -> Double {\n        return S\n    }\n\n}\n\n// main\nfunc sine(t: NSTimeInterval) -> Double {\n    let f = 0.5\n\n    return sin(2 * M_PI * f * t)\n}\n\nvar activeObject = ActiveObject(function: sine)\n\nvar date = NSDate()\n\nsleep(2)\n\nactiveObject.Input({(t: NSTimeInterval) -> Double in return 0.0})\n\nusleep(500000)\n\nprintln(activeObject.Output())\n"
                },
                {
                    "language": "Phix",
                    "solution": "-->\n <span style=\"color: #004080;\">sequence</span> <span style=\"color: #000000;\">x</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #0000FF;\">{}</span>\n <span style=\"color: #008080;\">enum</span> <span style=\"color: #000000;\">TERMINATE</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #000000;\">INTERVAL</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #000000;\">KFUN</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #000000;\">VALUE</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #000000;\">T0</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #000000;\">K0</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #000000;\">ID</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #000000;\">ISIZE</span><span style=\"color: #0000FF;\">=$</span>\n <span style=\"color: #004080;\">integer</span> <span style=\"color: #000000;\">xlock</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #000000;\">init_cs</span><span style=\"color: #0000FF;\">()</span>\n\n <span style=\"color: #008080;\">function</span> <span style=\"color: #000000;\">zero</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #004080;\">atom</span> <span style=\"color: #000080;font-style:italic;\">/*t*/</span><span style=\"color: #0000FF;\">)</span> <span style=\"color: #008080;\">return</span> <span style=\"color: #000000;\">0</span> <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">function</span>\n <span style=\"color: #008080;\">function</span> <span style=\"color: #000000;\">sine</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #004080;\">atom</span> <span style=\"color: #000000;\">t</span><span style=\"color: #0000FF;\">)</span> <span style=\"color: #008080;\">return</span> <span style=\"color: #7060A8;\">sin</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">2</span><span style=\"color: #0000FF;\">*</span><span style=\"color: #004600;\">PI</span><span style=\"color: #0000FF;\">*</span><span style=\"color: #000000;\">0.5</span><span style=\"color: #0000FF;\">*</span><span style=\"color: #000000;\">t</span><span style=\"color: #0000FF;\">)</span> <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">function</span>\n\n <span style=\"color: #008080;\">procedure</span> <span style=\"color: #000000;\">update</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #004080;\">integer</span> <span style=\"color: #000000;\">dx</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #7060A8;\">enter_cs</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">xlock</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #004080;\">atom</span> <span style=\"color: #000000;\">t1</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">time</span><span style=\"color: #0000FF;\">(),</span>\n          <span style=\"color: #000000;\">k1</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">call_func</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">x</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">dx</span><span style=\"color: #0000FF;\">][</span><span style=\"color: #000000;\">KFUN</span><span style=\"color: #0000FF;\">],{</span><span style=\"color: #000000;\">t1</span><span style=\"color: #0000FF;\">})</span>\n     <span style=\"color: #000000;\">x</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">dx</span><span style=\"color: #0000FF;\">][</span><span style=\"color: #000000;\">VALUE</span><span style=\"color: #0000FF;\">]</span> <span style=\"color: #0000FF;\">+=</span> <span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">k1</span> <span style=\"color: #0000FF;\">+</span> <span style=\"color: #000000;\">x</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">dx</span><span style=\"color: #0000FF;\">][</span><span style=\"color: #000000;\">K0</span><span style=\"color: #0000FF;\">])</span> <span style=\"color: #0000FF;\">*</span> <span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">t1</span> <span style=\"color: #0000FF;\">-</span> <span style=\"color: #000000;\">x</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">dx</span><span style=\"color: #0000FF;\">][</span><span style=\"color: #000000;\">T0</span><span style=\"color: #0000FF;\">])</span> <span style=\"color: #0000FF;\">/</span> <span style=\"color: #000000;\">2</span>\n     <span style=\"color: #000000;\">x</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">dx</span><span style=\"color: #0000FF;\">][</span><span style=\"color: #000000;\">T0</span><span style=\"color: #0000FF;\">]</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #000000;\">t1</span>\n     <span style=\"color: #000000;\">x</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">dx</span><span style=\"color: #0000FF;\">][</span><span style=\"color: #000000;\">K0</span><span style=\"color: #0000FF;\">]</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #000000;\">k1</span>\n     <span style=\"color: #7060A8;\">leave_cs</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">xlock</span><span style=\"color: #0000FF;\">)</span>\n <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">procedure</span>\n\n <span style=\"color: #008080;\">procedure</span> <span style=\"color: #000000;\">tick</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #004080;\">integer</span> <span style=\"color: #000000;\">dx</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #008080;\">while</span> <span style=\"color: #008080;\">not</span> <span style=\"color: #000000;\">x</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">dx</span><span style=\"color: #0000FF;\">][</span><span style=\"color: #000000;\">TERMINATE</span><span style=\"color: #0000FF;\">]</span> <span style=\"color: #008080;\">do</span>\n         <span style=\"color: #7060A8;\">sleep</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">x</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">dx</span><span style=\"color: #0000FF;\">][</span><span style=\"color: #000000;\">INTERVAL</span><span style=\"color: #0000FF;\">])</span>\n         <span style=\"color: #000000;\">update</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">dx</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">while</span>\n <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">procedure</span>\n\n <span style=\"color: #008080;\">function</span> <span style=\"color: #000000;\">new_integrator</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #004080;\">integer</span> <span style=\"color: #000000;\">rid</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #004080;\">atom</span> <span style=\"color: #000000;\">interval</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #000000;\">x</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">append</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">x</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #7060A8;\">repeat</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">0</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">ISIZE</span><span style=\"color: #0000FF;\">))</span>\n     <span style=\"color: #004080;\">integer</span> <span style=\"color: #000000;\">dx</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">length</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">x</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #000000;\">x</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">dx</span><span style=\"color: #0000FF;\">][</span><span style=\"color: #000000;\">TERMINATE</span><span style=\"color: #0000FF;\">]</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #004600;\">false</span>\n     <span style=\"color: #000000;\">x</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">dx</span><span style=\"color: #0000FF;\">][</span><span style=\"color: #000000;\">INTERVAL</span><span style=\"color: #0000FF;\">]</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #000000;\">interval</span>\n     <span style=\"color: #000000;\">x</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">dx</span><span style=\"color: #0000FF;\">][</span><span style=\"color: #000000;\">KFUN</span><span style=\"color: #0000FF;\">]</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #000000;\">rid</span>\n     <span style=\"color: #000000;\">x</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">dx</span><span style=\"color: #0000FF;\">][</span><span style=\"color: #000000;\">T0</span><span style=\"color: #0000FF;\">]</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">time</span><span style=\"color: #0000FF;\">()</span>\n     <span style=\"color: #000000;\">update</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">dx</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #000000;\">x</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">dx</span><span style=\"color: #0000FF;\">][</span><span style=\"color: #000000;\">ID</span><span style=\"color: #0000FF;\">]</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #000000;\">create_thread</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">tick</span><span style=\"color: #0000FF;\">,{</span><span style=\"color: #000000;\">dx</span><span style=\"color: #0000FF;\">})</span>\n     <span style=\"color: #008080;\">return</span> <span style=\"color: #000000;\">dx</span>\n <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">function</span>\n\n <span style=\"color: #008080;\">procedure</span> <span style=\"color: #000000;\">set_input</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #004080;\">integer</span> <span style=\"color: #000000;\">dx</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #000000;\">rid</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #7060A8;\">enter_cs</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">xlock</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #000000;\">x</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">dx</span><span style=\"color: #0000FF;\">][</span><span style=\"color: #000000;\">KFUN</span><span style=\"color: #0000FF;\">]</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #000000;\">rid</span>\n     <span style=\"color: #000000;\">x</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">dx</span><span style=\"color: #0000FF;\">][</span><span style=\"color: #000000;\">K0</span><span style=\"color: #0000FF;\">]</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #000000;\">0</span>\n     <span style=\"color: #7060A8;\">leave_cs</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">xlock</span><span style=\"color: #0000FF;\">)</span>\n <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">procedure</span>\n\n <span style=\"color: #008080;\">function</span> <span style=\"color: #000000;\">get_output</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #004080;\">integer</span> <span style=\"color: #000000;\">dx</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #7060A8;\">enter_cs</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">xlock</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #004080;\">atom</span> <span style=\"color: #000000;\">v</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #000000;\">x</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">dx</span><span style=\"color: #0000FF;\">][</span><span style=\"color: #000000;\">VALUE</span><span style=\"color: #0000FF;\">]</span>\n     <span style=\"color: #7060A8;\">leave_cs</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">xlock</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #008080;\">return</span> <span style=\"color: #000000;\">v</span>\n <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">function</span>\n\n <span style=\"color: #008080;\">procedure</span> <span style=\"color: #000000;\">stop_integrator</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #004080;\">integer</span> <span style=\"color: #000000;\">dx</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #000000;\">x</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">dx</span><span style=\"color: #0000FF;\">][</span><span style=\"color: #000000;\">TERMINATE</span><span style=\"color: #0000FF;\">]</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #004600;\">true</span>\n     <span style=\"color: #000000;\">wait_thread</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">x</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">dx</span><span style=\"color: #0000FF;\">][</span><span style=\"color: #000000;\">ID</span><span style=\"color: #0000FF;\">])</span>\n <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">procedure</span>\n\n <span style=\"color: #7060A8;\">puts</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #008000;\">\"\"</span><span style=\"color: #0000FF;\">)</span>\n <span style=\"color: #004080;\">integer</span> <span style=\"color: #000000;\">dx</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #000000;\">new_integrator</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">sine</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">0.01</span><span style=\"color: #0000FF;\">)</span>\n <span style=\"color: #7060A8;\">sleep</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">2</span><span style=\"color: #0000FF;\">)</span>\n <span style=\"color: #7060A8;\">printf</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #008000;\">\"%f\\n\"</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">get_output</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">dx</span><span style=\"color: #0000FF;\">))</span>\n <span style=\"color: #000000;\">set_input</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">dx</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">zero</span><span style=\"color: #0000FF;\">)</span>\n <span style=\"color: #7060A8;\">sleep</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">0.5</span><span style=\"color: #0000FF;\">)</span>\n <span style=\"color: #7060A8;\">printf</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #008000;\">\"%f\\n\"</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">get_output</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">dx</span><span style=\"color: #0000FF;\">))</span>\n <span style=\"color: #000000;\">stop_integrator</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">dx</span><span style=\"color: #0000FF;\">)</span>\n<!--\n"
                }
            ],
            [
                {
                    "language": "PicoLisp",
                    "solution": "(load \"@lib/math.l\")\n\n(class +Active)\n# inp val sum usec\n\n(dm T ()\n   (unless (assoc -100 *Run)           # Install timer task\n      (task -100 100                   # Update objects every 0.1 sec\n         (mapc 'update> *Actives) ) )\n   (=: inp '((U) 0))                   # Set zero input function\n   (=: val 0)                          # Initialize last value\n   (=: sum 0)                          # Initialize sum\n   (=: usec (usec))                    # and time\n   (push '*Actives This) )             # Install in notification list\n\n(dm input> (Fun)\n   (=: inp Fun) )\n\n(dm update> ()\n   (let (U (usec)  V ((: inp) U))      # Get current time, calculate value\n      (inc (:: sum)\n         (*/\n            (+ V (: val))              # (K(t[1]) + K(t[0])) *\n            (- U (: usec))             # (t[1] - t[0]) /\n            2.0 ) )                    # 2.0\n      (=: val V)\n      (=: usec U) ) )\n\n(dm output> ()\n   (format (: sum) *Scl) )             # Get result\n\n(dm stop> ()\n   (unless (del This '*Actives)        # Removing the last active object?\n      (task -100) ) )                  # Yes: Uninstall timer task\n\n(de integrate ()                       # Test it\n   (let Obj (new '(+Active))           # Create an active object\n      (input> Obj                      # Set input function\n         '((U) (sin (*/ pi U 1.0))) )  # to sin(\u00cf\u20ac * t)\n      (wait 2000)                      # Wait 2 sec\n      (input> Obj '((U) 0))            # Reset input function\n      (wait 500)                       # Wait 0.5 sec\n      (prinl \"Output: \" (output> Obj)) # Print return value\n      (stop> Obj) ) )                  # Stop active object\n"
                },
                {
                    "language": "Lingo",
                    "solution": "global gIntegrator\n\n-- entry point\non startMovie\n    gIntegrator = script(\"Integrator\").new(\"sin(PI * t)\")\n    timeout().new(\"timer\", 2000, #step1)\nend\n\non step1 (_, timer)\n    gIntegrator.input(\"0.0\")\n    timer.timeoutHandler = #step2\n    timer.period = 500\nend\n\non step2 (_, timer)\n    gIntegrator.stop()\n    put gIntegrator.output()\n    timer.forget()\nend\n"
                }
            ]
        ]
    },
    {
        "task_name": "Add-a-variable-to-a-class-instance-at-runtime",
        "task_description": "Demonstrate how to dynamically add variables to an object (a class instance) at runtime.\n\nThis is useful when the methods/variables of an instance are based on a data file that isn't available until runtime.  Hal Fulton gives an example of creating an OO CSV parser at [http://www.devsource.com/article2/0,1759,1928562,00.asp An Exercise in Metaprogramming with Ruby].  This is referred to as \"monkeypatching\" by Pythonistas and some others.\n\n",
        "solution_pairs": [
            [
                {
                    "language": "Groovy",
                    "solution": "class A {\n    final x = { it + 25 }\n    private map = new HashMap()\n    Object get(String key) { map[key] }\n    void set(String key, Object value) { map[key] = value }\n}\n"
                },
                {
                    "language": "Common-Lisp",
                    "solution": "(defun augment-instance-with-slots (instance slots)\n  (change-class instance\n                (make-instance 'standard-class\n                  :direct-superclasses (list (class-of instance))\n                  :direct-slots slots)))\n"
                }
            ],
            [
                {
                    "language": "PHP",
                    "solution": "class E {};\n\n$e=new E();\n\n$e->foo=1;\n\n$e->{\"foo\"} = 1; // using a runtime name\n$x = \"foo\";\n$e->$x = 1; // using a runtime name in a variable\n"
                },
                {
                    "language": "LOLCODE",
                    "solution": "HAI 1.3\n\nI HAS A object ITZ A BUKKIT\nI HAS A name, I HAS A value\n\nIM IN YR interface\n    VISIBLE \"R U WANTIN 2 (A)DD A VAR OR (P)RINT 1? \"!\n    I HAS A option, GIMMEH option\n\n    option, WTF?\n    OMG \"A\"\n        VISIBLE \"NAME: \"!, GIMMEH name\n        VISIBLE \"VALUE: \"!, GIMMEH value\n        object HAS A SRS name ITZ value, GTFO\n    OMG \"P\"\n        VISIBLE \"NAME: \"!, GIMMEH name\n        VISIBLE object'Z SRS name\n    OIC\nIM OUTTA YR interface\n\nKTHXBYE\n"
                }
            ],
            [
                {
                    "language": "Groovy",
                    "solution": "def a = new A()\na.y = 55\na.z = { println (new Date()); Thread.sleep 5000 }\n\nprintln a.x(25)\nprintln a.y\n(0..2).each(a.z)\n\nprintln a.q\n"
                },
                {
                    "language": "Go",
                    "solution": "package main\n\nimport (\n    \"bufio\"\n    \"fmt\"\n    \"log\"\n    \"os\"\n)\n\ntype SomeStruct struct {\n    runtimeFields map[string]string\n}\n\nfunc check(err error) {\n    if err != nil {\n        log.Fatal(err)\n    }\n}\n\nfunc main() {\n    ss := SomeStruct{make(map[string]string)}\n    scanner := bufio.NewScanner(os.Stdin)\n    fmt.Println(\"Create two fields at runtime: \")\n    for i := 1; i <= 2; i++ {\n        fmt.Printf(\"  Field #%d:\\n\", i)\n        fmt.Print(\"       Enter name  : \")\n        scanner.Scan()\n        name := scanner.Text()\n        fmt.Print(\"       Enter value : \")\n        scanner.Scan()\n        value := scanner.Text()\n        check(scanner.Err())\n        ss.runtimeFields[name] = value\n        fmt.Println()\n    }\n    for {\n        fmt.Print(\"Which field do you want to inspect ? \")\n        scanner.Scan()\n        name := scanner.Text()\n        check(scanner.Err())\n        value, ok := ss.runtimeFields[name]\n        if !ok {\n            fmt.Println(\"There is no field of that name, try again\")\n        } else {\n            fmt.Printf(\"Its value is '%s'\\n\", value)\n            return\n        }\n    }\n}\n"
                }
            ],
            [
                {
                    "language": "Perl",
                    "solution": "package Empty;\n\n# Constructor. Object is hash.\nsub new { return bless {}, shift; }\n\npackage main;\n\n# Object.\nmy $o = Empty->new;\n\n# Set runtime variable (key => value).\n$o->{'foo'} = 1;\n"
                },
                {
                    "language": "Oz",
                    "solution": "declare\n  %% Creates a new class derived from BaseClass\n  %% with an added feature (==public immutable attribute)\n  fun {AddFeature BaseClass FeatureName FeatureValue}\n     class DerivedClass from BaseClass\n        feat\n\t   %% \"FeatureName\" is escaped, otherwise a new variable\n\t   %% refering to a private feature would be created\n           !FeatureName:FeatureValue\n     end\n  in\n     DerivedClass\n  end\n\n  class Base\n     feat\n        bar:1\n\n     meth init\n        skip\n     end\n  end\n\n  Derived = {AddFeature Base foo 2}\n\n  Instance = {New Derived init}\nin\n  {Show Instance.bar} %% inherited feature\n  {Show Instance.foo} %% feature of \"synthesized\" class\n"
                }
            ],
            [
                {
                    "language": "Smalltalk",
                    "solution": "p := Point x:10 y:20.\naddSlot value:p value:'z'.\np z:30.\np z.\np z:40.\np inspect\n"
                },
                {
                    "language": "MiniScript",
                    "solution": "empty = {}\nvarName = \"foo\"\nempty[varName] = 1\n"
                }
            ]
        ]
    },
    {
        "task_name": "Additive-primes",
        "task_description": ";Definitions\nIn mathematics, '''additive primes''' are prime numbers for which the sum of their decimal digits are also primes.\n\n\n;Task\nWrite a program to determine (and show here) all '''additive primes''' less than '''500'''.\n\nOptionally, show the '''number''' of additive primes.\n\n\n;Also see:\n:* &nbsp; the OEIS entry: &nbsp; [https://oeis.org/A046704 A046704 additive primes].\n:* &nbsp; the prime-numbers entry: &nbsp; [https://prime-numbers.info/list/first-100-additive-primes additive primes].\n:* &nbsp; the geeks for geeks entry: [https://www.geeksforgeeks.org/additive-prime-number/ additive prime number].\n:* &nbsp; the prime-numbers fandom: [https://prime-numbers.fandom.com/wiki/Additive_Primes additive primes].\n<br><br>\n\n",
        "solution_pairs": [
            [
                {
                    "language": "SETL",
                    "solution": "program additive_primes;\n    loop for i in [i : i in [1..499] | additive_prime i] do\n        nprint(lpad(str i, 4));\n        if (n +:= 1) mod 10 = 0 then\n            print;\n        end if;\n    end loop;\n    print;\n    print(\"There are \" + str n + \" additive primes less than 500.\");\n\n    op additive_prime(n);\n        return prime n and prime digitsum n;\n    end op;\n\n    op prime(n);\n        return n>=2 and not exists d in {2..floor sqrt n} | n mod d = 0;\n    end op;\n\n    op digitsum(n);\n        loop while n>0;\n            s +:= n mod 10;\n            n div:= 10;\n        end loop;\n        return s;\n    end op;\nend program;\n"
                },
                {
                    "language": "Phixmonti",
                    "solution": "/# Rosetta Code problem: http://rosettacode.org/wiki/Additive_primes\nby Galileo, 05/2022 #/\n\ninclude ..\\Utilitys.pmt\n\ndef isprime\n    dup 1 <= if drop false\n    else dup 2 == not if\n        ( dup sqrt 2 swap ) for\n            over swap mod not if drop false exitfor endif\n        endfor\n        endif\n    endif\n    false == not\nenddef\n\ndef digitsum\n    0 swap dup 0 > while dup 10 mod rot + swap 10 / int dup 0 > endwhile\n    drop\nenddef\n\n0 500 for\n    dup isprime over digitsum isprime and if print \" \" print 1 + else drop endif\nendfor\n\n\"Additive primes found: \" print print\n"
                }
            ],
            [
                {
                    "language": "AWK",
                    "solution": "# syntax: GAWK -f ADDITIVE_PRIMES.AWK\nBEGIN {\n    start = 1\n    stop = 500\n    for (i=start; i<=stop; i++) {\n      if (is_prime(i) && is_prime(sum_digits(i))) {\n        printf(\"%4d%1s\",i,++count%10?\"\":\"\\n\")\n      }\n    }\n    printf(\"\\nAdditive primes %d-%d: %d\\n\",start,stop,count)\n    exit(0)\n}\nfunction is_prime(x,  i) {\n    if (x <= 1) {\n      return(0)\n    }\n    for (i=2; i<=int(sqrt(x)); i++) {\n      if (x % i == 0) {\n        return(0)\n      }\n    }\n    return(1)\n}\nfunction sum_digits(n,  i,sum) {\n    for (i=1; i<=length(n); i++) {\n      sum += substr(n,i,1)\n    }\n    return(sum)\n}\n"
                },
                {
                    "language": "Go",
                    "solution": "package main\n\nimport \"fmt\"\n\nfunc isPrime(n int) bool {\n    switch {\n    case n < 2:\n        return false\n    case n%2 == 0:\n        return n == 2\n    case n%3 == 0:\n        return n == 3\n    default:\n        d := 5\n        for d*d <= n {\n            if n%d == 0 {\n                return false\n            }\n            d += 2\n            if n%d == 0 {\n                return false\n            }\n            d += 4\n        }\n        return true\n    }\n}\n\nfunc sumDigits(n int) int {\n    sum := 0\n    for n > 0 {\n        sum += n % 10\n        n /= 10\n    }\n    return sum\n}\n\nfunc main() {\n    fmt.Println(\"Additive primes less than 500:\")\n    i := 2\n    count := 0\n    for {\n        if isPrime(i) && isPrime(sumDigits(i)) {\n            count++\n            fmt.Printf(\"%3d  \", i)\n            if count%10 == 0 {\n                fmt.Println()\n            }\n        }\n        if i > 2 {\n            i += 2\n        } else {\n            i++\n        }\n        if i > 499 {\n            break\n        }\n    }\n    fmt.Printf(\"\\n\\n%d additive primes found.\\n\", count)\n}\n"
                }
            ],
            [
                {
                    "language": "Ada",
                    "solution": "with Ada.Text_Io;\n\nprocedure Additive_Primes is\n\n   Last    : constant := 499;\n   Columns : constant := 12;\n\n   type Prime_List is array (2 .. Last) of Boolean;\n\n   function Get_Primes return Prime_List is\n      Prime : Prime_List := (others => True);\n   begin\n      for P in Prime'Range loop\n         if Prime (P) then\n            for N in 2 .. Positive'Last loop\n               exit when N * P not in Prime'Range;\n               Prime (N * P) := False;\n            end loop;\n         end if;\n      end loop;\n      return Prime;\n   end Get_Primes;\n\n   function Sum_Of (N : Natural) return Natural is\n      Image : constant String := Natural'Image (N);\n      Sum   : Natural := 0;\n   begin\n      for Char of Image loop\n         Sum := Sum + (if Char in '0' .. '9'\n                       then Natural'Value (\"\" & Char)\n                       else 0);\n      end loop;\n      return Sum;\n   end Sum_Of;\n\n   package Natural_Io is new Ada.Text_Io.Integer_Io (Natural);\n   use Ada.Text_Io, Natural_Io;\n\n   Prime : constant Prime_List := Get_Primes;\n   Count : Natural := 0;\nbegin\n   Put_Line (\"Additive primes <500:\");\n   for N in Prime'Range loop\n      if Prime (N) and then Prime (Sum_Of (N)) then\n         Count := Count + 1;\n         Put (N, Width => 5);\n         if Count mod Columns = 0 then\n            New_Line;\n         end if;\n      end if;\n   end loop;\n   New_Line;\n\n   Put (\"There are \");\n   Put (Count, Width => 2);\n   Put (\" additive primes.\");\n   New_Line;\nend Additive_Primes;\n"
                },
                {
                    "language": "Factor",
                    "solution": "USING: formatting grouping io kernel math math.primes\nprettyprint sequences ;\n\n: sum-digits ( n -- sum )\n    0 swap [ 10 /mod rot + swap ] until-zero ;\n\n499 primes-upto [ sum-digits prime? ] filter\n[ 9 group simple-table. nl ]\n[ length \"Found  %d  additive primes  <  500.\\n\" printf ] bi\n"
                }
            ],
            [
                {
                    "language": "Raku",
                    "solution": "unit sub MAIN ($limit = 500);\nsay \"{+$_} additive primes < $limit:\\n{$_\u00c2\u00bb.fmt(\"%\" ~ $limit.chars ~ \"d\").batch(10).join(\"\\n\")}\",\n    with ^$limit .grep: { .is-prime and .comb.sum.is-prime }\n"
                },
                {
                    "language": "Applesoft-BASIC",
                    "solution": " 0 E = 500\n 1 F = E - 1:L =  LEN ( STR$ (F)) + 1: FOR I = 2 TO L:S$ = S$ +  CHR$ (32): NEXT I: DIM P(E):P(0) =  - 1:P(1) =  - 1: FOR I = 2 TO  SQR (F): IF  NOT P(I) THEN  FOR J = I * 2 TO E STEP I:P(J) =  - 1: NEXT J\n 2  NEXT I: FOR I = B TO F: IF  NOT P(I) THEN  GOSUB 4\n 3  NEXT I: PRINT : PRINT N\" ADDITIVE PRIMES FOUND BELOW \"E;: END\n 4 S = 0: IF I THEN  FOR J = I TO 0 STEP 0:J1 =  INT (J / 10):S = S + (J - J1 * 10):J = J1: NEXT J\n 5  IF  NOT P(S) THEN N = N + 1: PRINT  RIGHT$ (S$ +  STR$ (I),L);\n 6  RETURN\n"
                }
            ],
            [
                {
                    "language": "VTL-2",
                    "solution": "10 M=499\n20 :1)=1\n30 P=2\n40 :P)=0\n50 P=P+1\n60 #=M>P*40\n70 P=2\n80 C=P*2\n90 :C)=1\n110 C=C+P\n120 #=M>C*90\n130 P=P+1\n140 #=M/2>P*80\n150 P=2\n160 N=0\n170 #=:P)*290\n180 S=0\n190 K=P\n200 K=K/10\n210 S=S+%\n220 #=0<K*200\n230 #=:S)*290\n240 ?=P\n250 $=9\n260 N=N+1\n270 #=N/10*0+%=0=0*290\n280 ?=\"\"\n290 P=P+1\n300 #=M>P*170\n310 ?=\"\"\n320 ?=\"There are \";\n330 ?=N\n340 ?=\" additive primes below \";\n350 ?=M+1\n"
                },
                {
                    "language": "EasyLang",
                    "solution": "func prime n .\n   if n mod 2 = 0 and n > 2\n      return 0\n   .\n   i = 3\n   sq = sqrt n\n   while i <= sq\n      if n mod i = 0\n         return 0\n      .\n      i += 2\n   .\n   return 1\n.\nfunc digsum n .\n   while n > 0\n      sum += n mod 10\n      n = n div 10\n   .\n   return sum\n.\nfor i = 2 to 500\n   if prime i = 1\n      s = digsum i\n      if prime s = 1\n         write i & \" \"\n      .\n   .\n.\nprint \"\"\n"
                }
            ]
        ]
    },
    {
        "task_name": "Address-of-a-variable",
        "task_description": "{{basic data operation}}\n\n;Task:\nDemonstrate how to get the address of a variable and how to set the address of a variable.\n<br><br>\n\n",
        "solution_pairs": [
            [
                {
                    "language": "Tcl",
                    "solution": "package require poker\n\n# Increment a memory location; this will probably crash if you try for real.\n# We don't define how to get a good address, but it's not usually a problem\n# for embedded programming...\nset where 0x12340\npoke $where [expr {[peek $where] + 1}]\n"
                },
                {
                    "language": "ERRE",
                    "solution": "PROGRAM POINTER\nBEGIN\n   A%=100\n   ADDR=VARPTR(A%)\n   PRINT(A%)       ! prints 100\n   POKE(ADDR,200)\n   PRINT(A%)       ! prints 200\nEND PROGRAM\n"
                }
            ],
            [
                {
                    "language": "ERRE",
                    "solution": "........\nA%=100\nADDR=VARPTR(A%)\n.......\n"
                },
                {
                    "language": "R",
                    "solution": "address <- function(obj) {\n  paste0(\"0x\", substring(sub(\" .*$\",\"\",capture.output(.Internal(inspect(obj)))),2))\n}\n\nx <- 5\ny <- x\naddress(x)\naddress(y)\n\ny <- y + 1\naddress(x)\naddress(y)\n"
                }
            ],
            [
                {
                    "language": "PureBasic",
                    "solution": "a.i = 5\n*b.Integer = @a    ;set *b equal to the address of variable a\n*c.Integer = $A100 ;set *c to point at memory location $A100 (in hex)\n\n\nMessageRequester(\"Address\",Str(*b)) ;display the address being pointed at by *b\nMessageRequester(\"Value\",Str(*b\\i)) ;de-reference the pointer *b to display the data being pointed at\n"
                },
                {
                    "language": "Oberon",
                    "solution": "VAR a: LONGINT;\nVAR b: INTEGER;\n\nb := 10;\na := SYSTEM.ADR(b); (* Sets variable a to the address of variable b *)\n"
                }
            ],
            [
                {
                    "language": "Wren",
                    "solution": "var a = [1, 2, 3, 4]\nvar b = a // now 'a' and 'b' both point to the same List data\nb[3] = 5\nSystem.print(\"'b' is %(b)\")\nSystem.print(\"'a' is %(a)\") // the previous change is of course reflected in 'a' as well\nvar t = Object.same(a, b)   // tells you whether 'a' and 'b' refer to the same object in memory\nSystem.print(\"'a' and 'b' are the same object? %(t ? \"yes\" : \"no\")\")\n"
                },
                {
                    "language": "Go",
                    "solution": "package main\n\nimport (\n\t\"fmt\"\n\t\"unsafe\"\n)\n\nfunc main() {\n\tmyVar := 3.14\n\tmyPointer := &myVar\n\tfmt.Println(\"Address:\", myPointer, &myVar)\n\tfmt.Printf(\"Address: %p %p\\n\", myPointer, &myVar)\n\n\tvar addr64 int64\n\tvar addr32 int32\n\tptr := unsafe.Pointer(myPointer)\n\tif unsafe.Sizeof(ptr) <= unsafe.Sizeof(addr64) {\n\t\taddr64 = int64(uintptr(ptr))\n\t\tfmt.Printf(\"Pointer stored in   int64: %#016x\\n\", addr64)\n\t}\n\tif unsafe.Sizeof(ptr) <= unsafe.Sizeof(addr32) {\n\t\t// Only runs on architectures where a pointer is <= 32 bits\n\t\taddr32 = int32(uintptr(ptr))\n\t\tfmt.Printf(\"Pointer stored in   int32: %#08x\\n\", addr32)\n\t}\n\taddr := uintptr(ptr)\n\tfmt.Printf(\"Pointer stored in uintptr: %#08x\\n\", addr)\n\n\tfmt.Println(\"value as float:\", myVar)\n\ti := (*int32)(unsafe.Pointer(&myVar))\n\tfmt.Printf(\"value as int32: %#08x\\n\", *i)\n}\n"
                }
            ],
            [
                {
                    "language": "Smalltalk",
                    "solution": "|holder|\nholder := ValueHolder with:123.\nholder onChangeSend:#someChange to:someone.\nholder value: 234\n"
                },
                {
                    "language": "Delphi",
                    "solution": "var\n\ti: integer;\n\tp: ^integer;\nbegin\n\tp := @i;\n\twriteLn(p^);\nend;\n"
                }
            ]
        ]
    },
    {
        "task_name": "ADFGVX-cipher",
        "task_description": ";Description\nThe [https://en.wikipedia.org/wiki/ADFGVX_cipher ADFGVX cipher] was a manually applied field cipher used by the German Army during World War I. It was broken in 1918 by the French cryptanalyst [https://en.wikipedia.org/wiki/Georges_Painvin Georges Painvin].\n\nThe workings of the cipher are described in the Wikipedia article, linked to above, and so will not be repeated here.\n\n;Task\n\nWrite routines, functions etc. in your language to:\n\n1. Encrypt ''suitable'' plaintext and decrypt the resulting cipher text using the ADFGVX cipher algorithm given a Polybius square (see 2. below) and a ''suitable'' key. For this purpose ''suitable'' means text consisting solely of ASCII upper case letters or digits.\n\n2. Create a 6 x 6 [https://en.wikipedia.org/wiki/Polybius_square Polybius square] using a random combination of the letters A to Z and the digits 0 to 9 and then display it.\n\n3. Given the number of letters (between 7 and 12 say) to use, create a key by selecting a ''suitable'' word at random from [http://wiki.puzzlers.org/pub/wordlists/unixdict.txt unixdict.txt] and then display it. The word selected should be such that none of its characters are repeated.\n\nUse these routines to create a Polybius square and a 9 letter key.\n\nThese should then be used to encrypt the plaintext: '''ATTACKAT1200AM''' and decrypt the resulting cipher text. Display here the results of both operations.\n\n;Note\n\nAs it's unclear from the Wikipedia article how to handle a final row with fewer elements than the number of characters in the key, either of the methods mentioned in [https://en.wikipedia.org/wiki/Transposition_cipher#Columnar_transposition Columnar transposition] may be used. In the case of the second method, it is also acceptable to fill any gaps after shuffling by moving elements to the left which makes decipherment harder.\n<br><br>\n\n",
        "solution_pairs": [
            [
                {
                    "language": "J",
                    "solution": "polybius=: {{6 6$8 u:({~?~&#)(48+i.10),65+i.26}}\nlenword=: {{ ;({~ ?@#)(#~ (-:~.)@>)(#~ y=#@>)cutLF fread'unixdict.txt'}}\nADFGVX=: {{ deb,' ',.n/:~|:(-#n)]\\'ADFGVX'{~,($m)#:(,m)i.y([-.-.),m }}\nXVGFDA=: {{ (,m){~($m)#.'ADFGVX'i._2]\\deb,|:(>cut y)/:/:n }}\n"
                },
                {
                    "language": "11l",
                    "solution": "V adfgvx = \u2018ADFGVX\u2019\n\nF encrypt(plainText, polybius, key)\n   V s = \u2018\u2019\n   L(ch) plainText\n      L(r) 6\n         L(c) 6\n            I polybius[r][c] == ch\n               s \u2018\u2019= :adfgvx[r]\u2018\u2019:adfgvx[c]\n\n   DefaultDict[Char, String] cols\n   L(ch) s\n      cols[key[L.index % key.len]] \u2018\u2019= ch\n\n   V result = \u2018\u2019\n   L(k) sorted(cols.keys())\n      I !result.empty\n         result \u2018\u2019= \u2018 \u2019\n      result \u2018\u2019= cols[k]\n   R result\n\nF decrypt(cipherText, polybius, key)\n   V skey = sorted(key)\n   V cols = [\u2018\u2019] * key.len\n   V idx = 0\n   L(col) cipherText.split(\u2018 \u2019)\n      cols[key.findi(skey[idx])] = col\n      idx++\n\n   V s = \u2018\u2019\n   L(i) 0 .< key.len\n      L(col) cols\n         I i < col.len\n            s \u2018\u2019= col[i]\n\n   V result = \u2018\u2019\n   L(i) (0 .< s.len - 1).step(2)\n      V r = :adfgvx.findi(s[i])\n      V c = :adfgvx.findi(s[i + 1])\n      result \u2018\u2019= polybius[r][c]\n   R result\n\nV polybius = [[Char(\"\\0\")] * 6] * 6\nV alphabet = \u2018ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\u2019\nrandom:shuffle(&alphabet)\nL(r) 6\n   L(c) 6\n      polybius[r][c] = alphabet[6 * r + c]\n\nprint(\"6 x 6 Polybius square:\\n\")\nprint(\u2018  | A D F G V X\u2019)\nprint(\u2018---------------\u2019)\nL(row) polybius\n   print(adfgvx[L.index]\u2018 | \u2019row.join(\u2018 \u2019))\n\nV words = File(\u2018unixdict.txt\u2019).read().split(\"\\n\").filter(w -> w.len == 9 & w.len == Set(Array(w)).len)\nV key = random:choice(words).uppercase()\nprint(\"\\nThe key is \"key)\n\nV PlainText = \u2018ATTACKAT1200AM\u2019\nprint(\"\\nPlaintext : \"PlainText)\n\nV cipherText = encrypt(PlainText, polybius, key)\nprint(\"\\nEncrypted : \"cipherText)\n\nV plainText = decrypt(cipherText, polybius, key)\nprint(\"\\nDecrypted : \"plainText)\n"
                }
            ],
            [
                {
                    "language": "Perl",
                    "solution": "#!/usr/bin/perl\n\nuse strict; # https://rosettacode.org/wiki/ADFGVX_cipher\nuse warnings;\nuse List::Util qw( shuffle );\n\nmy $plaintext = 'ATTACKAT1200AM';\nmy $keysize = 9;\n\nmy $polybius = <<END;\n  | A D F G V X\n--+------------\nA | x x x x x x\nD | x x x x x x\nF | x x x x x x\nG | x x x x x x\nV | x x x x x x\nX | x x x x x x\nEND\n$polybius =~ s/x/$_/ for my @letters = shuffle \"A\" .. 'Z' , 0 .. 9;\nprint \"Polybius square =\\n\\n$polybius\\n\";\nmy %char2pair;\n@char2pair{ @letters } = glob '{A,D,F,G,V,X}' x 2; # map chars to pairs\nmy %pair2char = reverse %char2pair;                # map pairs to chars\nmy ($keyword) = shuffle grep !/(.).*\\1/,\n  do { local (@ARGV, $/) = 'unixdict.txt'; <> =~ /^.{$keysize}$/gm };\nmy ($n, @deorder) = 0;\nmy @reorder = map /.(.+)/, sort map $_ . $n++, split //, $keyword;\n@deorder[@reorder] = 0 .. $#reorder;\nprint \"  keyword = $keyword\\n\\nplaintext = $plaintext\\n\\n\";\n\nmy $encoded = encode( $plaintext, \\%char2pair, \\@reorder );\nprint \"  encoded = $encoded\\n\\n\";\n\nmy $decoded = decode( $encoded, \\%pair2char, \\@deorder );\nprint \"  decoded = $decoded\\n\";\n\nsub encode\n  {\n  my ($plain, $c2p, $order) = @_;\n  my $len = @$order;\n  join ' ', (transpose( $plain =~ s/./$c2p->{$&}/gr =~ /.{1,$len}/g ))[@$order];\n  }\n\nsub decode\n  {\n  my ($encoded, $p2c, $order) = @_;\n  (join '', transpose((split ' ', $encoded)[@$order])) =~ s/../$p2c->{$&}/gr;\n  }\n\nsub transpose { map join('', map {s/.// ? $& : ''} @_), 1 .. length $_[0] }\n"
                },
                {
                    "language": "Wren",
                    "solution": "import \"random\" for Random\nimport \"./ioutil\" for FileUtil\nimport \"./seq\" for Lst\nimport \"./str\" for Char, Str\n\nvar rand = Random.new()\nvar adfgvx = \"ADFGVX\"\nvar alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\".toList\n\nvar createPolybius = Fn.new {\n    rand.shuffle(alphabet)\n    var p = Lst.chunks(alphabet, 6)\n    System.print(\"6 x 6 Polybius square:\\n\")\n    System.print(\"  | A D F G V X\")\n    System.print(\"---------------\")\n    for (i in 0...p.count) {\n        System.write(\"%(adfgvx[i]) | \")\n        System.print(p[i].join(\" \"))\n    }\n    return p\n}\n\nvar createKey = Fn.new { |n|\n    if (n < 7 || n > 12) Fiber.abort(\"Key should be within 7 and 12 letters long.\")\n    var candidates = FileUtil.readLines(\"unixdict.txt\").where { |word|\n        return word.count == n && Lst.distinct(word.toList).count == n &&\n               word.all { |ch| Char.isAsciiAlphaNum(ch) }\n    }.toList\n    var k = Str.upper(candidates[rand.int(candidates.count)])\n    System.print(\"\\nThe key is %(k)\")\n    return k\n}\n\n// helper function to sort the key into alphabetical order\n// and return a list of the original indices of its letters.\nvar orderKey = Fn.new { |key|\n    var temp = (0...key.count).map { |i| [key[i], i] }.toList\n    temp.sort { |x, y| x[0].bytes[0] < y[0].bytes[0] }\n    return temp.map { |e| e[1] }.toList\n}\n\nvar encrypt = Fn.new { |polybius, key, plainText|\n    var temp = \"\"\n    for (ch in plainText) {\n        var outer = false\n        for (r in 0..5) {\n            for (c in 0..5) {\n                if (polybius[r][c] == ch) {\n                    temp = temp + adfgvx[r] + adfgvx[c]\n                    outer = true\n                    break\n                }\n            }\n            if (outer) break\n        }\n    }\n    var colLen = (temp.count / key.count).floor\n    // all columns need to be the same length\n    if (temp.count % key.count > 0) colLen = colLen + 1\n    var table = Lst.chunks(temp.toList, key.count)\n    var lastLen = table[-1].count\n    if (lastLen < key.count) table[-1] = table[-1] + ([\"\"] * (key.count - lastLen))\n    var order = orderKey.call(key)\n    var cols = List.filled(key.count, null)\n    for (i in 0...cols.count) {\n        cols[i] = List.filled(colLen, null)\n        for (j in 0...table.count) cols[i][j] = table[j][order[i]]\n    }\n    return cols.map { |col| col.join() }.join(\" \")\n}\n\nvar decrypt = Fn.new { |polybius, key, cipherText|\n    var colStrs = cipherText.split(\" \")\n    // ensure all columns are same length\n    var maxColLen = colStrs.reduce(0) { |max, col| max = (col.count > max) ? col.count : max }\n    var cols = colStrs.map { |s|\n        return (s.count < maxColLen) ? s.toList + ([\"\"] * (maxColLen - s.count)) : s.toList\n    }.toList\n    var table = List.filled(maxColLen, null)\n    var order = orderKey.call(key)\n    for (i in 0...maxColLen) {\n        table[i] = List.filled(key.count, \"\")\n        for (j in 0...key.count) table[i][order[j]] = cols[j][i]\n    }\n    var temp = table.map { |row| row.join(\"\") }.join(\"\")\n    var plainText = \"\"\n    var i = 0\n    while (i < temp.count) {\n        var r = adfgvx.indexOf(temp[i])\n        var c = adfgvx.indexOf(temp[i+1])\n        plainText = plainText + polybius[r][c]\n        i = i + 2\n    }\n    return plainText\n}\n\nvar plainText = \"ATTACKAT1200AM\"\nvar polybius = createPolybius.call()\nvar key = createKey.call(9)\nSystem.print(\"\\nPlaintext : %(plainText)\")\nvar cipherText = encrypt.call(polybius, key, plainText)\nSystem.print(\"\\nEncrypted : %(cipherText)\")\nvar plainText2 = decrypt.call(polybius, key, cipherText)\nSystem.print(\"\\nDecrypted : %(plainText2)\")\n"
                }
            ],
            [
                {
                    "language": "C++",
                    "solution": "#include <algorithm>\n#include <cstdint>\n#include <fstream>\n#include <iostream>\n#include <random>\n#include <sstream>\n#include <stdexcept>\n#include <string>\n#include <unordered_set>\n#include <vector>\n\nconst std::string ADFGVX = \"ADFGVX\";\nconst std::string ALPHABET = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";\n\nstd::random_device random;\nstd::mt19937 mersenne_twister(random());\n\nstd::vector<std::vector<char>> initialise_polybius_square() {\n\tstd::vector<char> letters(ALPHABET.begin(), ALPHABET.end());\n\tstd::shuffle(letters.begin(), letters.end(), mersenne_twister);\n\n\tstd::vector<std::vector<char>> result = { 6, std::vector<char>(6, 0) };\n\tfor ( int32_t row = 0; row < 6; ++row ) {\n\t\tfor ( int32_t column = 0; column < 6; ++column ) {\n\t\t\tresult[row][column] = letters[6 * row + column];\n\t\t}\n\t}\n\treturn result;\n}\n\n// Create a key using a word from the dictionary 'unixdict.txt'\nstd::string create_key(const uint64_t& size) {\n\tif ( size < 7 || size > 12 ) {\n\t\tthrow std::invalid_argument(\"Key should contain between 7 and 12 letters, both inclusive.\");\n\t}\n\n\tstd::vector<std::string> candidates;\n\tstd::fstream file_stream;\n\tfile_stream.open(\"../unixdict.txt\");\n\tstd::string word;\n\twhile ( file_stream >> word ) {\n\t\tif ( word.length() == size &&\n\t\t\tword.length() == std::unordered_set<char>{ word.begin(), word.end() }.size() ) {\n\t\t\tstd::transform(word.begin(), word.end(), word.begin(), [](const char& ch){ return std::toupper(ch); });\n\t\t\tif ( word.find_first_not_of(ALPHABET) == std::string::npos ) {\n\t\t\t\tcandidates.emplace_back(word);\n\t\t\t}\n\t\t}\n\t}\n\tstd::shuffle(candidates.begin(), candidates.end(), mersenne_twister);\n\tstd::string key = candidates[0];\n\treturn key;\n}\n\nstd::string encrypt(const std::string& plain_text,\n\t\t\t\t\tconst std::vector<std::vector<char>>& polybius,\n\t\t\t\t\tconst std::string& key) {\n\tstd::string code = \"\";\n\tfor ( const char& ch : plain_text ) {\n\t\tfor ( int32_t row = 0; row < 6; ++row ) {\n\t\t\tfor ( int32_t column = 0; column < 6; ++column ) {\n\t\t\t\tif ( polybius[row][column] == ch ) {\n\t\t\t\t\tcode += ADFGVX[row];\n\t\t\t\t\tcode += ADFGVX[column];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tstd::string encrypted = \"\";\n\tfor ( const char& ch : key ) {\n\t\tfor ( uint64_t i = key.find(ch); i < code.length(); i += key.length() ) {\n\t\t\tencrypted += code[i];\n\t\t}\n\t\tencrypted += \" \";\n\t}\n\treturn encrypted;\n}\n\nstd::string decrypt(const std::string& encrypted_text,\n\t\t\t\t\tconst std::vector<std::vector<char>>& polybius,\n\t\t\t\t\tconst std::string& key) {\n\tconst uint64_t space_count = std::count(encrypted_text.begin(), encrypted_text.end(), ' ');\n\tconst uint64_t code_size = encrypted_text.length() - space_count;\n\n\tstd::vector<std::string> blocks;\n\tstd::stringstream stream(encrypted_text);\n\tstd:: string word;\n\twhile ( stream >> word ) {\n\t    blocks.emplace_back(word);\n\t}\n\n\tstd::string code = \"\";\n\tfor ( int32_t i = 0; code.length() < code_size; ++i ) {\n\t\tfor ( const std::string& block : blocks ) {\n\t\t\tif ( code.length() < code_size ) {\n\t\t\t\tcode += block[i];\n\t\t\t}\n\t\t}\n\t}\n\n\tstd::string plain_text = \"\";\n\tfor ( uint64_t i = 0; i < code_size - 1; i += 2 ) {\n\t\tint32_t row = ADFGVX.find(code[i]);\n\t\tint32_t column = ADFGVX.find(code[i + 1]);\n\t\tplain_text += polybius[row][column];\n\t}\n\treturn plain_text;\n}\n\nint main() {\n\tconst std::vector<std::vector<char>> polybius = initialise_polybius_square();\n\tstd::cout << \"The 6 x 6 Polybius square:\" << std::endl;\n\tstd::cout << \" | A D F G V X\" << std::endl;\n\tstd::cout << \"--------------\" << std::endl;\n\tfor ( int32_t row = 0; row < 6; ++row ) {\n\t\tstd::cout << ADFGVX[row] << \"|\";\n\t\tfor ( int32_t column = 0; column < 6; ++column ) {\n\t\t\tstd::cout << \" \" << polybius[row][column];\n\t\t}\n\t\tstd::cout << std::endl;\n\t}\n\tstd::cout << std::endl;\n\n\tconst std::string key = create_key(9);\n\tstd::cout << \"The key is \" << key << std::endl << std::endl;\n\tconst std::string plain_text = \"ATTACKAT1200AM\";\n\tstd::cout << \"Plain text: \" << plain_text <<std::endl << std::endl;\n\tconst std::string encrypted_text = encrypt(plain_text, polybius, key);\n\tstd::cout << \"Encrypted: \" << encrypted_text << std::endl << std::endl;\n\tconst std::string decrypted_text = decrypt(encrypted_text, polybius, key);\n\tstd::cout << \"Decrypted: \" << decrypted_text << std::endl;\n}\n"
                },
                {
                    "language": "J",
                    "solution": "   echo W=: lenword 9\nroughcast\n   echo P=: polybius ''\nPV5M6Q\nKR0391\n4ZS7LA\nFUT28E\nGXOBYW\nICJDNH\n   echo E=: P ADFGVX W 'ATTACKAT1200AM'\nFFF FGF FFF GXD XDG FDGG XDX XXA GAD\n   echo D=: P XVGFDA W E\nATTACKAT1200AM\n"
                }
            ],
            [
                {
                    "language": "AArch64-Assembly",
                    "solution": "/* ARM assembly AARCH64 Raspberry PI 3B */\n/*  program adfgvx64.s   */\n/* remark 1 : At each launch, the random values are identical.\n   To change them, modify the value of the seed (graine) */\n/* remark 2 : this program not run in android with termux\n              because the call system stats is not find */\n\n/************************************/\n/* Constantes                       */\n/************************************/\n/* for this file see task include a file in language AArch64 assembly*/\n.include \"../includeConstantesARM64.inc\"\n\n.equ SIZE,   6\n.equ SIZEC,  SIZE * SIZE\n.equ KEYSIZE,   9\n.equ FSTAT,        80\n.equ O_RDWR,  0x0002         // open for reading and writing\n\n/*******************************************/\n/* Structures                          **/\n/*******************************************/\n/* structure de type   stat 64 bits : infos fichier  */\n    .struct  0\nStat_dev_t:                  // ID of device containing file\n    .struct Stat_dev_t + 8\nStat_ino_t:                  // inode\n    .struct Stat_ino_t + 4\nStat_mode_t:                 // File type and mode\n    .struct Stat_mode_t + 4\nStat_nlink_t:                // Number of hard links\n    .struct Stat_nlink_t + 4\nStat_uid_t:                  // User ID of owner\n    .struct Stat_uid_t + 8\nStat_gid_t:                  // Group ID of owner\n    .struct Stat_gid_t + 8\nStat_rdev_t:                 // Device ID (if special file)\n    .struct Stat_rdev_t + 8\nStat_size_deb:               // la taille est sur 8 octets si gros fichiers\n     .struct Stat_size_deb + 4\nStat_size_t:                 // Total size, in bytes\n    .struct Stat_size_t + 4\nStat_blksize_t:              // Block size for filesystem I/O\n    .struct Stat_blksize_t + 4\nStat_blkcnt_t:               // Number of 512B blocks allocated\n    .struct Stat_blkcnt_t + 4\nStat_atime:                  // date et heure fichier\n    .struct Stat_atime + 8\nStat_mtime:                  // date et heure modif fichier\n    .struct Stat_atime + 8\nStat_ctime:                  // date et heure creation fichier\n    .struct Stat_atime + 8\nStat_Fin:\n\n\n/*********************************/\n/* Initialized data              */\n/*********************************/\n.data\nszText:               .asciz \"ATTACKAT1200AM\"\n//szText:               .asciz \"ABCDEFGHIJ\"\nszMessOpen:           .asciz \"File open error.\\n\"\nszMessStat:           .asciz \"File information error.\\n\"\nszMessRead:           .asciz \"File read error.\\n\"\nszMessClose:          .asciz \"File close error.\\n\"\nszMessDecryptText:    .asciz \"Decrypted text :\\n\"\nszMessCryptText:      .asciz \"Encrypted text :\\n\"\nszMessErrorChar:      .asciz \"Character text not Ok!\\n\"\nszFileName:           .asciz \"unixdict.txt\"\nszMessPolybius:       .asciz \"6 x 6 Polybius square:\\n\"\nszTitle:              .asciz \"  | A D F G V X\\n---------------\\n\"\nszLine1:              .asciz \"A |            \\n\"\nszLine2:              .asciz \"D |            \\n\"\nszLine3:              .asciz \"F |            \\n\"\nszLine4:              .asciz \"G |            \\n\"\nszLine5:              .asciz \"V |            \\n\"\nszLine6:              .asciz \"X |            \\n\"\nszListCharCode:       .asciz \"ADFGVX\"\nszListChar:           .asciz \"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\"\n.equ LGLISTCHAR,      . - szListChar - 1\nszMessStart:          .asciz \"Program 64 bits start.\\n\"\nszCarriageReturn:     .asciz \"\\n\"\n.align 4\n\nqGraine:  .quad  1234567         // random init\n\n/*********************************/\n/* UnInitialized data            */\n/*********************************/\n.bss\nsKeyWord:              .skip 16\nsKeyWordSorted:        .skip 16\ntabPolybius:           .skip SIZE * SIZE + 4\nsBuffer:               .skip 1000\nsBuffex1:              .skip 1000\nsBuffex2:              .skip 1000\ntabPosit:              .skip 16\ntabPositInv:           .skip 16\n/*********************************/\n/*  code section                 */\n/*********************************/\n.text\n.global main\nmain:                            // entry of program\n    ldr x0,qAdrszMessStart\n    bl affichageMess\n    bl createPolybius            // create 6*6 polybius\n\n    ldr x0,qAdrsKeyWord\n    bl generateKey               // generate key\n    cmp x0,#-1                   // file error ?\n    beq 100f\n    bl affichageMess             // display key\n    ldr x0,qAdrszCarriageReturn\n    bl affichageMess\n\n    ldr x0,qAdrszMessCryptText\n    bl affichageMess\n    ldr x0,qAdrszText             // text encrypt\n    ldr x1,qAdrtabPolybius\n    ldr x2,qAdrsKeyWord\n    ldr x3,qAdrsBuffer            // result buffer\n    bl encryption\n    cmp x0,#-1                    // error if unknow character in text\n    beq 100f\n    bl affichageMess              // display text encrypted\n    ldr x0,qAdrszCarriageReturn\n    bl affichageMess\n    ldr x0,qAdrszCarriageReturn\n    bl affichageMess\n\n    ldr x0,qAdrszMessDecryptText\n    bl affichageMess\n    ldr x0,qAdrsBuffer            // text decrypt\n    ldr x1,qAdrtabPolybius\n    ldr x2,qAdrsKeyWord\n    ldr x3,qAdrsBuffex1           // result buffer\n    bl decryption\n    bl affichageMess\n    ldr x0,qAdrszCarriageReturn\n    bl affichageMess\n\n100:                             // standard end of the program\n    mov x0, #0                   // return code\n    mov x8, #EXIT                // request to exit program\n    svc #0                       // perform the system call\n\nqAdrszCarriageReturn:        .quad  szCarriageReturn\nqAdrszMessDecryptText:       .quad  szMessDecryptText\nqAdrszMessCryptText:         .quad  szMessCryptText\nqAdrszMessStart:             .quad  szMessStart\nqAdrsKeyWord:                .quad  sKeyWord\nqAdrszText:                  .quad  szText\n/***************************************************/\n/*   create 6 * 6 polybius                    */\n/***************************************************/\ncreatePolybius:\n    stp x1,lr,[sp,-16]!          // save registers\n    stp x2,x3,[sp,-16]!\n    stp x4,x5,[sp,-16]!\n    ldr x0,qAdrszListChar        // character list address\n    mov x1,#LGLISTCHAR           // character list size\n    ldr x2,qAdrtabPolybius\n    bl shufflestrings            // shuffle list\n    ldr x0,qAdrszMessPolybius\n    bl affichageMess\n    ldr x0,qAdrszTitle           // display polybius lines\n    bl affichageMess\n    ldr x0,qAdrszLine1\n    mov x3,#0\n    mov x4,#4\n1:\n    ldrb w1,[x2,x3]\n    strb w1,[x0,x4]\n    add x4,x4,#2\n    add x3,x3,#1\n    cmp x3,#SIZE\n    blt 1b\n    bl affichageMess\n    ldr x0,qAdrszLine2\n    mov x3,#SIZE\n    mov x4,#4\n2:\n    ldrb w1,[x2,x3]\n    strb w1,[x0,x4]\n    add x4,x4,#2\n    add x3,x3,#1\n    cmp x3,#SIZE * 2\n    blt 2b\n    bl affichageMess\n    ldr x0,qAdrszLine3\n    mov x3,#SIZE * 2\n    mov x4,#4\n3:\n    ldrb w1,[x2,x3]\n    strb w1,[x0,x4]\n    add x4,x4,#2\n    add x3,x3,#1\n    cmp x3,#SIZE * 3\n    blt 3b\n    bl affichageMess\n    ldr x0,qAdrszLine4\n    mov x3,#SIZE * 3\n    mov x4,#4\n4:\n    ldrb w1,[x2,x3]\n    strb w1,[x0,x4]\n    add x4,x4,#2\n    add x3,x3,#1\n    cmp x3,#SIZE * 4\n    blt 4b\n    bl affichageMess\n    ldr x0,qAdrszLine5\n    mov x3,#SIZE * 4\n    mov x4,#4\n5:\n    ldrb w1,[x2,x3]\n    strb w1,[x0,x4]\n    add x4,x4,#2\n    add x3,x3,#1\n    cmp x3,#SIZE * 5\n    blt 5b\n    bl affichageMess\n    ldr x0,qAdrszLine6\n    mov x3,#SIZE * 5\n    mov x4,#4\n6:\n    ldrb w1,[x2,x3]\n    strb w1,[x0,x4]\n    add x4,x4,#2\n    add x3,x3,#1\n    cmp x3,#SIZE * 6\n    blt 6b\n    bl affichageMess\n\n100:\n    ldp x4,x5,[sp],16\n    ldp x2,x3,[sp],16\n    ldp x1,lr,[sp],16\n    ret\nqAdrszListChar:           .quad  szListChar\nqAdrtabPolybius:          .quad  tabPolybius\nqAdrszMessPolybius:       .quad  szMessPolybius\nqAdrszTitle:              .quad  szTitle\nqAdrszLine1:              .quad  szLine1\nqAdrszLine2:              .quad  szLine2\nqAdrszLine3:              .quad  szLine3\nqAdrszLine4:              .quad  szLine4\nqAdrszLine5:              .quad  szLine5\nqAdrszLine6:              .quad  szLine6\n/***************************************************/\n/*  generate key word                              */\n/***************************************************/\n/* x0  key word address */\ngenerateKey:\n    stp x1,lr,[sp,-16]!\n    stp x2,x3,[sp,-16]!\n    stp x4,x5,[sp,-16]!\n    stp x6,x7,[sp,-16]!\n    stp x8,x9,[sp,-16]!\n    stp x10,x11,[sp,-16]!\n    stp x12,x13,[sp,-16]!\n    mov x9,x0\n    mov x0,AT_FDCWD\n    ldr x1,qAdrszFileName    // file name\n    mov x2,#O_RDWR           // flags\n    mov x3,#0                // mode\n    mov x8,#OPEN             // file open\n    svc 0\n    cmp x0,#0                // error ?\n    ble 99f\n    mov x11,x0               // FD save\n    ldr x1,qAdrsBuffer       // buffer address\n    mov x8, #FSTAT           // call systeme NEWFSTAT\n    svc 0\n    cmp x0,#0\n    blt 98f\n                             //  load file size\n    ldr x1,qAdrsBuffer       // buffer address\n    ldr w6,[x1,#Stat_size_t] // file size\n    //ldr w6,[x1,mbox_data_size]\n    lsr x12,x6,#5            // align size to multiple 16 for stack alignement\n    lsl x12,x12,#5\n    add x12,x12,#32          // add for great buffer\n    sub sp,sp,x12            // reserve buffer on stack\n    mov fp,sp                // address save\n    mov x0,x11\n    mov x1,fp\n    mov x2,x12\n    mov x8,#READ             // call system read file\n    svc 0\n    cmp x0,#0                // error read ?\n    blt 97f\n    mov x0,x11\n    mov x8,#CLOSE            // call system close file\n    svc 0\n    cmp x0,#0                // error close ?\n    blt 96f\n    sub sp,sp,#0x1000        // create array word address on stack\n    mov x10,sp               // save address array\n    mov x1,#0\n    mov x2,fp\n    mov x5,#0                // index word ok\n    mov x3,#0                // word length\n1:\n    ldrb w4,[fp,x1]          // load character\n    cmp w4,#0x0D             // end word ?\n    beq 2f                   // yes\n    add x1,x1,#1\n    add x3,x3,#1\n    b 1b\n2:\n    cmp x3,#KEYSIZE          // word length = key length ?\n    bne 3f                   // no ?\n    mov x0,x2\n    bl wordControl           // contril if all letters are diff\u00c3\u00a9rent ?\n    cmp x0,#1\n    bne 3f\n    str x2,[x10,x5,lsl #3]   // if ok store word address in array on stack\n    add x5,x5,#1             // increment word counter\n3:\n    add x1,x1,#2\n    cmp x1,x6                // end ?\n    beq 4f\n    add x2,fp,x1             // new word begin\n    mov x3,#0                // init word length\n    b 1b                     // and loop\n4:\n    mov x0,x5                // number random to total words\n    bl genereraleas\n    ldr x2,[x10,x0,lsl #3]   // load address word\n    mov x1,#0\n5:                           // copy random word in word result\n    ldrb w3,[x2,x1]\n    strb w3,[x9,x1]\n    add x1,x1,#1\n    cmp x1,#KEYSIZE\n    blt 5b\n    strb wzr,[x9,x1]         // zero final\n    mov x0,x9\n    b 100f\n                             // display errors\n96:\n    ldr x0,qAdrszMessClose\n    bl affichageMess\n    mov x0,#-1               // error\n    b 100f\n97:\n    ldr x0,qAdrszMessRead\n    bl affichageMess\n    mov x0,#-1               // error\n    b 100f\n98:\n    ldr x0,qAdrszMessStat\n    bl  affichageMess\n    mov x0,#-1               // error\n    b 101f\n99:\n    ldr x0,qAdrszMessOpen\n    bl  affichageMess\n    mov x0,#-1               // error\n    b 101f\n100:\n    add sp,sp,x12\n    add sp,sp,#0x1000\n101:\n    ldp x12,x13,[sp],16\n    ldp x10,x11,[sp],16\n    ldp x8,x9,[sp],16\n    ldp x6,x7,[sp],16\n    ldp x4,x5,[sp],16\n    ldp x2,x3,[sp],16\n    ldp x1,lr,[sp],16\n    ret\nqAdrszFileName:     .quad  szFileName\nqAdrszMessOpen:     .quad  szMessOpen\nqAdrszMessRead:     .quad  szMessRead\nqAdrszMessStat:     .quad  szMessStat\nqAdrszMessClose:    .quad  szMessClose\nqAdrsBuffer:        .quad  sBuffer\n/******************************************************************/\n/*     control if letters are diferents                  */\n/******************************************************************/\n/* x0 contains the address of the string */\n/* x0 return 1 if Ok else return 0 */\nwordControl:\n    stp x1,lr,[sp,-16]!\n    stp x2,x3,[sp,-16]!\n    stp x4,x5,[sp,-16]!\n    mov x1,#0                 // init index 1\n1:\n    ldrb w3,[x0,x1]           // load one character\n    cmp x3,#0x0D              // end word ?\n    mov x5,#1\n    csel x0,x5,x0,eq          // yes is ok\n    //moveq x0,#1               // yes is ok\n    beq 100f                  // -> end\n    add x2,x1,#1              // init index two\n2:\n    ldrb w4,[x0,x2]           // load one character\n    cmp w4,#0x0D              // end word ?\n    add x5,x1,1\n    csel x1,x5,x1,eq          // yes increment index 1\n    beq 1b                    // and loop1\n    cmp x3,x4                 // caracters equals ?\n    csel x0,xzr,x0,eq         // yes is not good\n    beq 100f                  // and end\n    add x2,x2,#1              // else increment index 2\n    b 2b                      // and loop 2\n100:\n    ldp x4,x5,[sp],16\n    ldp x2,x3,[sp],16\n    ldp x1,lr,[sp],16\n    ret\n/******************************************************************/\n/*         key sort by insertion sort                                              */\n/******************************************************************/\n/* x0 contains the address of String */\n/* x1 contains the first element    */\n/* x2 contains the number of element */\n/* x3 contains result address */\nkeySort:\n    stp x1,lr,[sp,-16]!\n    stp x2,x3,[sp,-16]!\n    stp x4,x5,[sp,-16]!\n    stp x6,x7,[sp,-16]!\n    stp x8,x9,[sp,-16]!\n    stp x10,x11,[sp,-16]!\n    ldr x7,qAdrtabPosit\n    mov x10,x3\n    mov x3,#0\n0:                            // init position array and copy key\n    strb w3,[x7,x3]           // in result array\n    ldrb w4,[x0,x3]\n    strb w4,[x10,x3]\n    add x3,x3,#1\n    cmp x3,#KEYSIZE\n    blt 0b\n\n    add x3,x1,#1              // start index i\n1:                            // start loop\n    ldrb w4,[x10,x3]          // load value A[i]\n    ldrb w8,[x7,x3]           // load position\n    sub x5,x3,#1              // index j\n2:\n    ldrb w6,[x10,x5]          // load value A[j]\n    ldrb w9,[x7,x5]           // load position\n    cmp x6,x4                 // compare value\n    ble 3f\n    add x5,x5,#1                 // increment index j\n    strb w6,[x10,x5]          // store value A[j+1]\n    strb w9,[x7,x5]           // store position\n    subs x5,x5,#2                // j = j - 1\n    bge 2b                    // loop if j >= 0\n3:\n    add x5,x5,#1              // increment index j\n    strb w4,[x10,x5]          // store value A[i] in A[j+1]\n    strb w8,[x7,x5]\n    add x3,x3,#1                 // increment index i\n    cmp x3,x2                 // end ?\n    blt 1b                    // no -> loop\n\n    ldr x1,qAdrtabPositInv    // inverse position\n    mov x2,#0                 // index\n4:\n    ldrb w3,[x7,x2]           // load position index\n    strb w2,[x1,x3]           // store index in position\n    add x2,x2,#1              // increment index\n    cmp x2,#KEYSIZE           // end ?\n    blt 4b\n    mov x0,x10\n100:\n    ldp x10,x11,[sp],16\n    ldp x8,x9,[sp],16\n    ldp x6,x7,[sp],16\n    ldp x4,x5,[sp],16\n    ldp x2,x3,[sp],16\n    ldp x1,lr,[sp],16                 // TODO: retaur \u00e0 completer\n    ret\nqAdrtabPosit:        .quad  tabPosit\nqAdrtabPositInv:     .quad  tabPositInv\n/******************************************************************/\n/*         text encryption                                        */\n/******************************************************************/\n/* x0 contains the address of text */\n/* x1 contains polybius address\n/* x2 contains the key address   */\n/* x3 contains result buffer address */\nencryption:\n    stp x1,lr,[sp,-16]!\n    stp x2,x3,[sp,-16]!\n    stp x4,x5,[sp,-16]!\n    stp x6,x7,[sp,-16]!\n    stp x8,x9,[sp,-16]!\n    stp x10,x11,[sp,-16]!\n    mov x9,x0                  // save text address\n    mov x8,x3\n    mov x10,x1                 // save address polybius\n    mov x0,x2                  // key address\n    mov x1,#0                  // first character\n    mov x2,#KEYSIZE            // key length\n    ldr x3,qAdrsKeyWordSorted  // result address\n    bl keySort                 // sort leters of key\n   // bl affichageMess         // if you want display sorted key\n  //  ldr x0,qAdrszCarriageReturn\n  //  bl affichageMess\n    ldr x3,qAdrsBuffex1\n    mov x5,#0                  // init text index\n    mov x4,#0                  // init result index\n1:\n    ldrb w0,[x9,x5]            // load a byte to text\n    cmp x0,#0                  // end ?\n    beq 4f\n    mov x6,#0                  // init index polybius\n2:\n    ldrb w7,[x10,x6]           // load character polybius\n    cmp x7,x0                  // equal ?\n    beq 3f\n    add x6,x6,#1               // increment index\n    cmp x6,#SIZEC              // not find -> error\n    bge 99f\n    b 2b                       // and loop\n3:\n    mov x0,x6\n    bl convPosCode             // convert position in code character\n    strb w0,[x3,x4]            // line code character\n    add x4,x4,#1\n    strb w1,[x3,x4]            // column code character\n    add x4,x4,#1\n\n    add  x5,x5,#1              // increment text index\n    b 1b\n4:\n    mov x0,#0                  // zero final -> text result\n    strb w0,[x3,x4]\n    mov x5,x3\n    mov x1,#0                  // index position column\n    mov x7,#0                  // index text\n    ldr x2,qAdrtabPositInv\n5:\n    ldrb w0,[x2,x1]           // load position text\n7:                            // loop to characters transposition\n\n    ldrb w6,[x5,x0]           // load character\n    strb w6,[x8,x7]           // store position final\n    add x7,x7,#1              // increment final index\n    add x0,x0,#KEYSIZE        // add size key\n    cmp x0,x4                 // end ?\n    blt 7b\n    add x1,x1,#1              // add index column\n    cmp x1,#KEYSIZE           // < key size\n    blt 5b                    // yes -> loop\n\n    mov x6,#0                 // zero final\n    strb w6,[x8,x7]\n    mov x0,x8                 // return address encrypted text\n\n    b 100f\n99:                           // display error\n    ldr x0,qAdrszMessErrorChar\n    bl affichageMess\n    mov x0,#-1\n100:\n    ldp x10,x11,[sp],16\n    ldp x8,x9,[sp],16\n    ldp x6,x7,[sp],16\n    ldp x4,x5,[sp],16\n    ldp x2,x3,[sp],16\n    ldp x1,lr,[sp],16\n    ret\nqAdrsBuffex1:        .quad  sBuffex1\nqAdrsKeyWordSorted:  .quad  sKeyWordSorted\nqAdrszMessErrorChar: .quad  szMessErrorChar\n/******************************************************************/\n/*         text decryption                                              */\n/******************************************************************/\n/* x0 contains the address of text */\n/* x1 contains polybius address\n/* x2 contains the key    */\n/* x3 contains result buffer */\n/* x0 return decoded text */\ndecryption:\n    stp x1,lr,[sp,-16]!\n    stp x2,x3,[sp,-16]!\n    stp x4,x5,[sp,-16]!\n    stp x6,x7,[sp,-16]!\n    stp x8,x9,[sp,-16]!\n    stp x10,x11,[sp,-16]!\n    stp x12,x13,[sp,-16]!\n    mov x4,#0\n1:                              // compute text length\n    ldrb w5,[x0,x4]\n    cmp x5,#0\n    add x11,x4,1\n    csel x4,x11,x4,ne\n    bne 1b\n    mov x12,x0\n    mov x11,x1\n    mov x10,x2\n    mov x13,x3\n                                 // compute line number and remainder\n    mov x1,#KEYSIZE              // compute line number and remainder\n    udiv x8,x4,x1                // line number\n    msub x7,x8,x1,x4             // remainder characters last line\n    mov x0,x10                   // key address\n    mov x1,#0                    // first character\n    mov x2,#KEYSIZE              // size\n    ldr x3,qAdrsKeyWordSorted    // result address\n    bl keySort                   // sort key\n    ldr x10,qAdrtabPositInv      // inverse position\n    mov x2,#0                    // index colonne tabposit\n    mov x5,#0                    // text index\n    mov x0,#0                    // index line store text\n    mov x1,#0                    // counter line\n\n    ldr x9,qAdrsBuffex2\n1:\n    ldrb w3,[x10,x2]             // load position\n    ldrb w6,[x12,x5]             // load text character\n    add x3,x3,x0                 // compute position with index line\n    strb w6,[x9,x3]              // store character in good position\n\n    add x5,x5,#1                 // increment index text\n    cmp x5,x4                    // end ?\n    bge 4f\n    add x1,x1,#1                 // increment line\n    cmp x1,x8                    // line < line size\n    blt 2f\n    bgt 11f                      // line = line size\n    sub x3,x3,x0                 // restaure position column\n    cmp x3,x7                    // position < remainder  so add character other line\n    blt 2f\n11:\n    mov x1,#0                    // init ligne\n    mov x0,#0                    // init line shift\n    add x2,x2,#1                 // increment index array position inverse\n    cmp x2,#KEYSIZE              // end ?\n    csel x2,xzr,x2,ge            // init index\n    b 3f\n2:\n    add x0,x0,#KEYSIZE\n3:\n    b 1b\n4:                               // convertir characters with polybius\n    mov x3,#0\n    mov x5,#0\n\n5:\n    mov x0,x11\n    ldrb w1,[x9,x3]              // load a first character\n    add x3,x3,#1\n    ldrb w2,[x9,x3]              // load a 2ieme character\n    bl decodPosCode              // decode\n    strb w0,[x13,x5]              // store result in final result\n    add x5,x5,#1                 // increment final result index\n    add x3,x3,#1                 // increment index text\n    cmp x3,x4                    // end ?\n    blt 5b\n    mov x0,#0                    // final zero\n    strb w0,[x13,x5]\n    mov x0,x13                    // return final result address\n100:\n    ldp x12,x13,[sp],16\n    ldp x10,x11,[sp],16\n    ldp x8,x9,[sp],16\n    ldp x6,x7,[sp],16\n    ldp x4,x5,[sp],16\n    ldp x2,x3,[sp],16\n    ldp x1,lr,[sp],16                 // TODO: retaur \u00e0 completer\n    ret\nqAdrsBuffex2:      .quad    sBuffex2\n/******************************************************************/\n/*         convertir position en code                                              */\n/******************************************************************/\n/* x0 contains the position in polybius */\n/* x0 return code1 */\n/* x1 return code2 */\nconvPosCode:\n    stp x2,lr,[sp,-16]!\n    stp x3,x4,[sp,-16]!\n    ldr x4,qAdrszListCharCode\n    mov x1,#SIZE\n    udiv x2,x0,x1\n    msub x3,x2,x1,x0\n    //bl division\n    ldrb w0,[x4,x2]\n    ldrb w1,[x4,x3]\n100:\n    ldp x3,x4,[sp],16\n    ldp x2,lr,[sp],16\n    ret\nqAdrszListCharCode:   .quad  szListCharCode\n/******************************************************************/\n/*         convertir code en character                                              */\n/******************************************************************/\n/* x0  polybius address */\n/* x1 code 1 */\n/* x2 code 2 */\n/* x0 return character */\ndecodPosCode:\n    stp x1,lr,[sp,-16]!\n    stp x2,x3,[sp,-16]!\n    stp x4,x5,[sp,-16]!\n    ldr x4,qAdrszListCharCode\n    mov x3,#0\n1:\n    ldrb w5,[x4,x3]\n    cmp x5,#0\n    beq 2f\n    cmp x5,x1\n    csel x1,x3,x1,eq\n    cmp x5,x2\n    csel x2,x3,x2,eq\n    add x3,x3,#1\n    b 1b\n2:\n    mov x5,#SIZE\n    mul x1,x5,x1\n    add x1,x1,x2\n    ldrb w0,[x0,x1]\n100:\n    ldp x4,x5,[sp],16\n    ldp x2,x3,[sp],16\n    ldp x1,lr,[sp],16\n    ret\n\n/******************************************************************/\n/*     shuffle strings  algorithme Fisher-Yates                   */\n/******************************************************************/\n/* x0 contains the address of the string */\n/* x1 contains string length */\n/* x2 contains address result string */\nshufflestrings:\n    stp x1,lr,[sp,-16]!               // TODO: save \u00e0 completer\n    stp x2,x3,[sp,-16]!\n    stp x4,x5,[sp,-16]!\n    mov x3,#0\n1:                            // loop copy string in result\n    ldrb w4,[x0,x3]\n    strb w4,[x2,x3]\n    add x3,x3,#1\n    cmp x3,x1\n    ble 1b\n    sub x1,x1,#1              // last element\n2:\n    mov x0,x1\n    bl genereraleas           // call random\n    ldrb w4,[x2,x1]           // load byte string index loop\n    ldrb w3,[x2,x0]           // load byte string random index\n    strb w3,[x2,x1]           // and exchange\n    strb w4,[x2,x0]\n    subs x1,x1,#1\n    cmp x1,#1\n    bge 2b\n\n100:\n    ldp x4,x5,[sp],16\n    ldp x2,x3,[sp],16\n    ldp x1,lr,[sp],16\n    ret\n\n/***************************************************/\n/*   Generation random number                  */\n/***************************************************/\n/* x0 contains limit  */\ngenereraleas:\n    stp x1,lr,[sp,-16]!            // save  registers\n    stp x2,x3,[sp,-16]!            // save  registers\n    ldr x1,qAdrqGraine\n    ldr x2,[x1]\n    ldr x3,qNbDep1\n    mul x2,x3,x2\n    ldr x3,qNbDep2\n    add x2,x2,x3\n    str x2,[x1]                    // maj de la graine pour l appel suivant\n    cmp x0,#0\n    beq 100f\n    udiv x3,x2,x0\n    msub x0,x3,x0,x2               // r\u00e9sult = remainder\n\n100:                               // end function\n    ldp x2,x3,[sp],16              // restaur  2 registers\n    ldp x1,lr,[sp],16              // restaur  2 registers\n    ret                            // return to address lr x30\nqAdrqGraine: .quad qGraine\nqNbDep1:     .quad 0x0019660d\nqNbDep2:     .quad 0x3c6ef35f\n\n/***************************************************/\n/*      ROUTINES INCLUDE                           */\n/***************************************************/\n.include \"../includeARM64.inc\"\n"
                },
                {
                    "language": "Phix",
                    "solution": "(phixonline)-->\n <span style=\"color: #008080;\">with</span> <span style=\"color: #008080;\">javascript_semantics</span>\n <span style=\"color: #008080;\">constant</span> <span style=\"color: #000000;\">ADFGVX</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #008000;\">\"ADFGVX\"</span><span style=\"color: #0000FF;\">,</span>\n          <span style=\"color: #000000;\">ALEPH</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">tagset</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #008000;\">'Z'</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #008000;\">'A'</span><span style=\"color: #0000FF;\">)&</span><span style=\"color: #7060A8;\">tagset</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #008000;\">'9'</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #008000;\">'0'</span><span style=\"color: #0000FF;\">)</span>\n\n <span style=\"color: #008080;\">function</span> <span style=\"color: #000000;\">create_polybius</span><span style=\"color: #0000FF;\">()</span>\n     <span style=\"color: #004080;\">string</span> <span style=\"color: #000000;\">aleph</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">shuffle</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">ALEPH</span><span style=\"color: #0000FF;\">)</span>\n <span style=\"color: #000080;font-style:italic;\">--  string aleph = \"U1CNHFEM4RSGPI8965X2ZB7KA3YVOD0WQTJL\"   -- Nim\n --  string aleph = \"T71VB5HYG2JKIQM8REOPDUNCZ063FXAW9S4L\"   -- Wren\n --  string aleph = \"NA1C3H8TB2OME5WRPD4F6G7I9J0KLQSUVXYZ\"   -- wp</span>\n     <span style=\"color: #004080;\">sequence</span> <span style=\"color: #000000;\">tmp</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">split</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #7060A8;\">join_by</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">aleph</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">6</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #008000;\">\" \"</span><span style=\"color: #0000FF;\">),</span><span style=\"color: #008000;\">'\\n'</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #7060A8;\">printf</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #008000;\">\"6 x 6 Polybius square:\\n\"</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #7060A8;\">printf</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #008000;\">\"  | A D F G V X\\n\"</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #7060A8;\">printf</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #008000;\">\"---------------\\n\"</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #008080;\">for</span> <span style=\"color: #000000;\">i</span><span style=\"color: #0000FF;\">=</span><span style=\"color: #000000;\">1</span> <span style=\"color: #008080;\">to</span> <span style=\"color: #7060A8;\">length</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">tmp</span><span style=\"color: #0000FF;\">)</span> <span style=\"color: #008080;\">do</span>\n         <span style=\"color: #7060A8;\">printf</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #008000;\">\"%s | %s\\n\"</span><span style=\"color: #0000FF;\">,{</span><span style=\"color: #000000;\">ADFGVX</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">i</span><span style=\"color: #0000FF;\">],</span><span style=\"color: #000000;\">tmp</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">i</span><span style=\"color: #0000FF;\">]})</span>\n     <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">for</span>\n     <span style=\"color: #008080;\">return</span> <span style=\"color: #000000;\">aleph</span>\n <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">function</span>\n\n <span style=\"color: #008080;\">function</span> <span style=\"color: #000000;\">lnua</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #004080;\">string</span> <span style=\"color: #000000;\">word</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #004080;\">integer</span> <span style=\"color: #000000;\">n</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #008080;\">return</span> <span style=\"color: #7060A8;\">length</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">word</span><span style=\"color: #0000FF;\">)==</span><span style=\"color: #000000;\">n</span>\n        <span style=\"color: #008080;\">and</span> <span style=\"color: #7060A8;\">length</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #7060A8;\">unique</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">word</span><span style=\"color: #0000FF;\">))==</span><span style=\"color: #000000;\">n</span>\n        <span style=\"color: #008080;\">and</span> <span style=\"color: #7060A8;\">length</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #7060A8;\">filter</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">word</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #008000;\">\"in\"</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">ALEPH</span><span style=\"color: #0000FF;\">))==</span><span style=\"color: #000000;\">n</span>\n <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">function</span>\n\n <span style=\"color: #008080;\">function</span> <span style=\"color: #000000;\">create_key</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #004080;\">integer</span> <span style=\"color: #000000;\">n</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #7060A8;\">assert</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">n</span><span style=\"color: #0000FF;\">>=</span><span style=\"color: #000000;\">7</span> <span style=\"color: #008080;\">and</span> <span style=\"color: #000000;\">n</span><span style=\"color: #0000FF;\"><=</span><span style=\"color: #000000;\">12</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #004080;\">sequence</span> <span style=\"color: #000000;\">candidates</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">filter</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #7060A8;\">upper</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #7060A8;\">unix_dict</span><span style=\"color: #0000FF;\">()),</span><span style=\"color: #000000;\">lnua</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">n</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #004080;\">string</span> <span style=\"color: #000000;\">res</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #000000;\">candidates</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #7060A8;\">rand</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #7060A8;\">length</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">candidates</span><span style=\"color: #0000FF;\">))]</span>\n <span style=\"color: #000080;font-style:italic;\">--  string res = \"PHAGOCYTE\" -- Nim\n --  string res = \"SUNFLOWER\" -- Wren\n --  string res = \"PRIVACY\" -- wp</span>\n     <span style=\"color: #7060A8;\">printf</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #008000;\">\"\\nThe key is %s\\n\"</span><span style=\"color: #0000FF;\">,{</span><span style=\"color: #000000;\">res</span><span style=\"color: #0000FF;\">})</span>\n     <span style=\"color: #008080;\">return</span> <span style=\"color: #000000;\">res</span>\n <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">function</span>\n\n <span style=\"color: #008080;\">function</span> <span style=\"color: #000000;\">encrypt</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #004080;\">string</span> <span style=\"color: #000000;\">polybius</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #000000;\">key</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #000000;\">plaintext</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #004080;\">integer</span> <span style=\"color: #000000;\">l</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">length</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">key</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #004080;\">sequence</span> <span style=\"color: #000000;\">tags</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">custom_sort</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">key</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #7060A8;\">tagset</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">l</span><span style=\"color: #0000FF;\">)),</span>\n              <span style=\"color: #000000;\">res</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #008000;\">\"\"</span>\n     <span style=\"color: #008080;\">for</span> <span style=\"color: #000000;\">i</span><span style=\"color: #0000FF;\">=</span><span style=\"color: #000000;\">1</span> <span style=\"color: #008080;\">to</span> <span style=\"color: #7060A8;\">length</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">plaintext</span><span style=\"color: #0000FF;\">)</span> <span style=\"color: #008080;\">do</span>\n         <span style=\"color: #004080;\">integer</span> <span style=\"color: #000000;\">k</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">find</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">plaintext</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">i</span><span style=\"color: #0000FF;\">],</span><span style=\"color: #000000;\">polybius</span><span style=\"color: #0000FF;\">)</span>\n         <span style=\"color: #008080;\">if</span> <span style=\"color: #000000;\">k</span> <span style=\"color: #008080;\">then</span>   <span style=\"color: #000080;font-style:italic;\">-- (simply ignore any non-alphanum)</span>\n             <span style=\"color: #000000;\">res</span> <span style=\"color: #0000FF;\">&=</span> <span style=\"color: #000000;\">ADFGVX</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #7060A8;\">floor</span><span style=\"color: #0000FF;\">((</span><span style=\"color: #000000;\">k</span><span style=\"color: #0000FF;\">-</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">)/</span><span style=\"color: #000000;\">6</span><span style=\"color: #0000FF;\">)+</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">]&</span>\n                    <span style=\"color: #000000;\">ADFGVX</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #7060A8;\">remainder</span><span style=\"color: #0000FF;\">((</span><span style=\"color: #000000;\">k</span><span style=\"color: #0000FF;\">-</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">),</span><span style=\"color: #000000;\">6</span><span style=\"color: #0000FF;\">)+</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">]</span>\n         <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">if</span>\n     <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">for</span>\n     <span style=\"color: #000000;\">res</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">substitute</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #7060A8;\">join</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #7060A8;\">columnize</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #7060A8;\">split_by</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">res</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">l</span><span style=\"color: #0000FF;\">),</span><span style=\"color: #000000;\">tags</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #008000;\">' '</span><span style=\"color: #0000FF;\">)),</span><span style=\"color: #008000;\">\"  \"</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #008000;\">\" \"</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #008080;\">return</span> <span style=\"color: #000000;\">res</span>\n <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">function</span>\n\n <span style=\"color: #008080;\">function</span> <span style=\"color: #000000;\">decrypt</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #004080;\">string</span> <span style=\"color: #000000;\">polybius</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #000000;\">key</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #000000;\">encrypted</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #004080;\">integer</span> <span style=\"color: #000000;\">l</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">length</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">key</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #004080;\">sequence</span> <span style=\"color: #000000;\">tags</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">custom_sort</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">key</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #7060A8;\">tagset</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">l</span><span style=\"color: #0000FF;\">)),</span>\n              <span style=\"color: #000000;\">tmp</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">columnize</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #7060A8;\">split</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">encrypted</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #008000;\">' '</span><span style=\"color: #0000FF;\">),{},</span><span style=\"color: #008000;\">' '</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #000000;\">tmp</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">trim</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #7060A8;\">join</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #7060A8;\">apply</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #004600;\">true</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #7060A8;\">extract</span><span style=\"color: #0000FF;\">,{</span><span style=\"color: #000000;\">tmp</span><span style=\"color: #0000FF;\">,{</span><span style=\"color: #000000;\">tags</span><span style=\"color: #0000FF;\">},</span><span style=\"color: #004600;\">true</span><span style=\"color: #0000FF;\">}),</span><span style=\"color: #008000;\">\"\"</span><span style=\"color: #0000FF;\">))</span>\n     <span style=\"color: #004080;\">string</span> <span style=\"color: #000000;\">plaintext</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #008000;\">\"\"</span>\n     <span style=\"color: #008080;\">for</span> <span style=\"color: #000000;\">i</span><span style=\"color: #0000FF;\">=</span><span style=\"color: #000000;\">1</span> <span style=\"color: #008080;\">to</span> <span style=\"color: #7060A8;\">length</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">tmp</span><span style=\"color: #0000FF;\">)</span> <span style=\"color: #008080;\">by</span> <span style=\"color: #000000;\">2</span> <span style=\"color: #008080;\">do</span>\n         <span style=\"color: #004080;\">integer</span> <span style=\"color: #000000;\">r</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">find</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">tmp</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">i</span><span style=\"color: #0000FF;\">],</span><span style=\"color: #000000;\">ADFGVX</span><span style=\"color: #0000FF;\">)-</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">,</span>\n                 <span style=\"color: #000000;\">c</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">find</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">tmp</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">i</span><span style=\"color: #0000FF;\">+</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">],</span><span style=\"color: #000000;\">ADFGVX</span><span style=\"color: #0000FF;\">)</span>\n         <span style=\"color: #000000;\">plaintext</span> <span style=\"color: #0000FF;\">&=</span> <span style=\"color: #000000;\">polybius</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">r</span><span style=\"color: #0000FF;\">*</span><span style=\"color: #000000;\">6</span><span style=\"color: #0000FF;\">+</span><span style=\"color: #000000;\">c</span><span style=\"color: #0000FF;\">]</span>\n     <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">for</span>\n     <span style=\"color: #008080;\">return</span> <span style=\"color: #000000;\">plaintext</span>\n <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">function</span>\n\n <span style=\"color: #004080;\">string</span> <span style=\"color: #000000;\">polybius</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #000000;\">create_polybius</span><span style=\"color: #0000FF;\">(),</span>\n             <span style=\"color: #000000;\">key</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #000000;\">create_key</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">9</span><span style=\"color: #0000FF;\">),</span>\n        <span style=\"color: #000000;\">plaintext</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #008000;\">\"ATTACKAT1200AM\"</span><span style=\"color: #0000FF;\">,</span>\n        <span style=\"color: #000000;\">encrypted</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #000000;\">encrypt</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">polybius</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">key</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">plaintext</span><span style=\"color: #0000FF;\">),</span>\n        <span style=\"color: #000000;\">decrypted</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #000000;\">decrypt</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">polybius</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">key</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">encrypted</span><span style=\"color: #0000FF;\">)</span>\n <span style=\"color: #7060A8;\">printf</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #008000;\">\"\\nPlainText : %s\\n\\nEncrypted : %s\\n\\nDecrypted : %s\\n\"</span><span style=\"color: #0000FF;\">,</span>\n            <span style=\"color: #0000FF;\">{</span><span style=\"color: #000000;\">plaintext</span><span style=\"color: #0000FF;\">,</span>        <span style=\"color: #000000;\">encrypted</span><span style=\"color: #0000FF;\">,</span>        <span style=\"color: #000000;\">decrypted</span><span style=\"color: #0000FF;\">})</span>\n<!--\n"
                }
            ],
            [
                {
                    "language": "Perl",
                    "solution": "#!/usr/bin/perl\n\nuse strict; # https://rosettacode.org/wiki/ADFGVX_cipher\nuse warnings;\nuse List::Util qw( shuffle );\n\nmy $plaintext = 'ATTACKAT1200AM';\nmy $keysize = 9;\n\nmy $polybius = <<END;\n  | A D F G V X\n--+------------\nA | x x x x x x\nD | x x x x x x\nF | x x x x x x\nG | x x x x x x\nV | x x x x x x\nX | x x x x x x\nEND\n$polybius =~ s/x/$_/ for my @letters = shuffle \"A\" .. 'Z' , 0 .. 9;\nprint \"Polybius square =\\n\\n$polybius\\n\";\nmy %char2pair;\n@char2pair{ @letters } = glob '{A,D,F,G,V,X}' x 2; # map chars to pairs\nmy %pair2char = reverse %char2pair;                # map pairs to chars\nmy ($keyword) = shuffle grep !/(.).*\\1/,\n  do { local (@ARGV, $/) = 'unixdict.txt'; <> =~ /^.{$keysize}$/gm };\nmy ($n, @deorder) = 0;\nmy @reorder = map /.(.+)/, sort map $_ . $n++, split //, $keyword;\n@deorder[@reorder] = 0 .. $#reorder;\nprint \"  keyword = $keyword\\n\\nplaintext = $plaintext\\n\\n\";\n\nmy $encoded = encode( $plaintext, \\%char2pair, \\@reorder );\nprint \"  encoded = $encoded\\n\\n\";\n\nmy $decoded = decode( $encoded, \\%pair2char, \\@deorder );\nprint \"  decoded = $decoded\\n\";\n\nsub encode\n  {\n  my ($plain, $c2p, $order) = @_;\n  my $len = @$order;\n  join ' ', (transpose( $plain =~ s/./$c2p->{$&}/gr =~ /.{1,$len}/g ))[@$order];\n  }\n\nsub decode\n  {\n  my ($encoded, $p2c, $order) = @_;\n  (join '', transpose((split ' ', $encoded)[@$order])) =~ s/../$p2c->{$&}/gr;\n  }\n\nsub transpose { map join('', map {s/.// ? $& : ''} @_), 1 .. length $_[0] }\n"
                },
                {
                    "language": "Phix",
                    "solution": "(phixonline)-->\n <span style=\"color: #008080;\">with</span> <span style=\"color: #008080;\">javascript_semantics</span>\n <span style=\"color: #008080;\">constant</span> <span style=\"color: #000000;\">ADFGVX</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #008000;\">\"ADFGVX\"</span><span style=\"color: #0000FF;\">,</span>\n          <span style=\"color: #000000;\">ALEPH</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">tagset</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #008000;\">'Z'</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #008000;\">'A'</span><span style=\"color: #0000FF;\">)&</span><span style=\"color: #7060A8;\">tagset</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #008000;\">'9'</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #008000;\">'0'</span><span style=\"color: #0000FF;\">)</span>\n\n <span style=\"color: #008080;\">function</span> <span style=\"color: #000000;\">create_polybius</span><span style=\"color: #0000FF;\">()</span>\n     <span style=\"color: #004080;\">string</span> <span style=\"color: #000000;\">aleph</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">shuffle</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">ALEPH</span><span style=\"color: #0000FF;\">)</span>\n <span style=\"color: #000080;font-style:italic;\">--  string aleph = \"U1CNHFEM4RSGPI8965X2ZB7KA3YVOD0WQTJL\"   -- Nim\n --  string aleph = \"T71VB5HYG2JKIQM8REOPDUNCZ063FXAW9S4L\"   -- Wren\n --  string aleph = \"NA1C3H8TB2OME5WRPD4F6G7I9J0KLQSUVXYZ\"   -- wp</span>\n     <span style=\"color: #004080;\">sequence</span> <span style=\"color: #000000;\">tmp</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">split</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #7060A8;\">join_by</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">aleph</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">6</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #008000;\">\" \"</span><span style=\"color: #0000FF;\">),</span><span style=\"color: #008000;\">'\\n'</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #7060A8;\">printf</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #008000;\">\"6 x 6 Polybius square:\\n\"</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #7060A8;\">printf</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #008000;\">\"  | A D F G V X\\n\"</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #7060A8;\">printf</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #008000;\">\"---------------\\n\"</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #008080;\">for</span> <span style=\"color: #000000;\">i</span><span style=\"color: #0000FF;\">=</span><span style=\"color: #000000;\">1</span> <span style=\"color: #008080;\">to</span> <span style=\"color: #7060A8;\">length</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">tmp</span><span style=\"color: #0000FF;\">)</span> <span style=\"color: #008080;\">do</span>\n         <span style=\"color: #7060A8;\">printf</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #008000;\">\"%s | %s\\n\"</span><span style=\"color: #0000FF;\">,{</span><span style=\"color: #000000;\">ADFGVX</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">i</span><span style=\"color: #0000FF;\">],</span><span style=\"color: #000000;\">tmp</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">i</span><span style=\"color: #0000FF;\">]})</span>\n     <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">for</span>\n     <span style=\"color: #008080;\">return</span> <span style=\"color: #000000;\">aleph</span>\n <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">function</span>\n\n <span style=\"color: #008080;\">function</span> <span style=\"color: #000000;\">lnua</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #004080;\">string</span> <span style=\"color: #000000;\">word</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #004080;\">integer</span> <span style=\"color: #000000;\">n</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #008080;\">return</span> <span style=\"color: #7060A8;\">length</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">word</span><span style=\"color: #0000FF;\">)==</span><span style=\"color: #000000;\">n</span>\n        <span style=\"color: #008080;\">and</span> <span style=\"color: #7060A8;\">length</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #7060A8;\">unique</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">word</span><span style=\"color: #0000FF;\">))==</span><span style=\"color: #000000;\">n</span>\n        <span style=\"color: #008080;\">and</span> <span style=\"color: #7060A8;\">length</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #7060A8;\">filter</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">word</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #008000;\">\"in\"</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">ALEPH</span><span style=\"color: #0000FF;\">))==</span><span style=\"color: #000000;\">n</span>\n <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">function</span>\n\n <span style=\"color: #008080;\">function</span> <span style=\"color: #000000;\">create_key</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #004080;\">integer</span> <span style=\"color: #000000;\">n</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #7060A8;\">assert</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">n</span><span style=\"color: #0000FF;\">>=</span><span style=\"color: #000000;\">7</span> <span style=\"color: #008080;\">and</span> <span style=\"color: #000000;\">n</span><span style=\"color: #0000FF;\"><=</span><span style=\"color: #000000;\">12</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #004080;\">sequence</span> <span style=\"color: #000000;\">candidates</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">filter</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #7060A8;\">upper</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #7060A8;\">unix_dict</span><span style=\"color: #0000FF;\">()),</span><span style=\"color: #000000;\">lnua</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">n</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #004080;\">string</span> <span style=\"color: #000000;\">res</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #000000;\">candidates</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #7060A8;\">rand</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #7060A8;\">length</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">candidates</span><span style=\"color: #0000FF;\">))]</span>\n <span style=\"color: #000080;font-style:italic;\">--  string res = \"PHAGOCYTE\" -- Nim\n --  string res = \"SUNFLOWER\" -- Wren\n --  string res = \"PRIVACY\" -- wp</span>\n     <span style=\"color: #7060A8;\">printf</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #008000;\">\"\\nThe key is %s\\n\"</span><span style=\"color: #0000FF;\">,{</span><span style=\"color: #000000;\">res</span><span style=\"color: #0000FF;\">})</span>\n     <span style=\"color: #008080;\">return</span> <span style=\"color: #000000;\">res</span>\n <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">function</span>\n\n <span style=\"color: #008080;\">function</span> <span style=\"color: #000000;\">encrypt</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #004080;\">string</span> <span style=\"color: #000000;\">polybius</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #000000;\">key</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #000000;\">plaintext</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #004080;\">integer</span> <span style=\"color: #000000;\">l</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">length</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">key</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #004080;\">sequence</span> <span style=\"color: #000000;\">tags</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">custom_sort</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">key</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #7060A8;\">tagset</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">l</span><span style=\"color: #0000FF;\">)),</span>\n              <span style=\"color: #000000;\">res</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #008000;\">\"\"</span>\n     <span style=\"color: #008080;\">for</span> <span style=\"color: #000000;\">i</span><span style=\"color: #0000FF;\">=</span><span style=\"color: #000000;\">1</span> <span style=\"color: #008080;\">to</span> <span style=\"color: #7060A8;\">length</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">plaintext</span><span style=\"color: #0000FF;\">)</span> <span style=\"color: #008080;\">do</span>\n         <span style=\"color: #004080;\">integer</span> <span style=\"color: #000000;\">k</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">find</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">plaintext</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">i</span><span style=\"color: #0000FF;\">],</span><span style=\"color: #000000;\">polybius</span><span style=\"color: #0000FF;\">)</span>\n         <span style=\"color: #008080;\">if</span> <span style=\"color: #000000;\">k</span> <span style=\"color: #008080;\">then</span>   <span style=\"color: #000080;font-style:italic;\">-- (simply ignore any non-alphanum)</span>\n             <span style=\"color: #000000;\">res</span> <span style=\"color: #0000FF;\">&=</span> <span style=\"color: #000000;\">ADFGVX</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #7060A8;\">floor</span><span style=\"color: #0000FF;\">((</span><span style=\"color: #000000;\">k</span><span style=\"color: #0000FF;\">-</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">)/</span><span style=\"color: #000000;\">6</span><span style=\"color: #0000FF;\">)+</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">]&</span>\n                    <span style=\"color: #000000;\">ADFGVX</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #7060A8;\">remainder</span><span style=\"color: #0000FF;\">((</span><span style=\"color: #000000;\">k</span><span style=\"color: #0000FF;\">-</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">),</span><span style=\"color: #000000;\">6</span><span style=\"color: #0000FF;\">)+</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">]</span>\n         <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">if</span>\n     <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">for</span>\n     <span style=\"color: #000000;\">res</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">substitute</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #7060A8;\">join</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #7060A8;\">columnize</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #7060A8;\">split_by</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">res</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">l</span><span style=\"color: #0000FF;\">),</span><span style=\"color: #000000;\">tags</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #008000;\">' '</span><span style=\"color: #0000FF;\">)),</span><span style=\"color: #008000;\">\"  \"</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #008000;\">\" \"</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #008080;\">return</span> <span style=\"color: #000000;\">res</span>\n <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">function</span>\n\n <span style=\"color: #008080;\">function</span> <span style=\"color: #000000;\">decrypt</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #004080;\">string</span> <span style=\"color: #000000;\">polybius</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #000000;\">key</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #000000;\">encrypted</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #004080;\">integer</span> <span style=\"color: #000000;\">l</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">length</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">key</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #004080;\">sequence</span> <span style=\"color: #000000;\">tags</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">custom_sort</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">key</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #7060A8;\">tagset</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">l</span><span style=\"color: #0000FF;\">)),</span>\n              <span style=\"color: #000000;\">tmp</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">columnize</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #7060A8;\">split</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">encrypted</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #008000;\">' '</span><span style=\"color: #0000FF;\">),{},</span><span style=\"color: #008000;\">' '</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #000000;\">tmp</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">trim</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #7060A8;\">join</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #7060A8;\">apply</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #004600;\">true</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #7060A8;\">extract</span><span style=\"color: #0000FF;\">,{</span><span style=\"color: #000000;\">tmp</span><span style=\"color: #0000FF;\">,{</span><span style=\"color: #000000;\">tags</span><span style=\"color: #0000FF;\">},</span><span style=\"color: #004600;\">true</span><span style=\"color: #0000FF;\">}),</span><span style=\"color: #008000;\">\"\"</span><span style=\"color: #0000FF;\">))</span>\n     <span style=\"color: #004080;\">string</span> <span style=\"color: #000000;\">plaintext</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #008000;\">\"\"</span>\n     <span style=\"color: #008080;\">for</span> <span style=\"color: #000000;\">i</span><span style=\"color: #0000FF;\">=</span><span style=\"color: #000000;\">1</span> <span style=\"color: #008080;\">to</span> <span style=\"color: #7060A8;\">length</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">tmp</span><span style=\"color: #0000FF;\">)</span> <span style=\"color: #008080;\">by</span> <span style=\"color: #000000;\">2</span> <span style=\"color: #008080;\">do</span>\n         <span style=\"color: #004080;\">integer</span> <span style=\"color: #000000;\">r</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">find</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">tmp</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">i</span><span style=\"color: #0000FF;\">],</span><span style=\"color: #000000;\">ADFGVX</span><span style=\"color: #0000FF;\">)-</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">,</span>\n                 <span style=\"color: #000000;\">c</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">find</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">tmp</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">i</span><span style=\"color: #0000FF;\">+</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">],</span><span style=\"color: #000000;\">ADFGVX</span><span style=\"color: #0000FF;\">)</span>\n         <span style=\"color: #000000;\">plaintext</span> <span style=\"color: #0000FF;\">&=</span> <span style=\"color: #000000;\">polybius</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">r</span><span style=\"color: #0000FF;\">*</span><span style=\"color: #000000;\">6</span><span style=\"color: #0000FF;\">+</span><span style=\"color: #000000;\">c</span><span style=\"color: #0000FF;\">]</span>\n     <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">for</span>\n     <span style=\"color: #008080;\">return</span> <span style=\"color: #000000;\">plaintext</span>\n <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">function</span>\n\n <span style=\"color: #004080;\">string</span> <span style=\"color: #000000;\">polybius</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #000000;\">create_polybius</span><span style=\"color: #0000FF;\">(),</span>\n             <span style=\"color: #000000;\">key</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #000000;\">create_key</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">9</span><span style=\"color: #0000FF;\">),</span>\n        <span style=\"color: #000000;\">plaintext</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #008000;\">\"ATTACKAT1200AM\"</span><span style=\"color: #0000FF;\">,</span>\n        <span style=\"color: #000000;\">encrypted</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #000000;\">encrypt</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">polybius</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">key</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">plaintext</span><span style=\"color: #0000FF;\">),</span>\n        <span style=\"color: #000000;\">decrypted</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #000000;\">decrypt</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">polybius</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">key</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">encrypted</span><span style=\"color: #0000FF;\">)</span>\n <span style=\"color: #7060A8;\">printf</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #008000;\">\"\\nPlainText : %s\\n\\nEncrypted : %s\\n\\nDecrypted : %s\\n\"</span><span style=\"color: #0000FF;\">,</span>\n            <span style=\"color: #0000FF;\">{</span><span style=\"color: #000000;\">plaintext</span><span style=\"color: #0000FF;\">,</span>        <span style=\"color: #000000;\">encrypted</span><span style=\"color: #0000FF;\">,</span>        <span style=\"color: #000000;\">decrypted</span><span style=\"color: #0000FF;\">})</span>\n<!--\n"
                }
            ]
        ]
    },
    {
        "task_name": "AKS-test-for-primes",
        "task_description": "The [http://www.cse.iitk.ac.in/users/manindra/algebra/primality_v6.pdf AKS algorithm] for testing whether a number is prime is a polynomial-time algorithm based on an elementary theorem about Pascal triangles. \n\nThe theorem on which the test is based can be stated as follows:\n\n* &nbsp; a number &nbsp; <big><big><math>p</math></big></big> &nbsp; is prime &nbsp; if and only if &nbsp; all the coefficients of the polynomial expansion of\n::: <big><big><math>(x-1)^p - (x^p - 1)</math></big></big>\nare divisible by &nbsp; <big><big><math>p</math>.</big></big>\n\n\n;Example:\nUsing &nbsp; <big><big><math>p=3</math>:</big></big>\n\n          <big><big>(x-1)^3 - (x^3 - 1)\n             = (x^3 - 3x^2 + 3x - 1) - (x^3 - 1)\n             = -3x^2 + 3x</big></big>\n\n\nAnd all the coefficients are divisible by '''3''', &nbsp; so '''3''' is prime.\n\n\n{{alertbox|#ffe4e4|'''Note:'''<br/>This task is '''not''' the AKS primality test. &nbsp; It is an inefficient exponential time algorithm discovered in the late 1600s and used as an introductory lemma in the AKS derivation.}}\n\n\n;Task:\n\n\n# Create a function/subroutine/method that given &nbsp; <big><big><math>p</math></big></big> &nbsp; generates the coefficients of the expanded polynomial representation of &nbsp; <big><big><math>(x-1)^p</math>.</big></big>\n# Use the function to show here the polynomial expansions of &nbsp; <big><big><math>(x-1)^p</math></big></big> &nbsp; for &nbsp; <big><big><math>p</math></big></big> &nbsp; in the range &nbsp; '''0''' &nbsp; to at least &nbsp; '''7''', &nbsp; inclusive.\n# Use the previous function in creating another function that when given &nbsp; <big><big><math>p</math></big></big> &nbsp; returns whether &nbsp; <big><big><math>p</math></big></big> &nbsp; is prime using the theorem.\n# Use your test to generate a list of all primes ''under'' &nbsp; '''35'''.\n# '''As a stretch goal''', &nbsp; generate all primes under &nbsp; '''50''' &nbsp; (needs integers larger than 31-bit).\n\n\n;References:\n* [https://en.wikipedia.org/wiki/AKS_primality_test Agrawal-Kayal-Saxena (AKS) primality test] (Wikipedia) \n* [http://www.youtube.com/watch?v=HvMSRWTE2mI Fool-Proof Test for Primes] - Numberphile (Video).  The accuracy of this video is disputed -- at best it is an oversimplification.\n<br><br>\n\n",
        "solution_pairs": [
            [
                {
                    "language": "Rust",
                    "solution": "fn aks_coefficients(k: usize) -> Vec<i64> {\n\tif k == 0 {\n\t\tvec![1i64]\n\t} else {\n\t\tlet zero = Some(0i64);\n\t\trange(1, k).fold(vec![1i64, -1], |r, _| {\n\t\t\tlet a = r.iter().chain(zero.iter());\n\t\t\tlet b = zero.iter().chain(r.iter());\n\t\t\ta.zip(b).map(|(x, &y)| x-y).collect()\n\t\t})\n\t}\n}\n"
                },
                {
                    "language": "Seed7",
                    "solution": "$ include \"seed7_05.s7i\";\n\nconst func array integer: expand_x_1 (in integer: p) is func\n  result\n    var array integer: ex is [] (1);\n  local\n    var integer: i is 0;\n  begin\n    for i range 0 to p - 1 do\n      ex := [] (ex[1] * -(p - i) div (i + 1)) & ex;\n    end for;\n  end func;\n\nconst func boolean: aks_test (in integer: p) is func\n  result\n    var boolean: aks_test is FALSE;\n  local\n    var array integer: ex is 0 times 0;\n    var integer: idx is 0;\n  begin\n    if p >= 2 then\n      ex := expand_x_1(p);\n      ex[1] +:= 1;\n      for key idx range ex until ex[idx] rem p <> 0 do\n        noop;\n      end for;\n      aks_test := idx = length(ex);\n    end if;\n  end func;\n\nconst proc: main is func\n  local\n    var integer: p is 0;\n    var integer: n is 0;\n    var integer: e is 0;\n  begin\n    writeln(\"# p: (x-1)^p for small p\");\n    for p range 0 to 11 do\n      write(p lpad 3 <& \": \");\n      for n key e range expand_x_1(p) do\n        write(\" \");\n        if n >= 0 then\n          write(\"+\");\n        end if;\n        write(n);\n        if e > 1 then\n          write(\"x^\" <& pred(e));\n        end if;\n      end for;\n      writeln;\n    end for;\n    writeln;\n    writeln(\"# small primes using the aks test\");\n    for p range 0 to 61 do\n      if aks_test(p) then\n        write(p <& \" \");\n      end if;\n    end for;\n    writeln;\n  end func;\n"
                }
            ],
            [
                {
                    "language": "Julia",
                    "solution": "function polycoefs(n::Int64)\n    pc = typeof(n)[]\n    if n < 0\n        return pc\n    end\n    sgn = one(n)\n    for k in n:-1:0\n        push!(pc, sgn*binomial(n, k))\n        sgn = -sgn\n    end\n    return pc\nend\n"
                },
                {
                    "language": "Seed7",
                    "solution": "$ include \"seed7_05.s7i\";\n\nconst func array integer: expand_x_1 (in integer: p) is func\n  result\n    var array integer: ex is [] (1);\n  local\n    var integer: i is 0;\n  begin\n    for i range 0 to p - 1 do\n      ex := [] (ex[1] * -(p - i) div (i + 1)) & ex;\n    end for;\n  end func;\n\nconst func boolean: aks_test (in integer: p) is func\n  result\n    var boolean: aks_test is FALSE;\n  local\n    var array integer: ex is 0 times 0;\n    var integer: idx is 0;\n  begin\n    if p >= 2 then\n      ex := expand_x_1(p);\n      ex[1] +:= 1;\n      for key idx range ex until ex[idx] rem p <> 0 do\n        noop;\n      end for;\n      aks_test := idx = length(ex);\n    end if;\n  end func;\n\nconst proc: main is func\n  local\n    var integer: p is 0;\n    var integer: n is 0;\n    var integer: e is 0;\n  begin\n    writeln(\"# p: (x-1)^p for small p\");\n    for p range 0 to 11 do\n      write(p lpad 3 <& \": \");\n      for n key e range expand_x_1(p) do\n        write(\" \");\n        if n >= 0 then\n          write(\"+\");\n        end if;\n        write(n);\n        if e > 1 then\n          write(\"x^\" <& pred(e));\n        end if;\n      end for;\n      writeln;\n    end for;\n    writeln;\n    writeln(\"# small primes using the aks test\");\n    for p range 0 to 61 do\n      if aks_test(p) then\n        write(p <& \" \");\n      end if;\n    end for;\n    writeln;\n  end func;\n"
                }
            ],
            [
                {
                    "language": "ARM-Assembly",
                    "solution": "/* ARM assembly Raspberry PI  or android 32 bits */\n/*  program AKS.s   */\n\n/* REMARK 1 : this program use routines in a include file\n   see task Include a file language arm assembly\n   for the routine affichageMess conversion10\n   see at end of this program the instruction include */\n/* for constantes see task include a file in arm assembly */\n/************************************/\n/* Constantes                       */\n/************************************/\n.include \"../constantes.inc\"\n.equ MAXI,       32\n.equ NUMBERLOOP, 10\n\n/*********************************/\n/* Initialized data              */\n/*********************************/\n.data\nszMessResult:        .asciz \" (x-1)^@ = \"\nszMessResult1:       .asciz \" @ x^@   \"\nszMessResPrime:      .asciz \"Number @ is prime. \\n\"\nszCarriageReturn:    .asciz \"\\n\"\n\n/*********************************/\n/* UnInitialized data            */\n/*********************************/\n.bss\nsZoneConv:        .skip 24\niTabCoef:         .skip 4 * MAXI\n/*********************************/\n/*  code section                 */\n/*********************************/\n.text\n.global main\nmain:                               @ entry of program\n\n    mov r4,#1\n1:                                  @ loop\n    mov r0,r4\n    bl computeCoef                  @ compute coefficient\n    ldr r0,iAdriTabCoef\n    mov r0,r4\n    bl displayCoef                  @ display coefficient\n    add r4,r4,#1\n    cmp r4,#NUMBERLOOP\n    blt 1b\n\n    mov r4,#1\n2:\n    mov r0,r4\n    bl isPrime                      @ is prime ?\n    cmp r0,#1\n    bne 3f\n    mov r0,r4\n    ldr r1,iAdrsZoneConv\n    bl conversion10                  @ call decimal conversion\n    add r1,r0\n    mov r5,#0\n    strb r5,[r1]\n    ldr r0,iAdrszMessResPrime\n    ldr r1,iAdrsZoneConv             @ insert value conversion in message\n    bl strInsertAtCharInc\n    bl affichageMess\n\n3:\n    add r4,r4,#1\n    cmp r4,#MAXI\n    blt 2b\n\n100:                                  @ standard end of the program\n    mov r0, #0                        @ return code\n    mov r7, #EXIT                     @ request to exit program\n    svc #0                            @ perform the system call\n\niAdrszCarriageReturn:     .int szCarriageReturn\niAdrsZoneConv:            .int sZoneConv\niAdriTabCoef:             .int iTabCoef\niAdrszMessResPrime:       .int szMessResPrime\n/***************************************************/\n/*     display coefficients                        */\n/***************************************************/\n// r0 contains a number\ndisplayCoef:\n    push {r1-r6,lr}             @ save  registers\n    mov r2,r0\n    ldr r1,iAdrsZoneConv        @\n    bl conversion10             @ call decimal conversion\n    add r1,r0\n    mov r5,#0\n    strb r5,[r1]\n    ldr r0,iAdrszMessResult\n    ldr r1,iAdrsZoneConv        @ insert value conversion in message\n    bl strInsertAtCharInc\n    bl affichageMess\n    ldr r3,iAdriTabCoef\n1:\n    ldr r0,[r3,r2,lsl #2]\n    ldr r1,iAdrsZoneConv        @\n    bl conversion10S            @ call decimal conversion\n2:                              @ removing spaces\n    ldrb r6,[r1]\n    cmp r6,#' '\n    addeq r1,#1\n    beq 2b\n\n    ldr r0,iAdrszMessResult1\n    bl strInsertAtCharInc\n    mov r4,r0\n    mov r0,r2\n    ldr r1,iAdrsZoneConv        @ else display odd message\n    bl conversion10             @ call decimal conversion\n    add r1,r0\n    mov r5,#0\n    strb r5,[r1]\n    mov r0,r4\n    ldr r1,iAdrsZoneConv        @ insert value conversion in message\n    bl strInsertAtCharInc\n    bl affichageMess\n    subs r2,r2,#1\n    bge 1b\n\n    ldr r0,iAdrszCarriageReturn\n    bl affichageMess\n100:\n    pop {r1-r6,lr}             @ restaur registers\n    bx lr                      @ return\niAdrszMessResult:    .int szMessResult\niAdrszMessResult1:   .int szMessResult1\n/***************************************************/\n/*     compute coefficient               */\n/***************************************************/\n// r0 contains a number\ncomputeCoef:\n    push {r1-r6,lr}             @ save  registers\n    ldr r1,iAdriTabCoef         @ address coefficient array\n    mov r2,#1\n    str r2,[r1]                 @ store 1 to coeff [0]\n    mov r3,#0                   @ indice 1\n1:\n    add r4,r3,#1\n    mov r5,#1\n    str r5,[r1,r4,lsl #2]\n    mov r6,r3                   @ indice 2 = indice 1\n2:\n    cmp r6,#0                   @ zero ? -> end loop\n    ble 3f\n    sub r4,r6,#1\n    ldr r5,[r1,r4,lsl #2]\n    ldr r4,[r1,r6,lsl #2]\n    sub r5,r5,r4\n    str r5,[r1,r6,lsl #2]\n    sub r6,r6,#1\n    b 2b\n3:\n    ldr r2,[r1]                 @ inversion coeff [0]\n    neg r2,r2\n    str r2,[r1]\n    add r3,r3,#1\n    cmp r3,r0\n    blt 1b\n\n100:\n    pop {r1-r6,lr}             @ restaur registers\n    bx lr                      @ return\n/***************************************************/\n/*     verify number is prime              */\n/***************************************************/\n// r0 contains a number\nisPrime:\n    push {r1-r5,lr}             @ save  registers\n    bl computeCoef\n    ldr r4,iAdriTabCoef         @ address coefficient array\n    ldr r2,[r4]\n    add r2,r2,#1\n    str r2,[r4]\n    ldr r2,[r4,r0,lsl #2]\n    sub r2,r2,#1\n    str r2,[r4,r0,lsl #2]\n    mov r5,r0                  @ number start\n    mov r1,r0                  @ divisor\n1:\n    ldr r0,[r4,r5,lsl #2]      @ load one coeff\n    cmp r0,#0                  @ if negative inversion\n    neglt r0,r0\n    bl division                @ because this routine is number positive only\n    cmp r3,#0                  @ remainder = z\u221a\u00a9ro ?\n    movne r0,#0                @  if <> no prime\n    bne 100f\n    subs r5,r5,#1              @ next coef\n    bgt 1b\n    mov r0,#1                  @ prime\n\n100:\n    pop {r1-r5,lr}             @ restaur registers\n    bx lr                      @ return\n/***************************************************/\n/*      ROUTINES INCLUDE                           */\n/***************************************************/\n.include \"../affichage.inc\"\n"
                },
                {
                    "language": "Rust",
                    "solution": "fn aks_coefficients(k: usize) -> Vec<i64> {\n    let mut coefficients = vec![0i64; k + 1];\n    coefficients[0] = 1;\n    for i in 1..(k + 1) {\n        coefficients[i] = -(1..i).fold(coefficients[0], |prev, j|{\n            let old = coefficients[j];\n            coefficients[j] = old - prev;\n            old\n        });\n    }\n    coefficients\n}\n\nfn is_prime(p: usize) -> bool {\n    if p < 2 {\n        false\n    } else {\n        let c = aks_coefficients(p);\n        (1..p / 2 + 1).all(|i| c[i] % p as i64 == 0)\n    }\n}\n\nfn main() {\n    for i in 0..8 {\n        println!(\"{}: {:?}\", i, aks_coefficients(i));\n    }\n    for i in (1..=50).filter(|&i| is_prime(i)) {\n        print!(\"{} \", i);\n    }\n}\n"
                }
            ],
            [
                {
                    "language": "Scala",
                    "solution": "def powerMin1(n: BigInt) = if (n % 2 == 0) BigInt(1) else BigInt(-1)\n\nval pascal = (( Vector(Vector(BigInt(1))) /: (1 to 50)) { (rows, i) =>\n    val v = rows.head\n    val newVector = ((1 until v.length) map (j =>\n        powerMin1(j+i) * (v(j-1).abs + v(j).abs))\n    ).toVector\n    (powerMin1(i) +: newVector :+ powerMin1(i+v.length)) +: rows\n}).reverse\n\ndef poly2String(poly: Vector[BigInt]) = ((0 until poly.length) map { i =>\n    (i, poly(i)) match {\n        case (0, c) => c.toString\n        case (_, c) =>\n            (if (c >= 0) \"+\" else \"-\") +\n            (if (c == 1) \"x\" else c.abs + \"x\") +\n            (if (i == 1) \"\" else \"^\" + i)\n    }\n}) mkString \"\"\n\ndef isPrime(n: Int) = {\n    val poly = pascal(n)\n    poly.slice(1, poly.length - 1).forall(i => i % n == 0)\n}\n\nfor(i <- 0 to 7) { println( f\"(x-1)^$i = ${poly2String( pascal(i) )}\" ) }\n\nval primes = (2 to 50).filter(isPrime)\nprintln\nprintln(primes mkString \" \")\n"
                },
                {
                    "language": "Ada",
                    "solution": "with Ada.Text_IO;\n\nprocedure Test_For_Primes is\n\n   type Pascal_Triangle_Type is array (Natural range <>) of Long_Long_Integer;\n\n   function Calculate_Pascal_Triangle (N : in Natural) return Pascal_Triangle_Type is\n      Pascal_Triangle : Pascal_Triangle_Type (0 .. N);\n   begin\n      Pascal_Triangle (0) := 1;\n      for I in Pascal_Triangle'First .. Pascal_Triangle'Last - 1 loop\n         Pascal_Triangle (1 + I) := 1;\n         for J in reverse 1 .. I loop\n            Pascal_Triangle (J) := Pascal_Triangle (J - 1) - Pascal_Triangle (J);\n         end loop;\n         Pascal_Triangle (0) := -Pascal_Triangle (0);\n      end loop;\n      return Pascal_Triangle;\n   end Calculate_Pascal_Triangle;\n\n   function Is_Prime (N : Integer) return Boolean is\n      I      : Integer;\n      Result : Boolean := True;\n      Pascal_Triangle : constant Pascal_Triangle_Type := Calculate_Pascal_Triangle (N);\n   begin\n      I := N / 2;\n      while Result and I > 1 loop\n         Result := Result and Pascal_Triangle (I) mod Long_Long_Integer (N) = 0;\n         I := I - 1;\n      end loop;\n      return Result;\n   end Is_Prime;\n\n   function Image (N    : in Long_Long_Integer;\n                   Sign : in Boolean := False) return String is\n      Image : constant String := N'Image;\n   begin\n      if N < 0 then\n         return Image;\n      else\n         if Sign then\n            return \"+\" & Image (Image'First + 1 .. Image'Last);\n         else\n            return Image (Image'First + 1 .. Image'Last);\n         end if;\n      end if;\n   end Image;\n\n   procedure Show (Triangle : in Pascal_Triangle_Type) is\n      use Ada.Text_IO;\n   Begin\n      for I in reverse Triangle'Range loop\n         Put (Image (Triangle (I), Sign => True));\n         Put (\"x^\");\n         Put (Image (Long_Long_Integer (I)));\n         Put (\" \");\n      end loop;\n   end Show;\n\n   procedure Show_Pascal_Triangles is\n      use Ada.Text_IO;\n   begin\n      for N in 0 .. 9 loop\n         declare\n            Pascal_Triangle : constant Pascal_Triangle_Type := Calculate_Pascal_Triangle (N);\n         begin\n            Put (\"(x-1)^\" & Image (Long_Long_Integer (N)) & \" = \");\n            Show (Pascal_Triangle);\n            New_Line;\n         end;\n      end loop;\n   end Show_Pascal_Triangles;\n\n   procedure Show_Primes is\n      use Ada.Text_IO;\n   begin\n      for N in 2 .. 63 loop\n         if Is_Prime (N) then\n            Put (N'Image);\n         end if;\n      end loop;\n      New_Line;\n   end Show_Primes;\n\nbegin\n   Show_Pascal_Triangles;\n   Show_Primes;\nend Test_For_Primes;\n"
                }
            ],
            [
                {
                    "language": "ARM-Assembly",
                    "solution": "/* ARM assembly Raspberry PI  or android 32 bits */\n/*  program AKS.s   */\n\n/* REMARK 1 : this program use routines in a include file\n   see task Include a file language arm assembly\n   for the routine affichageMess conversion10\n   see at end of this program the instruction include */\n/* for constantes see task include a file in arm assembly */\n/************************************/\n/* Constantes                       */\n/************************************/\n.include \"../constantes.inc\"\n.equ MAXI,       32\n.equ NUMBERLOOP, 10\n\n/*********************************/\n/* Initialized data              */\n/*********************************/\n.data\nszMessResult:        .asciz \" (x-1)^@ = \"\nszMessResult1:       .asciz \" @ x^@   \"\nszMessResPrime:      .asciz \"Number @ is prime. \\n\"\nszCarriageReturn:    .asciz \"\\n\"\n\n/*********************************/\n/* UnInitialized data            */\n/*********************************/\n.bss\nsZoneConv:        .skip 24\niTabCoef:         .skip 4 * MAXI\n/*********************************/\n/*  code section                 */\n/*********************************/\n.text\n.global main\nmain:                               @ entry of program\n\n    mov r4,#1\n1:                                  @ loop\n    mov r0,r4\n    bl computeCoef                  @ compute coefficient\n    ldr r0,iAdriTabCoef\n    mov r0,r4\n    bl displayCoef                  @ display coefficient\n    add r4,r4,#1\n    cmp r4,#NUMBERLOOP\n    blt 1b\n\n    mov r4,#1\n2:\n    mov r0,r4\n    bl isPrime                      @ is prime ?\n    cmp r0,#1\n    bne 3f\n    mov r0,r4\n    ldr r1,iAdrsZoneConv\n    bl conversion10                  @ call decimal conversion\n    add r1,r0\n    mov r5,#0\n    strb r5,[r1]\n    ldr r0,iAdrszMessResPrime\n    ldr r1,iAdrsZoneConv             @ insert value conversion in message\n    bl strInsertAtCharInc\n    bl affichageMess\n\n3:\n    add r4,r4,#1\n    cmp r4,#MAXI\n    blt 2b\n\n100:                                  @ standard end of the program\n    mov r0, #0                        @ return code\n    mov r7, #EXIT                     @ request to exit program\n    svc #0                            @ perform the system call\n\niAdrszCarriageReturn:     .int szCarriageReturn\niAdrsZoneConv:            .int sZoneConv\niAdriTabCoef:             .int iTabCoef\niAdrszMessResPrime:       .int szMessResPrime\n/***************************************************/\n/*     display coefficients                        */\n/***************************************************/\n// r0 contains a number\ndisplayCoef:\n    push {r1-r6,lr}             @ save  registers\n    mov r2,r0\n    ldr r1,iAdrsZoneConv        @\n    bl conversion10             @ call decimal conversion\n    add r1,r0\n    mov r5,#0\n    strb r5,[r1]\n    ldr r0,iAdrszMessResult\n    ldr r1,iAdrsZoneConv        @ insert value conversion in message\n    bl strInsertAtCharInc\n    bl affichageMess\n    ldr r3,iAdriTabCoef\n1:\n    ldr r0,[r3,r2,lsl #2]\n    ldr r1,iAdrsZoneConv        @\n    bl conversion10S            @ call decimal conversion\n2:                              @ removing spaces\n    ldrb r6,[r1]\n    cmp r6,#' '\n    addeq r1,#1\n    beq 2b\n\n    ldr r0,iAdrszMessResult1\n    bl strInsertAtCharInc\n    mov r4,r0\n    mov r0,r2\n    ldr r1,iAdrsZoneConv        @ else display odd message\n    bl conversion10             @ call decimal conversion\n    add r1,r0\n    mov r5,#0\n    strb r5,[r1]\n    mov r0,r4\n    ldr r1,iAdrsZoneConv        @ insert value conversion in message\n    bl strInsertAtCharInc\n    bl affichageMess\n    subs r2,r2,#1\n    bge 1b\n\n    ldr r0,iAdrszCarriageReturn\n    bl affichageMess\n100:\n    pop {r1-r6,lr}             @ restaur registers\n    bx lr                      @ return\niAdrszMessResult:    .int szMessResult\niAdrszMessResult1:   .int szMessResult1\n/***************************************************/\n/*     compute coefficient               */\n/***************************************************/\n// r0 contains a number\ncomputeCoef:\n    push {r1-r6,lr}             @ save  registers\n    ldr r1,iAdriTabCoef         @ address coefficient array\n    mov r2,#1\n    str r2,[r1]                 @ store 1 to coeff [0]\n    mov r3,#0                   @ indice 1\n1:\n    add r4,r3,#1\n    mov r5,#1\n    str r5,[r1,r4,lsl #2]\n    mov r6,r3                   @ indice 2 = indice 1\n2:\n    cmp r6,#0                   @ zero ? -> end loop\n    ble 3f\n    sub r4,r6,#1\n    ldr r5,[r1,r4,lsl #2]\n    ldr r4,[r1,r6,lsl #2]\n    sub r5,r5,r4\n    str r5,[r1,r6,lsl #2]\n    sub r6,r6,#1\n    b 2b\n3:\n    ldr r2,[r1]                 @ inversion coeff [0]\n    neg r2,r2\n    str r2,[r1]\n    add r3,r3,#1\n    cmp r3,r0\n    blt 1b\n\n100:\n    pop {r1-r6,lr}             @ restaur registers\n    bx lr                      @ return\n/***************************************************/\n/*     verify number is prime              */\n/***************************************************/\n// r0 contains a number\nisPrime:\n    push {r1-r5,lr}             @ save  registers\n    bl computeCoef\n    ldr r4,iAdriTabCoef         @ address coefficient array\n    ldr r2,[r4]\n    add r2,r2,#1\n    str r2,[r4]\n    ldr r2,[r4,r0,lsl #2]\n    sub r2,r2,#1\n    str r2,[r4,r0,lsl #2]\n    mov r5,r0                  @ number start\n    mov r1,r0                  @ divisor\n1:\n    ldr r0,[r4,r5,lsl #2]      @ load one coeff\n    cmp r0,#0                  @ if negative inversion\n    neglt r0,r0\n    bl division                @ because this routine is number positive only\n    cmp r3,#0                  @ remainder = z\u221a\u00a9ro ?\n    movne r0,#0                @  if <> no prime\n    bne 100f\n    subs r5,r5,#1              @ next coef\n    bgt 1b\n    mov r0,#1                  @ prime\n\n100:\n    pop {r1-r5,lr}             @ restaur registers\n    bx lr                      @ return\n/***************************************************/\n/*      ROUTINES INCLUDE                           */\n/***************************************************/\n.include \"../affichage.inc\"\n"
                },
                {
                    "language": "Python",
                    "solution": "def expand_x_1(p):\n    ex = [1]\n    for i in range(p):\n        ex.append(ex[-1] * -(p-i) / (i+1))\n    return ex[::-1]\n\ndef aks_test(p):\n    if p < 2: return False\n    ex = expand_x_1(p)\n    ex[0] += 1\n    return not any(mult % p for mult in ex[0:-1])\n\n\nprint('# p: (x-1)^p for small p')\nfor p in range(12):\n    print('%3i: %s' % (p, ' '.join('%+i%s' % (e, ('x^%i' % n) if n else '')\n                                   for n,e in enumerate(expand_x_1(p)))))\n\nprint('\\n# small primes using the aks test')\nprint([p for p in range(101) if aks_test(p)])\n"
                }
            ]
        ]
    },
    {
        "task_name": "Algebraic-data-types",
        "task_description": "Some languages offer direct support for [[wp:Algebraic_data_type|algebraic data types]] and pattern matching on them. While this of course can always be simulated with manual tagging and conditionals, it allows for terse code which is easy to read, and can represent the algorithm directly.\n\n\n;Task:\nAs an example, implement insertion in a [[wp:Red_Black_Tree|red-black-tree]]. \n\nA red-black-tree is a binary tree where each internal node has a color attribute ''red'' or ''black''. Moreover, no red node can have a red child, and every path from the root to an empty node must contain the same number of black nodes. As a consequence, the tree is balanced, and must be re-balanced after an insertion.\n<br><br>\n\n;Reference:\n[https://www.cs.tufts.edu/comp/150FP/archive/chris-okasaki/redblack99.pdf Red-Black Trees in a Functional Setting] \n",
        "solution_pairs": [
            [
                {
                    "language": "Rascal",
                    "solution": "// Quoted pattern\n` Token1 Token2 ... Tokenn `\n// A typed quoted pattern\n(Symbol) ` Token1 Token2 ... TokenN `\n// A typed variable pattern\n<Type Var>\n// A variable pattern\n<Var>\n"
                },
                {
                    "language": "Rascal",
                    "solution": "rascal>/XX/i := \"some xx\";\nbool: true\nrascal>/a.c/ := \"abc\";\nbool: true\n"
                }
            ],
            [
                {
                    "language": "Phix",
                    "solution": "(phixonline)-->\n <span style=\"color: #000080;font-style:italic;\">--\n -- demo\\rosetta\\Pattern_matching.exw\n -- =================================\n --\n -- 1). Lightly modified copy of demo\\rosetta\\VisualiseTree.exw</span>\n\n <span style=\"color: #008080;\">with</span> <span style=\"color: #008080;\">javascript_semantics</span>\n\n <span style=\"color: #000080;font-style:italic;\">-- To the theme tune of the Milk Tray Ad iyrt,\n -- All because the Windows console hates utf8:</span>\n <span style=\"color: #008080;\">constant</span> <span style=\"color: #000000;\">TL</span> <span style=\"color: #0000FF;\">=</span> '\\<span style=\"color: #000000;\">#DA</span>'<span style=\"color: #0000FF;\">,</span> <span style=\"color: #000080;font-style:italic;\">-- aka '\u250c'</span>\n          <span style=\"color: #000000;\">VT</span> <span style=\"color: #0000FF;\">=</span> '\\<span style=\"color: #000000;\">#B3</span>'<span style=\"color: #0000FF;\">,</span> <span style=\"color: #000080;font-style:italic;\">-- aka '\u2502'</span>\n          <span style=\"color: #000000;\">BL</span> <span style=\"color: #0000FF;\">=</span> '\\<span style=\"color: #000000;\">#C0</span>'<span style=\"color: #0000FF;\">,</span> <span style=\"color: #000080;font-style:italic;\">-- aka '\u2514'</span>\n          <span style=\"color: #000000;\">HZ</span> <span style=\"color: #0000FF;\">=</span> '\\<span style=\"color: #000000;\">#C4</span>'<span style=\"color: #0000FF;\">,</span> <span style=\"color: #000080;font-style:italic;\">-- aka '\u2500'</span>\n          <span style=\"color: #000000;\">HS</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #008000;\">\"\\#C4\"</span>  <span style=\"color: #000080;font-style:italic;\">-- (string version of HZ)</span>\n\n <span style=\"color: #008080;\">function</span> <span style=\"color: #000000;\">w1252_to_utf8</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #004080;\">string</span> <span style=\"color: #000000;\">s</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #008080;\">if</span> <span style=\"color: #7060A8;\">platform</span><span style=\"color: #0000FF;\">()!=</span><span style=\"color: #004600;\">WINDOWS</span> <span style=\"color: #008080;\">then</span>\n         <span style=\"color: #000000;\">s</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">substitute_all</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">s</span><span style=\"color: #0000FF;\">,{</span> <span style=\"color: #000000;\">TL</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #000000;\">VT</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #000000;\">BL</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #000000;\">HZ</span><span style=\"color: #0000FF;\">},</span>\n                              <span style=\"color: #0000FF;\">{</span><span style=\"color: #008000;\">\"\u250c\"</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #008000;\">\"\u2502\"</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #008000;\">\"\u2514\"</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #008000;\">\"\u2500\"</span><span style=\"color: #0000FF;\">})</span>\n     <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">if</span>\n     <span style=\"color: #008080;\">return</span> <span style=\"color: #000000;\">s</span>\n <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">function</span>\n <span style=\"color: #000080;font-style:italic;\">--&lt;/hates utf8&gt;</span>\n\n <span style=\"color: #008080;\">procedure</span> <span style=\"color: #000000;\">visualise_tree</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #004080;\">object</span> <span style=\"color: #000000;\">tree</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #004080;\">string</span> <span style=\"color: #000000;\">root</span><span style=\"color: #0000FF;\">=</span><span style=\"color: #000000;\">HS</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #008080;\">if</span> <span style=\"color: #004080;\">atom</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">tree</span><span style=\"color: #0000FF;\">)</span> <span style=\"color: #008080;\">then</span>\n         <span style=\"color: #7060A8;\">puts</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #008000;\">\"&lt;empty&gt;\\n\"</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #008080;\">else</span>\n         <span style=\"color: #004080;\">object</span> <span style=\"color: #0000FF;\">{</span><span style=\"color: #000000;\">colour</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">left</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">v</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">right</span><span style=\"color: #0000FF;\">}</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #000000;\">tree</span>\n         <span style=\"color: #004080;\">integer</span> <span style=\"color: #000000;\">g</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #000000;\">root</span><span style=\"color: #0000FF;\">[$]</span>\n         <span style=\"color: #008080;\">if</span> <span style=\"color: #004080;\">sequence</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">left</span><span style=\"color: #0000FF;\">)</span> <span style=\"color: #008080;\">then</span>\n             <span style=\"color: #000000;\">root</span><span style=\"color: #0000FF;\">[$]</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #008080;\">iff</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">g</span><span style=\"color: #0000FF;\">=</span><span style=\"color: #000000;\">TL</span> <span style=\"color: #008080;\">or</span> <span style=\"color: #000000;\">g</span><span style=\"color: #0000FF;\">=</span><span style=\"color: #000000;\">HZ</span><span style=\"color: #0000FF;\">?</span><span style=\"color: #008000;\">' '</span><span style=\"color: #0000FF;\">:</span><span style=\"color: #000000;\">VT</span><span style=\"color: #0000FF;\">)</span>\n             <span style=\"color: #000000;\">visualise_tree</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">left</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">root</span><span style=\"color: #0000FF;\">&</span><span style=\"color: #000000;\">TL</span><span style=\"color: #0000FF;\">)</span>\n         <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">if</span>\n         <span style=\"color: #000000;\">root</span><span style=\"color: #0000FF;\">[$]</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #000000;\">g</span>\n         <span style=\"color: #7060A8;\">printf</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #008000;\">\"%s%s%v\\n\"</span><span style=\"color: #0000FF;\">,{</span><span style=\"color: #000000;\">w1252_to_utf8</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">root</span><span style=\"color: #0000FF;\">),</span><span style=\"color: #000000;\">colour</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">v</span><span style=\"color: #0000FF;\">})</span>\n         <span style=\"color: #008080;\">if</span> <span style=\"color: #004080;\">sequence</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">right</span><span style=\"color: #0000FF;\">)</span> <span style=\"color: #008080;\">then</span>\n             <span style=\"color: #000000;\">root</span><span style=\"color: #0000FF;\">[$]</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #008080;\">iff</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">g</span><span style=\"color: #0000FF;\">=</span><span style=\"color: #000000;\">TL</span><span style=\"color: #0000FF;\">?</span><span style=\"color: #000000;\">VT</span><span style=\"color: #0000FF;\">:</span><span style=\"color: #008000;\">' '</span><span style=\"color: #0000FF;\">)</span>\n             <span style=\"color: #000000;\">visualise_tree</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">right</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">root</span><span style=\"color: #0000FF;\">&</span><span style=\"color: #000000;\">BL</span><span style=\"color: #0000FF;\">)</span>\n         <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">if</span>\n     <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">if</span>\n <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">procedure</span>\n <span style=\"color: #000080;font-style:italic;\">--&lt;/copy VisualiseTree&gt;\n\n -- 2). Imagine the following is in a file, say algebraic_data_types.e - not quite generic enough\n --      for inclusion in builtins, but not exactly difficult to copy/maintain per-project either.</span>\n\n <span style=\"color: #008080;\">function</span> <span style=\"color: #000000;\">match_one</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #004080;\">sequence</span> <span style=\"color: #000000;\">key</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #004080;\">object</span> <span style=\"color: #000000;\">t</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #004080;\">sequence</span> <span style=\"color: #000000;\">res</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #0000FF;\">{}</span>\n     <span style=\"color: #008080;\">if</span> <span style=\"color: #004080;\">sequence</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">t</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #008080;\">and</span> <span style=\"color: #7060A8;\">length</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">key</span><span style=\"color: #0000FF;\">)==</span><span style=\"color: #7060A8;\">length</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">t</span><span style=\"color: #0000FF;\">)</span> <span style=\"color: #008080;\">then</span>\n         <span style=\"color: #008080;\">for</span> <span style=\"color: #000000;\">i</span><span style=\"color: #0000FF;\">=</span><span style=\"color: #000000;\">1</span> <span style=\"color: #008080;\">to</span> <span style=\"color: #7060A8;\">length</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">key</span><span style=\"color: #0000FF;\">)</span> <span style=\"color: #008080;\">do</span>\n             <span style=\"color: #004080;\">object</span> <span style=\"color: #000000;\">ki</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #000000;\">key</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">i</span><span style=\"color: #0000FF;\">],</span> <span style=\"color: #000000;\">ti</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #000000;\">t</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">i</span><span style=\"color: #0000FF;\">]</span>\n             <span style=\"color: #008080;\">if</span> <span style=\"color: #004080;\">sequence</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">ki</span><span style=\"color: #0000FF;\">)</span> <span style=\"color: #008080;\">and</span> <span style=\"color: #008080;\">not</span> <span style=\"color: #004080;\">string</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">ki</span><span style=\"color: #0000FF;\">)</span> <span style=\"color: #008080;\">then</span>\n                 <span style=\"color: #004080;\">sequence</span> <span style=\"color: #000000;\">r2</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #000000;\">match_one</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">ki</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">ti</span><span style=\"color: #0000FF;\">)</span>\n                 <span style=\"color: #008080;\">if</span> <span style=\"color: #000000;\">r2</span><span style=\"color: #0000FF;\">={}</span> <span style=\"color: #008080;\">then</span> <span style=\"color: #000000;\">res</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #0000FF;\">{}</span> <span style=\"color: #008080;\">exit</span> <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">if</span>\n                 <span style=\"color: #000000;\">res</span> <span style=\"color: #0000FF;\">&=</span> <span style=\"color: #000000;\">r2</span>\n             <span style=\"color: #008080;\">else</span>\n                 <span style=\"color: #008080;\">if</span> <span style=\"color: #000000;\">ki</span><span style=\"color: #0000FF;\">=</span><span style=\"color: #000000;\">0</span> <span style=\"color: #008080;\">then</span>\n                     <span style=\"color: #000000;\">res</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">append</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">res</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">ti</span><span style=\"color: #0000FF;\">)</span>\n                 <span style=\"color: #008080;\">else</span>\n                     <span style=\"color: #008080;\">if</span> <span style=\"color: #000000;\">ki</span><span style=\"color: #0000FF;\">!=</span><span style=\"color: #000000;\">ti</span> <span style=\"color: #008080;\">then</span> <span style=\"color: #000000;\">res</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #0000FF;\">{}</span> <span style=\"color: #008080;\">exit</span> <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">if</span>\n                 <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">if</span>\n             <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">if</span>\n         <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">for</span>\n     <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">if</span>\n     <span style=\"color: #008080;\">return</span> <span style=\"color: #000000;\">res</span>\n <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">function</span>\n\n <span style=\"color: #000080;font-style:italic;\">/*global*/</span> <span style=\"color: #008080;\">function</span> <span style=\"color: #000000;\">match_algebraic</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #004080;\">sequence</span> <span style=\"color: #000000;\">set</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #000000;\">t</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #004080;\">sequence</span> <span style=\"color: #000000;\">s</span>\n     <span style=\"color: #008080;\">for</span> <span style=\"color: #000000;\">i</span><span style=\"color: #0000FF;\">=</span><span style=\"color: #000000;\">1</span> <span style=\"color: #008080;\">to</span> <span style=\"color: #7060A8;\">length</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">set</span><span style=\"color: #0000FF;\">)</span> <span style=\"color: #008080;\">do</span>\n         <span style=\"color: #000000;\">s</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #000000;\">match_one</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">set</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">i</span><span style=\"color: #0000FF;\">],</span><span style=\"color: #000000;\">t</span><span style=\"color: #0000FF;\">)</span>\n         <span style=\"color: #008080;\">if</span> <span style=\"color: #7060A8;\">length</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">s</span><span style=\"color: #0000FF;\">)</span> <span style=\"color: #008080;\">then</span> <span style=\"color: #008080;\">exit</span> <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">if</span>\n     <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">for</span>\n     <span style=\"color: #008080;\">return</span> <span style=\"color: #000000;\">s</span>\n <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">function</span>\n <span style=\"color: #000080;font-style:italic;\">--&lt;/algebraic_data_types.e&gt;\n\n -- 3). The actual task</span>\n\n <span style=\"color: #008080;\">constant</span> <span style=\"color: #000000;\">B</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #008000;\">\"B\"</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #000000;\">R</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #008000;\">\"R\"</span>\n\n <span style=\"color: #008080;\">function</span> <span style=\"color: #000000;\">balance</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #004080;\">sequence</span> <span style=\"color: #000000;\">t</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #004080;\">sequence</span> <span style=\"color: #000000;\">s</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #000000;\">match_algebraic</span><span style=\"color: #0000FF;\">({{</span><span style=\"color: #000000;\">B</span><span style=\"color: #0000FF;\">,{</span><span style=\"color: #000000;\">R</span><span style=\"color: #0000FF;\">,{</span><span style=\"color: #000000;\">R</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">0</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">0</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">0</span><span style=\"color: #0000FF;\">},</span><span style=\"color: #000000;\">0</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">0</span><span style=\"color: #0000FF;\">},</span><span style=\"color: #000000;\">0</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">0</span><span style=\"color: #0000FF;\">},</span>\n                                   <span style=\"color: #0000FF;\">{</span><span style=\"color: #000000;\">B</span><span style=\"color: #0000FF;\">,{</span><span style=\"color: #000000;\">R</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">0</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">0</span><span style=\"color: #0000FF;\">,{</span><span style=\"color: #000000;\">R</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">0</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">0</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">0</span><span style=\"color: #0000FF;\">}},</span><span style=\"color: #000000;\">0</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">0</span><span style=\"color: #0000FF;\">},</span>\n                                   <span style=\"color: #0000FF;\">{</span><span style=\"color: #000000;\">B</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">0</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">0</span><span style=\"color: #0000FF;\">,{</span><span style=\"color: #000000;\">R</span><span style=\"color: #0000FF;\">,{</span><span style=\"color: #000000;\">R</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">0</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">0</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">0</span><span style=\"color: #0000FF;\">},</span><span style=\"color: #000000;\">0</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">0</span><span style=\"color: #0000FF;\">}},</span>\n                                   <span style=\"color: #0000FF;\">{</span><span style=\"color: #000000;\">B</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">0</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">0</span><span style=\"color: #0000FF;\">,{</span><span style=\"color: #000000;\">R</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">0</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">0</span><span style=\"color: #0000FF;\">,{</span><span style=\"color: #000000;\">R</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">0</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">0</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">0</span><span style=\"color: #0000FF;\">}}}},</span><span style=\"color: #000000;\">t</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #008080;\">if</span> <span style=\"color: #7060A8;\">length</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">s</span><span style=\"color: #0000FF;\">)</span> <span style=\"color: #008080;\">then</span>\n         <span style=\"color: #004080;\">object</span> <span style=\"color: #0000FF;\">{</span><span style=\"color: #000000;\">a</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">x</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">b</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">y</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">c</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">z</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">d</span><span style=\"color: #0000FF;\">}</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #000000;\">s</span>\n         <span style=\"color: #000000;\">t</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #0000FF;\">{</span><span style=\"color: #000000;\">R</span><span style=\"color: #0000FF;\">,{</span><span style=\"color: #000000;\">B</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">a</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">x</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">b</span><span style=\"color: #0000FF;\">},</span><span style=\"color: #000000;\">y</span><span style=\"color: #0000FF;\">,{</span><span style=\"color: #000000;\">B</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">c</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">z</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">d</span><span style=\"color: #0000FF;\">}}</span>\n     <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">if</span>\n     <span style=\"color: #008080;\">return</span> <span style=\"color: #000000;\">t</span>\n <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">function</span>\n\n <span style=\"color: #008080;\">function</span> <span style=\"color: #000000;\">ins</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #004080;\">object</span> <span style=\"color: #000000;\">tree</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #004080;\">object</span> <span style=\"color: #000000;\">leaf</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #008080;\">if</span> <span style=\"color: #000000;\">tree</span><span style=\"color: #0000FF;\">=</span><span style=\"color: #004600;\">NULL</span> <span style=\"color: #008080;\">then</span>\n         <span style=\"color: #000000;\">tree</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #0000FF;\">{</span><span style=\"color: #000000;\">R</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #004600;\">NULL</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">leaf</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #004600;\">NULL</span><span style=\"color: #0000FF;\">}</span>\n     <span style=\"color: #008080;\">else</span>\n         <span style=\"color: #004080;\">object</span> <span style=\"color: #0000FF;\">{</span><span style=\"color: #000000;\">c</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">l</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">k</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">r</span><span style=\"color: #0000FF;\">}</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #000000;\">tree</span>\n         <span style=\"color: #008080;\">if</span> <span style=\"color: #000000;\">leaf</span><span style=\"color: #0000FF;\">!=</span><span style=\"color: #000000;\">k</span> <span style=\"color: #008080;\">then</span>\n             <span style=\"color: #008080;\">if</span> <span style=\"color: #000000;\">leaf</span><span style=\"color: #0000FF;\"><</span><span style=\"color: #000000;\">k</span> <span style=\"color: #008080;\">then</span> <span style=\"color: #000000;\">l</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #000000;\">ins</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">l</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">leaf</span><span style=\"color: #0000FF;\">)</span>\n                       <span style=\"color: #008080;\">else</span> <span style=\"color: #000000;\">r</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #000000;\">ins</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">r</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">leaf</span><span style=\"color: #0000FF;\">)</span>\n             <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">if</span>\n             <span style=\"color: #000000;\">tree</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #000000;\">balance</span><span style=\"color: #0000FF;\">({</span><span style=\"color: #000000;\">c</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">l</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">k</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">r</span><span style=\"color: #0000FF;\">})</span>\n         <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">if</span>\n     <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">if</span>\n     <span style=\"color: #008080;\">return</span> <span style=\"color: #000000;\">tree</span>\n <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">function</span>\n\n <span style=\"color: #008080;\">function</span> <span style=\"color: #000000;\">tree_insert</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #004080;\">object</span> <span style=\"color: #000000;\">tree</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #004080;\">object</span> <span style=\"color: #000000;\">leaf</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #000000;\">tree</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #000000;\">ins</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">tree</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">leaf</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #000000;\">tree</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">]</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #000000;\">B</span>\n     <span style=\"color: #008080;\">return</span> <span style=\"color: #000000;\">tree</span>\n <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">function</span>\n\n <span style=\"color: #004080;\">sequence</span> <span style=\"color: #000000;\">stuff</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">shuffle</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #7060A8;\">tagset</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">10</span><span style=\"color: #0000FF;\">))</span>\n <span style=\"color: #004080;\">object</span> <span style=\"color: #000000;\">tree</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #004600;\">NULL</span>\n <span style=\"color: #008080;\">for</span> <span style=\"color: #000000;\">i</span><span style=\"color: #0000FF;\">=</span><span style=\"color: #000000;\">1</span> <span style=\"color: #008080;\">to</span> <span style=\"color: #7060A8;\">length</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">stuff</span><span style=\"color: #0000FF;\">)</span> <span style=\"color: #008080;\">do</span>\n     <span style=\"color: #000000;\">tree</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #000000;\">tree_insert</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">tree</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">stuff</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">i</span><span style=\"color: #0000FF;\">])</span>\n <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">for</span>\n <span style=\"color: #000000;\">visualise_tree</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">tree</span><span style=\"color: #0000FF;\">)</span>\n\n <span style=\"color: #0000FF;\">?</span><span style=\"color: #008000;\">\"done\"</span>\n <span style=\"color: #0000FF;\">{}</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">wait_key</span><span style=\"color: #0000FF;\">()</span>\n<!--\n"
                },
                {
                    "language": "Go",
                    "solution": "package main\n\nimport \"fmt\"\n\ntype Color string\n\nconst (\n    R Color = \"R\"\n    B       = \"B\"\n)\n\ntype Tree interface {\n    ins(x int) Tree\n}\n\ntype E struct{}\n\nfunc (_ E) ins(x int) Tree {\n    return T{R, E{}, x, E{}}\n}\n\nfunc (_ E) String() string {\n    return \"E\"\n}\n\ntype T struct {\n    cl Color\n    le Tree\n    aa int\n    ri Tree\n}\n\nfunc (t T) balance() Tree {\n    if t.cl != B {\n        return t\n    }\n    le, leIsT := t.le.(T)\n    ri, riIsT := t.ri.(T)\n    var lele, leri, rile, riri T\n    var leleIsT, leriIsT, rileIsT, ririIsT bool\n    if leIsT {\n        lele, leleIsT = le.le.(T)\n    }\n    if leIsT {\n        leri, leriIsT = le.ri.(T)\n    }\n    if riIsT {\n        rile, rileIsT = ri.le.(T)\n    }\n    if riIsT {\n        riri, ririIsT = ri.ri.(T)\n    }\n    switch {\n    case leIsT && leleIsT && le.cl == R && lele.cl == R:\n        _, t2, z, d := t.destruct()\n        _, t3, y, c := t2.(T).destruct()\n        _, a, x, b := t3.(T).destruct()\n        return T{R, T{B, a, x, b}, y, T{B, c, z, d}}\n    case leIsT && leriIsT && le.cl == R && leri.cl == R:\n        _, t2, z, d := t.destruct()\n        _, a, x, t3 := t2.(T).destruct()\n        _, b, y, c := t3.(T).destruct()\n        return T{R, T{B, a, x, b}, y, T{B, c, z, d}}\n    case riIsT && rileIsT && ri.cl == R && rile.cl == R:\n        _, a, x, t2 := t.destruct()\n        _, t3, z, d := t2.(T).destruct()\n        _, b, y, c := t3.(T).destruct()\n        return T{R, T{B, a, x, b}, y, T{B, c, z, d}}\n    case riIsT && ririIsT && ri.cl == R && riri.cl == R:\n        _, a, x, t2 := t.destruct()\n        _, b, y, t3 := t2.(T).destruct()\n        _, c, z, d := t3.(T).destruct()\n        return T{R, T{B, a, x, b}, y, T{B, c, z, d}}\n    default:\n        return t\n    }\n}\n\nfunc (t T) ins(x int) Tree {\n    switch {\n    case x < t.aa:\n        return T{t.cl, t.le.ins(x), t.aa, t.ri}.balance()\n    case x > t.aa:\n        return T{t.cl, t.le, t.aa, t.ri.ins(x)}.balance()\n    default:\n        return t\n    }\n}\n\nfunc (t T) destruct() (Color, Tree, int, Tree) {\n    return t.cl, t.le, t.aa, t.ri\n}\n\nfunc (t T) String() string {\n    return fmt.Sprintf(\"T(%s, %v, %d, %v)\", t.cl, t.le, t.aa, t.ri)\n}\n\nfunc insert(tr Tree, x int) Tree {\n    t := tr.ins(x)\n    switch t.(type) {\n    case T:\n        tt := t.(T)\n        _, a, y, b := tt.destruct()\n        return T{B, a, y, b}\n    case E:\n        return E{}\n    default:\n        return nil\n    }\n}\n\nfunc main() {\n    var tr Tree = E{}\n    for i := 1; i <= 16; i++ {\n        tr = insert(tr, i)\n    }\n    fmt.Println(tr)\n}\n"
                }
            ],
            [
                {
                    "language": "Rascal",
                    "solution": "// Quoted pattern\n` Token1 Token2 ... Tokenn `\n// A typed quoted pattern\n(Symbol) ` Token1 Token2 ... TokenN `\n// A typed variable pattern\n<Type Var>\n// A variable pattern\n<Var>\n"
                },
                {
                    "language": "TXR",
                    "solution": "(defmatch rb (color left right data)\n  (flet ((var? (sym) (if (bindable sym) ^@,sym sym)))\n    ^@(struct rbnode\n        color ,(var? color)\n        left ,(var? left)\n        right ,(var? right)\n        data ,(var? data))))\n\n(defmatch red (left right data)\n  ^@(rb :red ,left ,right ,data))\n\n(defmatch black (left right data)\n  ^@(rb :black ,left ,right ,data))\n"
                }
            ],
            [
                {
                    "language": "J",
                    "solution": "   ?.~20\n14 18 12 16 5 1 3 0 6 13 9 8 15 17 2 10 7 4 19 11\n   insert/?.~20\n\u250c\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502R\u2502\u250c\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250210\u2502\u250c\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u2502\n\u2502 \u2502\u2502R\u2502\u250c\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u25025\u2502\u250c\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u2502\u2502  \u2502\u2502B\u2502\u250c\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250217\u2502\u250c\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u252c\u2510\u2502\u2502\n\u2502 \u2502\u2502 \u2502\u2502B\u2502\u250c\u2500\u252c\u252c\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u25022\u2502\u250c\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u252c\u2510\u2502\u2502 \u2502\u2502B\u2502\u250c\u2500\u252c\u252c\u2500\u252c\u2510\u25027\u2502\u250c\u2500\u252c\u252c\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u2502\u2502\u2502  \u2502\u2502 \u2502\u2502R\u2502\u250c\u2500\u252c\u252c\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250213\u2502\u250c\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u2502\u2502  \u2502\u2502B\u2502\u250c\u2500\u252c\u252c\u2500\u2500\u252c\u2510\u250219\u2502\u2502\u2502\u2502\n\u2502 \u2502\u2502 \u2502\u2502 \u2502\u2502B\u2502\u25020\u2502\u250c\u2500\u252c\u252c\u2500\u252c\u2510\u2502\u2502 \u2502\u2502B\u2502\u250c\u2500\u252c\u252c\u2500\u252c\u2510\u25024\u2502\u2502\u2502\u2502 \u2502\u2502 \u2502\u2502B\u2502\u25026\u2502\u2502\u2502 \u2502\u2502B\u2502\u25028\u2502\u250c\u2500\u252c\u252c\u2500\u252c\u2510\u2502\u2502\u2502\u2502  \u2502\u2502 \u2502\u2502 \u2502\u2502B\u2502\u250211\u2502\u250c\u2500\u252c\u252c\u2500\u2500\u252c\u2510\u2502\u2502  \u2502\u2502B\u2502\u250c\u2500\u252c\u252c\u2500\u2500\u252c\u2510\u250215\u2502\u250c\u2500\u252c\u252c\u2500\u2500\u252c\u2510\u2502\u2502\u2502  \u2502\u2502 \u2502\u2502R\u2502\u250218\u2502\u2502\u2502  \u2502\u2502\u2502\u2502\n\u2502 \u2502\u2502 \u2502\u2502 \u2502\u2502 \u2502\u2502 \u2502\u2502R\u2502\u25021\u2502\u2502\u2502\u2502 \u2502\u2502 \u2502\u2502R\u2502\u25023\u2502\u2502\u2502 \u2502\u2502\u2502\u2502 \u2502\u2502 \u2502\u2514\u2500\u2534\u2534\u2500\u2534\u2518\u2502 \u2502\u2502 \u2502\u2502 \u2502\u2502R\u2502\u25029\u2502\u2502\u2502\u2502\u2502\u2502  \u2502\u2502 \u2502\u2502 \u2502\u2502 \u2502\u2502  \u2502\u2502R\u2502\u250212\u2502\u2502\u2502\u2502  \u2502\u2502 \u2502\u2502R\u2502\u250214\u2502\u2502\u2502  \u2502\u2502R\u2502\u250216\u2502\u2502\u2502\u2502\u2502  \u2502\u2502 \u2502\u2514\u2500\u2534\u2534\u2500\u2500\u2534\u2518\u2502  \u2502\u2502\u2502\u2502\n\u2502 \u2502\u2502 \u2502\u2502 \u2502\u2502 \u2502\u2502 \u2502\u2514\u2500\u2534\u2534\u2500\u2534\u2518\u2502\u2502 \u2502\u2502 \u2502\u2514\u2500\u2534\u2534\u2500\u2534\u2518\u2502 \u2502\u2502\u2502\u2502 \u2502\u2502 \u2502       \u2502 \u2502\u2502 \u2502\u2502 \u2502\u2514\u2500\u2534\u2534\u2500\u2534\u2518\u2502\u2502\u2502\u2502  \u2502\u2502 \u2502\u2502 \u2502\u2502 \u2502\u2502  \u2502\u2514\u2500\u2534\u2534\u2500\u2500\u2534\u2518\u2502\u2502  \u2502\u2502 \u2502\u2514\u2500\u2534\u2534\u2500\u2500\u2534\u2518\u2502  \u2502\u2514\u2500\u2534\u2534\u2500\u2500\u2534\u2518\u2502\u2502\u2502  \u2502\u2514\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2534\u2518\u2502\u2502\n\u2502 \u2502\u2502 \u2502\u2502 \u2502\u2514\u2500\u2534\u2534\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2502 \u2502\u2514\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2534\u2518\u2502\u2502 \u2502\u2502 \u2502       \u2502 \u2502\u2514\u2500\u2534\u2534\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2502\u2502\u2502  \u2502\u2502 \u2502\u2502 \u2502\u2514\u2500\u2534\u2534\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2502  \u2502\u2514\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2502\u2502  \u2502                \u2502\u2502\n\u2502 \u2502\u2502 \u2502\u2514\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2502 \u2502\u2514\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2502\u2502  \u2502\u2502 \u2502\u2514\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2502  \u2502                \u2502\u2502\n\u2502 \u2502\u2514\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2502  \u2502\u2514\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2502\n\u2514\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n   validate insert/?.~20\n4\n"
                },
                {
                    "language": "TXR",
                    "solution": "(defmatch rb (color left right data)\n  (flet ((var? (sym) (if (bindable sym) ^@,sym sym)))\n    ^@(struct rbnode\n        color ,(var? color)\n        left ,(var? left)\n        right ,(var? right)\n        data ,(var? data))))\n\n(defmatch red (left right data)\n  ^@(rb :red ,left ,right ,data))\n\n(defmatch black (left right data)\n  ^@(rb :black ,left ,right ,data))\n"
                }
            ],
            [
                {
                    "language": "EchoLisp",
                    "solution": "(define (t-show n (depth 0))\n\t(when (!eq? 'empty n)\n\t\t(t-show (N-left n) (+ 12 depth))\n\t\t(writeln (string-pad-left (format \"%s\" n ) depth))\n\t\t(t-show (N-right n) (+ 12 depth))))\n\n(define T (for/fold [t 'empty] ([i 32]) (insert (random 100) t)))\n(t-show T)\n"
                },
                {
                    "language": "J",
                    "solution": "insert=:{{\n  'R';'';y;a:\n:\n  if. 0=#y do. insert x\n  elseif. 0=L.y do. x insert insert y\n  else.\n    'C e K w'=. y\n    select. *x - K\n      case. _1 do. balance C;(x insert e);K;<w\n      case.  0 do. y\n      case.  1 do. balance C;e;K;<x insert w\n    end.\n  end.\n}}\n\nNB. C: color, e: east, K: key, w: west\nNB. two cascaded reds under a black become two black siblings under a red\nbalance=: {{\n  'C e K w'=. y\n  if. #e do.\n    'eC ee eK ew'=. e\n    if. 'R'=eC do.\n      if. #ee do.\n        'eeC eee eeK eew'=. ee NB. ((eee eeK eew) eK ew) K w   =>  (eee eeK eew) eK (ew K w)\n        if. 'R'=eeC do. 'R';('B';eee;eeK;<eew);eK;<'B';ew;K;<w return. end. end.\n      if. #ew do.\n        'ewC ewe ewK eww'=. ew NB. (ee ek (ewe ewK eww)) K w  =>  (ee ek ewe) ewK (eww K w)\n        if. 'R'=ewC do. 'R';('B';ee;eK;<ewe);ewK;<'B';eww;K;<w return. end. end. end. end.\n  if. #w do.\n    'wC we wK ww'=. w\n    if. 'R'=wC do.\n      if. #we do.\n        'weC wee weK wew'=. we NB. e K ((wee weK wew) wK ww)  =>  (e K wee) weK (wew wK ww)\n        if. 'R'=weC do. 'R';('B';e;K;<wee);weK;<'B';wew;wK;<ww return. end. end.\n      if. #ww do.\n        'wwC wwe wwK www'=. ww NB. e K (we wK (wwe wwK www))  =>  (e K we) wK (wwe wwK www)\n        if. 'R'=wwC do. 'R';('B';e;K;<we);wK;<'B';wwe;wwK;<www return. end. end. end. end.\n  y\n}}\n"
                }
            ]
        ]
    },
    {
        "task_name": "Align-columns",
        "task_description": "Given a text file of many lines, where fields within a line \nare delineated by a single 'dollar' character, write a program\nthat aligns each column of fields by ensuring that words in each \ncolumn are separated by at least one space.\nFurther, allow for each word in a column to be either left \njustified, right justified, or center justified within its column.\n\n<br clear=all>Use the following text to test your programs:\n<pre>Given$a$text$file$of$many$lines,$where$fields$within$a$line$\nare$delineated$by$a$single$'dollar'$character,$write$a$program\nthat$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\ncolumn$are$separated$by$at$least$one$space.\nFurther,$allow$for$each$word$in$a$column$to$be$either$left$\njustified,$right$justified,$or$center$justified$within$its$column.</pre>\n\n\nNote that:\n# &nbsp; The example input texts lines may, or may not, have trailing dollar characters.\n# &nbsp; All columns should share the same alignment.\n# &nbsp; Consecutive space characters produced adjacent to the end of lines are insignificant for the purposes of the task.\n# &nbsp; Output text will be viewed in a mono-spaced font on a plain text editor or basic terminal.\n# &nbsp; The minimum space between columns should be computed from the text and not hard-coded.\n# &nbsp; It is ''not'' a requirement to add separating characters between or around columns.\n\n\n{{Template:Strings}}\n<br><br>\n\n",
        "solution_pairs": [
            [
                {
                    "language": "Perl",
                    "solution": "#/usr/bin/perl -w\nuse strict ;\n\ndie \"Call : perl columnaligner.pl <inputfile> <printorientation>!\\n\" unless\n   @ARGV == 2 ; #$ARGV[ 0 ] contains example file , $ARGV[1] any of 'left' , 'right' or 'center'\ndie \"last argument must be one of center, left or right!\\n\" unless\n   $ARGV[ 1 ] =~ /center|left|right/ ;\nsub printLines( $$$ ) ;\nopen INFILE , \"<\" , \"$ARGV[ 0 ]\" or die \"Can't open $ARGV[ 0 ]!\\n\" ;\nmy @lines = <INFILE> ;\nclose INFILE ;\nchomp @lines ;\nmy @fieldwidths = map length, split /\\$/ , $lines[ 0 ] ;\nforeach my $i ( 1..$#lines ) {\n   my @words = split /\\$/ , $lines[ $i ] ;\n   foreach my $j ( 0..$#words ) {\n      if ( $j <= $#fieldwidths ) {\n         if ( length $words[ $j ] > $fieldwidths[ $j ] ) {\n               $fieldwidths[ $j ] = length $words[ $j ] ;\n         }\n      }\n      else {\n         push @fieldwidths, length $words[ $j ] ;\n      }\n   }\n}\nprintLine( $_ , $ARGV[ 1 ] , \\@fieldwidths ) foreach @lines ;\n##################################################################    ####\nsub printLine {\n   my $line = shift ;\n   my $orientation = shift ;\n   my $widthref = shift ;\n   my @words = split /\\$/, $line ;\n   foreach my $k ( 0..$#words ) {\n      my $printwidth = $widthref->[ $k ] + 1 ;\n      if ( $orientation eq 'center' ) {\n         $printwidth++ ;\n      }\n      if ( $orientation eq 'left' ) {\n         print $words[ $k ] ;\n         print \" \" x ( $printwidth - length $words[ $k ] ) ;\n      }\n      elsif ( $orientation eq 'right' ) {\n         print \" \" x ( $printwidth - length $words[ $k ] ) ;\n         print $words[ $k ] ;\n      }\n      elsif ( $orientation eq 'center' ) {\n         my $left = int( ( $printwidth - length $words[ $k ] )     / 2 ) ;\n         my $right = $printwidth - length( $words[ $k ] ) - $left      ;\n         print \" \" x $left ;\n         print $words[ $k ] ;\n         print \" \" x $right ;\n      }\n   }\n   print \"\\n\" ;\n}\n"
                },
                {
                    "language": "Sidef",
                    "solution": "text :=\n'Given$a$text$file$of$many$lines,$where$fields$within$a$line$\nare$delineated$by$a$single$''dollar''$character,$write$a$program\nthat$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\ncolumn$are$separated$by$at$least$one$space.\nFurther,$allow$for$each$word$in$a$column$to$be$either$left$\njustified,$right$justified,$or$center$justified$within$its$column.\n'.\n\nprintSep :=\n    [:colLengths |\n        Stdout nextPut:$+.\n        colLengths do:[:len | Stdout next:len put:$-; nextPut:$+ ].\n        Stdout cr.\n    ].\n\nprintRows :=\n    [:text :box :justifyEach |\n        lines := StringCollection fromString:text.\n        rowSet := lines collect:[:line | line splitBy:$$ ].\n        maxNumCols := (rowSet collect:[:row | row size]) max.\n        maxLengths := rowSet\n                        inject:(Array new:maxNumCols withAll:0)\n                        into:[:maxesSoFar :row|\n                                maxesSoFar\n                                    with:(row paddedTo:maxNumCols with:'')\n                                    collect:[:maxLen :col | maxLen max: col size]].\n        rowSet do:[:row |\n            |first|\n\n            box ifTrue:[ printSep value:maxLengths ].\n            first := true.\n            (box ifTrue:[row paddedTo:maxLengths size with:''] ifFalse:[row])\n            with: (box ifTrue:[maxLengths] ifFalse:[maxLengths to:row size])\n            do:[:col :len |\n                first ifTrue:[ box ifTrue:[Stdout nextPutAll:'|']. first := false.].\n                Stdout print:(justifyEach value:col value:len).\n                Stdout nextPutAll:(box ifTrue:'|' ifFalse:' ')\n            ].\n            Stdout cr.\n        ].\n        box ifTrue:[ printSep value:maxLengths ].\n    ].\n\nprintRightJustified :=\n    [:text :box | printRows value:text value:box value:[:col :len | (col leftPaddedTo:len)]].\n\nprintLeftJustified :=\n    [:text :box | printRows value:text value:box value:[:col :len | (col paddedTo:len)]].\n\nprintCentered :=\n    [:text :box | printRows value:text value:box value:[:col :len | col centerPaddedTo:len]].\n\nStdout printCR:'Left justified:'.\nprintLeftJustified value:text value:false.\n\nStdout cr; printCR:'Right justified:'.\nprintRightJustified value:text value:false.\n\nStdout cr; printCR:'Centered:'.\nprintCentered value:text value:false.\n\nStdout cr; printCR:'Left justified with box:'.\nprintLeftJustified value:text value:true.\n\nStdout cr; printCR:'Right justified with box:'.\nprintRightJustified value:text value:true.\n\nStdout cr; printCR:'Centered with box:'.\nprintCentered value:text value:true.\n"
                }
            ],
            [
                {
                    "language": "Scala",
                    "solution": "def pad(s:String, i:Int, d:String) = {\n  val padsize = (i-s.length).max(0)\n  d match {\n    case \"left\" => s+\" \"*padsize\n    case \"right\" => \" \"*padsize+s\n    case \"center\" => \" \"*(padsize/2) + s + \" \"*(padsize-padsize/2)\n  }\n}\n\nval lines = scala.io.Source.fromFile(\"c:\\\\text.txt\").getLines.map(_.trim())\nval words = lines.map(_.split(\"\\\\$\").toList).toList\nval lens = words.map(l => l.map(_.length)).toList\n\nvar maxlens = Map[Int,Int]() withDefaultValue 0\nlens foreach (l =>\n  for(i <- (0 until l.length)){\n    maxlens += i -> l(i).max(maxlens(i))\n  }\n)\n\nval padded = words map ( _.zipWithIndex.map{case(s,i)=>pad(s,maxlens(i),\"center\")+\" \"} )\npadded map (_.reduceLeft(_ + _)) foreach println\n"
                },
                {
                    "language": "J",
                    "solution": "'LEFT CENTER RIGHT'=: i.3                NB. justification constants\n\nNB.* alignCols v Format delimited text in justified columns\nNB. y:          text to format\nNB.                 rows marked by last character in text\nNB.                 columns marked by $\nNB. optional x: justification. Default is LEFT\nNB. result:     text table\nalignCols=: verb define\n  LEFT alignCols y                       NB. default\n:\n  global=. dyad def'9!:x y'each\n  oldbox=. 6 16 global '';''             NB. save settings\n  7 17 global (11#' ');,~x               NB. apply new settings\n  result=. _2{:\\ \": <;._2 @:,&'$';._2 y  NB. parse & format text\n  7 17 global oldbox                     NB. restore settings\n  result\n)\n"
                }
            ],
            [
                {
                    "language": "Phix",
                    "solution": "-->\n <span style=\"color: #008080;\">constant</span> <span style=\"color: #000000;\">data</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #0000FF;\">{</span>\n     <span style=\"color: #008000;\">\"Given$a$text$file$of$many$lines,$where$fields$within$a$line$\"</span><span style=\"color: #0000FF;\">,</span>\n     <span style=\"color: #008000;\">\"are$delineated$by$a$single$'dollar'$character,$write$a$program\"</span><span style=\"color: #0000FF;\">,</span>\n     <span style=\"color: #008000;\">\"that$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\"</span><span style=\"color: #0000FF;\">,</span>\n     <span style=\"color: #008000;\">\"column$are$separated$by$at$least$one$space.\"</span><span style=\"color: #0000FF;\">,</span>\n     <span style=\"color: #008000;\">\"Further,$allow$for$each$word$in$a$column$to$be$either$left$\"</span><span style=\"color: #0000FF;\">,</span>\n     <span style=\"color: #008000;\">\"justified,$right$justified,$or$center$justified$within$its$column.\"</span>\n <span style=\"color: #0000FF;\">}</span>\n\n <span style=\"color: #008080;\">function</span> <span style=\"color: #7060A8;\">split</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #004080;\">sequence</span> <span style=\"color: #000000;\">s</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #004080;\">integer</span> <span style=\"color: #000000;\">c</span><span style=\"color: #0000FF;\">)</span>\n <span style=\"color: #004080;\">sequence</span> <span style=\"color: #000000;\">out</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #0000FF;\">{}</span>\n <span style=\"color: #004080;\">integer</span> <span style=\"color: #000000;\">first</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #000000;\">delim</span>\n     <span style=\"color: #008080;\">while</span> <span style=\"color: #000000;\">first</span><span style=\"color: #0000FF;\"><=</span><span style=\"color: #7060A8;\">length</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">s</span><span style=\"color: #0000FF;\">)</span> <span style=\"color: #008080;\">do</span>\n         <span style=\"color: #000000;\">delim</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #000000;\">find_from</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">c</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">s</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">first</span><span style=\"color: #0000FF;\">)</span>\n         <span style=\"color: #008080;\">if</span> <span style=\"color: #000000;\">delim</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #000000;\">0</span> <span style=\"color: #008080;\">then</span>\n             <span style=\"color: #000000;\">delim</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">length</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">s</span><span style=\"color: #0000FF;\">)+</span><span style=\"color: #000000;\">1</span>\n         <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">if</span>\n         <span style=\"color: #000000;\">out</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">append</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">out</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">s</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">first</span><span style=\"color: #0000FF;\">..</span><span style=\"color: #000000;\">delim</span><span style=\"color: #0000FF;\">-</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">])</span>\n         <span style=\"color: #000000;\">first</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #000000;\">delim</span> <span style=\"color: #0000FF;\">+</span> <span style=\"color: #000000;\">1</span>\n     <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">while</span>\n     <span style=\"color: #008080;\">return</span> <span style=\"color: #000000;\">out</span>\n <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">function</span>\n\n <span style=\"color: #008080;\">function</span> <span style=\"color: #000000;\">align</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #004080;\">sequence</span> <span style=\"color: #000000;\">s</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #004080;\">integer</span> <span style=\"color: #000000;\">width</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #004080;\">integer</span> <span style=\"color: #000000;\">alignment</span><span style=\"color: #0000FF;\">)</span>\n <span style=\"color: #004080;\">integer</span> <span style=\"color: #000000;\">n</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #000000;\">width</span><span style=\"color: #0000FF;\">-</span><span style=\"color: #7060A8;\">length</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">s</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #008080;\">if</span> <span style=\"color: #000000;\">n</span><span style=\"color: #0000FF;\"><=</span><span style=\"color: #000000;\">0</span> <span style=\"color: #008080;\">then</span>\n         <span style=\"color: #008080;\">return</span> <span style=\"color: #000000;\">s</span>\n     <span style=\"color: #008080;\">elsif</span> <span style=\"color: #000000;\">alignment</span><span style=\"color: #0000FF;\"><</span><span style=\"color: #000000;\">0</span> <span style=\"color: #008080;\">then</span>\n         <span style=\"color: #008080;\">return</span> <span style=\"color: #000000;\">s</span> <span style=\"color: #0000FF;\">&</span> <span style=\"color: #7060A8;\">repeat</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #008000;\">' '</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #000000;\">n</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #008080;\">elsif</span> <span style=\"color: #000000;\">alignment</span><span style=\"color: #0000FF;\">></span><span style=\"color: #000000;\">0</span> <span style=\"color: #008080;\">then</span>\n         <span style=\"color: #008080;\">return</span> <span style=\"color: #7060A8;\">repeat</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #008000;\">' '</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #000000;\">n</span><span style=\"color: #0000FF;\">)</span> <span style=\"color: #0000FF;\">&</span> <span style=\"color: #000000;\">s</span>\n     <span style=\"color: #008080;\">else</span>\n         <span style=\"color: #000080;font-style:italic;\">-- (PL if I'd written this, I'd have n-floor(n/2) on the rhs)</span>\n         <span style=\"color: #008080;\">return</span> <span style=\"color: #7060A8;\">repeat</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #008000;\">' '</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #7060A8;\">floor</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">n</span><span style=\"color: #0000FF;\">/</span><span style=\"color: #000000;\">2</span><span style=\"color: #0000FF;\">))</span> <span style=\"color: #0000FF;\">&</span> <span style=\"color: #000000;\">s</span> <span style=\"color: #0000FF;\">&</span> <span style=\"color: #7060A8;\">repeat</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #008000;\">' '</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #7060A8;\">floor</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">n</span><span style=\"color: #0000FF;\">/</span><span style=\"color: #000000;\">2</span><span style=\"color: #0000FF;\">+</span><span style=\"color: #000000;\">0.5</span><span style=\"color: #0000FF;\">))</span>\n     <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">if</span>\n <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">function</span>\n\n <span style=\"color: #008080;\">procedure</span> <span style=\"color: #000000;\">AlignColumns</span><span style=\"color: #0000FF;\">()</span>\n <span style=\"color: #004080;\">integer</span> <span style=\"color: #000000;\">llij</span>\n <span style=\"color: #004080;\">sequence</span> <span style=\"color: #000000;\">lines</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #000000;\">li</span>\n <span style=\"color: #004080;\">sequence</span> <span style=\"color: #000000;\">maxlens</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #0000FF;\">{}</span>\n     <span style=\"color: #000000;\">lines</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">repeat</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">0</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #7060A8;\">length</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">data</span><span style=\"color: #0000FF;\">))</span>\n     <span style=\"color: #008080;\">for</span> <span style=\"color: #000000;\">i</span><span style=\"color: #0000FF;\">=</span><span style=\"color: #000000;\">1</span> <span style=\"color: #008080;\">to</span> <span style=\"color: #7060A8;\">length</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">data</span><span style=\"color: #0000FF;\">)</span> <span style=\"color: #008080;\">do</span>\n         <span style=\"color: #000000;\">li</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">split</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">data</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">i</span><span style=\"color: #0000FF;\">],</span><span style=\"color: #008000;\">'$'</span><span style=\"color: #0000FF;\">)</span>\n         <span style=\"color: #000000;\">lines</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">i</span><span style=\"color: #0000FF;\">]</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #000000;\">li</span>\n         <span style=\"color: #008080;\">if</span> <span style=\"color: #7060A8;\">length</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">li</span><span style=\"color: #0000FF;\">)></span><span style=\"color: #7060A8;\">length</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">maxlens</span><span style=\"color: #0000FF;\">)</span> <span style=\"color: #008080;\">then</span>\n             <span style=\"color: #000000;\">maxlens</span> <span style=\"color: #0000FF;\">&=</span> <span style=\"color: #7060A8;\">repeat</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">0</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #7060A8;\">length</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">li</span><span style=\"color: #0000FF;\">)-</span><span style=\"color: #7060A8;\">length</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">maxlens</span><span style=\"color: #0000FF;\">))</span>\n         <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">if</span>\n         <span style=\"color: #008080;\">for</span> <span style=\"color: #000000;\">j</span><span style=\"color: #0000FF;\">=</span><span style=\"color: #000000;\">1</span> <span style=\"color: #008080;\">to</span> <span style=\"color: #7060A8;\">length</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">li</span><span style=\"color: #0000FF;\">)</span> <span style=\"color: #008080;\">do</span>\n             <span style=\"color: #000000;\">llij</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">length</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">li</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">j</span><span style=\"color: #0000FF;\">])</span>\n             <span style=\"color: #008080;\">if</span> <span style=\"color: #000000;\">llij</span><span style=\"color: #0000FF;\">></span><span style=\"color: #000000;\">maxlens</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">j</span><span style=\"color: #0000FF;\">]</span> <span style=\"color: #008080;\">then</span> <span style=\"color: #000000;\">maxlens</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">j</span><span style=\"color: #0000FF;\">]</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #000000;\">llij</span> <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">if</span>\n         <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">for</span>\n     <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">for</span>\n\n     <span style=\"color: #008080;\">for</span> <span style=\"color: #000000;\">a</span><span style=\"color: #0000FF;\">=-</span><span style=\"color: #000000;\">1</span> <span style=\"color: #008080;\">to</span> <span style=\"color: #000000;\">1</span> <span style=\"color: #008080;\">do</span>    <span style=\"color: #000080;font-style:italic;\">-- (alignment = left/centre/right)</span>\n         <span style=\"color: #008080;\">for</span> <span style=\"color: #000000;\">i</span><span style=\"color: #0000FF;\">=</span><span style=\"color: #000000;\">1</span> <span style=\"color: #008080;\">to</span> <span style=\"color: #7060A8;\">length</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">lines</span><span style=\"color: #0000FF;\">)</span> <span style=\"color: #008080;\">do</span>\n             <span style=\"color: #008080;\">for</span> <span style=\"color: #000000;\">j</span><span style=\"color: #0000FF;\">=</span><span style=\"color: #000000;\">1</span> <span style=\"color: #008080;\">to</span> <span style=\"color: #7060A8;\">length</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">lines</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">i</span><span style=\"color: #0000FF;\">])</span> <span style=\"color: #008080;\">do</span>\n                 <span style=\"color: #7060A8;\">puts</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #000000;\">align</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">lines</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">i</span><span style=\"color: #0000FF;\">][</span><span style=\"color: #000000;\">j</span><span style=\"color: #0000FF;\">],</span><span style=\"color: #000000;\">maxlens</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">j</span><span style=\"color: #0000FF;\">],</span><span style=\"color: #000000;\">a</span><span style=\"color: #0000FF;\">)</span> <span style=\"color: #0000FF;\">&</span> <span style=\"color: #008000;\">' '</span><span style=\"color: #0000FF;\">)</span>\n             <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">for</span>\n             <span style=\"color: #7060A8;\">puts</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #008000;\">'\\n'</span><span style=\"color: #0000FF;\">)</span>\n         <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">for</span>\n         <span style=\"color: #7060A8;\">puts</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #008000;\">'\\n'</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">for</span>\n     <span style=\"color: #008080;\">if</span> <span style=\"color: #7060A8;\">getc</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">0</span><span style=\"color: #0000FF;\">)</span> <span style=\"color: #008080;\">then</span> <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">if</span>\n <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">procedure</span>\n\n <span style=\"color: #000000;\">AlignColumns</span><span style=\"color: #0000FF;\">()</span>\n<!--\n"
                },
                {
                    "language": "J",
                    "solution": "'LEFT CENTER RIGHT'=: i.3                NB. justification constants\n\nNB.* alignCols v Format delimited text in justified columns\nNB. y:          text to format\nNB.                 rows marked by last character in text\nNB.                 columns marked by $\nNB. optional x: justification. Default is LEFT\nNB. result:     text table\nalignCols=: verb define\n  LEFT alignCols y                       NB. default\n:\n  global=. dyad def'9!:x y'each\n  oldbox=. 6 16 global '';''             NB. save settings\n  7 17 global (11#' ');,~x               NB. apply new settings\n  result=. _2{:\\ \": <;._2 @:,&'$';._2 y  NB. parse & format text\n  7 17 global oldbox                     NB. restore settings\n  result\n)\n"
                }
            ],
            [
                {
                    "language": "Visual-Basic",
                    "solution": "Sub Main() 'usage of the above\nConst Text$ = \"Given$a$text$file$of$many$lines,$where$fields$within$a$line$\" & vbLf & _\n              \"are$delineated$by$a$single$'dollar'$character,$write$a$program\" & vbLf & _\n              \"that$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\" & vbLf & _\n              \"column$are$separated$by$at$least$one$space.\" & vbLf & _\n              \"Further,$allow$for$each$word$in$a$column$to$be$either$left$\" & vbLf & _\n              \"justified,$right$justified,$or$center$justified$within$its$column.\"\n\n  Debug.Print vbLf; \"-- Left:\":   AlignCols Split(Text, vbLf), vbLeftJustify\n  Debug.Print vbLf; \"-- Center:\": AlignCols Split(Text, vbLf), vbCenter\n  Debug.Print vbLf; \"-- Right:\":  AlignCols Split(Text, vbLf), vbRightJustify\nEnd Sub\n"
                },
                {
                    "language": "Perl",
                    "solution": "use List::Util qw(max);\n\nsub columns {\n    my @lines = map [split /\\$/] => split /\\n/ => shift;\n    my $pos = {qw/left 0 center 1 right 2/}->{+shift};\n    for my $col (0 .. max map {$#$_} @lines) {\n        my $max = max my @widths = map {length $_->[$col]} @lines;\n        for my $row (0 .. $#lines) {\n            my @pad = map {' ' x $_, ' ' x ($_ + 0.5)} ($max - $widths[$row]) / 2;\n            for ($lines[$row][$col])\n                {$_ = join '' => @pad[0 .. $pos-1], $_, @pad[$pos .. $#pad]}\n        }\n    }\n    join '' => map {\"@$_\\n\"} @lines\n}\n\nprint columns <<'END', $_ for qw(left right center);\nGiven$a$text$file$of$many$lines,$where$fields$within$a$line$\nare$delineated$by$a$single$'dollar'$character,$write$a$program\nthat$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\ncolumn$are$separated$by$at$least$one$space.\nFurther,$allow$for$each$word$in$a$column$to$be$either$left$\njustified,$right$justified,$or$center$justified$within$its$column.\nEND\n"
                }
            ],
            [
                {
                    "language": "Prolog",
                    "solution": "aligner :-\n\tL =\"Given$a$text$file$of$many$lines,$where$fields$within$a$line$\nare$delineated$by$a$single$'dollar'$character,$write$a$program\nthat$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\ncolumn$are$separated$by$at$least$one$space.\nFurther,$allow$for$each$word$in$a$column$to$be$either$left$\njustified,$right$justified,$or$center$justified$within$its$column.\",\n\n\t% read the lines and the words\n\t% compute the length of the longuest word.\n\t% LP is the list of lines,\n\t% each line is a list of words\n\tparse(L, 0, N, LP, []),\n\n\t% we need to add 1 to aligned\n\tN1 is N+1,\n\t% words will be left aligned\n\tsformat(AL, '~~w~~t~~~w|', [N1]),\n\t% words will be centered\n\tsformat(AC, '~~t~~w~~t~~~w|', [N1]),\n\t% words will be right aligned\n\tsformat(AR, '~~t~~w~~~w|', [N1]),\n\n\twrite('Left justified :'), nl,\n\tmaplist(affiche(AL), LP), nl,\n\twrite('Centered justified :'), nl,\n\tmaplist(affiche(AC), LP), nl,\n\twrite('Right justified :'), nl,\n\tmaplist(affiche(AR), LP), nl.\n\naffiche(F, L) :-\n\tmaplist(my_format(F), L),\n\tnl.\n\nmy_format(_F, [13]) :-\n\tnl.\n\nmy_format(F, W) :-\n\tstring_to_atom(W,AW),\n\tsformat(AF, F, [AW]),\n\twrite(AF).\n\n\nparse([], Max, Max) --> [].\n\nparse(T, N, Max) -->\n\t{ parse_line(T, 0, N1, T1, L, []),\n\t  (   N1 > N -> N2 = N1; N2 = N)},\n\t[L],\n\tparse(T1, N2, Max).\n\nparse_line([], NF, NF, []) --> [].\n\nparse_line([H|TF], NF, NF, TF) -->\n\t{code_type(H, end_of_line), !},\n\t[].\n\n\nparse_line(T, N, NF, TF) -->\n\t{ parse_word(T, 0, N1, T1, W, []),\n\t  (   N1 > N -> N2 = N1; N2 = N)},\n\t[W],\n\tparse_line(T1, N2, NF, TF).\n\n% 36 is the code of '$'\nparse_word([36|T], N, N, T) -->\n\t{!},\n\t[].\n\nparse_word([H|T], N, N, [H|T]) -->\n\t{code_type(H, end_of_line), !},\n\t[].\n\nparse_word([], N, N, []) --> [].\n\nparse_word([H|T], N1, NF, TF) -->\n\t[H],\n\t{N2 is  N1 + 1},\n\tparse_word(T, N2, NF, TF).\n"
                },
                {
                    "language": "M2000-Interpreter",
                    "solution": "Module Align_Columns {\n\ta$={Given$a$text$file$of$many$lines,$where$fields$within$a$line$\n\t\tare$delineated$by$a$single$'dollar'$character,$write$a$program\n\t\tthat$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\n\t\tcolumn$are$separated$by$at$least$one$space.\n\t\tFurther,$allow$for$each$word$in$a$column$to$be$either$left$\n\t\tjustified,$right$justified,$or$center$justified$within$its$column.\n\t\t}\n\tconst cr$=chr$(13), lf$=chr$(10)\n\tdef c1=0, cmax=0, p1=-1, i\n\tflush  ' empty stack\n\tfor i=1 to len(a$)\n\t\tselect case mid$(a$,i,1)\n\t\tcase \"$\", cr$\n\t\t\tif p1<>-1 then data (p1, c1):  p1=-1: cmax=max(c1,cmax):c1=0\n\t\tcase lf$\n\t\t\tdata (-1,0)     ' push to end of  stack an array of two items (a tuple in m2000)\n\t\telse case\n\t\t\tif p1=-1 then p1=i :c1=1 else c1++\n\t\tend select\n\tnext\n\tif p1<>-1 then push (p1, c1): cmax=max(c1,cmax):c1=0\n\t\\\\ so now stack of values hold all tuples.\n\tDim Words(), AlignType$(1 to 3)\n\tAlignType$(1)=lambda$ (a$,wd)->field$(a$, wd)\n\tAlignType$(2)=lambda$ (a$,wd)->{\n\t\ta$=left$(a$, wd)\n\t\t=left$(string$(\" \", (len(a$)-wd) div 2)+a$+string$(\" \",wd),wd)\n\t}\n\tAlignType$(3)= lambda$ (a$,wd)->format$(\"{0:\"+str$(-wd)+\"}\", a$)\n\t\\\\ [] return a stack object, reference and leave current stack of values a new stack\n\t\\\\ Array( stack_object) empty the stack object moving items to an array\n\tWords()=Array([])\n\tdocument export$\n\tdef aline$\n\tcmax++  ' add one space\n\tFor al=1 to 3\n\t\tFor i=0 to len(Words())-1\n\t\t\tif Words(i)(0)=-1 then\n\t\t\t\t' we use rtrim$() to cut trailing spaces\n\t\t\t\texport$=rtrim$(aline$)+cr$+lf$ : aline$=\"\"\n\t\t\telse\n\t\t\t\taline$+=AlignType$(al)(mid$(a$,Words(i)(0), Words(i)(1)),cmax)\n\t\t\tend if\n\t\tnext i\n\tnext\n\t\\\\ export to clipboard\n\tClipboard  export$\n\tRem\tForm 140, 60\n\tRem\tPrint #-2, export$ ' render text to console without using console's columns\n}\nAlign_Columns\n"
                }
            ]
        ]
    },
    {
        "task_name": "Aliquot-sequence-classifications",
        "task_description": "An [[wp:Aliquot sequence|aliquot sequence]] of a positive integer K is defined recursively as the first member\nbeing K and subsequent members being the sum of the [[Proper divisors]] of the previous term.\n\n:* If the terms eventually reach 0 then the series for K is said to '''terminate'''.\n\n:<br>There are several classifications for non termination:\n:* If the second term is K then all future terms are also K and so the sequence repeats from the first term with period 1 and K is called '''perfect'''.\n:* If the third term ''would'' be repeating K then the sequence repeats with period 2 and K is called '''amicable'''.\n:* If the N<sup>th</sup> term ''would'' be repeating K for the first time, with N > 3 then the sequence repeats with period N - 1 and K is called '''sociable'''.\n:<br>Perfect, amicable and sociable numbers eventually repeat the original number K; there are other repetitions...\n:* Some K have a sequence that eventually forms a periodic repetition of period 1 but of a number other than K, for example 95 which forms the sequence <code>95, 25, 6, 6, 6, ...</code> such K are called '''aspiring'''.\n:* K that have a sequence that eventually forms a periodic repetition of period >= 2 but of a number other than K, for example 562 which forms the sequence <code>562, 284, 220, 284, 220, ...</code> such K are called '''cyclic'''.\n\n:<br>And finally:\n:* Some K form aliquot sequences that are not known to be either terminating or periodic; these K are to be called '''non-terminating'''. <br>For the purposes of this task, K is to be classed as non-terminating if it has not been otherwise classed after generating '''16''' terms or if any term of the sequence is greater than 2**47 = 140,737,488,355,328. \n\n\n;Task:\n# Create routine(s) to generate the aliquot sequence of a positive integer enough to classify it according to the classifications given above.\n# Use it to display the classification and sequences of the numbers one to ten inclusive.\n# Use it to show the classification and sequences of the following integers, in order:\n:: 11, 12, 28, 496, 220, 1184,  12496, 1264460, 790, 909, 562, 1064, 1488, and optionally 15355717786080.\n\nShow all output on this page.\n\n\n;Related tasks:\n* &nbsp; [[Abundant, deficient and perfect number classifications]]. (Classifications from only the first two members of the whole sequence).\n* &nbsp; [[Proper divisors]]\n* &nbsp; [[Amicable pairs]]\n<br><br>\n\n",
        "solution_pairs": [
            [
                {
                    "language": "AppleScript",
                    "solution": "\"\n                 1:  terminating      1, 0\n                 2:  terminating      2, 1, 0\n                 3:  terminating      3, 1, 0\n                 4:  terminating      4, 3, 1, 0\n                 5:  terminating      5, 1, 0\n                 6:  perfect          6\n                 7:  terminating      7, 1, 0\n                 8:  terminating      8, 7, 1, 0\n                 9:  terminating      9, 4, 3, 1, 0\n                10:  terminating      10, 8, 7, 1, 0\n                11:  terminating      11, 1, 0\n                12:  terminating      12, 16, 15, 9, 4, 3, 1, 0\n                28:  perfect          28\n               496:  perfect          496\n               220:  amicable         220, 284\n              1184:  amicable         1184, 1210\n             12496:  sociable         12496, 14288, 15472, 14536, 14264\n           1264460:  sociable         1264460, 1547860, 1727636, 1305184\n               790:  aspiring         790, 650, 652, 496\n               909:  aspiring         909, 417, 143, 25, 6\n               562:  cyclic           562, 284, 220\n              1064:  cyclic           1064, 1336, 1184, 1210\n              1488:  non-terminating  1488, 2480, 3472, 4464, 8432, 9424, 10416, 21328, 22320, 55056, 95728, 96720, 236592, 459792, 881392, 882384\n1.535571778608E+13:  non-terminating  1.535571778608E+13, 4.453466360112E+13, 1.449400874645E+14\"\n"
                },
                {
                    "language": "Elixir",
                    "solution": "defmodule Proper do\n  def divisors(1), do: []\n  def divisors(n), do: [1 | divisors(2,n,:math.sqrt(n))] |> Enum.sort\n\n  defp divisors(k,_n,q) when k>q, do: []\n  defp divisors(k,n,q) when rem(n,k)>0, do: divisors(k+1,n,q)\n  defp divisors(k,n,q) when k * k == n, do: [k | divisors(k+1,n,q)]\n  defp divisors(k,n,q)                , do: [k,div(n,k) | divisors(k+1,n,q)]\nend\n\ndefmodule Aliquot do\n  def sequence(n, maxlen\\\\16, maxterm\\\\140737488355328)\n  def sequence(0, _maxlen, _maxterm), do: \"terminating\"\n  def sequence(n, maxlen, maxterm) do\n    {msg, s} = sequence(n, maxlen, maxterm, [n])\n    {msg, Enum.reverse(s)}\n  end\n\n  defp sequence(n, maxlen, maxterm, s) when length(s) < maxlen and n < maxterm do\n    m = Proper.divisors(n) |> Enum.sum\n    cond do\n      m in s ->\n        case {m, List.last(s), hd(s)} do\n          {x,x,_} ->\n            case length(s) do\n              1 -> {\"perfect\", s}\n              2 -> {\"amicable\", s}\n              _ -> {\"sociable of length #{length(s)}\", s}\n            end\n          {x,_,x} -> {\"aspiring\", [m | s]}\n          _       -> {\"cyclic back to #{m}\", [m | s]}\n        end\n      m == 0 -> {\"terminating\", [0 | s]}\n      true -> sequence(m, maxlen, maxterm, [m | s])\n    end\n  end\n  defp sequence(_, _, _, s), do: {\"non-terminating\", s}\nend\n\nEnum.each(1..10, fn n ->\n  {msg, s} = Aliquot.sequence(n)\n  :io.fwrite(\"~7w:~21s: ~p~n\", [n, msg, s])\nend)\nIO.puts \"\"\n[11, 12, 28, 496, 220, 1184, 12496, 1264460, 790, 909, 562, 1064, 1488, 15355717786080]\n|> Enum.each(fn n ->\n     {msg, s} = Aliquot.sequence(n)\n     if n<10000000, do: :io.fwrite(\"~7w:~21s: ~p~n\", [n, msg, s]),\n                  else: :io.fwrite(\"~w: ~s: ~p~n\", [n, msg, s])\n   end)\n"
                }
            ],
            [
                {
                    "language": "Java",
                    "solution": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.stream.LongStream;\n\npublic class AliquotSequenceClassifications {\n\n    private static Long properDivsSum(long n) {\n        return LongStream.rangeClosed(1, (n + 1) / 2).filter(i -> n % i == 0 && n != i).sum();\n    }\n\n    static boolean aliquot(long n, int maxLen, long maxTerm) {\n        List<Long> s = new ArrayList<>(maxLen);\n        s.add(n);\n        long newN = n;\n\n        while (s.size() <= maxLen && newN < maxTerm) {\n\n            newN = properDivsSum(s.get(s.size() - 1));\n\n            if (s.contains(newN)) {\n\n                if (s.get(0) == newN) {\n\n                    switch (s.size()) {\n                        case 1:\n                            return report(\"Perfect\", s);\n                        case 2:\n                            return report(\"Amicable\", s);\n                        default:\n                            return report(\"Sociable of length \" + s.size(), s);\n                    }\n\n                } else if (s.get(s.size() - 1) == newN) {\n                    return report(\"Aspiring\", s);\n\n                } else\n                    return report(\"Cyclic back to \" + newN, s);\n\n            } else {\n                s.add(newN);\n                if (newN == 0)\n                    return report(\"Terminating\", s);\n            }\n        }\n\n        return report(\"Non-terminating\", s);\n    }\n\n    static boolean report(String msg, List<Long> result) {\n        System.out.println(msg + \": \" + result);\n        return false;\n    }\n\n    public static void main(String[] args) {\n        long[] arr = {\n                11, 12, 28, 496, 220, 1184, 12496, 1264460,\n                790, 909, 562, 1064, 1488};\n\n        LongStream.rangeClosed(1, 10).forEach(n -> aliquot(n, 16, 1L << 47));\n        System.out.println();\n        Arrays.stream(arr).forEach(n -> aliquot(n, 16, 1L << 47));\n    }\n}\n"
                },
                {
                    "language": "PowerShell",
                    "solution": "function Get-NextAliquot ( [int]$X )\n    {\n    If ( $X -gt 1 )\n        {\n        $NextAliquot = 1\n        If ( $X -gt 2 )\n            {\n            $XSquareRoot = [math]::Sqrt( $X )\n\n            (2..$XSquareRoot).Where{ $X % $_ -eq 0 }.ForEach{ $NextAliquot += $_ + $x / $_ }\n\n            If ( $XSquareRoot % 1 -eq 0 ) { $NextAliquot -= $XSquareRoot }\n            }\n        return $NextAliquot\n        }\n    }\n\nfunction Get-AliquotSequence ( [int]$K, [int]$N )\n    {\n    $X = $K\n    $X\n    $i = 1\n    While ( $X -and $i -lt $N )\n        {\n        $i++\n        $Next = Get-NextAliquot $X\n        If ( $Next )\n            {\n            If ( $X -eq $Next )\n                {\n                ($i..$N).ForEach{ $X }\n                $i = $N\n                }\n            Else\n                {\n                $X = $Next\n                $X\n                }\n            }\n        Else\n            {\n            $i = $N\n            }\n        }\n    }\n\nfunction Classify-AlliquotSequence ( [int[]]$Sequence )\n    {\n    $K = $Sequence[0]\n    $LastN = $Sequence.Count\n    If ( $Sequence[-1] -eq 0 ) { return \"terminating\" }\n    If ( $Sequence[-1] -eq 1 ) { return \"terminating\" }\n    If ( $Sequence[1] -eq $K ) { return \"perfect\"     }\n    If ( $Sequence[2] -eq $K ) { return \"amicable\"    }\n    If ( $Sequence[3..($Sequence.Count-1)] -contains $K ) { return \"sociable\" }\n    If ( $Sequence[-1] -eq $Sequence[-2] ) { return \"aspiring\" }\n    If ( $Sequence.Count -gt ( $Sequence | Select -Unique ).Count ) { return \"cyclic\" }\n    return \"non-terminating and non-repeating through N = $($Sequence.Count)\"\n    }\n\n(1..10).ForEach{ [string]$_ + \" is \" + ( Classify-AlliquotSequence -Sequence ( Get-AliquotSequence -K $_ -N 16 ) ) }\n\n( 11, 12, 28, 496, 220, 1184, 12496, 1264460, 790, 909, 562, 1064, 1488 ).ForEach{ [string]$_ + \" is \" + ( Classify-AlliquotSequence -Sequence ( Get-AliquotSequence -K $_ -N 16 ) ) }\n"
                }
            ],
            [
                {
                    "language": "D",
                    "solution": "import std.stdio, std.range, std.algorithm, std.typecons, std.conv;\n\nauto properDivisors(in ulong n) pure nothrow @safe /*@nogc*/ {\n    return iota(1UL, (n + 1) / 2 + 1).filter!(x => n % x == 0 && n != x);\n}\n\nenum pDivsSum = (in ulong n) pure nothrow @safe /*@nogc*/ =>\n    n.properDivisors.sum;\n\nauto aliquot(in ulong n,\n             in size_t maxLen=16,\n             in ulong maxTerm=2UL^^47) pure nothrow @safe {\n    if (n == 0)\n        return tuple(\"Terminating\", [0UL]);\n    ulong[] s = [n];\n    size_t sLen = 1;\n    ulong newN = n;\n\n    while (sLen <= maxLen && newN < maxTerm) {\n        newN = s.back.pDivsSum;\n        if (s.canFind(newN)) {\n            if (s[0] == newN) {\n                if (sLen == 1) {\n                    return tuple(\"Perfect\", s);\n                } else if (sLen == 2) {\n                    return tuple(\"Amicable\", s);\n                } else\n                    return tuple(text(\"Sociable of length \", sLen), s);\n            } else if (s.back == newN) {\n                return tuple(\"Aspiring\", s);\n            } else\n                return tuple(text(\"Cyclic back to \", newN), s);\n        } else if (newN == 0) {\n            return tuple(\"Terminating\", s ~ 0);\n        } else {\n            s ~= newN;\n            sLen++;\n        }\n    }\n\n    return tuple(\"Non-terminating\", s);\n}\n\nvoid main() {\n    foreach (immutable n; 1 .. 11)\n        writefln(\"%s: %s\", n.aliquot[]);\n    writeln;\n    foreach (immutable n; [11, 12, 28, 496, 220, 1184,  12496, 1264460,\n                           790, 909, 562, 1064, 1488])\n        writefln(\"%s: %s\", n.aliquot[]);\n}\n"
                },
                {
                    "language": "11l",
                    "solution": "F pdsum(n)\n   R sum((1 .. (n + 1) I/ 2).filter(x -> @n % x == 0 & @n != x))\n\nF aliquot(n, maxlen = 16, maxterm = 2 ^ 30)\n   I n == 0\n      R (\u2018terminating\u2019, [0])\n   V s = [n]\n   V slen = 1\n   V new = n\n   L slen <= maxlen & new < maxterm\n      new = pdsum(s.last)\n      I new C s\n         I s[0] == new\n            I slen == 1\n               R (\u2018perfect\u2019, s)\n            E I slen == 2\n               R (\u2018amicable\u2019, s)\n            E\n               R (\u2018sociable of length #.\u2019.format(slen), s)\n         E I s.last == new\n            R (\u2018aspiring\u2019, s)\n         E\n            R (\u2018cyclic back to #.\u2019.format(new), s)\n      E I new == 0\n         R (\u2018terminating\u2019, s [+] [0])\n      E\n         s.append(new)\n         slen++\n   L.was_no_break\n      R (\u2018non-terminating\u2019, s)\n\nL(n) 1..10\n   V (cls, seq) = aliquot(n)\n   print(\u2018#.: #.\u2019.format(cls, seq))\nprint()\nL(n) [11, 12, 28, 496, 220, 1184, 12496, 1264460, 790, 909, 562, 1064, 1488]\n   V (cls, seq) = aliquot(n)\n   print(\u2018#.: #.\u2019.format(cls, seq))\n"
                }
            ],
            [
                {
                    "language": "V-(Vlang)",
                    "solution": "import math\nconst threshold = u64(1) << 47\n\nfn index_of(s []u64, search u64) int {\n    for i, e in s {\n        if e == search {\n            return i\n        }\n    }\n    return -1\n}\n\nfn contains(s []u64, search u64) bool {\n    return index_of(s, search) > -1\n}\n\nfn max_of(i1 int, i2 int) int {\n    if i1 > i2 {\n        return i1\n    }\n    return i2\n}\n\nfn sum_proper_divisors(n u64) u64 {\n    if n < 2 {\n        return 0\n    }\n    sqrt := u64(math.sqrt(f64(n)))\n    mut sum := u64(1)\n    for i := u64(2); i <= sqrt; i++ {\n        if n % i != 0 {\n            continue\n        }\n        sum += i + n / i\n    }\n    if sqrt * sqrt == n {\n        sum -= sqrt\n    }\n    return sum\n}\n\nfn classify_sequence(k u64) ([]u64, string) {\n    if k == 0 {\n        panic(\"Argument must be positive.\")\n    }\n    mut last := k\n    mut seq := []u64{}\n    seq << k\n    for {\n        last = sum_proper_divisors(last)\n        seq << last\n        n := seq.len\n        mut aliquot := \"\"\n        match true {\n            last == 0 {\n                aliquot = \"Terminating\"\n            }\n            n == 2 && last == k {\n                aliquot = \"Perfect\"\n            }\n            n == 3 && last == k {\n                aliquot = \"Amicable\"\n            }\n            n >= 4 && last == k {\n                aliquot = \"Sociable[${n-1}]\"\n            }\n            last == seq[n - 2] {\n                aliquot = \"Aspiring\"\n            }\n            contains(seq[1 .. max_of(1, n - 2)], last) {\n                aliquot = \"Cyclic[${n - 1 - index_of(seq, last)}]\"\n            }\n            n == 16 || last > threshold {\n                aliquot = \"Non-Terminating\"\n            }\n            else {}\n        }\n        if aliquot != \"\" {\n            return seq, aliquot\n        }\n    }\n    return seq, ''\n}\n\nfn main() {\n    println(\"Aliquot classifications - periods for Sociable/Cyclic in square brackets:\\n\")\n    for k := u64(1); k <= 10; k++ {\n        seq, aliquot := classify_sequence(k)\n        println(\"${k:2}: ${aliquot:-15} $seq\")\n    }\n    println('')\n\n    s := [\n        u64(11), 12, 28, 496, 220, 1184, 12496, 1264460, 790, 909, 562, 1064, 1488,\n    ]\n    for k in s {\n        seq, aliquot := classify_sequence(k)\n        println(\"${k:7}: ${aliquot:-15} $seq\")\n    }\n    println('')\n\n    k := u64(15355717786080)\n    seq, aliquot := classify_sequence(k)\n    println(\"$k: ${aliquot:-15} $seq\")\n}\n"
                },
                {
                    "language": "VBA",
                    "solution": "Option Explicit\n\nPrivate Type Aliquot\n   Sequence() As Double\n   Classification As String\nEnd Type\n\nSub Main()\nDim result As Aliquot, i As Long, j As Double, temp As String\n'display the classification and sequences of the numbers one to ten inclusive\n   For j = 1 To 10\n      result = Aliq(j)\n      temp = vbNullString\n      For i = 0 To UBound(result.Sequence)\n         temp = temp & result.Sequence(i) & \", \"\n      Next i\n      Debug.Print \"Aliquot seq of \" & j & \" : \" & result.Classification & \"   \" & Left(temp, Len(temp) - 2)\n   Next j\n'show the classification and sequences of the following integers, in order:\nDim a\n   '15 355 717 786 080 : impossible in VBA ==> out of memory\n   a = Array(11, 12, 28, 496, 220, 1184, 12496, 1264460, 790, 909, 562, 1064, 1488)\n   For j = LBound(a) To UBound(a)\n      result = Aliq(CDbl(a(j)))\n      temp = vbNullString\n      For i = 0 To UBound(result.Sequence)\n         temp = temp & result.Sequence(i) & \", \"\n      Next i\n      Debug.Print \"Aliquot seq of \" & a(j) & \" : \" & result.Classification & \"   \" & Left(temp, Len(temp) - 2)\n   Next\nEnd Sub\n\nPrivate Function Aliq(Nb As Double) As Aliquot\nDim s() As Double, i As Long, temp, j As Long, cpt As Long\n   temp = Array(\"non-terminating\", \"Terminate\", \"Perfect\", \"Amicable\", \"Sociable\", \"Aspiring\", \"Cyclic\")\n   ReDim s(0)\n   s(0) = Nb\n   For i = 1 To 15\n      cpt = cpt + 1\n      ReDim Preserve s(cpt)\n      s(i) = SumPDiv(s(i - 1))\n      If s(i) > 140737488355328# Then Exit For\n      If s(i) = 0 Then j = 1\n      If s(1) = s(0) Then j = 2\n      If s(i) = s(0) And i > 1 And i <> 2 Then j = 4\n      If s(i) = s(i - 1) And i > 1 Then j = 5\n      If i >= 2 Then\n         If s(2) = s(0) Then j = 3\n         If s(i) = s(i - 2) And i <> 2 Then j = 6\n      End If\n      If j > 0 Then Exit For\n   Next\n   Aliq.Classification = temp(j)\n   Aliq.Sequence = s\nEnd Function\n\nPrivate Function SumPDiv(n As Double) As Double\n'returns the sum of the Proper divisors of n\nDim j As Long, t As Long\n    If n > 1 Then\n        For j = 1 To n \\ 2\n            If n Mod j = 0 Then t = t + j\n        Next\n    End If\n    SumPDiv = t\nEnd Function\n"
                }
            ],
            [
                {
                    "language": "Picat",
                    "solution": "divisor_sum(N) = R =>\n    Total = 1,\n    Power = 2,\n    % Deal with powers of 2 first\n    while (N mod 2 == 0)\n        Total := Total + Power,\n        Power := Power*2,\n        N := N div 2\n    end,\n    % Odd prime factors up to the square root\n    P = 3,\n    while (P*P =< N)\n        Sum = 1,\n        Power1 = P,\n        while (N mod P == 0)\n            Sum := Sum + Power1,\n            Power1 := Power1*P,\n            N := N div P\n        end,\n        Total := Total * Sum,\n        P := P+2\n    end,\n    % If n > 1 then it's prime\n    if N > 1 then\n        Total := Total*(N + 1)\n    end,\n    R = Total.\n\n% See https://en.wikipedia.org/wiki/Aliquot_sequence\naliquot_sequence(N,Limit,Seq,Class) =>\n    aliquot_sequence(N,Limit,[N],Seq,Class).\n\naliquot_sequence(_,0,_,Seq,Class) => Seq = [], Class = 'non-terminating'.\naliquot_sequence(_,_,[0|_],Seq,Class) => Seq = [0], Class = terminating.\naliquot_sequence(N,_,[N,N|_],Seq,Class) => Seq = [], Class = perfect.\naliquot_sequence(N,_,[N,_,N|_],Seq,Class) => Seq = [N], Class = amicable.\naliquot_sequence(N,_,[N|S],Seq,Class), membchk(N,S) =>\n    Seq = [N], Class = sociable.\naliquot_sequence(_,_,[Term,Term|_],Seq,Class) => Seq = [], Class = aspiring.\naliquot_sequence(_,_,[Term|S],Seq,Class), membchk(Term,S) =>\n    Seq = [Term], Class = cyclic.\naliquot_sequence(N,Limit,[Term|S],Seq,Class) =>\n    Seq = [Term|Rest],\n    Sum = divisor_sum(Term),\n    Term1 is Sum - Term,\n    aliquot_sequence(N,Limit-1,[Term1,Term|S],Rest,Class).\n\nmain =>\n    foreach (N in [11,12,28,496,220,1184,12496,1264460,790,909,562,1064,1488,15355717786080,153557177860800])\n        aliquot_sequence(N,16,Seq,Class),\n        printf(\"%w: %w, sequence: %w \", N, Class, Seq[1]),\n        foreach (I in 2..len(Seq), break(Seq[I] == Seq[I-1]))\n            printf(\"%w \", Seq[I])\n        end,\n        nl\n    end.\n"
                },
                {
                    "language": "Haskell",
                    "solution": "divisors :: (Integral a) => a -> [a]\ndivisors n = filter ((0 ==) . (n `mod`)) [1 .. (n `div` 2)]\n\ndata Class\n  = Terminating\n  | Perfect\n  | Amicable\n  | Sociable\n  | Aspiring\n  | Cyclic\n  | Nonterminating\n  deriving (Show)\n\naliquot :: (Integral a) => a -> [a]\naliquot 0 = [0]\naliquot n = n : (aliquot $ sum $ divisors n)\n\nclassify :: (Num a, Eq a) => [a] -> Class\nclassify []             = Nonterminating\nclassify [0]            = Terminating\nclassify [_]            = Nonterminating\nclassify [a,b]\n  | a == b              = Perfect\n  | b == 0              = Terminating\n  | otherwise           = Nonterminating\nclassify x@(a:b:c:_)\n  | a == b              = Perfect\n  | a == c              = Amicable\n  | a `elem` (drop 1 x) = Sociable\n  | otherwise           =\n    case classify (drop 1 x) of\n      Perfect  -> Aspiring\n      Amicable -> Cyclic\n      Sociable -> Cyclic\n      d        -> d\n\nmain :: IO ()\nmain = do\n  let cls n = let ali = take 16 $ aliquot n in (classify ali, ali)\n  mapM_ (print . cls) $ [1..10] ++\n    [11, 12, 28, 496, 220, 1184, 12496, 1264460, 790, 909, 562, 1064, 1488]\n"
                }
            ]
        ]
    },
    {
        "task_name": "Almkvist-Giullera-formula-for-pi",
        "task_description": "The Almkvist-Giullera formula for calculating &nbsp; 1/\u03c0<sup>2</sup> &nbsp; is based on the Calabi-Yau\ndifferential equations of order 4 and 5, &nbsp; which were originally used to describe certain manifolds\nin string theory. \n\n\nThe formula is:\n::::: <big><big>1/\u03c0<sup>2</sup> = (2<sup>5</sup>/3)  &sum;<sub>0</sub><sup>\u221e</sup>  ((6n)! / (n!<sup>6</sup>))(532n<sup>2</sup> + 126n + 9) / 1000<sup>2n+1</sup></big></big>\n\n\nThis formula can be used to calculate the constant &nbsp; <big>\u03c0<sup>-2</sup></big>, &nbsp; and thus to calculate &nbsp; <big>\u03c0</big>.\n\nNote that, because the product of all terms but the power of 1000 can be calculated as an integer,\nthe terms in the series can be separated into a large integer term:\n\n::::: <big> (2<sup>5</sup>) (6n)! (532n<sup>2</sup> + 126n + 9) / (3(n!)<sup>6</sup>) </big> &nbsp;&nbsp;&nbsp;   (***)\n\nmultiplied by a negative integer power of 10:\n\n::::: <big> 10<sup>-(6n + 3)</sup> </big>\n\n\n;Task:\n:* Print the integer portions (the starred formula, which is without the power of 1000 divisor) of the first 10 terms of the series.\n:* Use the complete formula to calculate and print <big>\u03c0</big> to 70 decimal digits of precision.\n\n\n;Reference:\n:* &nbsp;[https://arxiv.org/pdf/1009.5202.pdf Gert Almkvist and Jes\u00fas Guillera, Ramanujan-like series for 1/\u03c0<sup>2</sup> and string theory, Experimental Mathematics, 21 (2012), page 2, formula 1].\n<br><br>\n\n",
        "solution_pairs": [
            [
                {
                    "language": "ARM-Assembly",
                    "solution": "/* ARM assembly Raspberry PI  */\n/*  program calculPi.s   */\n/* this program use gmp library package : libgmp3-dev */\n/* link with gcc option -lgmp */\n\n /* REMARK 1 : this program use routines in a include file\n   see task Include a file language arm assembly\n   for the routine affichageMess conversion10\n   see at end of this program the instruction include */\n/* for constantes see task include a file in arm assembly */\n/************************************/\n/* Constantes                       */\n/************************************/\n.include \"../constantes.inc\"\n\n.equ MAXI,      10\n.equ SIZEBIG,   100\n\n/*********************************/\n/* Initialized data              */\n/*********************************/\n.data\nszMessPi:            .asciz \"\\nPI = \\n\"\nszCarriageReturn:   .asciz \"\\n\"\n\nszFormat:           .asciz \" %Zd\\n\"\nszFormatFloat:      .asciz \" %.*Ff\\n\"\n/*********************************/\n/* UnInitialized data            */\n/*********************************/\n.bss\nResult1:                    .skip SIZEBIG\nResult2:                    .skip SIZEBIG\nResult3:                    .skip SIZEBIG\nResult4:                    .skip SIZEBIG\nfInter5:                    .skip SIZEBIG\nfInter6:                    .skip SIZEBIG\nfInter7:                    .skip SIZEBIG\nfSum:                       .skip SIZEBIG\nfSum1:                      .skip SIZEBIG\nsBuffer:                    .skip SIZEBIG\nfEpsilon:                   .skip SIZEBIG\nfPrec:                      .skip SIZEBIG\nfPI:                        .skip SIZEBIG\nfTEN:                       .skip SIZEBIG\nfONE:                       .skip SIZEBIG\n/*********************************/\n/*  code section                 */\n/*********************************/\n.text\n.global main\nmain:                             @ entry of program\n    mov r4,#0                     @ loop indice\n1:\n    mov r0,r4\n    bl computeAlmkvist            @ compute\n    mov r1,r0\n    ldr r0,iAdrszFormat           @ print big integer\n    bl __gmp_printf\n\n    add r4,r4,#1\n    cmp r4,#MAXI\n    blt 1b                        @ and loop\n\n    mov r0,#560                   @ float pr\u00e9cision in bits\n    bl __gmpf_set_default_prec\n\n    mov r4,#0                     @ compute indice\n    ldr r0,iAdrfSum               @ init to z\u00e9ro\n    bl __gmpf_init\n    ldr r0,iAdrfSum1              @ init to z\u00e9ro\n    bl __gmpf_init\n\n    ldr r0,iAdrfONE               @ result address\n    mov r1,#1                     @ init \u00e0 1\n    bl __gmpf_init_set_ui\n\n    ldr r0,iAdrfInter5            @ init to z\u00e9ro\n    bl __gmpf_init\n    ldr r0,iAdrfInter6            @ init to z\u00e9ro\n    bl __gmpf_init\n    ldr r0,iAdrfInter7            @ init to z\u00e9ro\n    bl __gmpf_init\n    ldr r0,iAdrfEpsilon           @ init to z\u00e9ro\n    bl __gmpf_init\n    ldr r0,iAdrfPrec              @ init to z\u00e9ro\n    bl __gmpf_init\n    ldr r0,iAdrfPI                @ init to z\u00e9ro\n    bl __gmpf_init\n    ldr r0,iAdrfTEN\n    mov r1,#10                    @ init to 10\n    bl __gmpf_init_set_ui\n\n    ldr r0,iAdrfInter6            @ compute 10 pow 70\n    ldr r1,iAdrfTEN\n    mov r2,#70\n    bl __gmpf_pow_ui\n\n    ldr r0,iAdrfEpsilon           @ divide 1 by 10 pow 70\n    ldr r1,iAdrfONE               @ dividende\n    ldr r2,iAdrfInter6            @ divisor\n    bl __gmpf_div\n\n2:                                @ PI compute loop\n    mov r0,r4\n    bl computeAlmkvist\n    mov r5,r0\n    mov r1,#6\n    mul r2,r1,r4\n    add r6,r2,#3                  @ compute 6n + 3\n\n    ldr r0,iAdrfInter6            @ compute 10 pow (6n+3)\n    ldr r1,iAdrfTEN\n    mov r2,r6\n    bl __gmpf_pow_ui\n\n    ldr r0,iAdrfInter7             @ compute 1 / 10 pow (6n+3)\n    ldr r1,iAdrfONE                @ dividende\n    ldr r2,iAdrfInter6             @ divisor\n    bl __gmpf_div\n\n    ldr r0,iAdrfInter6             @ result big float\n    mov r1,r5                      @ big integer Almkvist\n    bl __gmpf_set_z                @ conversion in big float\n\n    ldr r0,iAdrfInter5             @ result Almkvist * 1 / 10 pow (6n+3)\n    ldr r1,iAdrfInter7             @ operator 1\n    ldr r2,iAdrfInter6             @ operator 2\n    bl __gmpf_mul\n\n    ldr r0,iAdrfSum1               @ terms addition\n    ldr r1,iAdrfSum\n    ldr r2,iAdrfInter5\n    bl __gmpf_add\n\n    ldr r0,iAdrfSum                @ copy terms\n    ldr r1,iAdrfSum1\n    bl __gmpf_set\n\n\n    ldr r0,iAdrfInter7             @ compute 1 / sum\n    ldr r1,iAdrfONE                @ dividende\n    ldr r2,iAdrfSum                @ divisor\n    bl __gmpf_div\n\n    ldr r0,iAdrfPI                 @ compute square root (1 / sum )\n    ldr r1,iAdrfInter7\n    bl __gmpf_sqrt\n\n    ldr r0,iAdrfInter6             @ compute variation PI\n    ldr r1,iAdrfPrec\n    ldr r2,iAdrfPI\n    bl __gmpf_sub\n\n    ldr r0,iAdrfInter6             @ absolue value\n    ldr r1,iAdrfInter5\n    bl __gmpf_abs\n\n    add r4,r4,#1                   @ increment indice\n\n    ldr r0,iAdrfPrec               @ copy PI -> pr\u00e9vious\n    ldr r1,iAdrfPI\n    bl __gmpf_set\n\n    ldr r0,iAdrfInter6             @ compare gap and epsilon\n    ldr r1,iAdrfEpsilon\n    bl __gmpf_cmp\n    cmp r0,#0\n    bgt 2b                         @ if gap is highter -> loop\n\n    ldr r0,iAdrszMessPi            @ title display\n    bl affichageMess\n\n    ldr r2,iAdrfPI                 @ PI display\n    ldr r0,iAdrszFormatFloat\n    mov r1,#70\n    bl __gmp_printf\n\n\n100:                              @ standard end of the program\n    mov r0, #0                    @ return code\n    mov r7, #EXIT                 @ request to exit program\n    svc #0                        @ perform the system call\niAdrszCarriageReturn:        .int szCarriageReturn\niAdrfInter5:                 .int fInter5\niAdrfInter6:                 .int fInter6\niAdrfInter7:                 .int fInter7\niAdrfSum:                    .int fSum\niAdrfSum1:                   .int fSum1\niAdrszFormatFloat:           .int szFormatFloat\niAdrszMessPi:                .int szMessPi\niAdrfEpsilon:                .int fEpsilon\niAdrfPrec:                   .int fPrec\niAdrfPI:                     .int fPI\niAdrfTEN:                    .int fTEN\niAdrfONE:                    .int fONE\n/***************************************************/\n/*   compute  almkvist_giullera formula             */\n/***************************************************/\n/* r0 contains the number            */\ncomputeAlmkvist:\n    push {r1-r4,lr}               @ save registers\n    mov r4,r0\n    mov r1,#6\n    mul r0,r1,r0\n    ldr r1,iAdrResult1            @ result address\n    bl computeFactorielle         @ compute (n*6)!\n\n    mov r1,#532\n    mul r2,r4,r4\n    mul r2,r1,r2\n    mov r1,#126\n    mul r3,r4,r1\n    add r2,r2,r3\n    add r2,#9\n    lsl r2,r2,#5                   @ * 32\n\n    ldr r0,iAdrResult2             @ result\n    ldr r1,iAdrResult1             @ operator\n    bl __gmpz_mul_ui\n\n    mov r0,r4\n    ldr r1,iAdrResult1\n    bl computeFactorielle\n\n    ldr r0,iAdrResult3\n    bl __gmpz_init                 @ init to 0\n\n    ldr r0,iAdrResult3             @ result\n    ldr r1,iAdrResult1             @ operator\n    mov r2,#6\n    bl __gmpz_pow_ui\n\n    ldr r0,iAdrResult1             @ result\n    ldr r1,iAdrResult3             @ operator\n    mov r2,#3\n    bl __gmpz_mul_ui\n\n    ldr r0,iAdrResult3             @ result\n    ldr r1,iAdrResult2             @ operator\n    ldr r2,iAdrResult1             @ operator\n    bl __gmpz_cdiv_q\n\n    ldr r0,iAdrResult3             @ return result address\n\n    pop {r1-r4,pc}                 @ restaur des registres\niAdrszFormat:         .int szFormat\niAdrResult1:          .int Result1\niAdrResult2:          .int Result2\niAdrResult3:          .int Result3\n/***************************************************/\n/*   compute  factorielle N                        */\n/***************************************************/\n/* r0 contains the number            */\n/* r1 contains big number result address */\ncomputeFactorielle:\n    push {r1-r6,lr}               @ save registers\n    mov r5,r0                     @ save N\n    mov r6,r1                     @ save result address\n    mov r0,r1                     @ result address\n    mov r1,#1                     @ init to 1\n    bl __gmpz_init_set_ui\n    ldr r0,iAdrResult4\n    bl __gmpz_init                @ init to 0\n    mov r4,#1\n1:                                @ loop\n    ldr r0,iAdrResult4            @ result\n    mov r1,r6                     @ operator 1\n    mov r2,r4                     @ operator 2\n    bl __gmpz_mul_ui\n    mov r0,r6                     @ copy result4 -> result\n    ldr r1,iAdrResult4\n    bl __gmpz_set\n    add r4,r4,#1                  @ increment indice\n    cmp r4,r5                     @ N ?\n    ble 1b                        @ no -> loop\n\n    mov r0,r1\n\n    pop {r1-r6,pc}                @ restaur des registres\niAdrResult4:          .int Result4\n\n/***************************************************/\n/*      ROUTINES INCLUDE                           */\n/***************************************************/\n.include \"../affichage.inc\"\n"
                },
                {
                    "language": "Factor",
                    "solution": "USING: continuations formatting io kernel locals math\nmath.factorials math.functions sequences ;\n\n:: integer-term ( n -- m )\n    32 6 n * factorial * 532 n sq * 126 n * + 9 + *\n    n factorial 6 ^ 3 * / ;\n\n: exponent-term ( n -- m ) 6 * 3 + neg ;\n\n: nth-term ( n -- x )\n    [ integer-term ] [ exponent-term 10^ * ] bi ;\n\n! Factor doesn't have an arbitrary-precision square root afaik,\n! so make one using Heron's method.\n\n: sqrt-approx ( r x -- r' x ) [ over / + 2 / ] keep ;\n\n:: almkvist-guillera ( precision -- x )\n    0 0 :> ( summed! next-add! )\n    [\n        100,000,000 <iota> [| n |\n            summed n nth-term + next-add!\n            next-add summed - abs precision neg 10^ <\n            [ return ] when\n            next-add summed!\n        ] each\n    ] with-return\n    next-add ;\n\nCONSTANT: 1/pi 113/355  ! Use as initial guess for square root approximation\n\n: pi ( -- )\n    1/pi 70 almkvist-guillera 5 [ sqrt-approx ] times\n    drop recip \"%.70f\\n\" printf ;\n\n! Task\n\"N                               Integer Portion  Pow  Nth Term (33 dp)\" print\n89 CHAR: - <repetition> print\n10 [\n    dup [ integer-term ] [ exponent-term ] [ nth-term ] tri\n    \"%d  %44d  %3d  %.33f\\n\" printf\n] each-integer nl\n\"Pi to 70 decimal places:\" print pi\n"
                }
            ],
            [
                {
                    "language": "Go",
                    "solution": "package main\n\nimport (\n    \"fmt\"\n    \"math/big\"\n    \"strings\"\n)\n\nfunc factorial(n int64) *big.Int {\n    var z big.Int\n    return z.MulRange(1, n)\n}\n\nvar one = big.NewInt(1)\nvar three = big.NewInt(3)\nvar six = big.NewInt(6)\nvar ten = big.NewInt(10)\nvar seventy = big.NewInt(70)\n\nfunc almkvistGiullera(n int64, print bool) *big.Rat {\n    t1 := big.NewInt(32)\n    t1.Mul(factorial(6*n), t1)\n    t2 := big.NewInt(532*n*n + 126*n + 9)\n    t3 := new(big.Int)\n    t3.Exp(factorial(n), six, nil)\n    t3.Mul(t3, three)\n    ip := new(big.Int)\n    ip.Mul(t1, t2)\n    ip.Quo(ip, t3)\n    pw := 6*n + 3\n    t1.SetInt64(pw)\n    tm := new(big.Rat).SetFrac(ip, t1.Exp(ten, t1, nil))\n    if print {\n        fmt.Printf(\"%d  %44d  %3d  %-35s\\n\", n, ip, -pw, tm.FloatString(33))\n    }\n    return tm\n}\n\nfunc main() {\n    fmt.Println(\"N                               Integer Portion  Pow  Nth Term (33 dp)\")\n    fmt.Println(strings.Repeat(\"-\", 89))\n    for n := int64(0); n < 10; n++ {\n        almkvistGiullera(n, true)\n    }\n\n    sum := new(big.Rat)\n    prev := new(big.Rat)\n    pow70 := new(big.Int).Exp(ten, seventy, nil)\n    prec := new(big.Rat).SetFrac(one, pow70)\n    n := int64(0)\n    for {\n        term := almkvistGiullera(n, false)\n        sum.Add(sum, term)\n        z := new(big.Rat).Sub(sum, prev)\n        z.Abs(z)\n        if z.Cmp(prec) < 0 {\n            break\n        }\n        prev.Set(sum)\n        n++\n    }\n    sum.Inv(sum)\n    pi := new(big.Float).SetPrec(256).SetRat(sum)\n    pi.Sqrt(pi)\n    fmt.Println(\"\\nPi to 70 decimal places is:\")\n    fmt.Println(pi.Text('f', 70))\n}\n"
                },
                {
                    "language": "Dc",
                    "solution": "[* factorial *]sz\n[ 1 Sp [ d lp * sp 1 - d 1 <f ]Sf d 1 <f Lfsz sz Lp ]sF\n\n[* nth integral term *]sz\n[ sn 32 6 ln * lFx 532 ln * ln * 126 ln * + 9 + * * 3 ln lFx 6 ^ * / ]sI\n\n[* nth exponent of 10 *]sz\n[ 1 + 6 * 3 r - ]sE\n\n[* nth term in series *]sz\n[ d lIx r 10 r lEx _1 * ^ / ]sA\n\n[* sum of the first n terms *]sz\n[ [li lAx ls + ss li 1 - d si 0 r !<L]sL si 0ss lLx ls]sS\n\n[* approximation of pi after n terms *]sz\n[ lSx 1 r / v ]sP\n\n[* count digits in a number *]sz\n[sn 0 sd lCx ld]sD\n[ld 1 + sd ln 10 0k / d sn 0 !=C]sC\n\n[* print a number in a given column width *]sz\n[sw d lDx si lw li <T n]sW\n[[ ]n li 1 + si lw li <T]sT\n\n[* main loop: print values for first 10 terms *]sz\n[N. Integral part of Nth term .................. \u00c3\u2014 10^ =Actual value of Nth term]p\n0 sj\n[\n  lj n [. ]n\n  lj lIx 0k 1 / 44 lWx [ ]n\n  lj lEx 4 lWx [ ]n\n  lj 99k lAx 50k 1 / p\n  lj 1 + d sj 10 >M\n] sM\nlMx\n\n[]p\n\n[* print resulting value of pi to 70 places *]sz\n[Pi after ]n 52n [ iterations:]p\n99k 52 lPx 70k 1 / p\n"
                }
            ],
            [
                {
                    "language": "Kotlin",
                    "solution": "import java.math.BigDecimal\nimport java.math.BigInteger\nimport java.math.MathContext\nimport java.math.RoundingMode\n\nobject CodeKt{\n\n    @JvmStatic\n    fun main(args: Array<String>) {\n        println(\"n                                   Integer part\")\n        println(\"================================================\")\n        for (n in 0..9) {\n            println(String.format(\"%d%47s\", n, almkvistGiullera(n).toString()))\n        }\n\n        val decimalPlaces = 70\n        val mathContext = MathContext(decimalPlaces + 1, RoundingMode.HALF_EVEN)\n        val epsilon = BigDecimal.ONE.divide(BigDecimal.TEN.pow(decimalPlaces))\n        var previous = BigDecimal.ONE\n        var sum = BigDecimal.ZERO\n        var pi = BigDecimal.ZERO\n        var n = 0\n\n        while (pi.subtract(previous).abs().compareTo(epsilon) >= 0) {\n            val nextTerm = BigDecimal(almkvistGiullera(n)).divide(BigDecimal.TEN.pow(6 * n + 3), mathContext)\n            sum = sum.add(nextTerm)\n            previous = pi\n            n += 1\n            pi = BigDecimal.ONE.divide(sum, mathContext).sqrt(mathContext)\n        }\n\n        println(\"\\npi to $decimalPlaces decimal places:\")\n        println(pi)\n    }\n\n    private fun almkvistGiullera(aN: Int): BigInteger {\n        val term1 = factorial(6 * aN) * BigInteger.valueOf(32)\n        val term2 = BigInteger.valueOf(532L * aN * aN + 126 * aN + 9)\n        val term3 = factorial(aN).pow(6) * BigInteger.valueOf(3)\n        return term1 * term2 / term3\n    }\n\n    private fun factorial(aNumber: Int): BigInteger {\n        var result = BigInteger.ONE\n        for (i in 2..aNumber) {\n            result *= BigInteger.valueOf(i.toLong())\n        }\n        return result\n    }\n\n    private fun BigDecimal.sqrt(context: MathContext): BigDecimal {\n        var x = BigDecimal(Math.sqrt(this.toDouble()), context)\n        if (this == BigDecimal.ZERO) return BigDecimal.ZERO\n        val two = BigDecimal.valueOf(2)\n        while (true) {\n            val y = this.divide(x, context)\n            x = x.add(y).divide(two, context)\n            val nextY = this.divide(x, context)\n            if (y == nextY || y == nextY.add(BigDecimal.ONE.divide(BigDecimal.TEN.pow(context.precision), context))) {\n                break\n            }\n        }\n        return x\n    }\n}\n"
                },
                {
                    "language": "AArch64-Assembly",
                    "solution": "/* ARM assembly AARCH64 Raspberry PI 3B */\n/*  program calculPi64.s   */\n/* this program use gmp library */\n/* link with gcc option -lgmp */\n\n/*******************************************/\n/* Constantes file                         */\n/*******************************************/\n/* for this file see task include a file in language AArch64 assembly*/\n.include \"../includeConstantesARM64.inc\"\n\n.equ MAXI,      10\n.equ SIZEBIG,   100\n\n/*********************************/\n/* Initialized data              */\n/*********************************/\n.data\nszMessDebutPgm:     .asciz \"Program 64 bits start. \\n\"\nszMessPi:           .asciz \"\\nPI = \\n\"\nszCarriageReturn:   .asciz \"\\n\"\n\nszFormat:           .asciz \" %Zd\\n\"\nszFormatFloat:      .asciz \" %.*Ff\\n\"\n/*********************************/\n/* UnInitialized data            */\n/*********************************/\n.bss\nResult1:                    .skip SIZEBIG\nResult2:                    .skip SIZEBIG\nResult3:                    .skip SIZEBIG\nResult4:                    .skip SIZEBIG\nfIntex5:                    .skip SIZEBIG\nfIntex6:                    .skip SIZEBIG\nfIntex7:                    .skip SIZEBIG\nfSum:                       .skip SIZEBIG\nfSum1:                      .skip SIZEBIG\nsBuffer:                    .skip SIZEBIG\nfEpsilon:                   .skip SIZEBIG\nfPrec:                      .skip SIZEBIG\nfPI:                        .skip SIZEBIG\nfTEN:                       .skip SIZEBIG\nfONE:                       .skip SIZEBIG\n/*********************************/\n/*  code section                 */\n/*********************************/\n.text\n.global main\nmain:                             // entry of program\n    ldr x0,qAdrszMessDebutPgm\n    bl affichageMess\n    mov x20,#0                     // loop indice\n1:\n    mov x0,x20\n    bl computeAlmkvist            // compute\n    mov x1,x0\n    ldr x0,qAdrszFormat           // print big integer\n    bl __gmp_printf\n\n    add x20,x20,#1\n    cmp x20,#MAXI\n    blt 1b                        // and loop\n\n    mov x0,#560                   // float pr\u00e9cision in bits\n    bl __gmpf_set_default_prec\n\n    mov x19,#0                     // compute indice\n    ldr x0,qAdrfSum               // init to z\u00e9ro\n    bl __gmpf_init\n    ldr x0,qAdrfSum1              // init to z\u00e9ro\n    bl __gmpf_init\n\n    ldr x0,qAdrfONE               // result address\n    mov x1,#1                     // init \u00e0 1\n    bl __gmpf_init_set_ui\n\n    ldr x0,qAdrfIntex5            // init to z\u00e9ro\n    bl __gmpf_init\n    ldr x0,qAdrfIntex6            // init to z\u00e9ro\n    bl __gmpf_init\n    ldr x0,qAdrfIntex7            // init to z\u00e9ro\n    bl __gmpf_init\n    ldr x0,qAdrfEpsilon           // init to z\u00e9ro\n    bl __gmpf_init\n    ldr x0,qAdrfPrec              // init to z\u00e9ro\n    bl __gmpf_init\n    ldr x0,qAdrfPI                // init to z\u00e9ro\n    bl __gmpf_init\n    ldr x0,qAdrfTEN\n    mov x1,#10                    // init to 10\n    bl __gmpf_init_set_ui\n\n    ldr x0,qAdrfIntex6            // compute 10 pow 70\n    ldr x1,qAdrfTEN\n    mov x2,#70\n    bl __gmpf_pow_ui\n\n    ldr x0,qAdrfEpsilon           // divide 1 by 10 pow 70\n    ldr x1,qAdrfONE               // dividende\n    ldr x2,qAdrfIntex6            // divisor\n    bl __gmpf_div\n\n2:                                // PI compute loop\n    mov x0,x19\n    bl computeAlmkvist\n    mov x20,x0\n    mov x1,#6\n    mul x2,x1,x19\n    add x6,x2,#3                  // compute 6n + 3\n\n    ldr x0,qAdrfIntex6            // compute 10 pow (6n+3)\n    ldr x1,qAdrfTEN\n    mov x2,x6\n    bl __gmpf_pow_ui\n\n    ldr x0,qAdrfIntex7             // compute 1 / 10 pow (6n+3)\n    ldr x1,qAdrfONE                // dividende\n    ldr x2,qAdrfIntex6             // divisor\n    bl __gmpf_div\n\n    ldr x0,qAdrfIntex6             // result big float\n    mov x1,x20                     // big integer Almkvist\n    bl __gmpf_set_z                // conversion in big float\n\n    ldr x0,qAdrfIntex5             // result Almkvist * 1 / 10 pow (6n+3)\n    ldr x1,qAdrfIntex7             // operator 1\n    ldr x2,qAdrfIntex6             // operator 2\n    bl __gmpf_mul\n\n    ldr x0,qAdrfSum1               // terms addition\n    ldr x1,qAdrfSum\n    ldr x2,qAdrfIntex5\n    bl __gmpf_add\n\n    ldr x0,qAdrfSum                // copy terms\n    ldr x1,qAdrfSum1\n    bl __gmpf_set\n\n\n    ldr x0,qAdrfIntex7             // compute 1 / sum\n    ldr x1,qAdrfONE                // dividende\n    ldr x2,qAdrfSum                // divisor\n    bl __gmpf_div\n\n    ldr x0,qAdrfPI                 // compute square root (1 / sum )\n    ldr x1,qAdrfIntex7\n    bl __gmpf_sqrt\n\n    ldr x0,qAdrfIntex6             // compute variation PI\n    ldr x1,qAdrfPrec\n    ldr x2,qAdrfPI\n    bl __gmpf_sub\n\n    ldr x0,qAdrfIntex6             // absolue value\n    ldr x1,qAdrfIntex5\n    bl __gmpf_abs\n\n    add x19,x19,#1                   // increment indice\n\n    ldr x0,qAdrfPrec               // copy PI -> pr\u00e9vious\n    ldr x1,qAdrfPI\n    bl __gmpf_set\n\n    ldr x0,qAdrfIntex6             // compare gap and epsilon\n    ldr x1,qAdrfEpsilon\n    bl __gmpf_cmp\n    cmp w0,#0                      // !!! cmp return result on 32 bits\n    bgt 2b                         // if gap is highter -> loop\n\n    ldr x0,qAdrszMessPi            // title display\n    bl affichageMess\n\n    ldr x2,qAdrfPI                 // PI display\n    ldr x0,qAdrszFormatFloat\n    mov x1,#70\n    bl __gmp_printf\n\n\n100:                              // standard end of the program\n    mov x0, #0                    // return code\n    mov x8, #EXIT                 // request to exit program\n    svc #0                        // perform the system call\nqAdrszMessDebutPgm:          .quad szMessDebutPgm\nqAdrszCarriageReturn:        .quad szCarriageReturn\nqAdrfIntex5:                 .quad fIntex5\nqAdrfIntex6:                 .quad fIntex6\nqAdrfIntex7:                 .quad fIntex7\nqAdrfSum:                    .quad fSum\nqAdrfSum1:                   .quad fSum1\nqAdrszFormatFloat:           .quad szFormatFloat\nqAdrszMessPi:                .quad szMessPi\nqAdrfEpsilon:                .quad fEpsilon\nqAdrfPrec:                   .quad fPrec\nqAdrfPI:                     .quad fPI\nqAdrfTEN:                    .quad fTEN\nqAdrfONE:                    .quad fONE\n/***************************************************/\n/*   compute  almkvist_giullera formula             */\n/***************************************************/\n/* x0 contains the number            */\ncomputeAlmkvist:\n    stp x19,lr,[sp,-16]!           // save  registers\n    mov x19,x0\n    mov x1,#6\n    mul x0,x1,x0\n    ldr x1,qAdrResult1            // result address\n    bl computeFactorielle         // compute (n*6)!\n    mov x1,#532\n    mul x2,x19,x19\n    mul x2,x1,x2\n    mov x1,#126\n    mul x3,x19,x1\n    add x2,x2,x3\n    add x2,x2,#9\n    lsl x2,x2,#5                   // * 32\n\n    ldr x0,qAdrResult2             // result\n    ldr x1,qAdrResult1             // operator\n    bl __gmpz_mul_ui\n\n    mov x0,x19\n    ldr x1,qAdrResult1\n    bl computeFactorielle\n\n    ldr x0,qAdrResult3\n    bl __gmpz_init                 // init to 0\n\n    ldr x0,qAdrResult3             // result\n    ldr x1,qAdrResult1             // operator\n    mov x2,#6\n    bl __gmpz_pow_ui\n\n    ldr x0,qAdrResult1             // result\n    ldr x1,qAdrResult3             // operator\n    mov x2,#3\n    bl __gmpz_mul_ui\n\n    ldr x0,qAdrResult3             // result\n    ldr x1,qAdrResult2             // operator\n    ldr x2,qAdrResult1             // operator\n    bl __gmpz_cdiv_q\n\n    ldr x0,qAdrResult3             // return result address\n100:\n    ldp x19,lr,[sp],16              // restaur  2 registers\n    ret                            // return to address lr x30\nqAdrszFormat:         .quad szFormat\nqAdrResult1:          .quad Result1\nqAdrResult2:          .quad Result2\nqAdrResult3:          .quad Result3\n/***************************************************/\n/*   compute  factorielle N                        */\n/***************************************************/\n/* x0 contains the number            */\n/* x1 contains big number result address */\ncomputeFactorielle:\n    stp x19,lr,[sp,-16]!           // save  registers\n    stp x20,x21,[sp,-16]!           // save  registers\n    mov x19,x0                     // save N\n    mov x20,x1                     // save result address\n    mov x0,x1                     // result address\n    mov x1,#1                     // init to 1\n    bl __gmpz_init_set_ui\n    ldr x0,qAdrResult4\n    bl __gmpz_init                // init to 0\n    mov x21,#1\n1:                                // loop\n    ldr x0,qAdrResult4            // result\n    mov x1,x20                     // operator 1\n    mov x2,x21                     // operator 2\n    bl __gmpz_mul_ui\n    mov x0,x20                     // copy result4 -> result\n    ldr x1,qAdrResult4\n    bl __gmpz_set\n    add x21,x21,#1                  // increment indice\n    cmp x21,x19                     // N ?\n    ble 1b                        // no -> loop\n\n    ldr  x0,qAdrResult4\n    ldp x20,x21,[sp],16              // restaur  2 registers\n    ldp x19,lr,[sp],16              // restaur  2 registers\n    ret                            // return to address lr x30\nqAdrResult4:          .quad Result4\n/********************************************************/\n/*        File Include fonctions                        */\n/********************************************************/\n/* for this file see task include a file in language AArch64 assembly */\n.include \"../includeARM64.inc\"\n"
                }
            ],
            [
                {
                    "language": "REXX",
                    "solution": "/*REXX program uses the Almkvist\u2500Giullera formula for   1 / (pi**2)     [or  pi ** -2]. */\nnumeric digits length( pi() )  +  length(.);                                       w= 102\nsay $(   , 3)       $(              , w%2)       $('power', 5)       $(          , w)\nsay $('N', 3)       $('integer term', w%2)       $('of 10', 5)       $('Nth term', w)\nsay $(   , 3, \"\u2500\")  $(              , w%2, \"\u2500\")  $(       , 5, \"\u2500\")  $(          , w, \"\u2500\")\n                                  s= 0           /*initialize   S   (the sum)  to zero. */\n     do n=0  until old=s;    old= s              /*use the \"older\" value of  S  for OLD.*/\n     a= 2**5  *  !(6*n)  *  (532 * n**2  +  126*n  +  9)  /  (3 * !(n)**6)\n     z= 10 ** (- (6*n + 3) )\n     s= s     +   a * z\n     if n>10  then do;  do 3*(n==11);  say ' .';  end;  iterate;  end\n     say $(n, 3) right(a, w%2)  $(powX(z), 5)  right( lowE( format(a*z, 1, w-6, 2, 0)), w)\n     end   /*n*/\nsay\nsay 'The calculation of pi took '       n       \" iterations with \"         digits() ,\n    \" decimal digits precision using\"   subword( sourceLine(1), 4, 3).\nsay\nnumeric digits length( pi() ) - length(.);  d= digits() - length(.);          @= ' \u2193\u2193\u2193 '\nsay center(@ 'calculated pi to '  d   \" fractional decimal digits (below) is \"@, d+4, '\u2500')\nsay ' 'sqrt(1/s);          say\nsay ' 'pi();  @= ' \u2191\u2191\u2191 '\nsay center(@ 'the  true  pi to '  d   \" fractional decimal digits (above) is\" @, d+4, '\u2500')\nexit 0                                           /*stick a fork in it,  we're all done. */\n/*\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500*/\n$:    procedure; parse arg text,width,fill;     return center(text, width, left(fill, 1) )\n!:    procedure; parse arg x; !=1;;      do j=2  to x;    != !*j;    end;         return !\nlowE: procedure; parse arg x; return translate(x, 'e', \"E\")\npowX: procedure; parse arg p; return right( format( p, 1, 3, 2, 0),  3)   +   0\n/*\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500*/\npi:   pi=3.141592653589793238462643383279502884197169399375105820974944592307816406286208,\n      ||9986280348253421170679821480865132823066470938446095505822317253594081284811174503\n      return pi\n/*\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500*/\nsqrt: procedure; parse arg x;  if x=0  then return 0;  d=digits();  numeric digits;  h=d+6\n      m.=9; numeric form; parse value format(x,2,1,,0) 'E0' with g 'E' _ .; g=g*.5'e'_ % 2\n        do j=0  while h>9;        m.j= h;                 h= h % 2  +  1;       end  /*j*/\n        do k=j+5  to 0  by -1;    numeric digits m.k;     g= (g + x/g) * .5;    end  /*k*/\n      numeric digits d;           return g/1\n"
                },
                {
                    "language": "Phix",
                    "solution": "(phixonline)-->\n <span style=\"color: #008080;\">with</span> <span style=\"color: #008080;\">javascript_semantics</span>\n <span style=\"color: #7060A8;\">requires</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #008000;\">\"1.0.0\"</span><span style=\"color: #0000FF;\">)</span>\n <span style=\"color: #008080;\">include</span> <span style=\"color: #004080;\">mpfr</span><span style=\"color: #0000FF;\">.</span><span style=\"color: #000000;\">e</span>\n <span style=\"color: #7060A8;\">mpfr_set_default_precision</span><span style=\"color: #0000FF;\">(-</span><span style=\"color: #000000;\">70</span><span style=\"color: #0000FF;\">)</span>\n\n <span style=\"color: #008080;\">function</span> <span style=\"color: #000000;\">almkvistGiullera</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #004080;\">integer</span> <span style=\"color: #000000;\">n</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #004080;\">bool</span> <span style=\"color: #000000;\">bPrint</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #004080;\">mpz</span> <span style=\"color: #0000FF;\">{</span><span style=\"color: #000000;\">t1</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">t2</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">ip</span><span style=\"color: #0000FF;\">}</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">mpz_inits</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">3</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #7060A8;\">mpz_fac_ui</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">t1</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">6</span><span style=\"color: #0000FF;\">*</span><span style=\"color: #000000;\">n</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #7060A8;\">mpz_mul_si</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">t1</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">t1</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">32</span><span style=\"color: #0000FF;\">)</span>                <span style=\"color: #000080;font-style:italic;\">-- t1:=2^5*(6n)!</span>\n     <span style=\"color: #7060A8;\">mpz_fac_ui</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">t2</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">n</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #7060A8;\">mpz_pow_ui</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">t2</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">t2</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">6</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #7060A8;\">mpz_mul_si</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">t2</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">t2</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">3</span><span style=\"color: #0000FF;\">)</span>                 <span style=\"color: #000080;font-style:italic;\">-- t2:=3*(n!)^6</span>\n     <span style=\"color: #7060A8;\">mpz_mul_si</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">ip</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">t1</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">532</span><span style=\"color: #0000FF;\">*</span><span style=\"color: #000000;\">n</span><span style=\"color: #0000FF;\">*</span><span style=\"color: #000000;\">n</span><span style=\"color: #0000FF;\">+</span><span style=\"color: #000000;\">126</span><span style=\"color: #0000FF;\">*</span><span style=\"color: #000000;\">n</span><span style=\"color: #0000FF;\">+</span><span style=\"color: #000000;\">9</span><span style=\"color: #0000FF;\">)</span>   <span style=\"color: #000080;font-style:italic;\">-- ip:=t1*(532n^2+126n+9)</span>\n     <span style=\"color: #7060A8;\">mpz_fdiv_q</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">ip</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">ip</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">t2</span><span style=\"color: #0000FF;\">)</span>                <span style=\"color: #000080;font-style:italic;\">-- ip:=ip/t2</span>\n     <span style=\"color: #004080;\">integer</span> <span style=\"color: #000000;\">pw</span> <span style=\"color: #0000FF;\">:=</span> <span style=\"color: #000000;\">6</span><span style=\"color: #0000FF;\">*</span><span style=\"color: #000000;\">n</span><span style=\"color: #0000FF;\">+</span><span style=\"color: #000000;\">3</span>\n     <span style=\"color: #7060A8;\">mpz_ui_pow_ui</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">t1</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">10</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">pw</span><span style=\"color: #0000FF;\">)</span>             <span style=\"color: #000080;font-style:italic;\">-- t1 := 10^(6n+3)</span>\n     <span style=\"color: #004080;\">mpq</span> <span style=\"color: #000000;\">tm</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">mpq_init_set_z</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">ip</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">t1</span><span style=\"color: #0000FF;\">)</span>      <span style=\"color: #000080;font-style:italic;\">-- tm := rat(ip/t1)</span>\n     <span style=\"color: #008080;\">if</span> <span style=\"color: #000000;\">bPrint</span> <span style=\"color: #008080;\">then</span>\n         <span style=\"color: #004080;\">string</span> <span style=\"color: #000000;\">ips</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">mpz_get_str</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">ip</span><span style=\"color: #0000FF;\">),</span>\n                <span style=\"color: #000000;\">tms</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">mpfr_get_fixed</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #7060A8;\">mpfr_init_set_q</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">tm</span><span style=\"color: #0000FF;\">),</span><span style=\"color: #000000;\">50</span><span style=\"color: #0000FF;\">)</span>\n         <span style=\"color: #000000;\">tms</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">trim_tail</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">tms</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #008000;\">\"0\"</span><span style=\"color: #0000FF;\">)</span>\n         <span style=\"color: #7060A8;\">printf</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #008000;\">\"%d  %44s  %3d  %s\\n\"</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #0000FF;\">{</span><span style=\"color: #000000;\">n</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #000000;\">ips</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #0000FF;\">-</span><span style=\"color: #000000;\">pw</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #000000;\">tms</span><span style=\"color: #0000FF;\">})</span>\n     <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">if</span>\n     <span style=\"color: #008080;\">return</span> <span style=\"color: #000000;\">tm</span>\n <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">function</span>\n\n <span style=\"color: #008080;\">constant</span> <span style=\"color: #000000;\">hdr</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #008000;\">\"N --------------- Integer portion -------------  Pow  ----------------- Nth term (50 dp) -----------------\"</span>\n <span style=\"color: #7060A8;\">printf</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #008000;\">\"%s\\n%s\\n\"</span><span style=\"color: #0000FF;\">,{</span><span style=\"color: #000000;\">hdr</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #7060A8;\">repeat</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #008000;\">'-'</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #7060A8;\">length</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">hdr</span><span style=\"color: #0000FF;\">))})</span>\n <span style=\"color: #008080;\">for</span> <span style=\"color: #000000;\">n</span><span style=\"color: #0000FF;\">=</span><span style=\"color: #000000;\">0</span> <span style=\"color: #008080;\">to</span> <span style=\"color: #000000;\">9</span> <span style=\"color: #008080;\">do</span>\n     <span style=\"color: #0000FF;\">{}</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #000000;\">almkvistGiullera</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">n</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #004600;\">true</span><span style=\"color: #0000FF;\">)</span>\n <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">for</span>\n\n <span style=\"color: #004080;\">mpq</span> <span style=\"color: #0000FF;\">{</span><span style=\"color: #000000;\">res</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">prev</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">z</span><span style=\"color: #0000FF;\">}</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">mpq_inits</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">3</span><span style=\"color: #0000FF;\">),</span>\n     <span style=\"color: #000000;\">prec</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">mpq_init_set_str</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #7060A8;\">sprintf</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #008000;\">\"1/1%s\"</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #7060A8;\">repeat</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #008000;\">'0'</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">70</span><span style=\"color: #0000FF;\">)))</span>\n <span style=\"color: #004080;\">integer</span> <span style=\"color: #000000;\">n</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #000000;\">0</span>\n <span style=\"color: #008080;\">while</span> <span style=\"color: #004600;\">true</span> <span style=\"color: #008080;\">do</span>\n     <span style=\"color: #004080;\">mpq</span> <span style=\"color: #000000;\">term</span> <span style=\"color: #0000FF;\">:=</span> <span style=\"color: #000000;\">almkvistGiullera</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">n</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #004600;\">false</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #7060A8;\">mpq_add</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">res</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">res</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">term</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #7060A8;\">mpq_sub</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">z</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">res</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">prev</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #7060A8;\">mpq_abs</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">z</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">z</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #008080;\">if</span> <span style=\"color: #7060A8;\">mpq_cmp</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">z</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">prec</span><span style=\"color: #0000FF;\">)</span> <span style=\"color: #0000FF;\"><</span> <span style=\"color: #000000;\">0</span> <span style=\"color: #008080;\">then</span> <span style=\"color: #008080;\">exit</span> <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">if</span>\n     <span style=\"color: #7060A8;\">mpq_set</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">prev</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">res</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #000000;\">n</span> <span style=\"color: #0000FF;\">+=</span> <span style=\"color: #000000;\">1</span>\n <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">while</span>\n <span style=\"color: #7060A8;\">mpq_inv</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">res</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">res</span><span style=\"color: #0000FF;\">)</span>\n <span style=\"color: #004080;\">mpfr</span> <span style=\"color: #000000;\">pi</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">mpfr_init_set_q</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">res</span><span style=\"color: #0000FF;\">)</span>\n <span style=\"color: #7060A8;\">mpfr_sqrt</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">pi</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">pi</span><span style=\"color: #0000FF;\">)</span>\n <span style=\"color: #7060A8;\">printf</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #008000;\">\"\\nCalculation of pi took %d iterations using the Almkvist-Giullera formula.\\n\\n\"</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">n</span><span style=\"color: #0000FF;\">)</span>\n <span style=\"color: #7060A8;\">printf</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #008000;\">\"Pi to 70 d.p.: %s\\n\"</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #7060A8;\">mpfr_get_fixed</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">pi</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">70</span><span style=\"color: #0000FF;\">))</span>\n <span style=\"color: #7060A8;\">mpfr_const_pi</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">pi</span><span style=\"color: #0000FF;\">)</span>\n <span style=\"color: #7060A8;\">printf</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #008000;\">\"Pi (builtin) : %s\\n\"</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #7060A8;\">mpfr_get_fixed</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">pi</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">70</span><span style=\"color: #0000FF;\">))</span>\n<!--\n"
                }
            ],
            [
                {
                    "language": "Mathematica",
                    "solution": "ClearAll[numerator, denominator]\nnumerator[n_] := (2^5) ((6 n)!) (532 n^2 + 126 n + 9)/(3 (n!)^6)\ndenominator[n_] := 10^(6 n + 3)\nnumerator /@ Range[0, 9]\nval = 1/Sqrt[Total[numerator[#]/denominator[#] & /@ Range[0, 100]]];\nN[val, 70]\n"
                },
                {
                    "language": "JavaScript",
                    "solution": "import esMain from 'es-main';\nimport { BigFloat, set_precision as SetPrecision } from 'bigfloat-esnext';\n\nconst Iterations = 52;\n\nexport const demo = function() {\n  SetPrecision(-75);\n  console.log(\"N.\" + \"Integral part of Nth term\".padStart(45) + \" \u00c3\u201410^ =Actual value of Nth term\");\n  for (let i=0; i<10; i++) {\n    let line = `${i}. `;\n    line += `${integral(i)} `.padStart(45);\n    line += `${tenExponent(i)} `.padStart(5);\n    line += nthTerm(i);\n    console.log(line);\n  }\n\n  let pi = approximatePi(Iterations);\n  SetPrecision(-70);\n  pi = pi.dividedBy(100000).times(100000);\n  console.log(`\\nPi after ${Iterations} iterations: ${pi}`)\n}\n\nexport const bigFactorial = n => n <= 1n ? 1n : n * bigFactorial(n-1n);\n\n// the nth integer term\nexport const integral = function(i) {\n  let n = BigInt(i);\n  const polynomial  = 532n * n * n + 126n * n + 9n;\n  const numerator   = 32n * bigFactorial(6n * n) * polynomial;\n  const denominator = 3n * bigFactorial(n) ** 6n;\n  return numerator / denominator;\n}\n\n// the exponent for 10 in the nth term of the series\nexport const tenExponent = n => 3n - 6n * (BigInt(n) + 1n);\n\n// the nth term of the series\nexport const nthTerm = n =>\n  new BigFloat(integral(n)).dividedBy(new BigFloat(10n ** -tenExponent(n)))\n\n// the sum of the first n terms\nexport const sumThrough = function(n) {\n  let sum = new BigFloat(0);\n  for (let i=0; i<=n; ++i) {\n    sum = sum.plus(nthTerm(i));\n  }\n  return sum;\n}\n\n// the approximation to pi after n terms\nexport const approximatePi  = n =>\n   new BigFloat(1).dividedBy(sumThrough(n)).sqrt();\n\nif (esMain(import.meta))\n   demo();\n"
                }
            ]
        ]
    },
    {
        "task_name": "Almost-prime",
        "task_description": "A &nbsp; [[wp:Almost prime|k-Almost-prime]] &nbsp; is a natural number &nbsp; <math>n</math> &nbsp; that is the product of &nbsp; <math>k</math> &nbsp; (possibly identical) primes.\n\n\n;Example:\n1-almost-primes,     &nbsp; where &nbsp; <math>k=1</math>, &nbsp; are the prime numbers themselves.\n<br>2-almost-primes, &nbsp; where &nbsp; <math>k=2</math>, &nbsp; are the &nbsp; [[Semiprime|semiprimes]].\n\n\n;Task:\nWrite a function/method/subroutine/... that generates k-almost primes and use it to create a table here of the first ten members of k-Almost primes for &nbsp; <math>1 <= K <= 5</math>.\n\n\n;Related tasks:\n* &nbsp; [[Semiprime]]\n* &nbsp; [[:Category:Prime Numbers]]\n<br><br>\n\n",
        "solution_pairs": [
            [
                {
                    "language": "Wren",
                    "solution": "var kPrime = Fn.new { |n, k|\n    var nf = 0\n    var i = 2\n    while (i <= n) {\n        while (n%i == 0) {\n            if (nf == k) return false\n            nf = nf + 1\n            n = (n/i).floor\n        }\n        i = i + 1\n    }\n    return nf == k\n}\n\nvar gen = Fn.new { |k, n|\n    var r = List.filled(n, 0)\n    n = 2\n    for (i in 0...r.count) {\n        while (!kPrime.call(n, k)) n = n + 1\n        r[i] = n\n        n = n + 1\n    }\n    return r\n}\n\nfor (k in 1..5) System.print(\"%(k) %(gen.call(k, 10))\")\n"
                },
                {
                    "language": "VBA",
                    "solution": "Private Function kprime(ByVal n As Integer, k As Integer) As Boolean\n    Dim p As Integer, factors As Integer\n    p = 2\n    factors = 0\n    Do While factors < k And p * p <= n\n        Do While n Mod p = 0\n            n = n / p\n            factors = factors + 1\n        Loop\n        p = p + 1\n    Loop\n    factors = factors - (n > 1) 'true=-1\n    kprime = factors = k\nEnd Function\n\nPrivate Sub almost_primeC()\n    Dim nextkprime As Integer, count As Integer\n    Dim k As Integer\n    For k = 1 To 5\n        Debug.Print \"k =\"; k; \":\";\n        nextkprime = 2\n        count = 0\n        Do While count < 10\n            If kprime(nextkprime, k) Then\n                Debug.Print \" \"; Format(CStr(nextkprime), \"@@@@@\");\n                count = count + 1\n            End If\n            nextkprime = nextkprime + 1\n        Loop\n        Debug.Print\n    Next k\nEnd Sub\n"
                }
            ],
            [
                {
                    "language": "Visual-Basic-.NET",
                    "solution": "Module Module1\n\n    Class KPrime\n        Public K As Integer\n\n        Public Function IsKPrime(number As Integer) As Boolean\n            Dim primes = 0\n            Dim p = 2\n            While p * p <= number AndAlso primes < K\n                While number Mod p = 0 AndAlso primes < K\n                    number = number / p\n                    primes = primes + 1\n                End While\n                p = p + 1\n            End While\n            If number > 1 Then\n                primes = primes + 1\n            End If\n            Return primes = K\n        End Function\n\n        Public Function GetFirstN(n As Integer) As List(Of Integer)\n            Dim result As New List(Of Integer)\n            Dim number = 2\n            While result.Count < n\n                If IsKPrime(number) Then\n                    result.Add(number)\n                End If\n                number = number + 1\n            End While\n            Return result\n        End Function\n    End Class\n\n    Sub Main()\n        For Each k In Enumerable.Range(1, 5)\n            Dim kprime = New KPrime With {\n                .K = k\n            }\n            Console.WriteLine(\"k = {0}: {1}\", k, String.Join(\" \", kprime.GetFirstN(10)))\n        Next\n    End Sub\n\nEnd Module\n"
                },
                {
                    "language": "Factor",
                    "solution": "USING: formatting fry kernel lists lists.lazy locals\nmath.combinatorics math.primes.factors math.ranges sequences ;\nIN: rosetta-code.almost-prime\n\n: k-almost-prime? ( n k -- ? )\n    '[ factors _ <combinations> [ product ] map ]\n    [ [ = ] curry ] bi any? ;\n\n:: first10 ( k -- seq )\n    10 0 lfrom [ k k-almost-prime? ] lfilter ltake list>array ;\n\n5 [1,b] [ dup first10 \"K = %d: %[%3d, %]\\n\" printf ] each\n"
                }
            ],
            [
                {
                    "language": "Phixmonti",
                    "solution": "/# Rosetta Code problem: http://rosettacode.org/wiki/Almost_prime\nby Galileo, 06/2022 #/\n\ninclude ..\\Utilitys.pmt\n\ndef test tps over mod not enddef\n\ndef kprime?\n    >ps >ps\n    0 ( 2 tps ) for\n        test while\n            tps over / int ps> drop >ps\n            swap 1 + swap\n        test endwhile\n        drop\n    endfor\n    ps> drop\n    ps> ==\nenddef\n\n5 for >ps\n    2 ( )\n    len 10 < while over tps kprime? if over 0 put endif swap 1 + swap len 10 < endwhile\n    nip ps> drop\nendfor\n\npstack\n"
                },
                {
                    "language": "Lua",
                    "solution": "-- Returns boolean indicating whether n is k-almost prime\nfunction almostPrime (n, k)\n    local divisor, count = 2, 0\n    while count < k + 1 and n ~= 1 do\n        if n % divisor == 0 then\n            n = n / divisor\n            count = count + 1\n        else\n            divisor = divisor + 1\n        end\n    end\n    return count == k\nend\n\n-- Generates table containing first ten k-almost primes for given k\nfunction kList (k)\n    local n, kTab = 2^k, {}\n    while #kTab < 10 do\n        if almostPrime(n, k) then\n            table.insert(kTab, n)\n        end\n        n = n + 1\n    end\n    return kTab\nend\n\n-- Main procedure, displays results from five calls to kList()\nfor k = 1, 5 do\n    io.write(\"k=\" .. k .. \": \")\n    for _, v in pairs(kList(k)) do\n        io.write(v .. \", \")\n    end\n    print(\"...\")\nend\n"
                }
            ],
            [
                {
                    "language": "Cowgol",
                    "solution": "include \"cowgol.coh\";\n\nsub kprime(n: uint8, k: uint8): (kp: uint8) is\n    var p: uint8 := 2;\n    var f: uint8 := 0;\n    while f < k and p*p <= n loop\n        while 0 == n % p loop\n            n := n / p;\n            f := f + 1;\n        end loop;\n        p := p + 1;\n    end loop;\n    if n > 1 then\n        f := f + 1;\n    end if;\n    if f == k then\n        kp := 1;\n    else\n        kp := 0;\n    end if;\nend sub;\n\nvar k: uint8 := 1;\nwhile k <= 5 loop\n    print(\"k = \");\n    print_i8(k);\n    print(\":\");\n\n    var i: uint8 := 2;\n    var c: uint8 := 0;\n    while c < 10 loop\n        if kprime(i,k) != 0 then\n            print(\" \");\n            print_i8(i);\n            c := c + 1;\n        end if;\n        i := i + 1;\n    end loop;\n    print_nl();\n    k := k + 1;\nend loop;\n"
                },
                {
                    "language": "Sidef",
                    "solution": "func almost_primes(a, b, k) {\n\n    a = max(2**k, a)\n    var arr = []\n\n    func (m, lo, k) {\n\n        var hi = idiv(b,m).iroot(k)\n\n        if (k == 1) {\n\n            lo = max(lo, idiv_ceil(a, m))\n\n            each_prime(lo, hi, {|p|\n                arr << m*p\n            })\n\n            return nil\n        }\n\n        each_prime(lo, hi, {|p|\n\n            var t = m*p\n            var u = idiv_ceil(a, t)\n            var v = idiv(b, t)\n\n            next if (u > v)\n\n            __FUNC__(t, p, k-1)\n        })\n    }(1, 2, k)\n\n    return arr.sort\n}\n\nfor k in (1..5) {\n    var (x=10, lo=1, hi=2)\n    var arr = []\n    loop {\n        arr += almost_primes(lo, hi, k)\n        break if (arr.len >= x)\n        lo = hi+1\n        hi = 2*lo\n    }\n    say arr.first(x)\n}\n"
                }
            ],
            [
                {
                    "language": "ERRE",
                    "solution": "PROGRAM ALMOST_PRIME\n\n!\n! for rosettacode.org\n!\n\n!$INTEGER\n\nPROCEDURE KPRIME(N,K->KP)\n  LOCAL P,F\n  FOR P=2 TO 999 DO\n      EXIT IF NOT((F<K) AND (P*P<=N))\n      WHILE (N MOD P)=0 DO\n         N/=P\n         F+=1\n      END WHILE\n  END FOR\n  KP=(F-(N>1)=K)\nEND PROCEDURE\n\nBEGIN\n  PRINT(CHR$(12);)  !CLS\n  FOR K=1 TO 5 DO\n     PRINT(\"k =\";K;\":\";)\n     C=0\n     FOR I=2 TO 999 DO\n        EXIT IF NOT(C<10)\n        KPRIME(I,K->KP)\n        IF KP THEN\n            PRINT(I;)\n            C+=1\n        END IF\n     END FOR\n     PRINT\n  END FOR\nEND PROGRAM\n"
                },
                {
                    "language": "EchoLisp",
                    "solution": ";; we want  500-almost-primes from the 10000-th.\n(take (drop (list-sort < (almost-primes 500 10000)) 10000 ) 10)\n\n(7241149198492252834202927258094752774597239286103014697435725917649659974371690699721153852986\n440733637405206125678822081264723636566725108094369093648384\netc ...\n\n;; The first one is 2^497 * 3 * 17 * 347 , same result as Haskell.\n"
                }
            ]
        ]
    },
    {
        "task_name": "Amb",
        "task_description": "Define and give an example of the Amb operator.\n\nThe Amb operator (short for \"ambiguous\") expresses nondeterminism. This doesn't refer to randomness (as in \"nondeterministic universe\") but is closely related to the term as it is used in automata theory (\"non-deterministic finite automaton\").\n\nThe Amb operator takes a variable number of expressions (or values if that's simpler in the language) and yields a correct one which will satisfy a constraint in some future computation, thereby avoiding failure.\n\nProblems whose solution the Amb operator naturally expresses can be approached with other tools, such as explicit nested iterations over data sets, or with pattern matching. By contrast, the Amb operator appears integrated into the language. Invocations of Amb are not wrapped in any visible loops or other search patterns; they appear to be independent. \n\nEssentially Amb(x, y, z) splits the computation into three possible futures: a future in which the value x is yielded, a future in which the value y is yielded and a future in which the value z is yielded. The future which leads to a successful subsequent computation is chosen. The other \"parallel universes\" somehow go away.   Amb called with no arguments fails.\n\nFor simplicity, one of the domain values usable with Amb may denote failure, if that is convenient. For instance, it is convenient if a Boolean false denotes failure, so that Amb(false) fails, and thus constraints can be expressed using Boolean expressions like Amb(x * y == 8) which unless x and y add to four.\n\nA pseudo-code program which satisfies this constraint might look like:\n\n<pre>let x = Amb(1, 2, 3)\nlet y = Amb(7, 6, 4, 5)\nAmb(x * y = 8)\nprint x, y</pre>\n\nThe output is <code>2 4</code> because <code>Amb(1, 2, 3)</code> correctly chooses the future in which <code>x</code> has value <code>2</code>, <code>Amb(7, 6, 4, 5)</code> chooses <code>4</code> and consequently <code>Amb(x * y = 8)</code> produces a success.\n\nAlternatively, failure could be represented using strictly <code>Amb()</code>:\n\n<pre>unless x * y = 8 do Amb()</pre>\n\nOr else Amb could take the form of two operators or functions: one for producing values and one for enforcing constraints:\n\n<pre>let x = Ambsel(1, 2, 3)\nlet y = Ambsel(4, 5, 6)\nAmbassert(x * y = 8)\nprint x, y</pre>\n\nwhere <code>Ambassert</code> behaves like <code>Amb()</code> if the Boolean expression is false, otherwise it allows the future computation to take place, without yielding any value.\n\nThe task is to somehow implement Amb, and demonstrate it with a program which chooses one word from each of the following four sets of character strings to generate a four-word sentence:\n\n#<code>\"the\" \"that\" \"a\"</code>\n#<code>\"frog\" \"elephant\" \"thing\"</code>\n#<code>\"walked\" \"treaded\" \"grows\"</code>\n#<code>\"slowly\" \"quickly\"</code>\n\nThe constraint to be satisfied is that the last character of each word (other than the last) is the same as the first character of its successor.\n\nThe only successful sentence is <code>\"that thing grows slowly\"</code>; other combinations do not satisfy the constraint and thus fail.\n\nThe goal of this task isn't to simply process the four lists of words with explicit, deterministic program flow such as nested iteration, to trivially demonstrate the correct output. The goal is to implement the Amb operator, or a facsimile thereof that is possible within the language limitations.\n\n",
        "solution_pairs": [
            [
                {
                    "language": "Tcl",
                    "solution": "set amb {\n    {the    that     a}\n    {frog   elephant thing}\n    {walked treaded  grows}\n    {slowly quickly}\n}\n\nproc joins {a b} {\n    expr {[string index $a end] eq [string index $b 0]}\n}\n\nforeach i [lindex $amb 0] {\n    foreach j [lindex $amb 1] {\n        if ![joins $i $j] continue\n        foreach k [lindex $amb 2] {\n            if ![joins $j $k] continue\n            foreach l [lindex $amb 3] {\n                if [joins $k $l] {\n                    puts [list $i $j $k $l]\n                }\n            }\n        }\n    }\n}\n"
                },
                {
                    "language": "Jq",
                    "solution": "([\"the\",\"that\",\"a\"] | amb(true)) as $word1\n  | ([\"frog\",\"elephant\",\"thing\"] | amb( [$word1, .] | joins)) as $word2\n  | ([\"walked\",\"treaded\",\"grows\"] | amb( [$word2, .] | joins)) as $word3\n  | ([\"slowly\",\"quickly\"] | amb( [$word3, .] | joins)) as $word4\n  | [$word1, $word2,$word3, $word4]\n"
                }
            ],
            [
                {
                    "language": "Smalltalk",
                    "solution": "tryAll:valuesCollection in:aBlock\n    \"try each set of values in aBlock;\n     aBlock's number of args must be the number of elements in valuesCollection\"\n\n    |tryAll|\n\n    tryAll :=\n        [:valuesCollection :argsIn |\n            valuesCollection isEmpty ifTrue:[\n                aBlock valueWithArguments:argsIn\n            ] ifFalse:[\n                self try:(valuesCollection first) in:[:arg |\n                    tryAll value:(valuesCollection from:2) value:argsIn,{arg} ]]].\n\n    ^ tryAll value:valuesCollection value:#()\n"
                },
                {
                    "language": "Zkl",
                    "solution": "   // [()] notation unpacks parameter list: f((1,2,3))-->a=1,b=2,c=3\nfcn f([(a,b,c,d)]){ joins(a,b) and joins(b,c) and joins(c,d) }\namb(f, T(\"the\",\"that\",\"a\"), T(\"frog\",\"elephant\",\"thing\"),\n    T(\"walked\",\"treaded\",\"grows\"), T(\"slowly\",\"quickly\")\n).println();\n"
                }
            ],
            [
                {
                    "language": "PureBasic",
                    "solution": "Procedure Words_Ok(String1.s, String2.s)\n  If Mid(String1,Len(String1),1)=Mid(String2,1,1)\n    ProcedureReturn #True\n  EndIf\n  ProcedureReturn #False\nEndProcedure\n\nProcedure.s Amb(Array A.s(1), Array B.s(1), Array C.s(1), Array D.s(1))\n  Protected a, b, c, d\n  For a=0 To ArraySize(A())\n    For b=0 To ArraySize(B())\n      For c=0 To ArraySize(C())\n        For d=0 To ArraySize(D())\n          If Words_Ok(A(a),B(b)) And Words_Ok(B(b),C(c)) And Words_Ok(C(c),D(d))\n            ProcedureReturn A(a)+\" \"+B(b)+\" \"+C(c)+\" \"+D(d)\n          EndIf\n        Next\n      Next\n    Next\n  Next\n  ProcedureReturn \"\"   ; Empty string, e.g. fail\nEndProcedure\n\nIf OpenConsole()\n  Define Text.s\n  Dim Set1.s(2)\n  Dim Set2.s(2)\n  Dim Set3.s(2)\n  Dim Set4.s(1)\n\n  Set1(0)=\"the\":    set1(1)=\"that\":     set1(2)=\"a\"\n  Set2(0)=\"frog\":   set2(1)=\"elephant\": set2(2)=\"thing\"\n  Set3(0)=\"walked\": set3(1)=\"treaded\":  set3(2)=\"grows\"\n  Set4(0)=\"slowly\": set4(1)=\"quickly\"\n\n  text=Amb(set1(),set2(),Set3(),set4())\n  If Text<>\"\"\n    PrintN(\"Correct sentence would be,\"+#CRLF$+Text)\n  Else\n    PrintN(\"Failed to fine a correct sentence.\")\n  EndIf\n  PrintN(#CRLF$+#CRLF$+\"Press ENTER to exit.\"): Input()\n  CloseConsole()\nEndIf\n"
                },
                {
                    "language": "Bracmat",
                    "solution": "( ( Amb\n  =   first last list words word solution\n    .   !arg:(?first.?list)\n      & ( !list:\n        |   !list:(.?words) ?list\n          &   !words\n            :   ?\n                %( @(?word:!first ? @?last)\n                 & Amb$(!last.!list):?solution\n                 & !word !solution:?solution\n                 )\n                ?\n          & !solution\n        )\n  )\n&   Amb\n  $ (\n    .   (.the that a)\n        (.frog elephant thing)\n        (.walked treaded grows)\n        (.slowly quickly)\n    )\n)\n"
                }
            ],
            [
                {
                    "language": "Jq",
                    "solution": "def amb(condition): .[] | select(condition);\n\ndef joins:\n  (.[0][-1:]) as $left\n  | (.[1][0:1]) as $right\n  | $left == $right ;\n"
                },
                {
                    "language": "Lua",
                    "solution": "result = amb({{'the','that','a'},{'frog','elephant','thing'},{'walked','treaded','grows'},{'slowly','quickly'}})\nfor i,v in next,result do\n    io.write (i,':\\t')\n    for j,u in next,v do\n        io.write (u,' ')\n    end\n    io.write ('\\n')\nend\n"
                }
            ],
            [
                {
                    "language": "Racket",
                    "solution": "#lang racket\n\n;; A quick `amb' implementation (same as in the Twelve Statements task)\n(define failures null)\n\n(define (fail)\n  (if (pair? failures) ((first failures)) (error \"no more choices!\")))\n\n(define (amb/thunks choices)\n  (let/cc k (set! failures (cons k failures)))\n  (if (pair? choices)\n    (let ([choice (first choices)]) (set! choices (rest choices)) (choice))\n    (begin (set! failures (rest failures)) (fail))))\n\n(define-syntax-rule (amb E ...) (amb/thunks (list (lambda () E) ...)))\n\n(define (assert condition) (unless condition (fail)))\n\n;; Problem solution\n\n(define (joins? left right)\n  (regexp-match? #px\"(.)\\0\\\\1\" (~a left \"\\0\" right)))\n\n(let ([result (list (amb \"the\" \"that\" \"a\")\n                    (amb \"frog\" \"elephant\" \"thing\")\n                    (amb \"walked\" \"treaded\" \"grows\")\n                    (amb \"slowly\" \"quickly\"))])\n  (for ([x result] [y (cdr result)]) (assert (joins? x y)))\n  result)\n;; -> '(\"that\" \"thing\" \"grows\" \"slowly\")\n"
                },
                {
                    "language": "Ela",
                    "solution": "amb [\n       [\"the\",\"that\",\"a\"]\n      ,[\"frog\",\"elephant\",\"thing\"]\n      ,[\"walked\",\"treaded\",\"grows\"]\n      ,[\"slowly\",\"quickly\"]\n    ]\n"
                }
            ]
        ]
    },
    {
        "task_name": "Amicable-pairs",
        "task_description": "Two integers <math>N</math> and <math>M</math> are said to be [[wp:Amicable numbers|amicable pairs]] if <math>N \\neq M</math> and the sum of the [[Proper divisors|proper divisors]] of <math>N</math> (<math>\\mathrm{sum}(\\mathrm{propDivs}(N))</math>) <math>= M</math> as well as <math>\\mathrm{sum}(\\mathrm{propDivs}(M)) = N</math>.\n\n\n;Example:\n'''1184''' and '''1210''' are an amicable pair, with proper divisors:\n* &nbsp; 1, 2, 4, 8, 16, 32, 37, 74, 148, 296, 592 &nbsp; and \n* &nbsp; 1, 2, 5, 10, 11, 22, 55, 110, 121, 242, 605  &nbsp; respectively.\n\n\n;Task:\nCalculate and show here the Amicable pairs below 20,000; (there are eight).\n\n\n;Related tasks\n* [[Proper divisors]]\n* [[Abundant, deficient and perfect number classifications]]\n* [[Aliquot sequence classifications]] and its amicable ''classification''. \n<br><br>\n\n",
        "solution_pairs": [
            [
                {
                    "language": "Pascal",
                    "solution": "program AmicPair;\n{find amicable pairs in a limited region 2..MAX\nbeware that >both< numbers must be smaller than MAX\nthere are 455 amicable pairs up to 524*1000*1000\ncorrect up to\n#437 460122410\n}\n//optimized for freepascal 2.6.4 32-Bit\n{$IFDEF FPC}\n   {$MODE DELPHI}\n   {$OPTIMIZATION ON,peephole,cse,asmcse,regvar}\n   {$CODEALIGN loop=1,proc=8}\n{$ELSE}\n  {$APPTYPE CONSOLE}\n{$ENDIF}\n\nuses\n  sysutils;\n\ntype\n  tValue = LongWord;\n  tpValue = ^tValue;\n  tDivSum = array[0..0] of tValue;// evil, but dynamic arrays are slower\n  tpDivSum = ^tDivSum;\n  tPower = array[0..31] of tValue;\n  tIndex = record\n             idxI,\n             idxS : tValue;\n           end;\nvar\n  power,\n  PowerFac     : tPower;\n  ds           : array of tValue;\n  Indices      : array[0..511] of tIndex;\n  DivSumField  : tpDivSum;\n  MAX : tValue;\n\nprocedure Init;\nvar\n  i : LongInt;\nbegin\n  DivSumField[0]:= 0;\n  For i := 1 to MAX do\n    DivSumField[i]:= 1;\nend;\n\nprocedure ProperDivs(n: tValue);\n//Only for output, normally a factorication would do\nvar\n  su,so : string;\n  i,q : tValue;\nbegin\n  su:= '1';\n  so:= '';\n  i := 2;\n  while i*i <= n do\n  begin\n    q := n div i;\n    IF q*i -n = 0 then\n    begin\n      su:= su+','+IntToStr(i);\n      IF q <> i then\n        so:= ','+IntToStr(q)+so;\n    end;\n    inc(i);\n  end;\n  writeln('  [',su+so,']');\nend;\n\nprocedure AmPairOutput(cnt:tValue);\nvar\n  i : tValue;\n  r : double;\nbegin\n  r := 1.0;\n  For i := 0 to cnt-1 do\n  with Indices[i] do\n  begin\n    writeln(i+1:4,IdxI:12,IDxS:12,' ratio ',IdxS/IDxI:10:7);\n    if r < IdxS/IDxI then\n      r := IdxS/IDxI;\n      IF cnt < 20 then\n      begin\n        ProperDivs(IdxI);\n        ProperDivs(IdxS);\n      end;\n  end;\n  writeln(' max ratio ',r:10:4);\nend;\n\nfunction Check:tValue;\nvar\n  i,s,n : tValue;\nbegin\n  n := 0;\n  For i := 1 to MAX do\n  begin\n    //s = sum of proper divs (I)  == sum of divs (I) - I\n    s := DivSumField^[i];\n    IF (s <=MAX) AND (s>i) AND (DivSumField^[s]= i)then\n    begin\n      With indices[n] do\n      begin\n        idxI := i;\n        idxS := s;\n      end;\n      inc(n);\n    end;\n  end;\n  result := n;\nend;\n\nProcedure CalcPotfactor(prim:tValue);\n//PowerFac[k] = (prim^(k+1)-1)/(prim-1) == Sum (i=0..k) prim^i\nvar\n  k: tValue;\n  Pot,       //== prim^k\n  PFac : Int64;\nbegin\n  Pot := prim;\n  PFac := 1;\n  For k := 0 to High(PowerFac) do\n  begin\n    PFac := PFac+Pot;\n    IF (POT > MAX) then\n      BREAK;\n    PowerFac[k] := PFac;\n    Pot := Pot*prim;\n  end;\nend;\n\nprocedure InitPW(prim:tValue);\nbegin\n  fillchar(power,SizeOf(power),#0);\n  CalcPotfactor(prim);\nend;\n\nfunction NextPotCnt(p: tValue):tValue;\n//return the first power <> 0\n//power == n to base prim\nvar\n  i : tValue;\nbegin\n  result := 0;\n  repeat\n    i := power[result];\n    Inc(i);\n    IF i < p then\n      BREAK\n    else\n    begin\n      i := 0;\n      power[result]  := 0;\n      inc(result);\n    end;\n  until false;\n  power[result] := i;\nend;\n\nprocedure Sieve(prim: tValue);\nvar\n  actNumber,idx : tValue;\nbegin\n  //sieve with \"small\" primes\n  while prim*prim <= MAX do\n  begin\n    InitPW(prim);\n    Begin\n      //actNumber = actual number = n*prim\n      actNumber := prim;\n      idx := prim;\n      while actNumber <= MAX do\n      begin\n        dec(idx);\n        IF idx > 0 then\n          DivSumField^[actNumber] *= PowerFac[0]\n        else\n        Begin\n          DivSumField^[actNumber] *= PowerFac[NextPotCnt(prim)+1];\n          idx := Prim;\n        end;\n        inc(actNumber,prim);\n      end;\n    end;\n    //next prime\n    repeat\n      inc(prim);\n    until DivSumField^[prim]= 1;//(DivSumField[prim] = 1);\n  end;\n\n  //sieve with \"big\" primes, only one factor is possible\n  while 2*prim <= MAX do\n  begin\n    InitPW(prim);\n    Begin\n      actNumber := prim;\n      idx := PowerFac[0];\n      while actNumber <= MAX do\n      begin\n        DivSumField^[actNumber] *= idx;\n        inc(actNumber,prim);\n      end;\n    end;\n    repeat\n      inc(prim);\n    until DivSumField^[prim]= 1;\n  end;\n\n  For idx := 2 to MAX do\n    dec(DivSumField^[idx],idx);\nend;\n\nvar\n  T2,T1,T0: TDatetime;\n  APcnt: tValue;\n  i: NativeInt;\nbegin\n  MAX := 20000;\n  IF  ParamCount > 0 then\n    MAX := StrToInt(ParamStr(1));\n  setlength(ds,MAX);\n  DivSumField := @ds[0];\n  T0:= time;\n  For i := 1 to 1 do\n  Begin\n    Init;\n    Sieve(2);\n  end;\n  T1:= time;\n\n  APCnt := Check;\n  T2:= time;\n  AmPairOutput(APCnt);\n  writeln(APCnt,' amicable pairs til ',MAX);\n  writeln('Time to calc sum of divs    ',FormatDateTime('HH:NN:SS.ZZZ' ,T1-T0));\n  writeln('Time to find amicable pairs ',FormatDateTime('HH:NN:SS.ZZZ' ,T2-T1));\n  setlength(ds,0);\n  {$IFNDEF UNIX}\n    readln;\n  {$ENDIF}\nend.\n"
                },
                {
                    "language": "Ela",
                    "solution": "open monad io number list\n\ndivisors n = filter ((0 ==) << (n `mod`)) [1..(n `div` 2)]\nrange = [1 .. 20000]\ndivs = zip range $ map (sum << divisors) range\npairs = [(n, m) \\\\ (n, nd) <- divs, (m, md) <- divs | n < m && nd == m && md == n]\n\ndo putLn pairs ::: IO\n"
                }
            ],
            [
                {
                    "language": "Swift",
                    "solution": "import func Darwin.sqrt\n\nfunc sqrt(x:Int) -> Int { return Int(sqrt(Double(x))) }\n\nfunc properDivs(n: Int) -> [Int] {\n\n    if n == 1 { return [] }\n\n    var result = [Int]()\n\n    for div in filter (1...sqrt(n), { n % $0 == 0 }) {\n\n        result.append(div)\n\n        if n/div != div && n/div != n { result.append(n/div) }\n    }\n\n    return sorted(result)\n\n}\n\n\nfunc sumDivs(n:Int) -> Int {\n\n    struct Cache { static var sum = [Int:Int]() }\n\n    if let sum = Cache.sum[n] { return sum }\n\n    let sum = properDivs(n).reduce(0) { $0 + $1 }\n\n    Cache.sum[n] = sum\n\n    return sum\n}\n\nfunc amicable(n:Int, m:Int) -> Bool {\n\n    if n == m { return false }\n\n    if sumDivs(n) != m || sumDivs(m) != n { return false }\n\n    return true\n}\n\nvar pairs = [(Int, Int)]()\n\nfor n in 1 ..< 20_000 {\n    for m in n+1 ... 20_000 {\n        if amicable(n, m) {\n            pairs.append(n, m)\n            println(\"\\(n, m)\")\n        }\n    }\n}\n"
                },
                {
                    "language": "Frink",
                    "solution": "n = 1\nseen = new set\n\ndo\n{\n   n = n + 1\n   if seen.contains[n]\n      next\n\n   sum = sum[allFactors[n, true, false, false]]\n   if sum != n and sum[allFactors[sum, true, false, false]] == n\n   {\n      println[\"$n, $sum\"]\n      seen.put[sum]\n   }\n} while n <= 20000\n"
                }
            ],
            [
                {
                    "language": "Mathematica",
                    "solution": "amicableQ[n_] :=\n Module[{sum = Total[Most@Divisors@n]},\n  sum != n && n == Total[Most@Divisors@sum]]\n\nGrid@Partition[Cases[Range[4, 20000], _?(amicableQ@# &)], 2]\n"
                },
                {
                    "language": "Erlang",
                    "solution": "-module(properdivs).\n-export([amicable/1,divs/1,sumdivs/1]).\n\namicable(Limit) -> amicable(Limit,[],3,2).\n\namicable(Limit,List,_Current,Acc) when Acc >= Limit -> List;\namicable(Limit,List,Current,Acc) when Current =< Acc/2  ->\n    amicable(Limit,List,Acc,Acc+1);\namicable(Limit,List,Current,Acc) ->\n    CS = sumdivs(Current),\n    AS = sumdivs(Acc),\n    if\n        CS == Acc andalso AS == Current andalso Acc =/= Current ->\n          io:format(\"A: ~w, B: ~w, ~nL: ~w~w~n\",  [Current,Acc,divs(Current),divs(Acc)]),\n          NL = List ++ [{Current,Acc}],\n          amicable(Limit,NL,Acc+1,Acc+1);\n        true ->\n          amicable(Limit,List,Current-1,Acc) end.\n\ndivs(0) -> [];\ndivs(1) -> [];\ndivs(N) -> lists:sort(divisors(1,N)).\n\ndivisors(1,N) ->\n     [1] ++ divisors(2,N,math:sqrt(N)).\n\ndivisors(K,_N,Q) when K > Q -> [];\ndivisors(K,N,_Q) when N rem K =/= 0 ->\n    [] ++ divisors(K+1,N,math:sqrt(N));\ndivisors(K,N,_Q) when K * K  == N ->\n    [K] ++ divisors(K+1,N,math:sqrt(N));\ndivisors(K,N,_Q) ->\n    [K, N div K] ++ divisors(K+1,N,math:sqrt(N)).\n\nsumdivs(N) -> lists:sum(divs(N)).\n"
                }
            ],
            [
                {
                    "language": "SETL",
                    "solution": "program amicable_pairs;\n    p := propDivSums(20000);\n\n    loop for [n,m] in p | n = p(p(n)) and n<m do\n        print([n,m]);\n    end loop;\n\n    proc propDivSums(n);\n        divs := {};\n        loop for i in [1..n] do\n            loop for j in [i*2, i*3..n] do\n                divs(j) +:= i;\n            end loop;\n        end loop;\n        return divs;\n    end proc;\nend program;\n"
                },
                {
                    "language": "PureBasic",
                    "solution": "EnableExplicit\n\nProcedure.i SumProperDivisors(Number)\n  If Number < 2 : ProcedureReturn 0 : EndIf\n  Protected i, sum = 0\n  For i = 1 To Number / 2\n    If Number % i = 0\n      sum + i\n    EndIf\n  Next\n  ProcedureReturn sum\nEndProcedure\n\nDefine n, f\nDefine Dim sum(19999)\n\nIf OpenConsole()\n  For n = 1 To 19999\n    sum(n) = SumProperDivisors(n)\n  Next\n  PrintN(\"The pairs of amicable numbers below 20,000 are : \")\n  PrintN(\"\")\n  For n = 1 To 19998\n    f = sum(n)\n    If f <= n Or f < 1 Or f > 19999 : Continue : EndIf\n    If f = sum(n) And n = sum(f)\n      PrintN(RSet(Str(n),5) + \" and \" + RSet(Str(sum(n)), 5))\n    EndIf\n  Next\n  PrintN(\"\")\n  PrintN(\"Press any key to close the console\")\n  Repeat: Delay(10) : Until Inkey() <> \"\"\n  CloseConsole()\nEndIf\n"
                }
            ],
            [
                {
                    "language": "EasyLang",
                    "solution": "func sumdivs n .\n   sum = 1\n   for d = 2 to sqrt n\n      if n mod d = 0\n         sum += d + n div d\n      .\n   .\n   return sum\n.\nfor n = 1 to 20000\n   m = sumdivs n\n   if m > n\n      if sumdivs m = n\n         print n & \" \" & m\n      .\n   .\n.\n"
                },
                {
                    "language": "C-sharp",
                    "solution": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace RosettaCode.AmicablePairs\n{\n    internal static class Program {\n        private const int Limit = 20000;\n\n        private static void Main()\n        {\n            foreach (var pair in GetPairs(Limit))\n            {\n                Console.WriteLine(\"{0} {1}\", pair.Item1, pair.Item2);\n            }\n        }\n\n        private static IEnumerable<Tuple<int, int>> GetPairs(int max)\n        {\n            List<int> divsums =\n                Enumerable.Range(0, max + 1).Select(i => ProperDivisors(i).Sum()).ToList();\n            for(int i=1; i<divsums.Count; i++) {\n                int sum = divsums[i];\n                if(i < sum && sum <= divsums.Count && divsums[sum] == i) {\n                    yield return new Tuple<int, int>(i, sum);\n                }\n            }\n        }\n\n        private static IEnumerable<int> ProperDivisors(int number)\n        {\n            return\n                Enumerable.Range(1, number / 2)\n                    .Where(divisor => number % divisor == 0);\n        }\n    }\n}\n"
                }
            ]
        ]
    },
    {
        "task_name": "Anagrams",
        "task_description": "When two or more words are composed of the same characters, but in a different order, they are called [[wp:Anagram|anagrams]]. \n\n;Task\nUsing the word list at &nbsp; http://wiki.puzzlers.org/pub/wordlists/unixdict.txt, \n<br>find the sets of words that share the same characters that contain the most words in them.\n\n;Related tasks\n\n{{Related tasks/Word plays}}\n\n\n{{Template:Strings}}\n<br><br>\n\n",
        "solution_pairs": [
            [
                {
                    "language": "Lua",
                    "solution": "function sort(word)\n  local bytes = {word:byte(1, -1)}\n  table.sort(bytes)\n  return string.char(table.unpack(bytes))\nend\n\n-- Read in and organize the words.\n-- word_sets[<alphabetized_letter_list>] = {<words_with_those_letters>}\nlocal word_sets = {}\nlocal max_size = 0\nfor word in io.lines('unixdict.txt') do\n  local key = sort(word)\n  if word_sets[key] == nil then word_sets[key] = {} end\n  table.insert(word_sets[key], word)\n  max_size = math.max(max_size, #word_sets[key])\nend\n\n-- Print out the answer sets.\nfor _, word_set in pairs(word_sets) do\n  if #word_set == max_size then\n    for _, word in pairs(word_set) do io.write(word .. ' ') end\n    print('')  -- Finish with a newline.\n  end\nend\n"
                },
                {
                    "language": "LiveCode",
                    "solution": "on mouseUp\n   put mostCommonAnagrams(url \"http://wiki.puzzlers.org/pub/wordlists/unixdict.txt\")\nend mouseUp\n\nfunction mostCommonAnagrams X\n   put 0 into maxCount\n   repeat for each word W in X\n      get sortChars(W)\n      put W & comma after A[it]\n      add 1 to C[it]\n      if C[it] >= maxCount then\n         if C[it] > maxCount then\n            put C[it] into maxCount\n            put char 1 to -2 of A[it] into winnerList\n         else\n            put cr & char 1 to -2 of A[it] after winnerList\n         end if\n      end if\n   end repeat\n   return winnerList\nend mostCommonAnagrams\n\nfunction sortChars X\n   get charsToItems(X)\n   sort items of it\n   return itemsToChars(it)\nend sortChars\n\nfunction charsToItems X\n   repeat for each char C in X\n      put C & comma after R\n   end repeat\n   return char 1 to -2 of R\nend charsToItems\n\nfunction itemsToChars X\n   replace comma with empty in X\n   return X\nend itemsToChars\n"
                }
            ],
            [
                {
                    "language": "Zkl",
                    "solution": "URL:=\"http://wiki.puzzlers.org/pub/wordlists/unixdict.txt\";\nvar ZC=Import(\"zklCurl\");\nunixdict:=ZC().get(URL); //--> T(Data,bytes of header, bytes of trailer)\nunixdict=unixdict[0].del(0,unixdict[1]);  // remove HTTP header\nFile(\"unixdict.txt\",\"w\").write(unixdict);\n"
                },
                {
                    "language": "Python",
                    "solution": ">>> import urllib\n>>> from collections import defaultdict\n>>> words = urllib.urlopen('http://wiki.puzzlers.org/pub/wordlists/unixdict.txt').read().split()\n>>> len(words)\n25104\n>>> anagram = defaultdict(list) # map sorted chars to anagrams\n>>> for word in words:\n\tanagram[tuple(sorted(word))].append( word )\n\n\t\n>>> count = max(len(ana) for ana in anagram.itervalues())\n>>> for ana in anagram.itervalues():\n\tif len(ana) >= count:\n\t\tprint ana\n\n\t\t\n['angel', 'angle', 'galen', 'glean', 'lange']\n['alger', 'glare', 'lager', 'large', 'regal']\n['caret', 'carte', 'cater', 'crate', 'trace']\n['evil', 'levi', 'live', 'veil', 'vile']\n['elan', 'lane', 'lean', 'lena', 'neal']\n['abel', 'able', 'bale', 'bela', 'elba']\n>>> count\n5\n>>>\n"
                }
            ],
            [
                {
                    "language": "M4",
                    "solution": "divert(-1)\nchangequote(`[',`]')\ndefine([for],\n   [ifelse($#,0,[[$0]],\n   [ifelse(eval($2<=$3),1,\n   [pushdef([$1],$2)$4[]popdef([$1])$0([$1],incr($2),$3,[$4])])])])\ndefine([_bar],include(t.txt))\ndefine([eachlineA],\n   [ifelse(eval($2>0),1,\n      [$3(substr([$1],0,$2))[]eachline(substr([$1],incr($2)),[$3])])])\ndefine([eachline],[eachlineA([$1],index($1,[\n]),[$2])])\ndefine([removefirst],\n   [substr([$1],0,$2)[]substr([$1],incr($2))])\ndefine([checkfirst],\n   [ifelse(eval(index([$2],substr([$1],0,1))<0),1,\n      0,\n      [ispermutation(substr([$1],1),\n            removefirst([$2],index([$2],substr([$1],0,1))))])])\ndefine([ispermutation],\n   [ifelse([$1],[$2],1,\n      eval(len([$1])!=len([$2])),1,0,\n      len([$1]),0,0,\n      [checkfirst([$1],[$2])])])\ndefine([_set],[define($1<$2>,$3)])\ndefine([_get],[defn([$1<$2>])])\ndefine([_max],1)\ndefine([_n],0)\ndefine([matchj],\n   [_set([count],$2,incr(_get([count],$2)))[]ifelse(eval(_get([count],$2)>_max),\n         1,[define([_max],incr(_max))])[]_set([list],$2,[_get([list],$2) $1])])\ndefine([checkwordj],\n   [ifelse(ispermutation([$1],_get([word],$2)),1,[matchj([$1],$2)],\n         [addwordj([$1],incr($2))])])\ndefine([_append],\n   [_set([word],_n,[$1])[]_set([count],_n,1)[]_set([list],_n,\n         [$1 ])[]define([_n],incr(_n))])\ndefine([addwordj],\n   [ifelse($2,_n,[_append([$1])],[checkwordj([$1],$2)])])\ndefine([addword],\n   [addwordj([$1],0)])\ndivert\neachline(_bar,[addword])\n_max\nfor([x],1,_n,[ifelse(_get([count],x),_max,[_get([list],x)\n])])\n"
                },
                {
                    "language": "Stata",
                    "solution": "import delimited http://wiki.puzzlers.org/pub/wordlists/unixdict.txt, clear\nmata\na=st_sdata(.,.)\nn=rows(a)\nfor (i=1; i<=n; i++) a[i]=char(sort(ascii(a[i])',1)')\nst_addvar(st_vartype(1),\"group\")\nst_sstore(.,2,a)\nend\n\nbysort group (v1): gen k=_N\nqui sum k\nkeep if k==r(max)\nby group: replace k=_n\nreshape wide v1, i(k) j(group) string\ndrop k\nlist, noobs noheader\n"
                }
            ],
            [
                {
                    "language": "PicoLisp",
                    "solution": "(let Words NIL\n   (in \"unixdict.txt\"\n      (while (line)\n         (let (Word (pack @)  Key (pack (sort @)))\n            (if (idx 'Words Key T)\n               (push (car @) Word)\n               (set Key (list Word)) ) ) ) )\n   (flip (by length sort (mapcar val (idx 'Words)))) )\n"
                },
                {
                    "language": "F-Sharp",
                    "solution": "val it : string seq seq =\n  seq\n    [seq [\"abel\"; \"able\"; \"bale\"; \"bela\"; \"elba\"];\n     seq [\"alger\"; \"glare\"; \"lager\"; \"large\"; \"regal\"];\n     seq [\"angel\"; \"angle\"; \"galen\"; \"glean\"; \"lange\"];\n     seq [\"caret\"; \"carte\"; \"cater\"; \"crate\"; \"trace\"];\n     seq [\"elan\"; \"lane\"; \"lean\"; \"lena\"; \"neal\"];\n     seq [\"evil\"; \"levi\"; \"live\"; \"veil\"; \"vile\"]]\n"
                }
            ],
            [
                {
                    "language": "Mathematica",
                    "solution": "splits = Gather[list, Sort[Characters[#]] == Sort[Characters[#2]] &];\nmaxlen = Max[Length /@ splits];\nSelect[splits, Length[#] == maxlen &]\n"
                },
                {
                    "language": "Scheme",
                    "solution": "(import (scheme base)\n        (scheme char)\n        (scheme file)\n        (scheme write)\n        (srfi 125)  ; hash tables\n        (srfi 132)) ; sorting library\n\n;; read in the words\n(define (read-groups)\n  (with-input-from-file\n    \"unixdict.txt\"\n    (lambda ()\n      (let ((groups (hash-table string=?)))\n        (do ((line (read-line) (read-line)))\n          ((eof-object? line) groups)\n          (let* ((key (list->string (list-sort char<? (string->list line))))\n                 (val (hash-table-ref/default groups key '())))\n            (hash-table-set! groups key (cons line val))))))))\n\n;; extract the longest values from given hash-table of groups\n(define (largest-groups groups)\n  (define (find-largest grps n sofar)\n    (cond ((null? grps)\n           sofar)\n          ((> (length (car grps)) n)\n           (find-largest (cdr grps) (length (car grps)) (list (car grps))))\n          ((= (length (car grps)) n)\n           (find-largest (cdr grps) n (cons (car grps) sofar)))\n          (else\n            (find-largest (cdr grps) n sofar))))\n  (find-largest (hash-table-values groups) 0 '()))\n\n;; print results\n(for-each\n  (lambda (group)\n    (display \"[ \")\n    (for-each (lambda (word) (display word) (display \" \")) group)\n    (display \"]\\n\"))\n  (list-sort (lambda (a b) (string<? (car a) (car b)))\n             (map (lambda (grp) (list-sort string<? grp))\n                  (largest-groups (read-groups)))))\n"
                }
            ]
        ]
    },
    {
        "task_name": "Anagrams-Deranged-anagrams",
        "task_description": "Two or more words are said to be [[Anagrams|anagrams]] if they have the same characters, but in a different order. \n\nBy analogy with [[Permutations/Derangements|derangements]] we define a  ''deranged anagram'' as two words with the same characters, but in which the same character does ''not'' appear in the same position in both words.\n\n;Task\n\nUse the word list at [http://wiki.puzzlers.org/pub/wordlists/unixdict.txt unixdict] to find and display the longest deranged anagram. \n\n\n;Related\n* [[Permutations/Derangements]]\n* [[Best_shuffle|Best shuffle]]\n\n{{Related tasks/Word plays}}\n\n\n{{Template:Strings}}\n<br><br>\n\n",
        "solution_pairs": [
            [
                {
                    "language": "Ring",
                    "solution": "# Project : Anagrams/Deranged anagrams\n\nload \"stdlib.ring\"\nfn1 = \"unixdict.txt\"\n\nfp = fopen(fn1,\"r\")\nstr = fread(fp, getFileSize(fp))\nfclose(fp)\nstrlist = str2list(str)\nanagram = newlist(len(strlist), 5)\nanag = list(len(strlist))\nresult = list(len(strlist))\nfor x = 1 to len(result)\n     result[x] = 0\nnext\nfor x = 1 to len(anag)\n     anag[x] = 0\nnext\nfor x = 1 to len(anagram)\n      for y = 1 to 5\n           anagram[x][y] = 0\n      next\nnext\n\nstrbig = 1\nfor n = 1 to len(strlist)\n     for m = 1 to len(strlist)\n           sum = 0\n           if len(strlist[n]) = len(strlist[m]) and n != m\n              for p = 1 to len(strlist[m])\n                    temp1 = count(strlist[n], strlist[m][p])\n                    temp2 = count(strlist[m], strlist[m][p])\n                    if temp1 = temp2\n                       sum = sum + 1\n                    ok\n              next\n              if sum = len(strlist[n])\n                 anag[n] = anag[n] + 1\n                 if anag[n] < 6 and result[n] = 0 and result[m] = 0\n                    anagram[n][anag[n]] = strlist[m]\n                    if len(strlist[m]) > len(strlist[strbig])\n                       strbig = n\n                    ok\n                      result[m] = 1\n                  ok\n               ok\n            ok\n      next\n      if anag[n] > 0\n         result[n] = 1\n      ok\nnext\n\nflag = 0\nfor m = 1 to 5\n     if anagram[strbig][m] != 0\n        if m = 1\n           see strlist[strbig] +  \" \"\n           flag = 1\n        ok\n        see anagram[strbig][m] + \" \"\n     ok\nnext\n\nfunc getFileSize fp\n       c_filestart = 0\n       c_fileend = 2\n       fseek(fp,0,c_fileend)\n       nfilesize = ftell(fp)\n       fseek(fp,0,c_filestart)\n       return nfilesize\n\nfunc count(astring,bstring)\n       cnt = 0\n       while substr(astring,bstring) > 0\n                cnt = cnt + 1\n                astring = substr(astring,substr(astring,bstring)+len(string(sum)))\n       end\n       return cnt\n"
                },
                {
                    "language": "Delphi",
                    "solution": "program Anagrams_Deranged;\n\n{$APPTYPE CONSOLE}\n\n{$R *.res}\n\nuses\n  System.SysUtils,\n  System.Classes,\n  System.Diagnostics;\n\nfunction Sort(s: string): string;\nvar\n  c: Char;\n  i, j, aLength: Integer;\nbegin\n  aLength := s.Length;\n\n  if aLength = 0 then\n    exit('');\n\n  Result := s;\n\n  for i := 1 to aLength - 1 do\n    for j := i + 1 to aLength do\n      if result[i] > result[j] then\n      begin\n        c := result[i];\n        result[i] := result[j];\n        result[j] := c;\n      end;\nend;\n\nfunction IsAnagram(s1, s2: string): Boolean;\nbegin\n  if s1.Length <> s2.Length then\n    exit(False);\n\n  Result := Sort(s1) = Sort(s2);\n\nend;\n\nfunction CompareLength(List: TStringList; Index1, Index2: Integer): Integer;\nbegin\n  result := List[Index1].Length - List[Index2].Length;\n  if Result = 0 then\n    Result := CompareText(Sort(List[Index2]), Sort(List[Index1]));\nend;\n\nfunction IsDerangement(word1, word2: string): Boolean;\nvar\n  i: Integer;\nbegin\n  for i := 1 to word1.Length do\n    if word1[i] = word2[i] then\n      exit(False);\n  Result := True;\nend;\n\nvar\n  Dict: TStringList;\n  Count, Index: Integer;\n  words: string;\n  StopWatch: TStopwatch;\n\nbegin\n  StopWatch := TStopwatch.Create;\n  StopWatch.Start;\n\n  Dict := TStringList.Create();\n  Dict.LoadFromFile('unixdict.txt');\n\n  Dict.CustomSort(CompareLength);\n\n  Index := Dict.Count - 1;\n  words := '';\n  Count := 1;\n\n  while Index - Count >= 0 do\n  begin\n    if IsAnagram(Dict[Index], Dict[Index - Count]) then\n    begin\n      if IsDerangement(Dict[Index], Dict[Index - Count]) then\n      begin\n        words := Dict[Index] + ' - ' + Dict[Index - Count];\n        Break;\n      end;\n      Inc(Count);\n    end\n    else\n    begin\n      Dec(Index, Count);\n      Count := 1;\n    end;\n  end;\n\n  StopWatch.Stop;\n\n  Writeln(Format('Time pass: %d ms [i7-4500U Windows 7]', [StopWatch.ElapsedMilliseconds]));\n\n  writeln(#10'Longest derangement words are:'#10#10, words);\n\n  Dict.Free;\n  Readln;\nend.\n"
                }
            ],
            [
                {
                    "language": "C++",
                    "solution": "#include <algorithm>\n#include <fstream>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <set>\n#include <string>\n\nbool is_deranged(const std::string& left, const std::string& right)\n{\n    return (left.size() == right.size()) &&\n        (std::inner_product(left.begin(), left.end(), right.begin(), 0, std::plus<int>(), std::equal_to<char>()) == 0);\n}\n\nint main()\n{\n    std::ifstream input(\"unixdict.txt\");\n    if (!input) {\n        std::cerr << \"can't open input file\\n\";\n        return EXIT_FAILURE;\n    }\n\n    typedef std::set<std::string> WordList;\n    typedef std::map<std::string, WordList> AnagraMap;\n    AnagraMap anagrams;\n\n    std::pair<std::string, std::string> result;\n    size_t longest = 0;\n\n    for (std::string value; input >> value; /**/) {\n        std::string key(value);\n        std::sort(key.begin(), key.end());\n\n        if (longest < value.length()) { // is it a long candidate?\n            if (0 < anagrams.count(key)) { // is it an anagram?\n                for (const auto& prior : anagrams[key]) {\n                    if (is_deranged(prior, value)) { // are they deranged?\n                        result = std::make_pair(prior, value);\n                        longest = value.length();\n                    }\n                }\n            }\n        }\n        anagrams[key].insert(value);\n    }\n\n    std::cout << result.first << ' ' << result.second << '\\n';\n    return EXIT_SUCCESS;\n}\n"
                },
                {
                    "language": "11l",
                    "solution": "F is_not_deranged(s1, s2)\n   L(i) 0 .< s1.len\n      I s1[i] == s2[i]\n         R 1B\n   R 0B\n\nDict[String, Array[String]] anagram\nV count = 0\nL(word) File(\u00e2\u20ac\u02dcunixdict.txt\u00e2\u20ac\u2122).read().split(\"\\n\")\n   V a = sorted(word)\n   I a !C anagram\n      anagram[a] = [word]\n   E\n      L(ana) anagram[a]\n         I is_not_deranged(ana, word)\n            L.break\n      L.was_no_break\n         anagram[a].append(word)\n         count = max(count, word.len)\n\nL(ana) anagram.values()\n   I ana.len > 1 & ana[0].len == count\n      print(ana)\n"
                }
            ],
            [
                {
                    "language": "R",
                    "solution": "puzzlers.dict <- readLines(\"http://www.puzzlers.org/pub/wordlists/unixdict.txt\")\n\nlongest.deranged.anagram <- function(dict=puzzlers.dict) {\n  anagram.groups <- function(word.group) {\n    sorted <- sapply(lapply(strsplit(word.group,\"\"),sort),paste, collapse=\"\")\n    grouped <- tapply(word.group, sorted, force, simplify=FALSE)\n    grouped <- grouped[sapply(grouped, length) > 1]\n    grouped[order(-nchar(names(grouped)))]\n  }\n\n  derangements <- function(anagram.group) {\n    pairs <- expand.grid(a = anagram.group, b = anagram.group,\n                         stringsAsFactors=FALSE)\n    pairs <- subset(pairs, a < b)\n    deranged <- with(pairs, mapply(function(a,b) all(a!=b),\n                                   strsplit(a,\"\"), strsplit(b,\"\")))\n    pairs[which(deranged),]\n  }\n\n  for (anagram.group in anagram.groups(dict)) {\n    if (nrow(d <- derangements(anagram.group)) > 0) {\n      return(d[1,])\n    }\n  }\n}\n"
                },
                {
                    "language": "J",
                    "solution": "   #words=: 'b' freads 'unixdict.txt'\n25104\n   #anagrams=: (#~ 1 < #@>) (</.~ /:~&>) words\n1303\n   #maybederanged=: (#~ (1 -.@e. #@~.\"1)@|:@:>&>) anagrams\n432\n   #longest=: (#~ [: (= >./) #@>@{.@>) maybederanged\n1\n   longest\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u2502\n\u2502\u2502excitation\u2502intoxicate\u2502\u2502\n\u2502\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"
                }
            ],
            [
                {
                    "language": "Sidef",
                    "solution": "func find_deranged(Array a) {\n    for i in (^a) {\n        for j in (i+1 .. a.end) {\n            overlaps(a[i], a[j]) || (\n                printf(\"length %d: %s => %s\\n\", a[i].len, a[i], a[j])\n                return true\n            )\n        }\n    }\n    return false\n}\n\nfunc main(File file) {\n\n    file.open_r(\\var fh, \\var err) ->\n        || die \"Can't open file `#{file}' for reading: #{err}\\n\"\n\n    var letter_list = Hash()\n\n    # Store anagrams in hash table by letters they contain\n    fh.words.each { |word|\n        letter_list{word.sort} := [] << word\n    }\n\n    letter_list.keys                        \\\n         .grep {|k| letter_list{k}.len > 1} \\     # take only ones with anagrams\n         .sort {|a,b| b.len <=> a.len}      \\     # sort by length, descending\n         .each {|key|\n\n        # If we find a pair, they are the longested due to the sort before\n        find_deranged(letter_list{key}) && break\n    }\n}\n\nmain(%f'/tmp/unixdict.txt')\n"
                },
                {
                    "language": "Groovy",
                    "solution": "def map = new TreeMap<Integer,Map<String,List<String>>>()\n\nnew URL('http://www.puzzlers.org/pub/wordlists/unixdict.txt').eachLine { word ->\n    def size = - word.size()\n    map[size] = map[size] ?: new TreeMap<String,List<String>>()\n    def norm = word.toList().sort().sum()\n    map[size][norm] = map[size][norm] ?: []\n    map[size][norm] << word\n}\n\ndef result = map.findResult { negasize, normMap ->\n    def size = - negasize\n    normMap.findResults { x, anagrams ->\n        def n = anagrams.size()\n        (0..<(n-1)).findResults { i ->\n            ((i+1)..<n).findResult { j ->\n                (0..<size).every { k -> anagrams[i][k] != anagrams[j][k] } \\\n                    ? anagrams[i,j]\n                    : null\n            }\n        }?.flatten() ?: null\n    }?.flatten() ?: null\n}\n\nif (result) {\n    println \"Longest deranged anagram pair: ${result}\"\n} else {\n    println 'Deranged anagrams are a MYTH!'\n}\n"
                }
            ],
            [
                {
                    "language": "Sidef",
                    "solution": "func find_deranged(Array a) {\n    for i in (^a) {\n        for j in (i+1 .. a.end) {\n            overlaps(a[i], a[j]) || (\n                printf(\"length %d: %s => %s\\n\", a[i].len, a[i], a[j])\n                return true\n            )\n        }\n    }\n    return false\n}\n\nfunc main(File file) {\n\n    file.open_r(\\var fh, \\var err) ->\n        || die \"Can't open file `#{file}' for reading: #{err}\\n\"\n\n    var letter_list = Hash()\n\n    # Store anagrams in hash table by letters they contain\n    fh.words.each { |word|\n        letter_list{word.sort} := [] << word\n    }\n\n    letter_list.keys                        \\\n         .grep {|k| letter_list{k}.len > 1} \\     # take only ones with anagrams\n         .sort {|a,b| b.len <=> a.len}      \\     # sort by length, descending\n         .each {|key|\n\n        # If we find a pair, they are the longested due to the sort before\n        find_deranged(letter_list{key}) && break\n    }\n}\n\nmain(%f'/tmp/unixdict.txt')\n"
                },
                {
                    "language": "AArch64-Assembly",
                    "solution": "/* ARM assembly AARCH64 Raspberry PI 3B */\n/*  program anaderan64.s   */\n\n/*******************************************/\n/* Constantes file                         */\n/*******************************************/\n/* for this file see task include a file in language AArch64 assembly*/\n.include \"../includeConstantesARM64.inc\"\n\n.equ MAXI,         50000\n.equ BUFFERSIZE,   300000\n\n/*********************************/\n/* Structures                    */\n/*********************************/\n/* this structure has size multiple de 8 */\n/* see task anagram for program not use structure */\n    .struct  0\nWord_Ptr_buffer:                           // p.quader word buffer\n    .struct  Word_Ptr_buffer + 8\nWord_Ptr_sorted:                           // p.quader word sorted letters\n    .struct  Word_Ptr_sorted + 8\nWord_length:                               // word length\n    .struct  Word_length + 8\nWord_top:                                  // top\n    .struct  Word_top + 8\nWord_end:\n/*********************************/\n/* Initialized data              */\n/*********************************/\n.data\nszFileName:           .asciz \"./unixdict.txt\"\n//szFileName:           .asciz \"./listwordT.txt\"\nszMessErreur:         .asciz \"FILE ERROR.\"\nszMessStart:          .asciz \"Program 64 bits start.\\n\"\nszCarriageReturn:     .asciz \"\\n\"\nszMessSpace:          .asciz \" \"\n\nptBuffex1:            .quad sBuffex1\n/*********************************/\n/* UnInitialized data            */\n/*********************************/\n.bss\ntbStWords:                  .skip Word_end * MAXI\nqNBword:                    .skip 8\nsBuffer:                    .skip BUFFERSIZE\nsBuffex1:                   .skip BUFFERSIZE\n\n/*********************************/\n/*  code section                 */\n/*********************************/\n.text\n.global main\nmain:                      // entry of program\n    ldr x0,qAdrszMessStart\n    bl affichageMess\n    mov x4,#0              // loop indice\n    mov x0,AT_FDCWD        // current directory\n    ldr x1,qAdrszFileName  // file name\n    mov x2,#O_RDWR         // flags\n    mov x3,#0              // mode\n    mov x8,#OPEN           //\n    svc 0\n    cmp x0,#0              // error open\n    ble 99f\n    mov x9,x0              // FD save Fd\n    ldr x1,qAdrsBuffer     // buffer address\n    ldr x2,qSizeBuf        // buffersize\n    mov x8, #READ\n    svc 0\n    cmp x0,#0              // error read ?\n    blt 99f\n    mov x5,x0              // save size read bytes\n    ldr x4,qAdrsBuffer     // buffer address\n    ldr x0,qAdrsBuffer     // start word address\n    mov x2,#0\n    mov x1,#0              // word length\n1:\n    cmp x2,x5\n    bge 2f\n    ldrb w3,[x4,x2]\n    cmp w3,#0xD            // end word ?\n    cinc x1,x1,ne          // increment word length\n    cinc x2,x2,ne          // increment indice\n    bne 1b                 // and loop\n    strb wzr,[x4,x2]        // store final zero\n    bl anaWord             // sort word letters\n    add x2,x2,#2           // jump OD and 0A\n    add x0,x4,x2           // new address begin word\n    mov x1,#0              // init length\n    b 1b                   // and loop\n\n2:\n    strb wzr,[x4,x2]       // last word\n    bl anaWord\n\n    mov x0,x9              // file Fd\n    mov x8, #CLOSE\n    svc 0\n    cmp x0,#0              // error close ?\n    blt 99f\n\n    ldr x0,qAdrtbStWords   // array structure words address\n    mov x1,#0              // first indice\n    ldr x2,qAdrqNBword\n    ldr x2,[x2]            // last indice\n    bl triRapide           // quick sort\n    ldr x4,qAdrtbStWords   // array structure words address\n    mov x0,x4\n    mov x9,x2                     // size word array\n    mov x8,#0                     // indice first occurence\n    ldr x3,[x4,#Word_Ptr_sorted]  // load first value\n    mov x2,#1                     // loop indice\n    mov x10,#Word_end             // words structure size\n    mov x12,#0                    // max word length\n3:                                // begin loop\n    madd x7,x2,x10,x4              // compute array index\n    ldr x5,[x7,#Word_Ptr_sorted]  // load next value\n    mov x0,x3\n    mov x1,x5\n    bl comparStrings\n    cmp x0,#0                     // sorted strings equal ?\n    bne 4f\n    madd x11,x8,x10,x4\n    ldr x0,[x11,#Word_Ptr_buffer] // address word 1\n    ldr x1,[x7,#Word_Ptr_buffer]  // address word 2\n    bl controlLetters\n    cmp x0,#0                     // not ok ?\n    beq 5f\n    mov x0,#1                     // letters ok\n    str x0,[x7,#Word_top]         // store top in first occurence\n    str x0,[x11,#Word_top]        // store top in current occurence\n    ldr x0,[x7,#Word_length]      // word length\n    cmp x0,x12                    // compare maxi\n    csel x12,x0,x12,gt            // yes  length word -> value max\n    b 5f\n4:                                // no\n    mov x0,x8\n    add x8,x8,#1                  // init index  new first occurence\n    madd x11,x8,x10,x4             // compute array index\n    ldr x3,[x11,#Word_Ptr_sorted] // init value new first occurence\n    mov x2,x0                     // reprise au debut de la sequence\n5:\n    add x2,x2,#1                  // increment indice\n    cmp x2,x9                     // end word array ?\n    blt 3b                        // no -> loop\n\n    mov x2,#0                     // raz indice\n    ldr x4,qAdrtbStWords          // array structure words address\n6:                                // begin display loop\n    madd x11,x2,x10,x4             // compute array index\n    ldr x6,[x11,#Word_top]        // load top\n    cmp x6,#0                     // top ok ?\n    beq 7f\n    ldr x6,[x11,#Word_length]     // load length\n    cmp x6,x12                    // compare maxi\n    bne 7f\n    ldr x0,[x11,#Word_Ptr_buffer] // load address first word\n    bl affichageMess              // display first word\n    add x2,x2,#1                  // increment indice\n\n    madd x11,x2,x10,x4             // compute array index\n    ldr x6,[x11,#Word_top]        // load top\n    cmp x6,#0                     // top ok ?\n    beq 7f\n    ldr x0,qAdrszMessSpace\n    bl affichageMess\n    ldr x0,[x11,#Word_Ptr_buffer] // load address other word\n    bl affichageMess              // display second word\n\n    ldr x0,qAdrszCarriageReturn\n    bl affichageMess\n7:\n    add x2,x2,#1                  // increment indice\n    cmp x2,x9                     // maxi ?\n    blt 6b                        // no -> loop\n\n    b 100f\n99:                               // display error\n    ldr x0,qAdrszMessErreur\n    bl affichageMess\n\n100:                              // standard end of the program\n    mov x0, #0                    // return code\n    mov x8, #EXIT                 // request to exit program\n    svc #0                        // perform the system call\nqAdrszCarriageReturn:        .quad szCarriageReturn\nqAdrszFileName:              .quad szFileName\nqAdrszMessErreur:            .quad szMessErreur\nqAdrsBuffer:                 .quad sBuffer\nqSizeBuf:                    .quad BUFFERSIZE\nqAdrszMessSpace:             .quad szMessSpace\nqAdrtbStWords:               .quad tbStWords\nqAdrszMessStart:             .quad szMessStart\n/******************************************************************/\n/*     analizing word                                   */\n/******************************************************************/\n/*  x0  word address */\n/*  x1 word length   */\nanaWord:\n    stp x1,lr,[sp,-16]!           // save  registers\n    stp x2,x3,[sp,-16]!           // save  registers\n    stp x4,x5,[sp,-16]!           // save  registers\n    stp x6,x7,[sp,-16]!           // save  registers\n    mov x5,x0\n    mov x6,x1\n    ldr x1,qAdrtbStWords\n    ldr x2,qAdrqNBword\n    ldr x3,[x2]\n    mov x4,#Word_end\n    madd x1,x3,x4,x1\n    str x0,[x1,#Word_Ptr_buffer]\n    mov x0,#0\n    str x0,[x1,#Word_top]\n    str x6,[x1,#Word_length]\n    ldr x4,qAdrptBuffex1\n    ldr x0,[x4]\n    add x6,x6,x0\n    add x6,x6,#1\n    str x6,[x4]\n    str x0,[x1,#Word_Ptr_sorted]\n\n    add x3,x3,#1\n    str x3,[x2]\n    mov x1,x0\n    mov x0,x5\n    bl triLetters         // sort word letters\n    mov x2,#0\n100:\n    ldp x6,x7,[sp],16              // restaur  2 registers\n    ldp x4,x5,[sp],16              // restaur  2 registers\n    ldp x2,x3,[sp],16              // restaur  2 registers\n    ldp x1,lr,[sp],16              // restaur  2 registers\n    ret                            // return to address lr x30\nqAdrqNBword:            .quad qNBword\nqAdrptBuffex1:          .quad ptBuffex1\n/******************************************************************/\n/*     sort word letters                                  */\n/******************************************************************/\n/* x0  address begin word */\n/* x1  address recept array */\ntriLetters:\n    stp x1,lr,[sp,-16]!           // save  registers\n    stp x2,x3,[sp,-16]!           // save  registers\n    stp x4,x5,[sp,-16]!           // save  registers\n    stp x6,x7,[sp,-16]!           // save  registers\n    mov x2,#0\n1:\n    ldrb w3,[x0,x2]         // load letter\n    cmp w3,#0               // end word ?\n    beq 6f\n    cmp x2,#0               // first letter ?\n    bne 2f\n    strb w3,[x1,x2]         // yes store in first position\n    add x2,x2,#1            // increment indice\n    b 1b                    // and loop\n2:\n    mov x4,#0\n3:                          // begin loop to search insertion position\n    ldrb w5,[x1,x4]         // load letter\n    cmp w3,w5               // compare\n    blt 4f                  // to low -> insertion\n    add x4,x4,#1            // increment indice\n    cmp x4,x2               // compare to letters number in place\n    blt 3b                  // search loop\n    strb w3,[x1,x2]         // else store in last position\n    add x2,x2,#1\n    b 1b                    // and loop\n4:                          // move first letters in one position\n    sub x6,x2,#1            // start indice\n5:\n    ldrb w5,[x1,x6]         // load letter\n    add x7,x6,#1            // store indice - 1\n    strb w5,[x1,x7]         // store letter\n    sub x6,x6,#1            // decrement indice\n    cmp x6,x4               // end ?\n    bge 5b                  // no loop\n    strb w3,[x1,x4]         // else store letter in free position\n    add x2,x2,#1\n    b 1b                    // and loop\n6:\n    strb wzr,[x1,x2]        // final z\u00c3\u00a9ro\n100:\n    ldp x6,x7,[sp],16              // restaur  2 registers\n    ldp x4,x5,[sp],16              // restaur  2 registers\n    ldp x2,x3,[sp],16              // restaur  2 registers\n    ldp x1,lr,[sp],16              // restaur  2 registers\n    ret                            // return to address lr x30\n/******************************************************************/\n/*     control letters                                  */\n/******************************************************************/\n/* x0  address  word 1*/\n/* x1  address  word 2 */\ncontrolLetters:\n    stp x1,lr,[sp,-16]!           // save  registers\n    stp x2,x3,[sp,-16]!           // save  registers\n    stp x4,x5,[sp,-16]!           // save  registers\n    mov x2,#0\n    mov x5,x0\n1:\n    ldrb w3,[x5,x2]      // load a letter\n    cmp w3,#0            // end word ?\n    cset x0,eq\n   // moveq x0,#1          //  yes it is OK\n    beq 100f\n    ldrb w4,[x1,x2]      // load a letter word 2 same position\n    cmp w3,w4            // equal ?\n    cset x0,ne           // yes -> not good\n    //moveq x0,#0          // yes -> not good\n    beq 100f\n    add x2,x2,#1\n    b 1b\n100:\n    ldp x4,x5,[sp],16              // restaur  2 registers\n    ldp x2,x3,[sp],16              // restaur  2 registers\n    ldp x1,lr,[sp],16              // restaur  2 registers\n    ret                            // return to address lr x30\n/***************************************************/\n/*   Appel r\u00c3\u00a9cursif Tri Rapide quicksort           */\n/***************************************************/\n/* x0 contains the address of table */\n/* x1 contains index of first item  */\n/* x2 contains the number of elements  > 0  */\ntriRapide:\n    stp x1,lr,[sp,-16]!           // save  registers\n    stp x2,x3,[sp,-16]!           // save  registers\n    stp x4,x5,[sp,-16]!           // save  registers\n    sub x2,x2,#1               // last item index\n    cmp x1,x2               // first > last ?\n    bge 100f                // yes -> end\n    mov x4,x0               // save x0\n    mov x5,x2               // save x2\n    bl partition1           // cutting.quado 2 parts\n    mov x2,x0               // index partition\n    mov x0,x4               // table address\n    bl triRapide            // sort lower part\n    mov x0,x4               // table address\n    add x1,x2,#1            // index begin = index partition + 1\n    add x2,x5,#1            // number of elements\n    bl triRapide            // sort higter part\n\n 100:                       // end function\n    ldp x4,x5,[sp],16       // restaur  2 registers\n    ldp x2,x3,[sp],16       // restaur  2 registers\n    ldp x1,lr,[sp],16       // restaur  2 registers\n    ret                     // return to address lr x30\n\n/******************************************************************/\n/*      Partition table elements                                */\n/******************************************************************/\n/* x0 contains the address of table */\n/* x1 contains index of first item  */\n/* x2 contains index of last item   */\npartition1:\n    stp x1,lr,[sp,-16]!     // save  registers\n    stp x2,x3,[sp,-16]!     // save  registers\n    stp x4,x5,[sp,-16]!     // save  registers\n    stp x6,x7,[sp,-16]!     // save  registers\n    stp x8,x9,[sp,-16]!     // save  registers\n    mov x8,x0               // save address table 2\n    mov x7,x2\n    mov x9,#Word_end\n    madd x3,x7,x9,x8\n    ldr x6,[x3,#Word_Ptr_sorted]  // load string address last index\n    mov x4,x1               // init with first index\n    mov x5,x1               // init with first index\n1:                          // begin loop\n    madd x3,x5,x9,x8\n    ldr x0,[x3,#Word_Ptr_sorted]   // load current string address\n    mov x1,x6                      // first string address\n    bl comparStrings\n    cmp x0,#0\n    bge 2f\n    mov x0,x8                // current string < first string\n    mov x1,x4                // swap array\n    mov x2,x5\n    bl swapWord\n    add x4,x4,#1             // and increment index 1\n2:\n    add x5,x5,#1             // increment index 2\n    cmp x5,x7                // end ?\n    blt 1b                   // no -> loop\n\n    mov x0,x8                // and swap array\n    mov x1,x4\n    mov x2,x7\n    bl swapWord\n\n    mov x0,x4                // return index partition\n100:\n    ldp x8,x9,[sp],16       // restaur  2 registers\n    ldp x6,x7,[sp],16       // restaur  2 registers\n    ldp x4,x5,[sp],16       // restaur  2 registers\n    ldp x2,x3,[sp],16       // restaur  2 registers\n    ldp x1,lr,[sp],16       // restaur  2 registers\n    ret                     // return to address lr x30\n/******************************************************************/\n/*      Swap table elements                                */\n/******************************************************************/\n/* x0 contains the address of table */\n/* x1 contains index 1  */\n/* x2 contains index  2   */\nswapWord:\n    stp x1,lr,[sp,-16]!           // save  registers\n    stp x2,x3,[sp,-16]!           // save  registers\n    stp x4,x5,[sp,-16]!           // save  registers\n    stp x6,x7,[sp,-16]!           // save  registers\n    mov x3,#Word_end\n    madd x4,x1,x3,x0        // compute array index\n    madd x5,x2,x3,x0\n    mov x6,#0\n1:\n    ldr x2,[x4,x6]         // load 4 bytes\n    ldr x3,[x5,x6]\n    str x2,[x5,x6]         // store 4 bytes\n    str x3,[x4,x6]\n    add x6,x6,#8           // increment 4 bytes\n    cmp x6,#Word_end       // structure size is multiple to 4\n    blt 1b\n100:\n    ldp x6,x7,[sp],16              // restaur  2 registers\n    ldp x4,x5,[sp],16              // restaur  2 registers\n    ldp x2,x3,[sp],16              // restaur  2 registers\n    ldp x1,lr,[sp],16              // restaur  2 registers\n    ret                            // return to address lr x30\n\n/************************************/\n/* Strings case sensitive comparisons  */\n/************************************/\n/* x0 et x1 contains the address of strings */\n/* return 0 in x0 if equals */\n/* return -1 if string x0 < string x1 */\n/* return 1  if string x0 > string x1 */\ncomparStrings:\n    stp x1,lr,[sp,-16]! // save  registers\n    stp x2,x3,[sp,-16]! // save  registers\n    stp x4,x5,[sp,-16]! // save  registers\n    mov x2,#0           // counter\n1:\n    ldrb w3,[x0,x2]     // byte string 1\n    ldrb w4,[x1,x2]     // byte string 2\n    cmp w3,w4\n    blt 2f              // small\n    bgt 3f              // greather\n    cmp x3,#0           // 0 end string\n    beq 4f              // end string\n    add x2,x2,#1        // else add 1 in counter\n    b 1b                // and loop\n2:\n    mov x0,#-1          // small\n    b 100f\n3:\n    mov x0,#1           // greather\n    b 100f\n4:\n   mov x0,#0            // equal\n100:\n    ldp x4,x5,[sp],16   // restaur  2 registers\n    ldp x2,x3,[sp],16   // restaur  2 registers\n    ldp x1,lr,[sp],16   // restaur  2 registers\n    ret                 // return to address lr x30\n\n/********************************************************/\n/*        File Include fonctions                        */\n/********************************************************/\n/* for this file see task include a file in language AArch64 assembly */\n.include \"../includeARM64.inc\"\n"
                }
            ]
        ]
    },
    {
        "task_name": "Angle-difference-between-two-bearings",
        "task_description": "Finding the angle between two bearings is often confusing.<ref>[https://stackoverflow.com/questions/16180595/find-the-angle-between-two-bearings]</ref>\n\n\n;Task:\nFind the angle which is the result of the subtraction '''b2 - b1''', where '''b1''' and '''b2''' are the bearings. \n\n<br>Input bearings are expressed in the range &nbsp; '''-180''' &nbsp; to &nbsp; '''+180''' &nbsp; degrees. \n<br>The &nbsp;result&nbsp; is also expressed in the range &nbsp; '''-180''' &nbsp; to &nbsp; '''+180''' &nbsp; degrees. \n\n\nCompute the angle for the following pairs:\n*  20 degrees ('''b1''') and 45 degrees ('''b2''')\n* -45 and  45\n* -85 and  90\n* -95 and  90\n* -45 and 125\n* -45 and 145\n*  29.4803 and  -88.6381\n* -78.3251 and -159.036\n\n\n;Optional extra:  \nAllow the input bearings to be any (finite) value. \n\n\n;Test cases:\n*  -70099.74233810938   and   29840.67437876723\n* -165313.6666297357    and   33693.9894517456\n*    1174.8380510598456 and -154146.66490124757\n*   60175.77306795546   and   42213.07192354373\n<br><br>\n\n",
        "solution_pairs": [
            [
                {
                    "language": "Erlang",
                    "solution": "-module(bearings).\n\n%% API\n-export([angle_sub_degrees/2,test/0]).\n\n-define(RealAngleMultiplier,16#10000000000).\n-define(DegreesPerTurn,360).\n-define(Precision,9).\n%%%===================================================================\n%%% API\n%%%===================================================================\n\n%%--------------------------------------------------------------------\n%% @doc\n%% @spec\n%% @end\n%%--------------------------------------------------------------------\n%%\nangle_sub_degrees(B1,B2) when is_integer(B1), is_integer(B2) ->\n    angle_sub(B2-B1,?DegreesPerTurn);\nangle_sub_degrees(B1,B2) ->\n    NewB1 = trunc(B1*?RealAngleMultiplier),\n    NewB2 = trunc(B2*?RealAngleMultiplier),\n    round(angle_sub(NewB2 - NewB1,\n\t      ?DegreesPerTurn*?RealAngleMultiplier)\n\t/?RealAngleMultiplier,?Precision).\n\n%%%===================================================================\n%%% Internal functions\n%%%===================================================================\n\n%% delta normalises the angle difference.  Consider a turn from 350 degrees\n%% to 20 degrees.  Subtraction results in 330 degress.  This is equivalent of\n%% a turn in the other direction of 30 degrees, thus 330 degrees is equal\n%% to -30 degrees.\n\n\nangle_sub(Value,TurnSize) ->\n    NormalisedValue = Value rem TurnSize,\n    minimise_angle(NormalisedValue,TurnSize).\n\n% X rem Turn result in 0..Turn for X > 0 and -Turn..0 for X < 0\n% specification requires -Turn/2 < X < Turn/2.  This is achieved\n% by adding or removing a turn as required.\n% bsr 1 divides an integer by 2\nminimise_angle(Angle,Turn) when Angle + (Turn bsr 1) < 0 ->\n    Angle+Turn;\nminimise_angle(Angle,Turn) when Angle - (Turn bsr 1) > 0 ->\n    Angle-Turn;\nminimise_angle(Angle,_) ->\n    Angle.\n\nround(Number,Precision) ->\n    P = math:pow(10,Precision),\n    round(Number*P)/P.\n\ntest() ->\n    25 = angle_sub_degrees(20,45),\n    90 = angle_sub_degrees(-45,45),\n    175 = angle_sub_degrees(-85,90),\n    -175 = angle_sub_degrees(-95,90),\n    170 = angle_sub_degrees(-45,125),\n    -170 = angle_sub_degrees(-45,145),\n    -118.1184 = angle_sub_degrees( 29.4803,-88.6381),\n    -139.583283124=angle_sub_degrees(-70099.742338109,29840.674378767),\n    -72.343918514=angle_sub_degrees( -165313.66662974,33693.989451746),\n    -161.50295231=angle_sub_degrees(  1174.8380510598,-154146.66490125),\n    37.298855589=angle_sub_degrees(  60175.773067955,42213.071923544),\n\n    passed.\n"
                },
                {
                    "language": "Python",
                    "solution": "'''Difference between two bearings'''\n\nfrom math import (acos, cos, pi, sin)\n\n\n# bearingDelta :: Radians -> Radians -> Radians\ndef bearingDelta(ar):\n    '''Difference between two bearings,\n       expressed in radians.'''\n    def go(br):\n        [(ax, ay), (bx, by)] = [\n            (sin(x), cos(x)) for x in [ar, br]\n        ]\n        # cross-product > 0 ?\n        sign = +1 if 0 < ((ay * bx) - (by * ax)) else -1\n        # sign * dot-product\n        return sign * acos((ax * bx) + (ay * by))\n    return lambda br: go(br)\n\n\n# TEST ----------------------------------------------------\n# main :: IO ()\ndef main():\n    '''Test and display'''\n\n    # showMap :: Degrees -> Degrees -> String\n    def showMap(da, db):\n        return unwords(\n            str(x).rjust(n) for n, x in\n            [\n                (22, str(da) + ' +'),\n                (24, str(db) + '  -> '),\n                (7, round(\n                    degrees(\n                        bearingDelta\n                        (radians(da))\n                        (radians(db))\n                    ), 2)\n                 )\n            ]\n        )\n\n    print(__doc__ + ':')\n    print(\n        unlines(showMap(a, b) for a, b in [\n            (20, 45),\n            (-45, 45),\n            (-85, 90),\n            (-95, 90),\n            (-45, 125),\n            (-45, 145),\n            (-70099.74233810938, 29840.67437876723),\n            (-165313.6666297357, 33693.9894517456),\n            (1174.8380510598456, -154146.66490124757),\n            (60175.77306795546, 42213.07192354373)\n        ]))\n\n\n# GENERIC ----------------------------------------------\n\n\n# radians :: Float x => Degrees x -> Radians x\ndef radians(x):\n    '''Radians derived from degrees.'''\n    return pi * x / 180\n\n\n# degrees :: Float x => Radians x -> Degrees x\ndef degrees(x):\n    '''Degrees derived from radians.'''\n    return 180 * x / pi\n\n\n# unlines :: [String] -> String\ndef unlines(xs):\n    '''A single newline-delimited string derived\n       from a list of strings.'''\n    return '\\n'.join(xs)\n\n\n# unwords :: [String] -> String\ndef unwords(xs):\n    '''A space-separated string derived from\n       a list of words.'''\n    return ' '.join(xs)\n\n\nif __name__ == '__main__':\n    main()\n"
                }
            ],
            [
                {
                    "language": "Klingphix",
                    "solution": "include ..\\Utilitys.tlhy\n\n:bearing sub 360 mod 540 add 360 mod 180 sub ;\n\n20 45 bearing\n-45 45 bearing\n-85 90 bearing\n-95 90 bearing\n-45 125 bearing\n-45 145 bearing\n29.4803 -88.6381 bearing\n-78.3251 -159.036 bearing\n-70099.74233810938 29840.67437876723 bearing\n-165313.6666297357 33693.9894517456 bearing\n1174.8380510598456 -154146.66490124757 bearing\n60175.77306795546 42213.07192354373 bearing\n\npstack\n\n\" \" input\n"
                },
                {
                    "language": "ALGOL-68",
                    "solution": "BEGIN # angle difference between 2 bearings - translated from the 11l sample #\n\n    PROC wrap = (REAL v, l1, l2 )REAL:\n         BEGIN\n            REAL result := v;\n            WHILE result < l1 DO result +:= 2 * l2 OD;\n            WHILE result > l2 DO result +:= 2 * l1 OD;\n            result\n         END # wrap # ;\n\n    PROC get_difference = ( REAL b1, b2 )REAL: wrap( b2 - b1, -180.0, 180.0 );\n\n    OP   FMT = ( REAL v )STRING:\n         BEGIN\n            STRING result := fixed( ABS v, 0, 3 );\n            IF result[ LWB result ] = \".\" THEN \"0\" +=: result FI;\n            WHILE result[ UPB result ] = \"0\" DO result := result[ : UPB result - 1 ] OD;\n            IF result[ UPB result ] = \".\" THEN result := result[ : UPB result - 1 ] FI;\n            IF v < 0 THEN \"-\" ELSE \" \" FI + result\n         END # FMT # ;\n\n    print( ( FMT get_difference(  20.0,  45.0 ),       newline ) );\n    print( ( FMT get_difference( -45.0,  45.0 ),       newline ) );\n    print( ( FMT get_difference( -85.0,  90.0 ),       newline ) );\n    print( ( FMT get_difference( -95.0,  90.0 ),       newline ) );\n    print( ( FMT get_difference( -45.0, 125.0 ),       newline ) );\n    print( ( FMT get_difference( -45.0, 145.0 ),       newline ) );\n    print( ( FMT get_difference( -45.0, 125.0 ),       newline ) );\n    print( ( FMT get_difference( -45.0, 145.0 ),       newline ) );\n    print( ( FMT get_difference(  29.4803, -88.6381 ), newline ) );\n    print( ( FMT get_difference( -78.3251, -159.036 ), newline ) );\n    print( ( newline ) );\n    print( ( FMT get_difference(  -70099.74233810938,     29840.67437876723 ), newline ) );\n    print( ( FMT get_difference( -165313.6666297357,      33693.9894517456  ), newline ) );\n    print( ( FMT get_difference(    1174.8380510598456, -154146.66490124757 ), newline ) );\n    print( ( FMT get_difference(   60175.77306795546,     42213.07192354373 ), newline ) )\n\nEND\n"
                }
            ],
            [
                {
                    "language": "Craft-Basic",
                    "solution": "precision 4\n\ndefine s1 = 0, s2 = 0\n\ndim b1[20, -45, -85, -95, -45, -45, 29.4803, -78.3251]\ndim b2[45, 45, 90, 90, 125, 145, -88.6381, -159.036]\n\narraysize s1, b1\narraysize s2, b2\n\nif s1 = s2 then\n\n\tfor i = 0 to s1 - 1\n\n\t\tlet r = (b2[i] - b1[i]) % 360\n\n\t\tif r >= 180 then\n\n\t\t\tlet r = r - 360\n\n\t\tendif\n\n\t\tprint \"bearing 1: \", b1[i], \" bearing 2: \", b2[i], \" difference: \", r\n\n\tnext i\n\nendif\n"
                },
                {
                    "language": "Seed7",
                    "solution": "$ include \"seed7_05.s7i\";\n  include \"float.s7i\";\n\nconst func float: getDifference (in float: b1, in float: b2) is func\n  result\n    var float: difference is 0.0;\n  begin\n    difference := (b2 - b1) mod 360.0;\n    if difference > 180.0 then\n      difference -:= 360.0;\n    end if;\n  end func;\n\nconst proc: main is func\n  begin\n    writeln(\"Input in -180 to +180 range\");\n    writeln(getDifference(20.0, 45.0));\n    writeln(getDifference(-45.0, 45.0));\n    writeln(getDifference(-85.0, 90.0));\n    writeln(getDifference(-95.0, 90.0));\n    writeln(getDifference(-45.0, 125.0));\n    writeln(getDifference(-45.0, 145.0));\n    writeln(getDifference(-45.0, 125.0));\n    writeln(getDifference(-45.0, 145.0));\n    writeln(getDifference(29.4803, -88.6381));\n    writeln(getDifference(-78.3251, -159.036));\n    writeln(\"Input in wider range\");\n    writeln(getDifference(-70099.74233810938, 29840.67437876723));\n    writeln(getDifference(-165313.6666297357, 33693.9894517456));\n    writeln(getDifference(1174.8380510598456, -154146.66490124757));\n    writeln(getDifference(60175.77306795546, 42213.07192354373));\n  end func;\n"
                }
            ],
            [
                {
                    "language": "IS-BASIC",
                    "solution": "100 INPUT PROMPT \"1. angle: \":A1\n110 INPUT PROMPT \"2. angle: \":A2\n120 LET B=MOD(A2-A1,360)\n130 IF B>180 THEN LET B=B-360\n140 IF B<-180 THEN LET B=B+360\n150 PRINT \"Difference: \";B\n"
                },
                {
                    "language": "D",
                    "solution": "import std.stdio;\n\ndouble getDifference(double b1, double b2) {\n    double r = (b2 - b1) % 360.0;\n    if (r < -180.0) {\n        r += 360.0;\n    }\n    if (r >= 180.0) {\n        r -= 360.0;\n    }\n    return r;\n}\n\nvoid main() {\n    writeln(\"Input in -180 to +180 range\");\n    writeln(getDifference(20.0, 45.0));\n    writeln(getDifference(-45.0, 45.0));\n    writeln(getDifference(-85.0, 90.0));\n    writeln(getDifference(-95.0, 90.0));\n    writeln(getDifference(-45.0, 125.0));\n    writeln(getDifference(-45.0, 145.0));\n    writeln(getDifference(-45.0, 125.0));\n    writeln(getDifference(-45.0, 145.0));\n    writeln(getDifference(29.4803, -88.6381));\n    writeln(getDifference(-78.3251, -159.036));\n\n    writeln(\"Input in wider range\");\n    writeln(getDifference(-70099.74233810938, 29840.67437876723));\n    writeln(getDifference(-165313.6666297357, 33693.9894517456));\n    writeln(getDifference(1174.8380510598456, -154146.66490124757));\n    writeln(getDifference(60175.77306795546, 42213.07192354373));\n}\n"
                }
            ],
            [
                {
                    "language": "Excel",
                    "solution": "ANGLEBETWEENBEARINGS\n=LAMBDA(ab,\n    DEGREES(\n        BEARINGDELTA(\n            RADIANS(ab)\n        )\n    )\n)\n\n\nBEARINGDELTA\n=LAMBDA(ab,\n    LET(\n        sinab, SIN(ab),\n        cosab, COS(ab),\n\n        ax, INDEX(sinab, 1),\n        bx, INDEX(sinab, 2),\n        ay, INDEX(cosab, 1),\n        by, INDEX(cosab, 2),\n\n        rem, \"Sign * dot product\",\n        IF(0 < ((ay * bx) - (by * ax)),\n            1,\n            -1\n        ) * ACOS((ax * bx) + (ay * by))\n    )\n)\n"
                },
                {
                    "language": "BQN",
                    "solution": "Adiff \u2190 180 - 360 | 180 + -\n\ntests \u2190 [20\u203f45, \u00af45\u203f45, \u00af85\u203f90, \u00af95\u203f90, \u00af45\u203f125, \u00af45\u203f145\n         99\u203f279, 29.4803\u203f\u00af88.6381, \u00af78.3251\u203f\u00af159.036\n         \u00af70099.74233810938\u203f29840.67437876723\n         \u00af165313.6666297357\u203f33693.9894517456\n         1174.8380510598456\u203f\u00af154146.66490124757\n         60175.77306795546\u203f42213.07192354373]\n\nRound \u2190 \u230a\u2218+\u27dc0.5\u233e(1e3\u22b8\u00d7)\n\nRound\u2218\u223e\u27dc(Adiff\u00b4)\u02d8 tests\n"
                }
            ]
        ]
    },
    {
        "task_name": "Angles-geometric-normalization-and-conversion",
        "task_description": "This task is about the normalization and/or conversion of (geometric) angles using\nsome common scales.\n\n\nThe angular scales that will be used in this task are:\n::* &nbsp; degree\n::* &nbsp; gradian\n::* &nbsp; mil\n::* &nbsp; radian\n\n\n\n;Definitions:\nThe angular scales used or referenced here:\n::* &nbsp; '''turn'''    &nbsp; is a full turn or 360 degrees, also shown as 360\u00ba\n::* &nbsp; '''degree'''  &nbsp; is &nbsp; <big>'''<sup>1</sup>/<sub>360</sub>'''</big>                                     &nbsp; of a turn\n::* &nbsp; '''gradian''' &nbsp; is &nbsp; <big>'''<sup>1</sup>/<sub>400</sub>'''</big>                                     &nbsp; of a turn\n::* &nbsp; '''mil'''     &nbsp; is &nbsp; <big>'''<sup>1</sup>/<sub>6400</sub>'''</big>                                    &nbsp; of a turn\n::* &nbsp; '''radian'''  &nbsp; is &nbsp; <big>'''<sup>1</sup>/<sub>2<big><big><math>\\pi</math></big></big></sub></big>''' &nbsp; of a turn &nbsp; (or &nbsp; <big>'''<sup>0.5</sup>/<sub><big><big><math>\\pi</math></big></big></sub>'''</big> &nbsp; of a turn)\n\n\nOr, to put it another way, &nbsp; for a full circle:\n::* &nbsp; there are &nbsp;   '''360''' &nbsp; degrees\n::* &nbsp; there are &nbsp;   '''400''' &nbsp; gradians\n::* &nbsp; there are &nbsp; '''6,400''' &nbsp; mils\n::* &nbsp; there are &nbsp; '''2<big><big><math>\\pi</math></big></big>''' &nbsp; radians &nbsp; (roughly equal to '''6.283<small>+</small>''')\n\n\nA &nbsp; '''mil''' &nbsp; is approximately equal to a &nbsp; ''milliradian'' &nbsp; (which is &nbsp; <big>'''<sup>1</sup>/<sub>1000</sub>'''</big> &nbsp; of a radian).\n\nThere is another definition of a &nbsp; '''mil''' &nbsp; which\nis &nbsp; '''<sup>1</sup>/<sub>1000</sub>''' &nbsp; of a radian &nbsp; \u2500\u2500\u2500 this\ndefinition <u>won't</u> be used in this Rosetta Code task.\n\n\n'''Turns''' &nbsp; are sometimes known or shown as:\n:::* &nbsp; turn(s)\n:::* &nbsp; 360 degrees\n:::* &nbsp; unit circle\n:::* &nbsp; a (full) circle\n\n\n'''Degrees''' &nbsp; are sometimes known or shown as:\n:::* &nbsp; degree(s)\n:::* &nbsp; deg\n:::* &nbsp; \u00ba &nbsp; &nbsp; &nbsp; (a symbol)\n:::* &nbsp; \u00b0 &nbsp; &nbsp; &nbsp; (another symbol)\n\n\n'''Gradians''' &nbsp; are sometimes known or shown as:\n:::* &nbsp; gradian(s)\n:::* &nbsp; grad(s)\n:::* &nbsp; grade(s)\n:::* &nbsp; gon(s)\n:::* &nbsp; metric degree(s)\n:::* &nbsp; (Note that &nbsp; '''centigrade''' &nbsp; was used for <sup>1</sup>/<sub>100</sub><sup>th</sup> of a grade, see the note below.)\n\n\n'''Mils''' &nbsp; are sometimes known or shown as:\n:::* &nbsp; mil(s)\n:::* &nbsp; NATO mil(s)\n\n\n'''Radians''' &nbsp; are sometimes known or shown as:\n:::* &nbsp; radian(s)\n:::* &nbsp; rad(s)\n\n\n\n;Notes:\nIn continental Europe, the French term &nbsp; '''centigrade''' &nbsp; was used\nfor &nbsp; '''<sup>1</sup>/<sub>100</sub>''' &nbsp; of a grad (grade); &nbsp; this was\none reason for the adoption of the term &nbsp; '''Celsius''' &nbsp; to\nreplace &nbsp; '''centigrade''' &nbsp; as the name of a temperature scale.\n\nGradians were commonly used in civil engineering.\n\nMils were normally used for artillery &nbsp; (elevations of the gun barrel for ranging).\n\n\n;Positive and negative angles:\nAlthough the definition of the measurement of an angle doesn't support the\nconcept of a negative angle, &nbsp; it's frequently useful to impose a convention that\nallows positive and negative angular values to represent orientations and/or rotations\nin opposite directions relative to some reference. &nbsp; It is this reason that\nnegative angles will keep their sign and <u>not</u> be normalized to positive angles.\n\n\n;Normalization:\nNormalization &nbsp; (for this Rosetta Code task) &nbsp; will keep the same\nsign, &nbsp; but it will reduce the magnitude to less than a full circle; &nbsp; in\nother words, less than 360\u00ba.\n\nNormalization &nbsp; <u>shouldn't</u> &nbsp; change &nbsp; '''-45\u00ba''' &nbsp; to &nbsp; '''315\u00ba''',\n\nAn angle of &nbsp; '''0\u00ba''', &nbsp; '''+0\u00ba''', &nbsp; '''0.000000''',  &nbsp; or &nbsp; '''-0\u00ba''' &nbsp; should be\nshown as &nbsp; '''0\u00ba'''.\n\n\n;Task:\n::* &nbsp; write a function (or equivalent) to do the normalization for each scale\n:::::* Suggested names:\n:::::* '''d2d''', &nbsp; '''g2g''', &nbsp; '''m2m''', &nbsp; and &nbsp;'''r2r'''\n::* &nbsp; write a function (or equivalent) to convert one scale to another\n:::::* Suggested names for comparison of different computer language function names:\n:::::* '''d2g''', &nbsp; '''d2m''', &nbsp; and &nbsp; '''d2r''' &nbsp; for degrees\n:::::* '''g2d''', &nbsp; '''g2m''', &nbsp; and &nbsp; '''g2r''' &nbsp; for gradians\n:::::* '''m2d''', &nbsp; '''m2g''', &nbsp; and &nbsp; '''m2r''' &nbsp; for mils\n:::::* '''r2d''', &nbsp; '''r2g''', &nbsp; and &nbsp; '''r2m''' &nbsp; for radians\n::* &nbsp; normalize all angles used &nbsp; (except for the \"original\" or \"base\" angle)\n::* &nbsp; show the angles in every scale and convert them to all other scales\n::* &nbsp; show all output here on this page\n\n\nFor the (above) conversions, &nbsp; use these dozen numbers &nbsp; (in the order shown):\n:* &nbsp; '''-2 &nbsp; -1 &nbsp; 0 &nbsp; 1 &nbsp; 2 &nbsp; 6.2831853 &nbsp; 16 &nbsp; 57.2957795 &nbsp; 359 &nbsp; 399 &nbsp; 6399 &nbsp; 1000000'''\n<br><br>\n\n",
        "solution_pairs": [
            [
                {
                    "language": "Swift",
                    "solution": "import Foundation\n\nfunc normalize(_ f: Double, N: Double) -> Double {\n  var a = f\n\n  while a < -N { a += N }\n  while a >= N { a -= N }\n\n  return a\n}\n\nfunc normalizeToDeg(_ f: Double) -> Double {\n  return normalize(f, N: 360)\n}\n\nfunc normalizeToGrad(_ f: Double) -> Double {\n  return normalize(f, N: 400)\n}\n\nfunc normalizeToMil(_ f: Double) -> Double {\n  return normalize(f, N: 6400)\n}\n\nfunc normalizeToRad(_ f: Double) -> Double {\n  return normalize(f, N: 2 * .pi)\n}\n\nfunc d2g(_ f: Double) -> Double { f * 10 / 9 }\nfunc d2m(_ f: Double) -> Double { f * 160 / 9 }\nfunc d2r(_ f: Double) -> Double { f * .pi / 180 }\n\nfunc g2d(_ f: Double) -> Double { f * 9 / 10 }\nfunc g2m(_ f: Double) -> Double { f * 16 }\nfunc g2r(_ f: Double) -> Double { f * .pi / 200 }\n\nfunc m2d(_ f: Double) -> Double { f * 9 / 160 }\nfunc m2g(_ f: Double) -> Double { f / 16 }\nfunc m2r(_ f: Double) -> Double { f * .pi / 3200 }\n\nfunc r2d(_ f: Double) -> Double { f * 180 / .pi }\nfunc r2g(_ f: Double) -> Double { f * 200 / .pi }\nfunc r2m(_ f: Double) -> Double { f * 3200 / .pi }\n\nlet angles = [-2, -1, 0, 1, 2, 6.2831853, 16, 57.2957795, 359, 6399, 1_000_000]\nlet names = [\"Degrees\", \"Gradians\", \"Mils\", \"Radians\"]\nlet fmt = { String(format: \"%.4f\", $0) }\n\nlet normal = [normalizeToDeg, normalizeToGrad, normalizeToMil, normalizeToRad]\nlet convert = [\n  [{ $0 }, d2g, d2m, d2r],\n  [g2d, { $0 }, g2m, g2r],\n  [m2d, m2g, { $0 }, m2r],\n  [r2d, r2g, r2m, { $0 }]\n]\n\nlet ans =\n  angles.map({ angle in\n    (0..<4).map({ ($0, normal[$0](angle)) }).map({\n      (fmt(angle),\n        fmt($0.1),\n        names[$0.0],\n        fmt(convert[$0.0][0]($0.1)),\n        fmt(convert[$0.0][1]($0.1)),\n        fmt(convert[$0.0][2]($0.1)),\n        fmt(convert[$0.0][3]($0.1))\n      )\n    })\n  })\n\nprint(\"angle\", \"normalized\", \"unit\", \"degrees\", \"grads\", \"mils\", \"radians\")\n\nfor res in ans {\n  for unit in res {\n    print(unit)\n  }\n\n  print()\n}\n"
                },
                {
                    "language": "Kotlin",
                    "solution": "import java.text.DecimalFormat as DF\n\nconst val DEGREE = 360.0\nconst val GRADIAN = 400.0\nconst val MIL = 6400.0\nconst val RADIAN = 2 * Math.PI\n\nfun d2d(a: Double) = a % DEGREE\nfun d2g(a: Double) = a * (GRADIAN / DEGREE)\nfun d2m(a: Double) = a * (MIL / DEGREE)\nfun d2r(a: Double) = a * (RADIAN / 360)\nfun g2d(a: Double) = a * (DEGREE / GRADIAN)\nfun g2g(a: Double) = a % GRADIAN\nfun g2m(a: Double) = a * (MIL / GRADIAN)\nfun g2r(a: Double) = a * (RADIAN / GRADIAN)\nfun m2d(a: Double) = a * (DEGREE / MIL)\nfun m2g(a: Double) = a * (GRADIAN / MIL)\nfun m2m(a: Double) = a % MIL\nfun m2r(a: Double) = a * (RADIAN / MIL)\nfun r2d(a: Double) = a * (DEGREE / RADIAN)\nfun r2g(a: Double) = a * (GRADIAN / RADIAN)\nfun r2m(a: Double) = a * (MIL / RADIAN)\nfun r2r(a: Double) = a % RADIAN\n\nfun main() {\n    val fa = DF(\"######0.000000\")\n    val fc = DF(\"###0.0000\")\n    println(\"                               degrees    gradiens        mils     radians\")\n    for (a in listOf(-2.0, -1.0, 0.0, 1.0, 2.0, 6.2831853, 16.0, 57.2957795, 359.0, 399.0, 6399.0, 1000000.0))\n        for (units in listOf(\"degrees\", \"gradiens\", \"mils\", \"radians\")) {\n            val (d,g,m,r) = when (units) {\n                \"degrees\" -> {\n                    val d = d2d(a)\n                    listOf(d, d2g(d), d2m(d), d2r(d))\n                }\n                \"gradiens\" -> {\n                    val g = g2g(a)\n                    listOf(g2d(g), g, g2m(g), g2r(g))\n                }\n                \"mils\" -> {\n                    val m = m2m(a)\n                    listOf(m2d(m), m2g(m), m, m2r(m))\n                }\n                \"radians\" -> {\n                    val r = r2r(a)\n                    listOf(r2d(r), r2g(r), r2m(r), r)\n                }\n                else -> emptyList()\n            }\n\n            println(\"%15s  %8s = %10s  %10s  %10s  %10s\".format(fa.format(a), units, fc.format(d), fc.format(g), fc.format(m), fc.format(r)))\n        }\n}\n"
                }
            ],
            [
                {
                    "language": "J",
                    "solution": "   TAU =: 2p1 NB. tauday.com\n\n   normalize =: * * 1 | | NB. signum times the fractional part of absolute value\n\n   TurnTo=: &*\n\n   as_turn    =:    1 TurnTo\n   as_degree  =:  360 TurnTo\n   as_gradian =:  400 TurnTo\n   as_mil     =: 6400 TurnTo\n   as_radian  =:  TAU TurnTo\n\n   Turn    =: adverb def 'normalize as_turn inv m'\n   Degree  =: adverb def 'normalize as_degree inv m'\n   Gradian =: adverb def 'normalize as_gradian inv m'\n   Mil     =: adverb def 'normalize as_mil inv m'\n   Radian  =: adverb def 'normalize as_radian inv m'\n"
                },
                {
                    "language": "V-(Vlang)",
                    "solution": "import math\nimport strconv\nfn d2d(d f64) f64 { return math.mod(d, 360) }\nfn g2g(g f64) f64 { return math.mod(g, 400) }\nfn m2m(m f64) f64 { return math.mod(m, 6400) }\nfn r2r(r f64) f64 { return math.mod(r, 2*math.pi) }\nfn d2g(d f64) f64 { return d2d(d) * 400 / 360 }\nfn d2m(d f64) f64 { return d2d(d) * 6400 / 360 }\nfn d2r(d f64) f64 { return d2d(d) * math.pi / 180 }\nfn g2d(g f64) f64 { return g2g(g) * 360 / 400 }\nfn g2m(g f64) f64 { return g2g(g) * 6400 / 400 }\nfn g2r(g f64) f64 { return g2g(g) * math.pi / 200 }\nfn m2d(m f64) f64 { return m2m(m) * 360 / 6400 }\nfn m2g(m f64) f64 { return m2m(m) * 400 / 6400 }\nfn m2r(m f64) f64 { return m2m(m) * math.pi / 3200 }\nfn r2d(r f64) f64 { return r2r(r) * 180 / math.pi }\nfn r2g(r f64) f64 { return r2r(r) * 200 / math.pi }\nfn r2m(r f64) f64 { return r2r(r) * 3200 / math.pi }\n\nfn s(f f64) string {\n    wf := strconv.format_fl(f, strconv.BF_param{\n        len0: 15\n        len1: 7\n        positive: f>=0\n    }).split('.')\n    if wf[1] == '0000000' {\n        return \"${wf[0]:7}        \"\n    }\n    mut le := wf[1].len\n    if le > 7 {\n        le = 7\n    }\n    return \"${wf[0]:7}.${wf[1][..le]:-7}\"\n}\nfn main() {\n    angles := [-2.0, -1, 0, 1, 2, 6.2831853, 16, 57.2957795, 359, 399, 6399, 1000000]\n    println(\"    degrees     normalized degs     gradians         mils            radians\")\n    for a in angles {\n        println('${s(a)} ${s(d2d(a))} ${s(d2g(a))} ${s(d2m(a))} ${s(d2r(a))}')\n    }\n    println(\"\\n   gradians     normalized grds     degrees          mils            radians\")\n    for a in angles {\n        println('${s(a)} ${s(g2g(a))} ${s(g2d(a))} ${s(g2m(a))} ${s(g2r(a))}')\n    }\n    println(\"\\n     mils       normalized mils     degrees        gradians          radians\")\n    for a in angles {\n        println('${s(a)} ${s(m2m(a))} ${s(m2d(a))} ${s(m2g(a))} ${s(m2r(a))}')\n    }\n    println(\"\\n    radians     normalized rads     degrees        gradians           mils  \")\n    for a in angles {\n        println('${s(a)} ${s(r2r(a))} ${s(r2d(a))} ${s(r2g(a))} ${s(r2m(a))}')\n    }\n}\n"
                }
            ],
            [
                {
                    "language": "Rust",
                    "solution": "use std::{\n    marker::PhantomData,\n    f64::consts::PI,\n};\n\npub trait AngleUnit: Copy {\n    const TURN: f64;\n    const NAME: &'static str;\n}\n\nmacro_rules! unit {\n    ($name:ident, $value:expr, $string:expr) => (\n        #[derive(Debug, Copy, Clone)]\n        struct $name;\n        impl AngleUnit for $name {\n            const TURN: f64 = $value;\n            const NAME: &'static str = $string;\n        }\n    );\n}\n\nunit!(Degrees,  360.0,      \"Degrees\");\nunit!(Radians,  PI * 2.0,   \"Radians\");\nunit!(Gradians, 400.0,      \"Gradians\");\nunit!(Mils,     6400.0,     \"Mils\");\n\n#[derive(Copy, Clone, PartialEq, PartialOrd)]\nstruct Angle<T: AngleUnit>(f64, PhantomData<T>);\n\nimpl<T: AngleUnit> Angle<T> {\n    pub fn new(val: f64) -> Self {\n        Self(val, PhantomData)\n    }\n\n    pub fn normalize(self) -> Self {\n        Self(self.0 % T::TURN, PhantomData)\n    }\n\n    pub fn val(self) -> f64 {\n        self.0\n    }\n\n    pub fn convert<U: AngleUnit>(self) -> Angle<U> {\n        Angle::new(self.0 * U::TURN / T::TURN)\n    }\n\n    pub fn name(self) -> &'static str {\n        T::NAME\n    }\n}\n\nfn print_angles<T: AngleUnit>() {\n    let angles = [-2.0, -1.0, 0.0, 1.0, 2.0, 6.2831853, 16.0, 57.2957795, 359.0, 399.0, 6399.0, 1000000.0];\n    println!(\"{:<12} {:<12} {:<12} {:<12} {:<12} {:<12}\", \"Angle\", \"Unit\", \"Degrees\", \"Gradians\", \"Mils\", \"Radians\");\n\n    for &angle in &angles {\n        let deg = Angle::<T>::new(angle).normalize();\n        println!(\"{:<12} {:<12} {:<12.4} {:<12.4} {:<12.4} {:<12.4}\",\n                 angle,\n                 deg.name(),\n                 deg.convert::<Degrees>().val(),\n                 deg.convert::<Gradians>().val(),\n                 deg.convert::<Mils>().val(),\n                 deg.convert::<Radians>().val(),\n        );\n    }\n\n    println!();\n}\n\nfn main() {\n    print_angles::<Degrees>();\n    print_angles::<Gradians>();\n    print_angles::<Mils>();\n    print_angles::<Radians>();\n}\n"
                },
                {
                    "language": "Nim",
                    "solution": "import math\nimport strformat\n\nconst Values = [float -2, -1, 0, 1, 2, 6.2831853, 16, 57.2957795, 359, 399, 6399, 1000000]\n\nfunc d2d(x: float): float {.inline.} = x mod 360\nfunc g2g(x: float): float {.inline.} = x mod 400\nfunc m2m(x: float): float {.inline.} = x mod 6400\nfunc r2r(x: float): float {.inline.} = x mod (2 * Pi)\n\nfunc d2g(x: float): float {.inline.} = d2d(x) * 10 / 9\nfunc d2m(x: float): float {.inline.} = d2d(x) * 160 / 9\nfunc d2r(x: float): float {.inline.} = d2d(x) * Pi / 180\n\nfunc g2d(x: float): float {.inline.} = g2g(x) * 9 / 10\nfunc g2m(x: float): float {.inline.} = g2g(x) * 16\nfunc g2r(x: float): float {.inline.} = g2g(x) * Pi / 200\n\nfunc m2d(x: float): float {.inline.} = m2m(x) * 9 / 160\nfunc m2g(x: float): float {.inline.} = m2m(x) / 16\nfunc m2r(x: float): float {.inline.} = m2m(x) * Pi / 3200\n\nfunc r2d(x: float): float {.inline.} = r2r(x) * 180 / Pi\nfunc r2g(x: float): float {.inline.} = r2r(x) * 200 / Pi\nfunc r2m(x: float): float {.inline.} = r2r(x) * 3200 / Pi\n\n# Normalizing and converting degrees.\necho \"       Degrees        Normalized         Gradians          Mils            Radians\"\necho \"\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\"\nfor val in Values:\n  echo fmt\"{val:15.7f}  {d2d(val):15.7f}  {d2g(val):15.7f}  {d2m(val):15.7f}  {d2r(val):15.7f}\"\n\n# Normalizing and converting gradians.\necho \"\"\necho \"      Gradians        Normalized         Degrees           Mils            Radians\"\necho \"\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\"\nfor val in Values:\n  echo fmt\"{val:15.7f}  {g2g(val):15.7f}  {g2d(val):15.7f}  {g2m(val):15.7f}  {g2r(val):15.7f}\"\n\n# Normalizing and converting mils.\necho \"\"\necho \"        Mils          Normalized         Degrees         Gradians          Radians\"\necho \"\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\"\nfor val in Values:\n  echo fmt\"{val:15.7f}  {m2m(val):15.7f}  {m2d(val):15.7f}  {m2g(val):15.7f}  {m2r(val):15.7f}\"\n\n# Normalizing and converting radians.\necho \"\"\necho \"       Radians        Normalized         Degrees         Gradians          Mils\"\necho \"\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\"\nfor val in Values:\n  echo fmt\"{val:15.7f}  {r2r(val):15.7f}  {r2d(val):15.7f}  {r2g(val):15.7f}  {r2m(val):15.7f}\"\n"
                }
            ],
            [
                {
                    "language": "EasyLang",
                    "solution": "func angconv ang f$ t$ .\n   sgn = sign ang\n   ang = abs ang\n   if f$ = \"degree\"\n      turn = ang / 360 mod 1\n   elif f$ = \"gradian\"\n      turn = ang / 400 mod 1\n   elif f$ = \"mil\"\n      turn = ang / 6400 mod 1\n   elif f$ = \"radian\"\n      turn = ang / (2 * pi) mod 1\n   .\n   if t$ = \"degree\"\n      ang = turn * 360\n   elif t$ = \"gradian\"\n      ang = turn * 400\n   elif t$ = \"mil\"\n      ang = turn * 6400\n   elif t$ = \"radian\"\n      ang = turn * 2 * pi\n   .\n   return ang * sgn\n.\nfunc$ fmt s$ .\n   return substr \"        \" 1 (9 - len s$) & s$ & \" \"\n.\n#\nscales$[] = [ \"degree\" \"gradian\" \"mil\" \"radian\" ]\nvalues[] = [ -2 -1 0 1 2 6.2831853 16 57.2957795 359 399 6399 1000000 ]\nnumfmt 3 10\nfor f$ in scales$[]\n   write fmt f$\n   for t$ in scales$[]\n      write fmt t$\n   .\n   print \"\"\n   print \"  ------------------------------------------------\"\n   for v in values[]\n      write v\n      for t$ in scales$[]\n         write angconv v f$ t$\n      .\n      print \"\"\n   .\n   print \"\"\n.\n"
                },
                {
                    "language": "J",
                    "solution": "   as_degree   100 Gradian\n90\n"
                }
            ],
            [
                {
                    "language": "Ruby",
                    "solution": "module Angles\n  BASES = {\"d\" => 360, \"g\" => 400, \"m\" => 6400, \"r\" => Math::PI*2 ,\"h\" => 24 }\n\n  def self.method_missing(meth, angle)\n    from, to = BASES.values_at(*meth.to_s.split(\"2\"))\n    raise NoMethodError, meth if (from.nil? or to.nil?)\n    mod = (angle.to_f * to / from) % to\n    angle < 0 ? mod - to : mod\n  end\n\nend\n\n#Demo\nnames = Angles::BASES.keys\nputs \" \" + \"%12s \"*names.size % names\ntest = [-2, -1, 0, 1, 2*Math::PI, 16, 360/(2*Math::PI), 360-1, 400-1, 6400-1, 1_000_000]\n\ntest.each do |n|\n  names.each do |first|\n    res = names.map{|last| Angles.send((first + \"2\" + last).to_sym, n)}\n    puts first + \"%12g \"*names.size % res\n  end\n  puts\nend\n"
                },
                {
                    "language": "Raku",
                    "solution": "sub postfix:<t>( $t ) { my $a = $t % 1 * \u03c4;           $t >=0 ?? $a !! $a - \u03c4 }\nsub postfix:<d>( $d ) { my $a = $d % 360 * \u03c4 / 360;   $d >=0 ?? $a !! $a - \u03c4 }\nsub postfix:<g>( $g ) { my $a = $g % 400 * \u03c4 / 400;   $g >=0 ?? $a !! $a - \u03c4 }\nsub postfix:<m>( $m ) { my $a = $m % 6400 * \u03c4 / 6400; $m >=0 ?? $a !! $a - \u03c4 }\nsub postfix:<r>( $r ) { my $a = $r % \u03c4;               $r >=0 ?? $a !! $a - \u03c4 }\n\nsub postfix:\u00ab->t\u00bb ($angle) { my $a = $angle / \u03c4;        ($angle < 0 and $a == -1)    ?? -0 !! $a }\nsub postfix:\u00ab->d\u00bb ($angle) { my $a = $angle / \u03c4 * 360;  ($angle < 0 and $a == -360)  ?? -0 !! $a }\nsub postfix:\u00ab->g\u00bb ($angle) { my $a = $angle / \u03c4 * 400;  ($angle < 0 and $a == -400)  ?? -0 !! $a }\nsub postfix:\u00ab->m\u00bb ($angle) { my $a = $angle / \u03c4 * 6400; ($angle < 0 and $a == -6400) ?? -0 !! $a }\nsub postfix:\u00ab->r\u00bb ($angle) { my $a = $angle;            ($angle < 0 and $a == -\u03c4)    ?? -0 !! $a }\n\nfor <-2 -1 0 1 2 6.2831853 16 57.2957795 359 399 6399 1000000> -> $a {\n    say '';\n    say '  Quantity  Unit      ', <turns degrees gradians mils radians>.fmt('%15s');\n    for 'turns', &postfix:\u00abt\u00bb, 'degrees', &postfix:\u00abd\u00bb, 'gradians', &postfix:\u00abg\u00bb,\n        'mils',  &postfix:\u00abm\u00bb, 'radians', &postfix:\u00abr\u00bb\n      -> $unit, &f {\n            printf \"%10s %-10s %15s %15s %15s %15s %15s\\n\", $a, $unit,\n            |($a.&f->t, $a.&f->d, $a.&f->g, $a.&f->m, $a.&f->r)\u00bb.round(.00000001);\n    }\n}\n"
                }
            ]
        ]
    },
    {
        "task_name": "Animate-a-pendulum",
        "task_description": "One good way of making an animation is by simulating a physical system and illustrating the variables in that system using a dynamically changing graphical display. \n\nThe classic such physical system is a [[wp:Pendulum|simple gravity pendulum]].\n\n\n;Task:\nCreate a simple physical model of a pendulum and animate it.\n<br><br>\n\n",
        "solution_pairs": [
            [
                {
                    "language": "JavaScript",
                    "solution": "<svg height=\"100%\" width=\"100%\" viewBox=\"-2 0 4 4\" xmlns=\"http://www.w3.org/2000/svg\">\n  <line id=\"string\" x1=\"0\" y1=\"0\" x2=\"1\" y2=\"0\" stroke=\"grey\" stroke-width=\"0.05\" />\n  <circle id=\"ball\" cx=\"0\" cy=\"0\" r=\"0.1\" fill=\"black\" />\n  <script>\n    /*jshint esnext: true */\n\n    function rk4(dt, x, f) {\n      \"use strict\";\n      let from = Array.from,\n          a = from(f(from(x,  $    => $         )), $ => $*dt),\n          b = from(f(from(x, ($,i) => $ + a[i]/2)), $ => $*dt),\n          c = from(f(from(x, ($,i) => $ + b[i]/2)), $ => $*dt),\n          d = from(f(from(x, ($,i) => $ + c[i]  )), $ => $*dt);\n      return from(x, (_,i) => (a[i] + 2*b[i] + 2*c[i] + d[i])/6);\n    }\n\n    function setPendulumPos($) {\n      const string = document.getElementById(\"string\"),\n            ball = document.getElementById(\"ball\");\n      let $2 = $*$,\n          x = 2*$/(1+$2),\n          y = (1-$2)/(1+$2);\n      string.setAttribute(\"x2\", x);\n      string.setAttribute(\"y2\", y);\n      ball.setAttribute(\"cx\", x);\n      ball.setAttribute(\"cy\", y);\n    }\n\n    var q = [1, 0];\n    var previousTimestamp;\n    (function animate(timestamp) {\n      if ( previousTimestamp !== undefined) {\n        let dq = rk4((timestamp - previousTimestamp)/1000, q, $ => [$[1], 2*$[1]*$[1]*$[0]/(1+$[0]*$[0]) - $[0]]);\n        q = [q[0] + dq[0], q[1] + dq[1]];\n        setPendulumPos(q[0]);\n      }\n      previousTimestamp = timestamp;\n      window.requestAnimationFrame(animate);\n    })()\n  </script>\n</svg>\n"
                },
                {
                    "language": "Liberty-BASIC",
                    "solution": "nomainwin\n    WindowWidth = 400\n    WindowHeight = 300\n\n    open \"Pendulum\" for graphics_nsb_nf as #main\n    #main \"down;fill white; flush\"\n    #main \"color black\"\n    #main \"trapclose [quit.main]\"\n\n    Angle = asn(1)\n    DeltaT = 0.1\n    PendLength = 150\n    FixX = int(WindowWidth / 2)\n    FixY = 40\n\n    timer 30, [swing]\n\n    wait\n\n[swing]\n\n    #main \"cls\"\n    #main \"discard\"\n\n    PlumbobX = FixX + int(sin(Angle) * PendLength)\n    PlumbobY = FixY + int(cos(Angle) * PendLength)\n    AngAccel = -9.81 / PendLength * sin(Angle)\n    AngVelocity = AngVelocity + AngAccel * DeltaT\n    Angle = Angle + AngVelocity * DeltaT\n\n    #main \"backcolor black\"\n    #main \"place \";FixX;\" \";FixY\n    #main \"circlefilled 3\"\n    #main \"line \";FixX;\" \";FixY;\" \";PlumbobX;\" \";PlumbobY\n    #main \"backcolor red\"\n    #main \"circlefilled 10\"\n\n    wait\n\n[quit.main]\n    close #main\n    end\n"
                }
            ],
            [
                {
                    "language": "Ada",
                    "solution": "generic\n   type Float_Type is digits <>;\n   Gravitation : Float_Type;\npackage Pendulums is\n   type Pendulum is private;\n   function New_Pendulum (Length : Float_Type;\n                          Theta0 : Float_Type) return Pendulum;\n   function Get_X (From : Pendulum) return Float_Type;\n   function Get_Y (From : Pendulum) return Float_Type;\n   procedure Update_Pendulum (Item : in out Pendulum; Time : in Duration);\nprivate\n   type Pendulum is record\n      Length   : Float_Type;\n      Theta    : Float_Type;\n      X        : Float_Type;\n      Y        : Float_Type;\n      Velocity : Float_Type;\n   end record;\nend Pendulums;\n"
                },
                {
                    "language": "Amazing-Hopper",
                    "solution": "// in \"Animate a Pendulum\"\n\n  SET( px,  640 )//65 )\n  SET( py,  30 ) //7 )\n\n// long of the line:\n\n    LET( bx := ADD( px, MUL( MUL( l, 180 ), SIN(theta) ) ) )\n    LET( by := SUB( py, MUL( MUL( l, 180 ), COS(theta) ) ) )\n\n// and circle ratio:\n    {bx, by, 10} GOSUB( CIRCLE )\n"
                }
            ],
            [
                {
                    "language": "JavaScript",
                    "solution": "<svg height=\"100%\" width=\"100%\" viewBox=\"-2 0 4 4\" xmlns=\"http://www.w3.org/2000/svg\">\n  <line id=\"string\" x1=\"0\" y1=\"0\" x2=\"1\" y2=\"0\" stroke=\"grey\" stroke-width=\"0.05\" />\n  <circle id=\"ball\" cx=\"0\" cy=\"0\" r=\"0.1\" fill=\"black\" />\n  <script>\n    /*jshint esnext: true */\n\n    function rk4(dt, x, f) {\n      \"use strict\";\n      let from = Array.from,\n          a = from(f(from(x,  $    => $         )), $ => $*dt),\n          b = from(f(from(x, ($,i) => $ + a[i]/2)), $ => $*dt),\n          c = from(f(from(x, ($,i) => $ + b[i]/2)), $ => $*dt),\n          d = from(f(from(x, ($,i) => $ + c[i]  )), $ => $*dt);\n      return from(x, (_,i) => (a[i] + 2*b[i] + 2*c[i] + d[i])/6);\n    }\n\n    function setPendulumPos($) {\n      const string = document.getElementById(\"string\"),\n            ball = document.getElementById(\"ball\");\n      let $2 = $*$,\n          x = 2*$/(1+$2),\n          y = (1-$2)/(1+$2);\n      string.setAttribute(\"x2\", x);\n      string.setAttribute(\"y2\", y);\n      ball.setAttribute(\"cx\", x);\n      ball.setAttribute(\"cy\", y);\n    }\n\n    var q = [1, 0];\n    var previousTimestamp;\n    (function animate(timestamp) {\n      if ( previousTimestamp !== undefined) {\n        let dq = rk4((timestamp - previousTimestamp)/1000, q, $ => [$[1], 2*$[1]*$[1]*$[0]/(1+$[0]*$[0]) - $[0]]);\n        q = [q[0] + dq[0], q[1] + dq[1]];\n        setPendulumPos(q[0]);\n      }\n      previousTimestamp = timestamp;\n      window.requestAnimationFrame(animate);\n    })()\n  </script>\n</svg>\n"
                },
                {
                    "language": "Julia",
                    "solution": "using Luxor\nusing Colors\nusing BoundaryValueDiffEq\n\n# constants for differential equations and movie\nconst g = 9.81\nconst L = 1.0                         # pendulum length in meters\nconst bobd = 0.10                     # pendulum bob diameter in meters\nconst framerate = 50.0                # intended frame rate/sec\nconst t0 = 0.0                        # start time (s)\nconst tf = 2.3                        # end simulation time (s)\nconst dtframe = 1.0/framerate         # time increment per frame\nconst tspan = LinRange(t0, tf, Int(floor(tf*framerate)))  # array of time points in animation\n\nconst bgcolor = \"black\"               # gif background\nconst leaderhue = (0.80, 0.70, 0.20)  # gif swing arm hue light gold\nconst hslcolors = [HSL(col) for col in (distinguishable_colors(\n                   Int(floor(tf*framerate)+3),[RGB(1,1,1)])[2:end])]\nconst giffilename = \"pendulum.gif\"    # output file\n\n# differential equations\nsimplependulum(du, u, p, t) = (\u03b8=u[1]; d\u03b8=u[2]; du[1]=d\u03b8; du[2]=-(g/L)*sin(\u03b8))\nbc2(residual, u, p, t) = (residual[1] = u[end\u00f72][1] + pi/2; residual[2] = u[end][1] - pi/2)\nbvp2 = BVProblem(simplependulum, bc2, [pi/2,pi/2], (tspan[1],tspan[end]))\nsol2 = solve(bvp2, MIRK4(), dt=dtframe) # use the MIRK4 solver for TwoPointBVProblem\n\n# movie making background\nbackdrop(scene, framenumber) = background(bgcolor)\n\nfunction frame(scene, framenumber)\n    u1, u2 = sol2.u[framenumber]\n    y, x = L*cos(u1), L*sin(u1)\n    sethue(leaderhue)\n    poly([Point(-4.0, 0.0), Point(4.0, 0.0),\n          Point(160.0x,160.0y)], :fill)\n    sethue(Colors.HSV(framenumber*4.0, 1, 1))\n    circle(Point(160.0x,160.0y), 160bobd, :fill)\n    text(string(\"frame $framenumber of $(scene.framerange.stop)\"),\n        Point(0.0, -190.0),\n        halign=:center)\nend\n\nmuv = Movie(400, 400, \"Pendulum Demo\", 1:length(tspan))\nanimate(muv, [Scene(muv, backdrop),\n              Scene(muv, frame, easingfunction=easeinoutcubic)],\n              creategif=true, pathname=giffilename)\n"
                }
            ],
            [
                {
                    "language": "Python",
                    "solution": "import pygame, sys\nfrom pygame.locals import *\nfrom math import sin, cos, radians\n\npygame.init()\n\nWINDOWSIZE = 250\nTIMETICK = 100\nBOBSIZE = 15\n\nwindow = pygame.display.set_mode((WINDOWSIZE, WINDOWSIZE))\npygame.display.set_caption(\"Pendulum\")\n\nscreen = pygame.display.get_surface()\nscreen.fill((255,255,255))\n\nPIVOT = (WINDOWSIZE/2, WINDOWSIZE/10)\nSWINGLENGTH = PIVOT[1]*4\n\nclass BobMass(pygame.sprite.Sprite):\n    def __init__(self):\n        pygame.sprite.Sprite.__init__(self)\n        self.theta = 45\n        self.dtheta = 0\n        self.rect = pygame.Rect(PIVOT[0]-SWINGLENGTH*cos(radians(self.theta)),\n                                PIVOT[1]+SWINGLENGTH*sin(radians(self.theta)),\n                                1,1)\n        self.draw()\n\n    def recomputeAngle(self):\n        scaling = 3000.0/(SWINGLENGTH**2)\n\n        firstDDtheta = -sin(radians(self.theta))*scaling\n        midDtheta = self.dtheta + firstDDtheta\n        midtheta = self.theta + (self.dtheta + midDtheta)/2.0\n\n        midDDtheta = -sin(radians(midtheta))*scaling\n        midDtheta = self.dtheta + (firstDDtheta + midDDtheta)/2\n        midtheta = self.theta + (self.dtheta + midDtheta)/2\n\n        midDDtheta = -sin(radians(midtheta)) * scaling\n        lastDtheta = midDtheta + midDDtheta\n        lasttheta = midtheta + (midDtheta + lastDtheta)/2.0\n\n        lastDDtheta = -sin(radians(lasttheta)) * scaling\n        lastDtheta = midDtheta + (midDDtheta + lastDDtheta)/2.0\n        lasttheta = midtheta + (midDtheta + lastDtheta)/2.0\n\n        self.dtheta = lastDtheta\n        self.theta = lasttheta\n        self.rect = pygame.Rect(PIVOT[0]-\n                                SWINGLENGTH*sin(radians(self.theta)),\n                                PIVOT[1]+\n                                SWINGLENGTH*cos(radians(self.theta)),1,1)\n\n\n    def draw(self):\n        pygame.draw.circle(screen, (0,0,0), PIVOT, 5, 0)\n        pygame.draw.circle(screen, (0,0,0), self.rect.center, BOBSIZE, 0)\n        pygame.draw.aaline(screen, (0,0,0), PIVOT, self.rect.center)\n        pygame.draw.line(screen, (0,0,0), (0, PIVOT[1]), (WINDOWSIZE, PIVOT[1]))\n\n    def update(self):\n        self.recomputeAngle()\n        screen.fill((255,255,255))\n        self.draw()\n\nbob = BobMass()\n\nTICK = USEREVENT + 2\npygame.time.set_timer(TICK, TIMETICK)\n\ndef input(events):\n    for event in events:\n        if event.type == QUIT:\n            sys.exit(0)\n        elif event.type == TICK:\n            bob.update()\n\nwhile True:\n    input(pygame.event.get())\n    pygame.display.flip()\n"
                },
                {
                    "language": "Liberty-BASIC",
                    "solution": "nomainwin\n    WindowWidth = 400\n    WindowHeight = 300\n\n    open \"Pendulum\" for graphics_nsb_nf as #main\n    #main \"down;fill white; flush\"\n    #main \"color black\"\n    #main \"trapclose [quit.main]\"\n\n    Angle = asn(1)\n    DeltaT = 0.1\n    PendLength = 150\n    FixX = int(WindowWidth / 2)\n    FixY = 40\n\n    timer 30, [swing]\n\n    wait\n\n[swing]\n\n    #main \"cls\"\n    #main \"discard\"\n\n    PlumbobX = FixX + int(sin(Angle) * PendLength)\n    PlumbobY = FixY + int(cos(Angle) * PendLength)\n    AngAccel = -9.81 / PendLength * sin(Angle)\n    AngVelocity = AngVelocity + AngAccel * DeltaT\n    Angle = Angle + AngVelocity * DeltaT\n\n    #main \"backcolor black\"\n    #main \"place \";FixX;\" \";FixY\n    #main \"circlefilled 3\"\n    #main \"line \";FixX;\" \";FixY;\" \";PlumbobX;\" \";PlumbobY\n    #main \"backcolor red\"\n    #main \"circlefilled 10\"\n\n    wait\n\n[quit.main]\n    close #main\n    end\n"
                }
            ],
            [
                {
                    "language": "Amazing-Hopper",
                    "solution": "// in \"Animate a Pendulum\"\n\n  SET( px,  640 )//65 )\n  SET( py,  30 ) //7 )\n\n// long of the line:\n\n    LET( bx := ADD( px, MUL( MUL( l, 180 ), SIN(theta) ) ) )\n    LET( by := SUB( py, MUL( MUL( l, 180 ), COS(theta) ) ) )\n\n// and circle ratio:\n    {bx, by, 10} GOSUB( CIRCLE )\n"
                },
                {
                    "language": "JavaScript",
                    "solution": "<svg height=\"100%\" width=\"100%\" viewBox=\"-2 0 4 4\" xmlns=\"http://www.w3.org/2000/svg\">\n  <line id=\"string\" x1=\"0\" y1=\"0\" x2=\"1\" y2=\"0\" stroke=\"grey\" stroke-width=\"0.05\" />\n  <circle id=\"ball\" cx=\"0\" cy=\"0\" r=\"0.1\" fill=\"black\" />\n  <script>\n    /*jshint esnext: true */\n\n    function rk4(dt, x, f) {\n      \"use strict\";\n      let from = Array.from,\n          a = from(f(from(x,  $    => $         )), $ => $*dt),\n          b = from(f(from(x, ($,i) => $ + a[i]/2)), $ => $*dt),\n          c = from(f(from(x, ($,i) => $ + b[i]/2)), $ => $*dt),\n          d = from(f(from(x, ($,i) => $ + c[i]  )), $ => $*dt);\n      return from(x, (_,i) => (a[i] + 2*b[i] + 2*c[i] + d[i])/6);\n    }\n\n    function setPendulumPos($) {\n      const string = document.getElementById(\"string\"),\n            ball = document.getElementById(\"ball\");\n      let $2 = $*$,\n          x = 2*$/(1+$2),\n          y = (1-$2)/(1+$2);\n      string.setAttribute(\"x2\", x);\n      string.setAttribute(\"y2\", y);\n      ball.setAttribute(\"cx\", x);\n      ball.setAttribute(\"cy\", y);\n    }\n\n    var q = [1, 0];\n    var previousTimestamp;\n    (function animate(timestamp) {\n      if ( previousTimestamp !== undefined) {\n        let dq = rk4((timestamp - previousTimestamp)/1000, q, $ => [$[1], 2*$[1]*$[1]*$[0]/(1+$[0]*$[0]) - $[0]]);\n        q = [q[0] + dq[0], q[1] + dq[1]];\n        setPendulumPos(q[0]);\n      }\n      previousTimestamp = timestamp;\n      window.requestAnimationFrame(animate);\n    })()\n  </script>\n</svg>\n"
                }
            ]
        ]
    },
    {
        "task_name": "Animation",
        "task_description": "'''Animation''' is integral to many parts of [[GUI]]s, including both the fancy effects when things change used in window managers, and of course games. &nbsp; The core of any animation system is a scheme for periodically changing the display while still remaining responsive to the user. &nbsp; This task demonstrates this.\n\n\n;Task:\nCreate a window containing the string \"<code>Hello World! </code>\" (the trailing space is significant). \n\nMake the text appear to be rotating right by periodically removing one letter from the end of the string and attaching it to the front. \n\nWhen the user clicks on the (windowed) text, it should reverse its direction.\n<br><br>\n",
        "solution_pairs": [
            [
                {
                    "language": "Scala",
                    "solution": "import scala.actors.Actor.{actor, loop, reactWithin, exit}\nimport scala.actors.TIMEOUT\nimport scala.swing.{SimpleSwingApplication, MainFrame, Label}\nimport scala.swing.event.MouseClicked\n\ncase object Revert\n\nobject BasicAnimation extends SimpleSwingApplication {\n  val label = new Label(\"Hello World! \")\n  val rotator = actor {\n    var goingRight = true\n    loop {\n      reactWithin(250 /*ms*/) {\n        case Revert => goingRight = !goingRight\n        case TIMEOUT =>\n          if (goingRight)\n            label.text = label.text.last + label.text.init\n          else\n            label.text = label.text.tail + label.text.head\n        case unknown => println(\"Unknown message \"+unknown); exit()\n      }\n    }\n  }\n  def top = new MainFrame {\n    title = \"Basic Animation\"\n    contents = label\n  }\n  listenTo(label.mouse.clicks) // use \"Mouse\" instead of \"mouse\" on Scala 2.7\n  reactions += {\n    case _ : MouseClicked => rotator ! Revert\n  }\n}\n"
                },
                {
                    "language": "Phix",
                    "solution": "(phixonline)-->\n <span style=\"color: #000080;font-style:italic;\">-- demo\\rosetta\\Animation.exw</span>\n <span style=\"color: #008080;\">with</span> <span style=\"color: #008080;\">javascript_semantics</span>\n <span style=\"color: #008080;\">include</span> <span style=\"color: #000000;\">pGUI</span><span style=\"color: #0000FF;\">.</span><span style=\"color: #000000;\">e</span>\n\n <span style=\"color: #004080;\">string</span> <span style=\"color: #000000;\">hw</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #008000;\">\"Hello World!     \"</span>\n <span style=\"color: #004080;\">bool</span> <span style=\"color: #000000;\">direction</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #004600;\">true</span>\n <span style=\"color: #004080;\">Ihandle</span> <span style=\"color: #000000;\">label</span>\n\n <span style=\"color: #008080;\">function</span> <span style=\"color: #000000;\">button_cb</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #004080;\">Ihandle</span> <span style=\"color: #000080;font-style:italic;\">/*ih*/</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #004080;\">integer</span> <span style=\"color: #000080;font-style:italic;\">/*button*/</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #000000;\">pressed</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #000080;font-style:italic;\">/*x*/</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #000080;font-style:italic;\">/*y*/</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #004080;\">atom</span> <span style=\"color: #000080;font-style:italic;\">/*pStatus*/</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #008080;\">if</span> <span style=\"color: #000000;\">pressed</span> <span style=\"color: #008080;\">then</span>\n         <span style=\"color: #000000;\">direction</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #008080;\">not</span> <span style=\"color: #000000;\">direction</span>\n     <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">if</span>\n     <span style=\"color: #008080;\">return</span> <span style=\"color: #004600;\">IUP_CONTINUE</span>\n <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">function</span>\n\n <span style=\"color: #008080;\">function</span> <span style=\"color: #000000;\">timer_cb</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #004080;\">Ihandle</span> <span style=\"color: #000080;font-style:italic;\">/*ih*/</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #000000;\">hw</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #008080;\">iff</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">direction</span> <span style=\"color: #0000FF;\">?</span> <span style=\"color: #000000;\">hw</span><span style=\"color: #0000FF;\">[$]</span> <span style=\"color: #0000FF;\">&</span> <span style=\"color: #000000;\">hw</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">..-</span><span style=\"color: #000000;\">2</span><span style=\"color: #0000FF;\">]</span>\n                        <span style=\"color: #0000FF;\">:</span> <span style=\"color: #000000;\">hw</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">2</span><span style=\"color: #0000FF;\">..$]</span> <span style=\"color: #0000FF;\">&</span> <span style=\"color: #000000;\">hw</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">])</span>\n     <span style=\"color: #7060A8;\">IupSetAttribute</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">label</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #008000;\">\"TITLE\"</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">hw</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #008080;\">return</span> <span style=\"color: #004600;\">IUP_IGNORE</span>\n <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">function</span>\n\n <span style=\"color: #008080;\">procedure</span> <span style=\"color: #000000;\">main</span><span style=\"color: #0000FF;\">()</span>\n     <span style=\"color: #7060A8;\">IupOpen</span><span style=\"color: #0000FF;\">()</span>\n     <span style=\"color: #000000;\">label</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">IupLabel</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">hw</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #008000;\">`FONT=\"Verdana, 18\"`</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #7060A8;\">IupSetCallback</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">label</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #008000;\">\"BUTTON_CB\"</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #7060A8;\">Icallback</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #008000;\">\"button_cb\"</span><span style=\"color: #0000FF;\">))</span>\n     <span style=\"color: #004080;\">Ihandle</span> <span style=\"color: #000000;\">dlg</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">IupDialog</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">label</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #008000;\">\"TITLE=Animation, DIALOGFRAME=YES, CHILDOFFSET=70x40, SIZE=200x80\"</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #7060A8;\">IupShow</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">dlg</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #004080;\">Ihandle</span> <span style=\"color: #000000;\">hTimer</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">IupTimer</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #7060A8;\">Icallback</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #008000;\">\"timer_cb\"</span><span style=\"color: #0000FF;\">),</span> <span style=\"color: #000000;\">160</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #008080;\">if</span> <span style=\"color: #7060A8;\">platform</span><span style=\"color: #0000FF;\">()!=</span><span style=\"color: #004600;\">JS</span> <span style=\"color: #008080;\">then</span>\n         <span style=\"color: #7060A8;\">IupMainLoop</span><span style=\"color: #0000FF;\">()</span>\n         <span style=\"color: #7060A8;\">IupClose</span><span style=\"color: #0000FF;\">()</span>\n     <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">if</span>\n <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">procedure</span>\n\n <span style=\"color: #000000;\">main</span><span style=\"color: #0000FF;\">()</span>\n<!--\n"
                }
            ],
            [
                {
                    "language": "Delphi",
                    "solution": "unit Main;\n\ninterface\n\nuses\n  Winapi.Windows, System.SysUtils, System.Classes, Vcl.Controls, Vcl.Forms,\n  Vcl.StdCtrls, Vcl.ExtCtrls;\n\ntype\n  TForm1 = class(TForm)\n    lblAniText: TLabel;\n    tmrAniFrame: TTimer;\n    procedure lblAniTextClick(Sender: TObject);\n    procedure tmrAniFrameTimer(Sender: TObject);\n  end;\n\nvar\n  Form1: TForm1;\n  Reverse: boolean = false;\n\nimplementation\n\n{$R *.dfm}\n\nprocedure TForm1.lblAniTextClick(Sender: TObject);\nbegin\n  Reverse := not Reverse;\nend;\n\nfunction Shift(text: string; direction: boolean): string;\nbegin\n  if direction then\n    result := text[text.Length] + text.Substring(0, text.Length - 1)\n  else\n    result := text.Substring(1, text.Length) + text[1];\nend;\n\nprocedure TForm1.tmrAniFrameTimer(Sender: TObject);\nbegin\n  with lblAniText do\n    Caption := Shift(Caption, Reverse);\nend;\nend.\n"
                },
                {
                    "language": "R",
                    "solution": "rotate_string <- function(x, forwards)\n{\n\u00a0 \u00a0nchx <- nchar(x)\n\u00a0 \u00a0if(forwards)\n\u00a0 \u00a0{ \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0\n\u00a0 \u00a0 \u00a0 paste(substr(x, nchx, nchx), substr(x, 1, nchx - 1), sep = \"\")\n\u00a0 \u00a0} else\n\u00a0 \u00a0{ \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0\n\u00a0 \u00a0 \u00a0 paste(substr(x, 2, nchx), substr(x, 1, 1), sep = \"\")\n\u00a0 \u00a0}\n}\n\nhandle_rotate_label <- function(obj, interval = 100)\n{\n\u00a0 addHandlerIdle(obj,\n\u00a0\u00a0\u00a0 handler = function(h, ...)\n\u00a0\u00a0\u00a0 {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 svalue(obj) <- rotate_string(svalue(obj), tag(obj, \"forwards\"))\n\u00a0\u00a0\u00a0 },\n\u00a0\u00a0\u00a0 interval = interval\n\u00a0 )\n}\n\nhandle_change_direction_on_click <- function(obj)\n{\n\u00a0 addHandlerClicked(obj,\n\u00a0\u00a0\u00a0 handler = function(h, ...)\n\u00a0\u00a0\u00a0 {\n\u00a0\u00a0\u00a0\u00a0\u00a0 tag(h$obj, \"forwards\") <- !tag(h$obj, \"forwards\")\n\u00a0\u00a0\u00a0 }\n\u00a0 )\n}\n\nlibrary(gWidgets)\nlibrary(gWidgetstcltk) #or library(gWidgetsRGtk2)\u00a0or library(gWidgetsrJava)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0\nlab <- glabel(\"Hello World! \", container = gwindow()) \u00a0\ntag(lab, \"forwards\") <- TRUE\nhandle_rotate_label(lab)\nhandle_change_direction_on_click(lab)\n"
                }
            ],
            [
                {
                    "language": "Python",
                    "solution": "import Tkinter as tki\n\ndef scroll_text(s, how_many):\n    return s[how_many:] + s[:how_many]\n\ndirection = 1\ntk = tki.Tk()\nvar = tki.Variable(tk)\n\ndef mouse_handler(point):\n    global direction\n    direction *= -1\n\ndef timer_handler():\n    var.set(scroll_text(var.get(),direction))\n    tk.after(125, timer_handler)\n\nvar.set('Hello, World! ')\ntki.Label(tk, textvariable=var).pack()\ntk.bind(\"<Button-1>\", mouse_handler)\ntk.after(125, timer_handler)\ntk.title('Python Animation')\ntki.mainloop()\n"
                },
                {
                    "language": "Racket",
                    "solution": "#lang racket\n(require racket/match)\n(require 2htdp/image)\n(require 2htdp/universe)\n\n; program state\n; value -> no. of rotations of string\n; step -> number (positive for right rotations, else negative)\n(struct rotations (value step) #:transparent)\n\n(define STR \"Hello World! \")\n(define LEN (string-length STR))\n\n; font\n(define COLOR \"red\")\n(define TEXT-SIZE 16)   ;; pixels\n\n(define (render rots)\n  (define val (rotations-value rots))\n  (text (string-append (substring STR val)\n                       (substring STR 0 val))\n        TEXT-SIZE\n        COLOR))\n\n(define (update rots)\n  (match rots\n      [(rotations val dir)\n       (rotations (modulo (+ val dir) LEN) dir)]))\n\n; reverse direction on mouse click\n(define (handle-mouse rots x y event)\n  (case event\n    ; \"button-up\" indicates mouse click\n    [(\"button-up\") (rotations (rotations-value rots)\n                              (- (rotations-step rots)))]\n    [else rots]))\n\n; start GUI, with given event handlers\n(big-bang (rotations 0 1)\n  [to-draw render]\n  [on-tick update]\n  [on-mouse handle-mouse])\n"
                }
            ],
            [
                {
                    "language": "Vedit-macro-language",
                    "solution": "Buf_Switch(Buf_Free)\nWin_Create(Buf_Num, 1, 1, 2, 14)\nIns_Text(\"Hello World! \")\n#2 = Cur_Pos\nRepeat(ALL) {\n    if (Key_Shift_Status & 64) {\n        BOL\n        Block_Copy(#2-1, #2, DELETE)\n    } else {\n        Block_Copy(0, 1, DELETE)\n    }\n    EOL\n    Update()\n    Sleep(2)\n}\n"
                },
                {
                    "language": "M2000-Interpreter",
                    "solution": "Module UseThread {\n      Def boolean direction=True\n      rotating$ =lambda$ a$=\"Hello World! \" (direction as boolean)->{\n            =a$\n            a$=if$(direction->right$(a$,1)+mid$(a$,1, len(a$)-1), mid$(a$,2)+left$(a$,1))\n      }\n      Declare MyForm Form\n      Layer MyForm {\n            Thread {\n                  Cls #225577,0\n                  Print @(2,height/2),rotating$(direction)\n            } as M interval 200\n      }\n      Function MyForm.Click {\n            direction~\n      }\n\n      With MyForm, \"Title\", \"Animation\"\n\n      Method MyForm, \"Show\", 1\n      Threads Erase\n}\nUseThread\n"
                }
            ],
            [
                {
                    "language": "Fantom",
                    "solution": "using concurrent\nusing fwt\nusing gfx\n\nconst class RotateString : Actor\n{\n  new make (Label label) : super (ActorPool ())\n  {\n    Actor.locals[\"rotate-label\"] = label\n    Actor.locals[\"rotate-string\"] = label.text\n    Actor.locals[\"direction\"] = \"forward\"\n    sendLater (1sec, \"update\")\n  }\n\n  // responsible for calling appropriate methods to process each message\n  override Obj? receive (Obj? msg)\n  {\n    switch (msg)\n    {\n      case \"update\":\n        Desktop.callAsync |->| { update }  // make sure we update GUI in event thread\n        sendLater (1sec, \"update\")\n      case \"reverse\":\n        Desktop.callAsync |->| { reverse }\n    }\n\n    return null\n  }\n\n  // change the stored string indicating the direction to rotate\n  Void reverse ()\n  {\n    Actor.locals[\"direction\"] =\n        (Actor.locals[\"direction\"] == \"forward\" ? \"backward\" : \"forward\")\n  }\n\n  // update the text on the label according to the stored direction\n  Void update ()\n  {\n    label := Actor.locals[\"rotate-label\"] as Label\n    str := Actor.locals[\"rotate-string\"] as Str\n    if (label != null)\n    {\n      newStr := \"\"\n      if (Actor.locals[\"direction\"] == \"forward\")\n        newStr = str[1..-1] + str[0].toChar\n      else\n        newStr = str[-1].toChar + str[0..<-1]\n      label.text = newStr\n      Actor.locals[\"rotate-string\"] = newStr\n    }\n  }\n}\n\nclass Animate\n{\n  public static Void main ()\n  {\n    label := Label\n    {\n      text = \"Hello world! \"\n      halign = Halign.center\n    }\n    ticker := RotateString (label)\n    label.onMouseDown.add |Event e|\n    {\n      ticker.send (\"reverse\")\n    }\n    Window\n    {\n      title = \"Animate\"\n      label,\n    }.open\n  }\n}\n"
                },
                {
                    "language": "JavaScript",
                    "solution": "<svg xmlns=\"http://www.w3.org/2000/svg\"\n     width=\"100\" height=\"40\">\n    <script type=\"text/javascript\">\n        function animate(element) {\n            var textNode = element.childNodes[0]; // assuming no other children\n            var text = textNode.data;\n            var reverse = false;\n\n            element.onclick = function () { reverse = !reverse; };\n\n            setInterval(function () {\n                if (reverse)\n                    text = text.substring(1) + text[0];\n                else\n                    text = text[text.length - 1] + text.substring(0, text.length - 1);\n                textNode.data = text;\n            }, 100);\n        }\n    </script>\n\n    <rect width=\"100\" height=\"40\" fill=\"yellow\"/>\n    <text x=\"2\" y=\"20\" onload=\"animate(this);\">Hello World! </text>\n</svg>\n"
                }
            ]
        ]
    },
    {
        "task_name": "Anonymous-recursion",
        "task_description": "While implementing a recursive function, it often happens that we must resort to a separate &nbsp; ''helper function'' &nbsp; to handle the actual recursion.\n\nThis is usually the case when directly calling the current function would waste too many resources (stack space, execution time), causing unwanted side-effects, &nbsp; and/or the function doesn't have the right arguments and/or return values.\n\nSo we end up inventing some silly name like &nbsp; '''foo2''' &nbsp; or &nbsp; '''foo_helper'''. &nbsp; I have always found it painful to come up with a proper name, and see some disadvantages:\n\n::* &nbsp; You have to think up a name, which then pollutes the namespace\n::* &nbsp; Function is created which is called from nowhere else\n::* &nbsp; The program flow in the source code is interrupted\n\nSome languages allow you to embed recursion directly in-place. &nbsp; This might work via a label, a local ''gosub'' instruction, or some special keyword.\n\nAnonymous recursion can also be accomplished using the &nbsp; [[Y combinator]].\n\n\n;Task:\nIf possible, demonstrate this by writing the recursive version of the fibonacci function &nbsp; (see [[Fibonacci sequence]]) &nbsp; which checks for a negative argument before doing the actual recursion.\n;Related tasks:\n:* &nbsp; [[Y combinator]]\n\n<br><br>\n\n",
        "solution_pairs": [
            [
                {
                    "language": "Ruby",
                    "solution": "require 'continuation' unless defined? Continuation\n\nmodule Kernel\n  module_function\n\n  def function(&block)\n    f = (proc do |*args|\n           (class << args; self; end).class_eval do\n             define_method(:callee) { f }\n           end\n           ret = nil\n           cont = catch(:function) { ret = block.call(*args); nil }\n           cont[args] if cont\n           ret\n         end)\n  end\n\n  def arguments\n    callcc { |cont| throw(:function, cont) }\n  end\nend\n\ndef fib(n)\n  raise RangeError, \"fib of negative\" if n < 0\n  function { |m|\n    if m < 2\n      m\n    else\n      arguments.callee[m - 1] + arguments.callee[m - 2]\n    end\n  }[n]\nend\n"
                },
                {
                    "language": "Python",
                    "solution": ">>> Y = lambda f: (lambda x: x(x))(lambda y: f(lambda *args: y(y)(*args)))\n>>> fib = lambda f: lambda n: None if n < 0 else (0 if n == 0 else (1 if n == 1 else f(n-1) + f(n-2)))\n>>> [ Y(fib)(i) for i in range(-2, 10) ]\n[None, None, 0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n"
                }
            ],
            [
                {
                    "language": "Nemerle",
                    "solution": "using System;\nusing System.Console;\n\nmodule Fib\n{\n    Fib(n : long) : long\n    {\n        def fib(m : long)\n        {\n            |0 => 1\n            |1 => 1\n            |_ => fib(m - 1) + fib(m - 2)\n        }\n\n        match(n)\n        {\n            |n when (n < 0) => throw ArgumentException(\"Fib() not defined on negative numbers\")\n            |_ => fib(n)\n        }\n    }\n\n    Main() : void\n    {\n        foreach (i in [-2 .. 10])\n        {\n            try {WriteLine(\"{0}\", Fib(i));}\n            catch {|e is ArgumentException => WriteLine(e.Message)}\n        }\n    }\n}\n"
                },
                {
                    "language": "Axiom",
                    "solution": "#include \"axiom\"\nZ ==> Integer;\nfib(x:Z):Z == {\n\tx <= 0 => error \"argument outside of range\";\n\tf(n:Z,v1:Z,v2:Z):Z == if n<2 then v2 else f(n-1,v2,v1+v2);\n\tf(x,1,1);\n}\n"
                }
            ],
            [
                {
                    "language": "Python",
                    "solution": ">>> from inspect import currentframe\n>>> from types import FunctionType\n>>> def myself (*args, **kw):\n...    caller_frame = currentframe(1)\n...    code = caller_frame.f_code\n...    return FunctionType(code, caller_frame.f_globals)(*args, **kw)\n...\n>>> print \"factorial(5) =\",\n>>> print (lambda n:1 if n<=1 else n*myself(n-1)) ( 5 )\n"
                },
                {
                    "language": "TXR",
                    "solution": "(defmacro recursive ((. parm-init-pairs) . body)\n  (let ((hidden-name (gensym \"RECURSIVE-\")))\n    ^(macrolet ((recurse (. args) ^(,',hidden-name ,*args)))\n       (labels ((,hidden-name (,*[mapcar first parm-init-pairs]) ,*body))\n         (,hidden-name ,*[mapcar second parm-init-pairs])))))\n\n(defun fib (number)\n  (if (< number 0)\n    (error \"Error. The number entered: ~a is negative\" number)\n    (recursive ((n number) (a 0) (b 1))\n      (if (= n 0)\n        a\n        (recurse (- n 1) b (+ a b))))))\n\n(put-line `fib(10) = @(fib 10)`)\n(put-line `fib(-1) = @(fib -1)`))\n"
                }
            ],
            [
                {
                    "language": "Perl",
                    "solution": "use v5.16;\nsay sub {\n  my $n = shift;\n  $n < 2 ? $n : __SUB__->($n-2) + __SUB__->($n-1)\n}->($_) for 0..10\n"
                },
                {
                    "language": "11l",
                    "solution": "F fib(n)\n   F f(Int n) -> Int\n      I n < 2\n         R n\n      R @f(n - 1) + @f(n - 2)\n   R f(n)\n\nL(i) 0..20\n   print(fib(i), end' \u2018 \u2019)\n"
                }
            ],
            [
                {
                    "language": "Lambdatalk",
                    "solution": "1) defining a quasi-recursive function combined with a simple \u00ce\u00a9-combinator:\n{def fibo {lambda {:n}\n {{{lambda {:f} {:f :f}}\n  {lambda {:f :n :a :b}\n   {if {< :n 0}\n    then the number must be positive!\n    else {if {<  :n 1}\n    then :a\n    else {:f :f {- :n 1} {+ :a :b} :a}}}}} :n 1 0}}}\n-> fibo\n\n2) testing:\n{fibo -1} -> the number must be positive!\n{fibo 0} -> 1\n{fibo 8} -> 34\n{fibo 1000} -> 7.0330367711422765e+208\n{S.map fibo {S.serie 1 20}}\n-> 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765 10946\n\nWe could also avoid any name and write an IIFE\n\n{{lambda {:n}\n {{{lambda {:f} {:f :f}}\n  {lambda {:f :n :a :b}\n   {if {< :n 0}\n    then the number must be positive!\n    else {if {<  :n 1}\n    then :a\n    else {:f :f {- :n 1} {+ :a :b} :a}}}}} :n 1 0}}\n 8}\n-> 34\n"
                },
                {
                    "language": "Racket",
                    "solution": "#lang racket\n\n;; Natural -> Natural\n;; Calculate factorial\n(define (fact n)\n  (define (fact-helper n acc)\n    (if (= n 0)\n        acc\n        (fact-helper (sub1 n) (* n acc))))\n  (unless (exact-nonnegative-integer? n)\n    (raise-argument-error 'fact \"natural\" n))\n  (fact-helper n 1))\n\n;; Unit tests, works in v5.3 and newer\n(module+ test\n  (require rackunit)\n  (check-equal? (fact 0) 1)\n  (check-equal? (fact 5) 120))\n"
                }
            ]
        ]
    },
    {
        "task_name": "Anti-primes",
        "task_description": "The [https://youtu.be/2JM2oImb9Qg anti-primes] \n(or [https://en.wikipedia.org/wiki/Highly_composite_number highly composite numbers], sequence [https://oeis.org/A002182 A002182] in the [https://oeis.org/ OEIS]) \nare the natural numbers with more factors than any smaller than itself.\n\n\n;Task:\nGenerate and show here, the first twenty anti-primes.\n\n\n;Related tasks:\n:* &nbsp; [[Factors of an integer]]\n:* &nbsp; [[Sieve of Eratosthenes]]\n<br><br>\n\n",
        "solution_pairs": [
            [
                {
                    "language": "R",
                    "solution": "# Antiprimes\n\nmax_divisors <- 0\n\nfindFactors <- function(x){\n  myseq <- seq(x)\n  myseq[(x %% myseq) == 0]\n}\n\nantiprimes <- vector()\nx <- 1\nn <- 1\nwhile(length(antiprimes) < 20){\n  y <- findFactors(x)\n  if (length(y) > max_divisors){\n    antiprimes <- c(antiprimes, x)\n    max_divisors <- length(y)\n    n <- n + 1\n  }\n  x <- x + 1\n}\n\nantiprimes\n"
                },
                {
                    "language": "Fortran",
                    "solution": "program anti_primes\n    use iso_fortran_env, only: output_unit\n    implicit none\n\n    integer :: n, d, maxDiv, pCount\n\n    write(output_unit,*) \"The first 20 anti-primes are:\"\n    n = 1\n    maxDiv = 0\n    pCount = 0\n    do\n        if (pCount >= 20) exit\n\n        d = countDivisors(n)\n        if (d > maxDiv) then\n            write(output_unit,'(I0,x)', advance=\"no\") n\n            maxDiv = d\n            pCount = pCount + 1\n        end if\n        n = n + 1\n    end do\n    write(output_unit,*)\ncontains\n    pure function countDivisors(n)\n        integer, intent(in) :: n\n        integer             :: countDivisors\n        integer             :: i\n\n        countDivisors = 1\n        if (n < 2) return\n        countDivisors = 2\n        do i = 2, n/2\n            if (modulo(n, i) == 0) countDivisors = countDivisors + 1\n        end do\n    end function countDivisors\nend program anti_primes\n"
                }
            ],
            [
                {
                    "language": "Gambas",
                    "solution": "Function count_divisors(n As Integer) As Integer\n\n  Dim i, count As Integer\n  If n < 2 Then Return 1\n\n  count = 2\n  For i = 2 To n / 2\n    If Not (n Mod i) Then Inc count\n  Next\n  Return count\n\nEnd Function\n\nPublic Sub Main()\n\n  Dim count, max_divisors, n, d As Integer\n\n  Print \"Los primeros 20 anti-primos son:\"\n  While (count < 20)\n    Inc n\n    d = count_divisors(n)\n    If d > max_divisors Then\n      Print n; \" \";\n      max_divisors = d\n      Inc count\n    End If\n  Wend\n\nEnd\n"
                },
                {
                    "language": "Oberon",
                    "solution": "MODULE AntiPrimes;\n\n  IMPORT Out;\n\n  CONST\n    Amount = 20;\n\n  VAR\n    Max,Seen,N,F:INTEGER;\n\n  PROCEDURE Factors(N:INTEGER):INTEGER;\n    VAR\n      Facts,Div:INTEGER;\n  BEGIN\n    IF N < 2 THEN RETURN 1 END;\n    Facts := 2;\n    FOR Div := 2 TO N DIV 2 DO\n      IF N MOD Div = 0 THEN INC(Facts) END;\n    END;\n    RETURN Facts;\n  END Factors;\n\nBEGIN\n  Max := 0;\n  Seen := 0;\n  N := 1;\n  WHILE Seen < Amount DO\n    F := Factors(N);\n    IF F > Max THEN\n      Out.Int(N,5);\n      Max := F;\n      INC(Seen);\n      IF Seen MOD 10 = 0 THEN Out.Ln END;\n    END;\n    INC(N);\n  END;\nEND AntiPrimes.\n"
                }
            ],
            [
                {
                    "language": "Java",
                    "solution": "public class Antiprime {\n\n    static int countDivisors(int n) {\n        if (n < 2) return 1;\n        int count = 2; // 1 and n\n        for (int i = 2; i <= n/2; ++i) {\n            if (n%i == 0) ++count;\n        }\n        return count;\n    }\n\n    public static void main(String[] args) {\n        int maxDiv = 0, count = 0;\n        System.out.println(\"The first 20 anti-primes are:\");\n        for (int n = 1; count < 20; ++n) {\n            int d = countDivisors(n);\n            if (d > maxDiv) {\n                System.out.printf(\"%d \", n);\n                maxDiv = d;\n                count++;\n            }\n        }\n        System.out.println();\n    }\n}\n"
                },
                {
                    "language": "Prolog",
                    "solution": "divcount(N, Count) :- divcount(N, 1, 0, Count).\n\ndivcount(N, D, C, C) :- D*D > N, !.\ndivcount(N, D, C, Count) :-\n    succ(D, D2),\n    divs(N, D, A), plus(A, C, C2),\n    divcount(N, D2, C2, Count).\n\ndivs(N, D, 0) :- N mod D =\\= 0, !.\ndivs(N, D, 1) :- D*D =:= N, !.\ndivs(_, _, 2).\n\n\nantiprimes(N, L) :- antiprimes(N, 1, 0, [], L).\n\nantiprimes(0, _, _, L, R) :- reverse(L, R), !.\nantiprimes(N, M, Max, L, R) :-\n    divcount(M, Count),\n    succ(M, M2),\n    (Count > Max\n        -> succ(N0, N), antiprimes(N0, M2, Count, [M|L], R)\n         ; antiprimes(N, M2, Max, L, R)).\n\nmain :-\n    antiprimes(20, X),\n    write(\"The first twenty anti-primes are \"), write(X), nl,\n    halt.\n\n?- main.\n"
                }
            ],
            [
                {
                    "language": "PARI-GP",
                    "solution": "countfactors(n)={\n    my(count(m)= prod(i=1,#factor(m)~,factor(m)[i,2]+1));\n    v=vector(n);\n    v[1]=1;\n    for(x=2,n,\n        v[x]=v[x-1]+1;\n        while(count(v[x-1])>=count(v[x]),v[x]++));\nreturn(v)}\ncountfactors(20)\n"
                },
                {
                    "language": "PicoLisp",
                    "solution": "(de factors (N)\n   (let C 1\n      (when (>= N 2)\n         (inc 'C)\n         (for (I 2 (>= (/ N 2) I) (inc I))\n            (and (=0 (% N I)) (inc 'C)) ) )\n      C ) )\n(de anti (X)\n   (let (M 0  I 0  N 0)\n      (make\n         (while (> X I)\n            (inc 'N)\n            (let R (factors N)\n               (when (> R M)\n                  (link N)\n                  (setq M R)\n                  (inc 'I) ) ) ) ) ) )\n(println (anti 20))\n"
                }
            ],
            [
                {
                    "language": "F-Sharp",
                    "solution": "printfn \"The first 20 anti-primes are :-\"; for (_,g) in (List.rev fL)|>List.take 20 do printfn \"%A\" g\n"
                },
                {
                    "language": "Racket",
                    "solution": "#lang racket\n\n(require racket/generator\n         math/number-theory)\n\n(define (get-divisors n)\n  (apply * (map (\u00ce\u00bb (factor) (add1 (second factor))) (factorize n))))\n\n(define antiprimes\n  (in-generator\n   (for/fold ([prev 0]) ([i (in-naturals 1)])\n     (define divisors (get-divisors i))\n     (when (> divisors prev) (yield i))\n     (max prev divisors))))\n\n(for/list ([i (in-range 20)] [antiprime antiprimes]) antiprime)\n"
                }
            ]
        ]
    },
    {
        "task_name": "Append-a-record-to-the-end-of-a-text-file",
        "task_description": "Many systems offer the ability to open a file for writing, such that any data written will be appended to the end of the file. Further, the file operations will always adjust the position pointer to guarantee the end of the file, even in a multitasking environment.\n\nThis feature is most useful in the case of log files, where many jobs may be appending to the log file at the same time, or where care ''must'' be taken to avoid concurrently overwriting the same record from another job.\n\n\n;Task:\nGiven a two record sample for a mythical \"passwd\" file:\n* Write these records out in the typical system format.\n** Ideally these records will have named fields of various types.\n* Close the file, then reopen the file for append.\n** '''Append''' a new record to the file and close the file again.\n** Take appropriate care to avoid concurrently overwrites from another job.\n* Open the file and demonstrate the new record has indeed written to the end.\n\n{|class=\"wikitable\" style=\"text-align: center; margin: 1em auto 1em auto;\"\n|+ Source record field types and contents.\n|-\n!account||password||UID||GID||fullname,office,extension,homephone,email||directory||shell\n|-\n!string||string||int||int||struct(string,string,string,string,string)||string||string\n|-\n|jsmith||x||1001||1000||Joe Smith,Room 1007,(234)555-8917,(234)555-0077,jsmith@rosettacode.org||/home/jsmith||/bin/bash\n|-\n|jdoe||x||1002||1000||Jane Doe,Room 1004,(234)555-8914,(234)555-0044,jdoe@rosettacode.org||/home/jdoe||/bin/bash\n|}\n\n{|class=\"wikitable\" style=\"text-align: center; margin: 1em auto 1em auto;\"\n|+ Record to be appended.\n|-\n!account||password||UID||GID||fullname,office,extension,homephone,email||directory||shell\n|-\n!string||string||int||int||struct(string,string,string,string,string)||string||string\n|-\n|xyz||x||1003||1000||X Yz,Room 1003,(234)555-8913,(234)555-0033,xyz@rosettacode.org||/home/xyz||/bin/bash\n|}\n\n'''Resulting file format:''' should mimic Linux's /etc/passwd file format with particular attention to the \",\" separator used in the [[wp:Gecos field|GECOS field]].  But if the specific language has a particular or unique format of storing records in text file, then this format should be named and demonstrated with an additional example.\n\n'''Expected output:'''\n<pre>\nAppended record: xyz:x:1003:1000:X Yz,Room 1003,(234)555-8913,(234)555-0033,xyz@rosettacode.org:/home/xyz:/bin/bash\n</pre>\n\n'''Finally:''' Provide a summary of the language's \"append record\" capabilities in a table. eg.\n{|class=\"wikitable\" style=\"text-align: center; margin: 1em auto 1em auto;\"\n|+ Append Capabilities.\n|-\n!colspan=2| Data Representation \n!rowspan=2| IO<BR>Library \n!rowspan=2| Append<BR>Possible \n!rowspan=2| Automatic<BR>Append \n!rowspan=2| Multi-tasking<BR>Safe\n|-\n! In core || On disk\n|-\n| C struct || CSV text file || glibc/stdio || \u2611 || \u2611 || \u2611 (Not all, eg NFS)\n|}\n\nAlternatively: If the language's appends can not guarantee its writes will '''always''' append, then note this restriction in the table. If possible, provide an actual code example (possibly using file/record locking) to guarantee correct concurrent appends.\n<br><br>\n\n",
        "solution_pairs": [
            [
                {
                    "language": "RapidQ",
                    "solution": "'Short solution: Append record and read last record\n$Include \"Rapidq.inc\"\n\ndim file as qfilestream\ndim filename as string\ndim LogRec as string\n\n'First create our logfile\nfilename = \"C:\\Logfile2.txt\"\nfile.open(filename, fmCreate)\nfile.writeline \"jsmith:x:1001:1000:Joe Smith,Room 1007,(234)555-8917,(234)555-0077,jsmith@rosettacode.org:/home/jsmith:/bin/bash\"\nfile.writeline \"jdoe:x:1002:1000:Jane Doe,Room 1004,(234)555-8914,(234)555-0044,jdoe@rosettacode.org:/home/jsmith:/bin/bash\"\nfile.close\n\n'Append record\nfile.open(filename, fmOpenWrite)\nfile.position = File.size\nfile.writeline \"xyz:x:1003:1000:X Yz,Room 1003,(234)555-8913,(234)555-0033,xyz@rosettacode.org:/home/xyz:/bin/bash\"\nfile.close\n\n'Read last record\nfile.open (filename, fmOpenRead)\nwhile not file.EOF\n    LogRec = File.Readline\nwend\nfile.close\n\nshowmessage \"Appended record: \" + LogRec\n"
                },
                {
                    "language": "Haskell",
                    "solution": "{-# LANGUAGE RecordWildCards #-}\n\nimport System.IO\nimport Data.List (intercalate)\n\ndata Gecos = Gecos { fullname  :: String\n                   , office    :: String\n                   , extension :: String\n                   , homephone :: String\n                   , email     :: String\n                   }\n\ndata Record = Record { account   :: String\n                     , password  :: String\n                     , uid       :: Int\n                     , gid       :: Int\n                     , directory :: String\n                     , shell     :: String\n                     , gecos     :: Gecos\n                     }\n\ninstance Show Gecos where\n    show (Gecos {..}) = intercalate \",\" [fullname, office, extension, homephone, email]\n\ninstance Show Record where\n    show (Record {..}) = intercalate \":\" [account, password, show uid, show gid, show gecos, directory, shell]\n\naddRecord :: String -> Record -> IO ()\naddRecord path r = appendFile path (show r)\n"
                }
            ],
            [
                {
                    "language": "Raku",
                    "solution": "class record {\n    has $.name;\n    has $.password;\n    has $.UID;\n    has $.GID;\n    has $.fullname;\n    has $.office;\n    has $.extension;\n    has $.homephone;\n    has $.email;\n    has $.directory;\n    has $.shell;\n\n    method gecos { join ',', $.fullname, $.office, $.extension, $.homephone, $.email }\n\n    method gist {\n        join ':',\n        $.name,\n        $.password,\n        $.UID,\n        $.GID,\n        self.gecos,\n        $.directory,\n        $.shell;\n    }\n};\n\nmy $fname = 'foo.fil';\n\ngiven $fname.IO.open(:w) { .close }; # clear file\n\nsub append ($file, $line){\n    my $fh = $file.IO.open(:a) or fail \"Unable to open $file\";\n    given $fh {\n        # Get a lock on the file, waits until lock is active\n        .lock;\n        # seek to the end in case some other process wrote to\n        # the file while we were waiting for the lock\n        .seek(0, SeekType::SeekFromEnd);\n        # write the record\n        .say: $line;\n        .close;\n    }\n}\n\nsub str-to-record ($str) {\n    my %rec = <name password UID GID fullname office extension\n      homephone email directory shell> Z=> $str.split(/<[:,]>/);\n    my $user = record.new(|%rec);\n}\n\nfor\n  'jsmith:x:1001:1000:Joe Smith,Room 1007,(234)555-8917,(234)555-0077,jsmith@rosettacode.org:/home/jsmith:/bin/bash',\n  'jdoe:x:1002:1000:Jane Doe,Room 1004,(234)555-8914,(234)555-0044,jdoe@rosettacode.org:/home/jdoe:/bin/bash'\n-> $line {\n        my $thisuser = str-to-record $line;\n       $fname.&append: $thisuser.gist;\n}\n\nput \"Last line of $fname before append:\";\nput $fname.IO.lines.tail;\n\n$fname.&append: str-to-record('xyz:x:1003:1000:X Yz,Room 1003,(234)555-8913,(234)555-0033,xyz@rosettacode.org:/home/xyz:/bin/bash').gist;\n\nput \"Last line of $fname after append:\";\nput $fname.IO.lines.tail;\n"
                },
                {
                    "language": "Fortran",
                    "solution": "      PROGRAM DEMO\t!As per the described task, more or less.\n      TYPE DETAILS\t\t!Define a component.\n       CHARACTER*28 FULLNAME\n       CHARACTER*12 OFFICE\n       CHARACTER*16 EXTENSION\n       CHARACTER*16 HOMEPHONE\n       CHARACTER*88 EMAIL\n      END TYPE DETAILS\n      TYPE USERSTUFF\t\t!Define the desired data aggregate.\n       CHARACTER*8 ACCOUNT\n       CHARACTER*8 PASSWORD\t!Plain text!! Eeek!!!\n       INTEGER*2 UID\n       INTEGER*2 GID\n       TYPE(DETAILS) PERSON\n       CHARACTER*18 DIRECTORY\n       CHARACTER*12 SHELL\n      END TYPE USERSTUFF\n      TYPE(USERSTUFF) NOTE\t!After all that, I'll have one.\n      NAMELIST /STUFF/ NOTE\t!Enables free-format I/O, with names.\n      INTEGER F,MSG,N\n      MSG = 6\t!Standard output.\n      F = 10\t!Suitable for some arbitrary file.\n      OPEN(MSG, DELIM = \"QUOTE\")\t!Text variables are to be enquoted.\n\nCreate the file and supply its initial content.\n      OPEN (F, FILE=\"Staff.txt\",STATUS=\"REPLACE\",ACTION=\"WRITE\",\n     1 DELIM=\"QUOTE\",RECL=666)\t!Special parameters for the free-format WRITE working.\n\n      WRITE (F,*) USERSTUFF(\"jsmith\",\"x\",1001,1000,\n     1 DETAILS(\"Joe Smith\",\"Room 1007\",\"(234)555-8917\",\n     2  \"(234)555-0077\",\"jsmith@rosettacode.org\"),\n     2 \"/home/jsmith\",\"/bin/bash\")\n\n      WRITE (F,*) USERSTUFF(\"jdoe\",\"x\",1002,1000,\n     1 DETAILS(\"Jane Doe\",\"Room 1004\",\"(234)555-8914\",\n     2  \"(234)555-0044\",\"jdoe@rosettacode.org\"),\n     3 \"home/jdoe\",\"/bin/bash\")\n      CLOSE (F)\t\t!The file is now existing.\n\nChoose the existing file, and append a further record to it.\n      OPEN (F, FILE=\"Staff.txt\",STATUS=\"OLD\",ACTION=\"WRITE\",\n     1 DELIM=\"QUOTE\",RECL=666,ACCESS=\"APPEND\")\n\n      NOTE = USERSTUFF(\"xyz\",\"x\",1003,1000,\t\t!Create a new record's worth of stuff.\n     1 DETAILS(\"X Yz\",\"Room 1003\",\"(234)555-8193\",\n     2  \"(234)555-033\",\"xyz@rosettacode.org\"),\n     3 \"/home/xyz\",\"/bin/bash\")\n      WRITE (F,*) NOTE\t\t\t\t\t!Append its content to the file.\n      CLOSE (F)\n\nChase through the file, revealing what had been written..\n      OPEN (F, FILE=\"Staff.txt\",STATUS=\"OLD\",ACTION=\"READ\",\n     1 DELIM=\"QUOTE\",RECL=666)\n      N = 0\n   10 READ (F,*,END = 20) NOTE\t!As it went out, so it comes in.\n      N = N + 1\t\t\t!Another record read.\n      WRITE (MSG,11) N\t\t!Announce.\n   11 FORMAT (/,\"Record \",I0)\t!Thus without quotes around the text part.\n      WRITE (MSG,STUFF)\t\t!Reveal.\n      GO TO 10\t\t\t!Try again.\n\nClosedown.\n   20 CLOSE (F)\n      END\n"
                }
            ],
            [
                {
                    "language": "Elixir",
                    "solution": "defmodule Gecos do\n  defstruct [:fullname, :office, :extension, :homephone, :email]\n\n  defimpl String.Chars do\n    def to_string(gecos) do\n      [:fullname, :office, :extension, :homephone, :email]\n      |> Enum.map_join(\",\", &Map.get(gecos, &1))\n    end\n  end\nend\n\ndefmodule Passwd do\n  defstruct [:account, :password, :uid, :gid, :gecos, :directory, :shell]\n\n  defimpl String.Chars do\n    def to_string(passwd) do\n      [:account, :password, :uid, :gid, :gecos, :directory, :shell]\n      |> Enum.map_join(\":\", &Map.get(passwd, &1))\n    end\n  end\nend\n\ndefmodule Appender do\n  def write(filename) do\n    jsmith = %Passwd{\n      account: \"jsmith\",\n      password: \"x\",\n      uid: 1001,\n      gid: 1000,\n      gecos: %Gecos{\n        fullname: \"Joe Smith\",\n        office: \"Room 1007\",\n        extension: \"(234)555-8917\",\n        homephone: \"(234)555-0077\",\n        email: \"jsmith@rosettacode.org\"\n      },\n      directory: \"/home/jsmith\",\n      shell: \"/bin/bash\"\n    }\n\n    jdoe = %Passwd{\n      account: \"jdoe\",\n      password: \"x\",\n      uid: 1002,\n      gid: 1000,\n      gecos: %Gecos{\n        fullname: \"Jane Doe\",\n        office: \"Room 1004\",\n        extension: \"(234)555-8914\",\n        homephone: \"(234)555-0044\",\n        email: \"jdoe@rosettacode.org\"\n      },\n      directory: \"/home/jdoe\",\n      shell: \"/bin/bash\"\n    }\n\n    xyz = %Passwd{\n      account: \"xyz\",\n      password: \"x\",\n      uid: 1003,\n      gid: 1000,\n      gecos: %Gecos{\n        fullname: \"X Yz\",\n        office: \"Room 1003\",\n        extension: \"(234)555-8913\",\n        homephone: \"(234)555-0033\",\n        email: \"xyz@rosettacode.org\"\n      },\n      directory: \"/home/xyz\",\n      shell: \"/bin/bash\"\n    }\n\n    File.open!(filename, [:write], fn file ->\n      IO.puts(file, jsmith)\n      IO.puts(file, jdoe)\n    end)\n\n    File.open!(filename, [:append], fn file ->\n      IO.puts(file, xyz)\n    end)\n\n    IO.puts File.read!(filename)\n  end\nend\n\nAppender.write(\"passwd.txt\")\n"
                },
                {
                    "language": "M2000-Interpreter",
                    "solution": "Module TestThis {\n\tClass passwd {\n\t\taccount$, password$\n\t\tUID, GID\n\t\tgroup GECOS {\n\t\t\tfullname$,office$,extension$,homephone$,email$\n\t\t\tfunction Line$() {\n\t\t\t\t=format$(\"{0},{1} {2},{3},{4}\", .fullname$,.office$,.extension$,.homephone$,.email$)\n\t\t\t}\n\t\t}\n\t\tdirectory$, shell$\n\t\tFunction Line$() {\n\t\t\t=format$(\"{0}:{1}:{2}:{3}:{4}:{5}:{6}\",.account$,.password$, .UID, .GID, .GECOS.Line$(), .directory$, .shell$)\n\t\t}\n\tclass:\n\t\tModule passwd {\n\t\t\tif match(\"SSNNSSSSSSS\") then\n\t\t\t\tRead .account$, .password$\n\t\t\t\tRead .UID, .GID\n\t\t\t\tFor .GECOS {\n\t\t\t\t\tRead .fullname$,.office$,.extension$,.homephone$,.email$\n\t\t\t\t}\n\t\t\t\tRead .directory$, .shell$\n\t\t\tElse.If Match(\"S\") then\n\t\t\t\tDim a$(), b$()\n\t\t\t\ta$()=Piece$(letter$, \":\")\n\t\t\t\t.account$<=a$(0)\n\t\t\t\t.password$<=a$(1)\n\t\t\t\t.UID<=Val(a$(2))\n\t\t\t\t.GID<=Val(a$(3))\n\t\t\t\tFor .GECOS {\n\t\t\t\t\tb$()=Piece$(a$(4), \",\")\n\t\t\t\t\t.fullname$<=b$(0)\n\t\t\t\t\t.office$<=Piece$(b$(1), \" \")(0)\n\t\t\t\t\t.extension$<=Piece$(b$(1), \" \")(1)\n\t\t\t\t\t.homephone$<=b$(2)\n\t\t\t\t\t.email$<=b$(3)\n\t\t\t\t}\n\t\t\t\t.directory$<=a$(5)\n\t\t\t\t.shell$<=a$(6)\n\t\t\tEnd if\n\t\t}\n\t}\n\tFlush\n\tData PASSWD(\"jsmith\", \"x\", 1001, 1000, \"Joe Smith\", \"Room\", \"1007\",\"(234)555-8917\",\"(234)555-0077\",\"jsmith@rosettacode.org\",\"/home/jsmith\",\"/bin/bash\")\n\tData PASSWD(\"jdoe:x:1002:1000:Jane Doe,Room 1004,(234)555-8914,(234)555-0044:jdoe@rosettacode.org:/home/jdoe\")\n\t\\\\ we have to make the file if not exist before we use APPEND\n\tif not exist(\"passwd\") then\n\t\tOpen \"passwd\" for Output as #F\n\t\tClose #F\n\tend if\n\tOpen \"passwd\" for wide append as #F\n\tWhile not empty\n\t\tread A\n\t\tPrint #F, A.Line$()\n\tEnd While\n\tClose #F\n\tRet=PASSWD(\"xyz\",\"x\",1003,1000,\"X Yz\", \"Room\", \"1003\", \"(234)555-8913\", \"(234)555-0033\", \"xyz@rosettacode.org\",\"/home/xyz\",\"/bin/bash\")\n\tRepeat\n\t\tTry ok {\n\t\t\tOpen \"passwd\" for wide append exclusive as F\n\t\t\tPrint #F, Ret.Line$()\n\t\t\tclose #F\n\t\t}\n\t\t\n\tUntil  Not (Error or Not ok)\n\tI=1\n\tDocument Ret$\n\tOpen \"passwd\" for wide input as #F\n\tWhile not Eof(#F)\n\t\tLine Input #F, record$\n\t\tRet$=Format$(\"{0}|{1}\",Str$(I,\"0000\"),Record$)+{\n\t\t}\n\t\tI++\n\tEnd While\n\tClose #F\n\tClipBoard Ret$\n\tReport Ret$\n}\nTestThis\n"
                }
            ],
            [
                {
                    "language": "Nim",
                    "solution": "import posix\nimport strutils\n\ntype\n\n  # GECOS representation.\n  Gecos = tuple[fullname, office, extension, homephone, email: string]\n\n  # Record representation.\n  Record = object\n    account: string\n    password: string\n    uid: int\n    gid: int\n    gecos: Gecos\n    directory: string\n    shell: string\n\n#---------------------------------------------------------------------------------------------------\n\nproc str(gecos: Gecos): string =\n  ## Explicit representation of a GECOS.\n\n  result = \"(\"\n  for name, field in gecos.fieldPairs:\n    result.addSep(\", \", 1)\n    result.add(name & \": \" & field)\n  result.add(')')\n\n#---------------------------------------------------------------------------------------------------\n\nproc `$`(gecos: Gecos): string =\n  ## Compact representation of a GECOS.\n\n  for field in gecos.fields:\n    result.addSep(\",\", 0)\n    result.add(field)\n\n#---------------------------------------------------------------------------------------------------\n\nproc parseGecos(s: string): Gecos =\n  ## Parse a string and return a Gecos tuple.\n\n  let fields = s.split(\",\")\n  result = (fields[0], fields[1], fields[2], fields[3], fields[4])\n\n#---------------------------------------------------------------------------------------------------\n\nproc str(rec: Record): string =\n  ## Explicit representation of a record.\n\n  for name, field in rec.fieldPairs:\n    result.add(name & \": \")\n    when typeof(field) is Gecos:\n      result.add(str(field))\n    else:\n      result.add($field)\n    result.add('\\n')\n\n#---------------------------------------------------------------------------------------------------\n\nproc `$`(rec: Record): string =\n  # Compact representation fo a record.\n\n  for field in rec.fields:\n    result.addSep(\":\", 0)\n    result.add($field)\n\n#---------------------------------------------------------------------------------------------------\n\nproc parseRecord(line: string): Record =\n  ## Parse a string and return a Record object.\n\n  let fields = line.split(\":\")\n  result.account = fields[0]\n  result.password = fields[1]\n  result.uid = fields[2].parseInt()\n  result.gid = fields[3].parseInt()\n  result.gecos = parseGecos(fields[4])\n  result.directory = fields[5]\n  result.shell = fields[6]\n\n#---------------------------------------------------------------------------------------------------\n\nproc getLock(f: File): bool =\n  ## Try to get an exclusive write lock on file \"f\". Return false is unsuccessful.\n\n  when defined(posix):\n    var flock = TFlock(l_type: cshort(F_WRLCK), l_whence: cshort(SEEK_SET), l_start: 0, l_len: 0)\n    result = f.getFileHandle().fcntl(F_SETLK, flock.addr) >= 0\n  else:\n    result = true\n\n#\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\n\nvar pwfile: File\n\nconst Filename = \"passwd\"\n\nconst Data = [\"jsmith:x:1001:1000:Joe Smith,Room 1007,(234)555-8917,(234)555-0077,jsmith@rosettacode.org:/home/jsmith:/bin/bash\",\n              \"jdoe:x:1002:1000:Jane Doe,Room 1004,(234)555-8914,(234)555-0044,jdoe@rosettacode.org:/home/jdoe:/bin/bash\"]\n\n# Prepare initial file.\n# We don'\u2019t use a lock here as it is only the preparation.\npwfile = open(FileName, fmWrite)\nfor line in Data:\n  pwfile.writeLine(line)\npwfile.close()\n\n# Display initial contents.\necho \"Raw content of initial password file:\"\necho \"-------------------------------------\"\nvar records: seq[Record]\nfor line in lines(FileName):\n  echo line\n  records.add(line.parseRecord())\n\necho \"\"\necho \"Structured content of initial password file:\"\necho \"--------------------------------------------\"\nfor rec in records:\n  echo str(rec)\n\n# Add a new record at the end of password file.\npwfile = open(Filename, fmAppend)\nlet newRecord = Record(account: \"xyz\",\n                       password: \"x\",\n                       uid: 1003,\n                       gid: 1000,\n                       gecos: (\"X Yz\", \"Room 1003\", \"(234)555-8913\", \"(234)555-0033\", \"xyz@rosettacode.org\"),\n                       directory: \"/home/xyz\",\n                       shell: \"/bin/bash\")\necho \"Appending new record:\"\necho \"---------------------\"\necho str(newRecord)\nif pwfile.getLock():\n  pwFile.writeLine(newRecord)\n  pwfile.close()\nelse:\n  echo \"File is locked. Quitting.\"\n  pwFile.close()\n  quit(QuitFailure)\n\n# Reopen the file and display its contents.\necho \"Raw content of updated password file:\"\necho \"-------------------------------------\"\nfor line in lines(FileName):\n  echo line\n"
                },
                {
                    "language": "Phix",
                    "solution": "(notonline)-->\n <span style=\"color: #008080;\">without</span> <span style=\"color: #008080;\">js</span> <span style=\"color: #000080;font-style:italic;\">-- (file i/o, sleep, task_yield, wait_key)</span>\n <span style=\"color: #008080;\">constant</span> <span style=\"color: #000000;\">filename</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #008000;\">\"passwd.txt\"</span>\n <span style=\"color: #004080;\">integer</span> <span style=\"color: #000000;\">fn</span>\n\n <span style=\"color: #008080;\">constant</span>\n  <span style=\"color: #000000;\">rec1</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #0000FF;\">{</span><span style=\"color: #008000;\">\"jsmith\"</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #008000;\">\"x\"</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">1001</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">1000</span><span style=\"color: #0000FF;\">,{</span><span style=\"color: #008000;\">\"Joe Smith\"</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #008000;\">\"Room 1007\"</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #008000;\">\"(234)555-8917\"</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #008000;\">\"(234)555-0077\"</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #008000;\">\"jsmith@rosettacode.org\"</span><span style=\"color: #0000FF;\">},</span><span style=\"color: #008000;\">\"/home/jsmith\"</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #008000;\">\"/bin/bash\"</span><span style=\"color: #0000FF;\">},</span>\n  <span style=\"color: #000000;\">rec2</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #0000FF;\">{</span><span style=\"color: #008000;\">\"jdoe\"</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #008000;\">\"x\"</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">1002</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">1000</span><span style=\"color: #0000FF;\">,{</span><span style=\"color: #008000;\">\"Jane Doe\"</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #008000;\">\"Room 1004\"</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #008000;\">\"(234)555-8914\"</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #008000;\">\"(234)555-0044\"</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #008000;\">\"jdoe@rosettacode.org\"</span><span style=\"color: #0000FF;\">},</span><span style=\"color: #008000;\">\"/home/jdoe\"</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #008000;\">\"/bin/bash\"</span><span style=\"color: #0000FF;\">},</span>\n  <span style=\"color: #000000;\">rec3</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #0000FF;\">{</span><span style=\"color: #008000;\">\"xyz\"</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #008000;\">\"x\"</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">1003</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">1000</span><span style=\"color: #0000FF;\">,{</span><span style=\"color: #008000;\">\"X Yz\"</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #008000;\">\"Room 1003\"</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #008000;\">\"(234)555-8913\"</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #008000;\">\"(234)555-0033\"</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #008000;\">\"xyz@rosettacode.org\"</span><span style=\"color: #0000FF;\">},</span><span style=\"color: #008000;\">\"/home/xyz\"</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #008000;\">\"/bin/bash\"</span><span style=\"color: #0000FF;\">}</span>\n\n <span style=\"color: #008080;\">function</span> <span style=\"color: #000000;\">tostring</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #004080;\">sequence</span> <span style=\"color: #000000;\">record</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #000000;\">record</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">3</span><span style=\"color: #0000FF;\">]</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">sprintf</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #008000;\">\"%d\"</span><span style=\"color: #0000FF;\">,{</span><span style=\"color: #000000;\">record</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">3</span><span style=\"color: #0000FF;\">]})</span>\n     <span style=\"color: #000000;\">record</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">4</span><span style=\"color: #0000FF;\">]</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">sprintf</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #008000;\">\"%d\"</span><span style=\"color: #0000FF;\">,{</span><span style=\"color: #000000;\">record</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">4</span><span style=\"color: #0000FF;\">]})</span>\n     <span style=\"color: #000000;\">record</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">5</span><span style=\"color: #0000FF;\">]</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">join</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">record</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">5</span><span style=\"color: #0000FF;\">],</span><span style=\"color: #008000;\">\",\"</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #000000;\">record</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">join</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">record</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #008000;\">\":\"</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #008080;\">return</span> <span style=\"color: #000000;\">record</span>\n <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">function</span>\n\n <span style=\"color: #008080;\">procedure</span> <span style=\"color: #000000;\">wait</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #004080;\">string</span> <span style=\"color: #000000;\">what</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #0000FF;\">?</span><span style=\"color: #7060A8;\">sprintf</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #008000;\">\"wait (%s)\"</span><span style=\"color: #0000FF;\">,{</span><span style=\"color: #000000;\">what</span><span style=\"color: #0000FF;\">})</span>\n     <span style=\"color: #7060A8;\">sleep</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #000000;\">task_yield</span><span style=\"color: #0000FF;\">()</span>\n <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">procedure</span>\n\n <span style=\"color: #008080;\">if</span> <span style=\"color: #008080;\">not</span> <span style=\"color: #7060A8;\">file_exists</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">filename</span><span style=\"color: #0000FF;\">)</span> <span style=\"color: #008080;\">then</span>\n     <span style=\"color: #000000;\">fn</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">open</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">filename</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #008000;\">\"w\"</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #008080;\">if</span> <span style=\"color: #000000;\">fn</span><span style=\"color: #0000FF;\">!=-</span><span style=\"color: #000000;\">1</span> <span style=\"color: #008080;\">then</span> <span style=\"color: #000080;font-style:italic;\">-- (someone else just beat us to it?)</span>\n         <span style=\"color: #7060A8;\">printf</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">fn</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #008000;\">\"account:password:UID:GID:fullname,office,extension,homephone,email:directory:shell\\n\"</span><span style=\"color: #0000FF;\">)</span>\n         <span style=\"color: #7060A8;\">printf</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">fn</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #008000;\">\"%s\\n\"</span><span style=\"color: #0000FF;\">,{</span><span style=\"color: #000000;\">tostring</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">rec1</span><span style=\"color: #0000FF;\">)})</span>\n         <span style=\"color: #7060A8;\">printf</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">fn</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #008000;\">\"%s\\n\"</span><span style=\"color: #0000FF;\">,{</span><span style=\"color: #000000;\">tostring</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">rec2</span><span style=\"color: #0000FF;\">)})</span>\n         <span style=\"color: #7060A8;\">close</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">fn</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">if</span>\n <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">if</span>\n <span style=\"color: #008080;\">while</span> <span style=\"color: #000000;\">1</span> <span style=\"color: #008080;\">do</span>\n     <span style=\"color: #000000;\">fn</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">open</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">filename</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #008000;\">\"a\"</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #008080;\">if</span> <span style=\"color: #000000;\">fn</span><span style=\"color: #0000FF;\">!=-</span><span style=\"color: #000000;\">1</span> <span style=\"color: #008080;\">then</span> <span style=\"color: #008080;\">exit</span> <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">if</span>\n     <span style=\"color: #000000;\">wait</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #008000;\">\"append\"</span><span style=\"color: #0000FF;\">)</span>\n <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">while</span>\n <span style=\"color: #000080;font-style:italic;\">--?\"file open in append mode\"; {} = wait_key()</span>\n <span style=\"color: #008080;\">while</span> <span style=\"color: #000000;\">1</span> <span style=\"color: #008080;\">do</span>\n     <span style=\"color: #008080;\">if</span> <span style=\"color: #000000;\">lock_file</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">fn</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">LOCK_EXCLUSIVE</span><span style=\"color: #0000FF;\">,{})</span> <span style=\"color: #008080;\">then</span> <span style=\"color: #008080;\">exit</span> <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">if</span>\n     <span style=\"color: #000000;\">wait</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #008000;\">\"lock\"</span><span style=\"color: #0000FF;\">)</span>\n <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">while</span>\n <span style=\"color: #000080;font-style:italic;\">--?\"file locked\"; {} = wait_key()</span>\n <span style=\"color: #7060A8;\">printf</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">fn</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #008000;\">\"%s\\n\"</span><span style=\"color: #0000FF;\">,{</span><span style=\"color: #000000;\">tostring</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">rec3</span><span style=\"color: #0000FF;\">)})</span>\n <span style=\"color: #000000;\">unlock_file</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">fn</span><span style=\"color: #0000FF;\">,{})</span>\n <span style=\"color: #7060A8;\">close</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">fn</span><span style=\"color: #0000FF;\">)</span>\n <span style=\"color: #008080;\">while</span> <span style=\"color: #000000;\">1</span> <span style=\"color: #008080;\">do</span>\n     <span style=\"color: #000000;\">fn</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">open</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">filename</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #008000;\">\"r\"</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #008080;\">if</span> <span style=\"color: #000000;\">fn</span><span style=\"color: #0000FF;\">!=-</span><span style=\"color: #000000;\">1</span> <span style=\"color: #008080;\">then</span> <span style=\"color: #008080;\">exit</span> <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">if</span>\n     <span style=\"color: #000000;\">wait</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #008000;\">\"read\"</span><span style=\"color: #0000FF;\">)</span>\n <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">while</span>\n\n <span style=\"color: #0000FF;\">?</span><span style=\"color: #7060A8;\">gets</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">fn</span><span style=\"color: #0000FF;\">)</span>\n <span style=\"color: #008080;\">while</span> <span style=\"color: #000000;\">1</span> <span style=\"color: #008080;\">do</span>\n     <span style=\"color: #004080;\">object</span> <span style=\"color: #000000;\">line</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">gets</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">fn</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #008080;\">if</span> <span style=\"color: #004080;\">atom</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">line</span><span style=\"color: #0000FF;\">)</span> <span style=\"color: #008080;\">then</span> <span style=\"color: #008080;\">exit</span> <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">if</span>\n     <span style=\"color: #0000FF;\">?</span><span style=\"color: #000000;\">line</span>\n     <span style=\"color: #0000FF;\">{</span><span style=\"color: #000000;\">line</span><span style=\"color: #0000FF;\">}</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">scanf</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">line</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #008000;\">\"%s:%s:%d:%d:%s:%s:%s\\n\"</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #000000;\">line</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">5</span><span style=\"color: #0000FF;\">]</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">split</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">line</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">5</span><span style=\"color: #0000FF;\">],</span><span style=\"color: #008000;\">','</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #0000FF;\">?</span><span style=\"color: #000000;\">line</span>\n <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">while</span>\n <span style=\"color: #7060A8;\">close</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">fn</span><span style=\"color: #0000FF;\">)</span>\n<!--\n"
                }
            ],
            [
                {
                    "language": "D",
                    "solution": "class Record {\n    private const string account;\n    private const string password;\n    private const int uid;\n    private const int gid;\n    private const string[] gecos;\n    private const string directory;\n    private const string shell;\n\n    public this(string account, string password, int uid, int gid, string[] gecos, string directory, string shell) {\n        import std.exception;\n        this.account = enforce(account);\n        this.password = enforce(password);\n        this.uid = uid;\n        this.gid = gid;\n        this.gecos = enforce(gecos);\n        this.directory = enforce(directory);\n        this.shell = enforce(shell);\n    }\n\n    public void toString(scope void delegate(const(char)[]) sink) const {\n        import std.conv   : toTextRange;\n        import std.format : formattedWrite;\n        import std.range  : put;\n\n        sink(account);\n        put(sink, ':');\n        sink(password);\n        put(sink, ':');\n        toTextRange(uid, sink);\n        put(sink, ':');\n        toTextRange(gid, sink);\n        put(sink, ':');\n        formattedWrite(sink, \"%-(%s,%)\", gecos);\n        put(sink, ':');\n        sink(directory);\n        put(sink, ':');\n        sink(shell);\n    }\n}\n\npublic Record parse(string text) {\n    import std.array  : split;\n    import std.conv   : to;\n    import std.string : chomp;\n\n    string[] tokens = text.chomp.split(':');\n    return new Record(\n            tokens[0],\n            tokens[1],\n            to!int(tokens[2]),\n            to!int(tokens[3]),\n            tokens[4].split(','),\n            tokens[5],\n            tokens[6]);\n}\n\nvoid main() {\n    import std.algorithm : map;\n    import std.file      : exists, mkdir;\n    import std.stdio;\n\n    auto rawData = [\n        \"jsmith:x:1001:1000:Joe Smith,Room 1007,(234)555-8917,(234)555-0077,jsmith@rosettacode.org:/home/jsmith:/bin/bash\",\n        \"jdoe:x:1002:1000:Jane Doe,Room 1004,(234)555-8914,(234)555-0044,jdoe@rosettacode.org:/home/jdoe:/bin/bash\",\n        \"xyz:x:1003:1000:X Yz,Room 1003,(234)555-8913,(234)555-0033,xyz@rosettacode.org:/home/xyz:/bin/bash\"\n    ];\n\n    auto records = rawData.map!parse;\n\n    if (!exists(\"_rosetta\")) {\n        mkdir(\"_rosetta\");\n    }\n\n    auto passwd = File(\"_rosetta/.passwd\", \"w\");\n    passwd.lock();\n    passwd.writeln(records[0]);\n    passwd.writeln(records[1]);\n    passwd.unlock();\n    passwd.close();\n\n    passwd.open(\"_rosetta/.passwd\", \"a\");\n    passwd.lock();\n    passwd.writeln(records[2]);\n    passwd.unlock();\n    passwd.close();\n\n    passwd.open(\"_rosetta/.passwd\");\n    foreach(string line; passwd.lines()) {\n        parse(line).writeln();\n    }\n    passwd.close();\n}\n"
                },
                {
                    "language": "PowerShell",
                    "solution": "$records = @()\n\n$records+= New-Record -Account   'jsmith' `\n                      -Password  'x' `\n                      -UID       1001 `\n                      -GID       1000 `\n                      -FullName  'Joe Smith' `\n                      -Office    'Room 1007' `\n                      -Extension '(234)555-8917' `\n                      -HomePhone '(234)555-0077' `\n                      -Email     'jsmith@rosettacode.org' `\n                      -Directory '/home/jsmith' `\n                      -Shell     '/bin/bash'\n\n$records+= New-Record -Account   'jdoe' `\n                      -Password  'x' `\n                      -UID       1002 `\n                      -GID       1000 `\n                      -FullName  'Jane Doe' `\n                      -Office    'Room 1004' `\n                      -Extension '(234)555-8914' `\n                      -HomePhone '(234)555-0044' `\n                      -Email     'jdoe@rosettacode.org' `\n                      -Directory '/home/jdoe' `\n                      -Shell     '/bin/bash'\n"
                }
            ]
        ]
    },
    {
        "task_name": "Apply-a-callback-to-an-array",
        "task_description": ";Task:\nTake a combined set of elements and apply a function to each element.\n<br><br>\n\n",
        "solution_pairs": [
            [
                {
                    "language": "Nanoquery",
                    "solution": "// create a list of numbers 1-10\nnumbers = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\n\n// display the list as it is\nprintln numbers\n\n// square each element in the list\nfor i in range(1, len(numbers) - 1)\n\tnumbers[i] = numbers[i] * numbers[i]\nend\n\n// display the squared list\nprintln numbers\n"
                },
                {
                    "language": "Haskell",
                    "solution": "import Data.Array (Array, listArray)\n\nsquare :: Int -> Int\nsquare x = x * x\n\nvalues :: Array Int Int\nvalues = listArray (1, 10) [1 .. 10]\n\nmain :: IO ()\nmain = print $ fmap square values\n"
                }
            ],
            [
                {
                    "language": "ACL2",
                    "solution": "(defun apply-to-each (xs)\n   (if (endp xs)\n       nil\n       (cons (fn-to-apply (first xs))\n             (sq-each (rest xs)))))\n\n(defun fn-to-apply (x)\n   (* x x))\n"
                },
                {
                    "language": "Lambdatalk",
                    "solution": "{A.map {lambda {:x} {* :x :x}} {A.new 1 2 3 4 5 6 7 8 9 10}}\n-> [1,4,9,16,25,36,49,64,81,100]\n"
                }
            ],
            [
                {
                    "language": "Perl",
                    "solution": "# create array\nmy @a = (1, 2, 3, 4, 5);\n\n# create callback function\nsub mycallback {\n  return 2 * shift;\n}\n\n# use array indexing\nfor (my $i = 0; $i < scalar @a; $i++) {\n  print \"mycallback($a[$i]) = \", mycallback($a[$i]), \"\\n\";\n}\n\n# using foreach\nforeach my $x (@a) {\n  print \"mycallback($x) = \", mycallback($x), \"\\n\";\n}\n\n# using map (useful for transforming an array)\nmy @b = map mycallback($_), @a;                # @b is now (2, 4, 6, 8, 10)\n\n# and the same using an anonymous function\nmy @c = map { $_ * 2 } @a;                     # @c is now (2, 4, 6, 8, 10)\n\n# use a callback stored in a variable\nmy $func = \\&mycallback;\nmy @d = map $func->($_), @a;                  # @d is now (2, 4, 6, 8, 10)\n\n# filter an array\nmy @e = grep { $_ % 2 == 0 } @a;               # @e is now (2, 4)\n"
                },
                {
                    "language": "Salmon",
                    "solution": "include \"short.salm\";\n\nfun apply(list, ageless to_apply)\n  (comp(x; list) (to_apply(x)));\n\nfun square(x) (x*x);\n\niter(x; apply([0...9], square))\n    x!;\n"
                }
            ],
            [
                {
                    "language": "JavaScript",
                    "solution": "[1, 2, 3, 4, 5].map(v => v * v);\n"
                },
                {
                    "language": "Odin",
                    "solution": "package main\n\nimport \"core:slice\"\nimport \"core:fmt\"\n\nsquared :: proc(x: int) -> int {\n  return x * x\n}\n\nmain :: proc() {\n  arr := []int{1, 2, 3, 4, 5}\n  res := slice.mapper(arr, squared)\n\n  fmt.println(res)  // prints: [1, 4, 9, 16, 25]\n}\n"
                }
            ],
            [
                {
                    "language": "Haskell",
                    "solution": "let printSquares = mapM_ (print.square)\nprintSquares values\n"
                },
                {
                    "language": "ALGOL-W",
                    "solution": "begin\n    procedure printSquare ( integer value x ) ; writeon( i_w := 1, s_w := 0, \" \", x * x );\n    % applys f to each element of a from lb to ub (inclusive) %\n    procedure applyI ( procedure f; integer array a ( * ); integer value lb, ub ) ;\n        for i := lb until ub do f( a( i ) );\n    % test applyI %\n    begin\n        integer array a ( 1 :: 3 );\n        a( 1 ) := 1; a( 2 ) := 2; a( 3 ) := 3;\n        applyI( printSquare, a, 1, 3 )\n    end\nend.\n"
                }
            ]
        ]
    },
    {
        "task_name": "Apply-a-digital-filter-direct-form-II-transposed-",
        "task_description": "Digital filters are used to apply a mathematical operation to a sampled signal. One of the common formulations is the \"direct form II transposed\" which can represent both infinite impulse response (IIR) and finite impulse response (FIR) filters, as well as being more numerically stable than other forms. <ref>[https://ccrma.stanford.edu/~jos/fp/Transposed_Direct_Forms.html]</ref>\n\n;Task:\n\nFilter a signal using an order 3 low-pass Butterworth filter. The coefficients for the filter are a=[1.00000000, -2.77555756e-16, 3.33333333e-01, -1.85037171e-17] and b = [0.16666667, 0.5, 0.5, 0.16666667]\n\nThe signal that needs filtering is the following vector: [-0.917843918645, 0.141984778794, 1.20536903482, 0.190286794412, -0.662370894973, -1.00700480494, -0.404707073677 ,0.800482325044, 0.743500089861, 1.01090520172, 0.741527555207, 0.277841675195, 0.400833448236, -0.2085993586, -0.172842103641, -0.134316096293, 0.0259303398477, 0.490105989562, 0.549391221511, 0.9047198589]\n\n;See also:\n[[https://en.wikipedia.org/wiki/Butterworth_filter Wikipedia on Butterworth filters]]\n\n\n",
        "solution_pairs": [
            [
                {
                    "language": "J",
                    "solution": "Butter=: {{\n  t=. (#n) +/ .*&(|.n)\\(}.n*0),y\n  A=.|.}.m\n  for_i.}.i.#y do.\n    t=. t i}~ (i{t) - (i{.t) +/ .* (-i){.A\n  end.\n  t%{.m\n}}\n\n\nsig=: \". rplc&('-_') {{)n\n  -0.917843918645, 0.141984778794, 1.20536903482,\n   0.190286794412,-0.662370894973,-1.00700480494,\n  -0.404707073677, 0.800482325044, 0.743500089861,\n   1.01090520172,  0.741527555207, 0.277841675195,\n   0.400833448236,-0.2085993586,  -0.172842103641,\n  -0.134316096293, 0.0259303398477,0.490105989562,\n   0.549391221511, 0.9047198589\n}}-.LF\n\na=: 1.00000000 _2.77555756e_16 3.33333333e_01 _1.85037171e_17\nb=: 0.16666667 0.5 0.5 0.16666667\n\n   4 5$ a Butter b sig\n_0.152974 _0.435258 _0.136043 0.697503   0.656445\n_0.435482  _1.08924 _0.537677  0.51705    1.05225\n 0.961854   0.69569  0.424356 0.196262 _0.0278351\n_0.211722 _0.174746 0.0692584 0.385446   0.651771\n"
                },
                {
                    "language": "Mathematica",
                    "solution": "b = {0.16666667, 0.5, 0.5, 0.16666667};\na = {1.00000000, -2.77555756*^-16, 3.33333333*^-01, -1.85037171*^-17};\nsignal = {-0.917843918645, 0.141984778794, 1.20536903482, 0.190286794412, -0.662370894973, -1.00700480494, -0.404707073677, 0.800482325044, 0.743500089861, 1.01090520172, 0.741527555207, 0.277841675195, 0.400833448236, -0.2085993586, -0.172842103641, -0.134316096293, 0.0259303398477, 0.490105989562, 0.549391221511, 0.9047198589};\nRecurrenceFilter[{a, b}, signal]\n"
                }
            ],
            [
                {
                    "language": "Scala",
                    "solution": "object ButterworthFilter extends App {\n  private def filter(a: Vector[Double],\n                     b: Vector[Double],\n                     signal: Vector[Double]): Vector[Double] = {\n\n    @scala.annotation.tailrec\n    def outer(i: Int, acc: Vector[Double]): Vector[Double] = {\n      if (i >= signal.length) acc\n      else {\n        @scala.annotation.tailrec\n        def inner0(j: Int, tmp: Double): Double = if (j >= b.length) tmp\n        else if ((i - j) >= 0) inner0(j + 1, tmp + b(j) * signal(i - j)) else inner0(j + 1, tmp)\n\n        @scala.annotation.tailrec\n        def inner1(j: Int, tmp: Double): Double = if (j >= a.length) tmp\n        else if (i - j >= 0) inner1(j + 1, tmp - a(j) * acc(i - j)) else inner1(j + 1, tmp)\n\n        outer(i + 1, acc :+ inner1(1, inner0(0, 0D)) / a(0))\n      }\n    }\n\n    outer(0, Vector())\n  }\n\n  filter(Vector[Double](1, -2.77555756e-16, 3.33333333e-01, -1.85037171e-17),\n    Vector[Double](0.16666667, 0.5, 0.5, 0.16666667),\n    Vector[Double](\n      -0.917843918645, 0.141984778794, 1.20536903482, 0.190286794412, -0.662370894973,\n      -1.00700480494, -0.404707073677, 0.800482325044, 0.743500089861, 1.01090520172,\n      0.741527555207, 0.277841675195, 0.400833448236, -0.2085993586, -0.172842103641,\n      -0.134316096293, 0.0259303398477, 0.490105989562, 0.549391221511, 0.9047198589)\n  ).grouped(5)\n    .map(_.map(x => f\"$x% .8f\"))\n    .foreach(line => println(line.mkString(\" \")))\n\n}\n"
                },
                {
                    "language": "C",
                    "solution": "#include<stdlib.h>\n#include<string.h>\n#include<stdio.h>\n\n#define MAX_LEN 1000\n\ntypedef struct{\n\tfloat* values;\n\tint size;\n}vector;\n\nvector extractVector(char* str){\n\tvector coeff;\n\tint i=0,count = 1;\n\tchar* token;\n\t\n\twhile(str[i]!=00){\n\t\tif(str[i++]==' ')\n\t\t\tcount++;\n\t}\n\t\n\tcoeff.values = (float*)malloc(count*sizeof(float));\n\tcoeff.size = count;\n\t\n\ttoken = strtok(str,\" \");\n\t\n\ti = 0;\n\t\n\twhile(token!=NULL){\n\t\tcoeff.values[i++] = atof(token);\n\t\ttoken = strtok(NULL,\" \");\n\t}\n\t\n\treturn coeff;\n}\n\nvector processSignalFile(char* fileName){\n\tint i,j;\n\tfloat sum;\n\tchar str[MAX_LEN];\n\tvector coeff1,coeff2,signal,filteredSignal;\n\t\n\tFILE* fp = fopen(fileName,\"r\");\n\t\n\tfgets(str,MAX_LEN,fp);\n\tcoeff1 = extractVector(str);\n\t\n\tfgets(str,MAX_LEN,fp);\n\tcoeff2 = extractVector(str);\n\t\n\tfgets(str,MAX_LEN,fp);\n\tsignal = extractVector(str);\n\n        fclose(fp);\n\t\n\tfilteredSignal.values = (float*)calloc(signal.size,sizeof(float));\n\tfilteredSignal.size = signal.size;\n\t\n\tfor(i=0;i<signal.size;i++){\n\t\tsum = 0;\n\t\t\n\t\tfor(j=0;j<coeff2.size;j++){\n\t\t\tif(i-j>=0)\n\t\t\t\tsum += coeff2.values[j]*signal.values[i-j];\n\t\t}\n\t\t\n\t\tfor(j=0;j<coeff1.size;j++){\n\t\t\tif(i-j>=0)\n\t\t\t\tsum -= coeff1.values[j]*filteredSignal.values[i-j];\n\t\t}\n\t\t\n\t\tsum /= coeff1.values[0];\n\t\tfilteredSignal.values[i] = sum;\n\t}\n\t\n\treturn filteredSignal;\n}\n\nvoid printVector(vector v, char* outputFile){\n\tint i;\n\t\n\tif(outputFile==NULL){\n\t\tprintf(\"[\");\n\t\tfor(i=0;i<v.size;i++)\n\t\t\tprintf(\"%.12f, \",v.values[i]);\n\t\tprintf(\"\\b\\b]\");\n\t}\n\t\n\telse{\n\t\tFILE* fp = fopen(outputFile,\"w\");\n\t\tfor(i=0;i<v.size-1;i++)\n\t\t\tfprintf(fp,\"%.12f, \",v.values[i]);\n\t\tfprintf(fp,\"%.12f\",v.values[i]);\n\t\tfclose(fp);\n\t}\n\t\n}\n\nint main(int argC,char* argV[])\n{\n\tchar *str;\n\tif(argC<2||argC>3)\n\t\tprintf(\"Usage : %s <name of signal data file and optional output file.>\",argV[0]);\n\telse{\n\t\tif(argC!=2){\n\t\t\tstr = (char*)malloc((strlen(argV[2]) + strlen(str) + 1)*sizeof(char));\n\t\t\tstrcpy(str,\"written to \");\n\t\t}\n\t\tprintf(\"Filtered signal %s\",(argC==2)?\"is:\\n\":strcat(str,argV[2]));\n\t\tprintVector(processSignalFile(argV[1]),argV[2]);\n\t}\n\treturn 0;\n}\n"
                }
            ],
            [
                {
                    "language": "Perl",
                    "solution": "use strict;\nuse List::AllUtils 'natatime';\n\nsub TDF_II_filter {\n    our(@signal,@a,@b);\n    local(*signal,*a,*b) = (shift, shift, shift);\n    my @out = (0) x $#signal;\n    for my $i (0..@signal-1) {\n        my $this;\n        map { $this += $b[$_] * $signal[$i-$_] if $i-$_ >= 0 } 0..@b;\n        map { $this -= $a[$_] *    $out[$i-$_] if $i-$_ >= 0 } 0..@a;\n        $out[$i] = $this / $a[0];\n    }\n    @out\n}\n\nmy @signal = (\n    -0.917843918645,  0.141984778794, 1.20536903482,   0.190286794412,\n    -0.662370894973, -1.00700480494, -0.404707073677,  0.800482325044,\n     0.743500089861,  1.01090520172,  0.741527555207,  0.277841675195,\n     0.400833448236, -0.2085993586,  -0.172842103641, -0.134316096293,\n     0.0259303398477, 0.490105989562, 0.549391221511,  0.9047198589\n);\nmy @a = ( 1.00000000, -2.77555756e-16, 3.33333333e-01, -1.85037171e-17 );\nmy @b = ( 0.16666667,  0.5,            0.5,             0.16666667     );\n\nmy @filtered = TDF_II_filter(\\@signal, \\@a, \\@b);\nmy $iter = natatime 5, @filtered;\nwhile( my @values = $iter->() ) {\n    printf(' %10.6f' x 5 . \"\\n\", @values);\n}\n"
                },
                {
                    "language": "11l",
                    "solution": "F apply_filter(a, b, signal)\n   V result = [0.0] * signal.len\n   L(i) 0 .< signal.len\n      V tmp = 0.0\n      L(j) 0 .< min(i + 1, b.len)\n         tmp += b[j] * signal[i - j]\n      L(j) 1 .< min(i + 1, a.len)\n         tmp -= a[j] * result[i - j]\n      tmp /= a[0]\n      result[i] = tmp\n   R result\n\nV a = [1.00000000, -2.77555756e-16, 3.33333333e-01, -1.85037171e-17]\nV b = [0.16666667, 0.5, 0.5, 0.16666667]\n\nV signal = [-0.917843918645,  0.141984778794, 1.20536903482,   0.190286794412,\n            -0.662370894973, -1.00700480494, -0.404707073677,  0.800482325044,\n             0.743500089861,  1.01090520172,  0.741527555207,  0.277841675195,\n             0.400833448236, -0.2085993586,  -0.172842103641, -0.134316096293,\n             0.0259303398477, 0.490105989562, 0.549391221511,  0.9047198589]\n\nV result = apply_filter(a, b, signal)\nL(r) result\n   print(\u2018#2.8\u2019.format(r), end' \u2018\u2019)\n   print(I (L.index + 1) % 5 != 0 {\u2018, \u2019} E \"\\n\", end' \u2018\u2019)\n"
                }
            ],
            [
                {
                    "language": "Zkl",
                    "solution": "signal:=T(-0.917843918645, 0.141984778794, 1.20536903482,  0.190286794412,\n\t  -0.662370894973,-1.00700480494, -0.404707073677, 0.800482325044,\n\t   0.743500089861, 1.01090520172,  0.741527555207, 0.277841675195,\n\t   0.400833448236,-0.2085993586,  -0.172842103641,-0.134316096293,\n\t   0.0259303398477,0.490105989562, 0.549391221511, 0.9047198589 );\na:=T(1.0, -2.77555756e-16, 3.33333333e-01, -1.85037171e-17 );\nb:=T(0.16666667, 0.5, 0.5, 0.16666667 );\nresult:=direct_form_II_transposed_filter(b,a,signal);\nprintln(result);\n"
                },
                {
                    "language": "Kotlin",
                    "solution": "// version 1.1.3\n\nfun filter(a: DoubleArray, b: DoubleArray, signal: DoubleArray): DoubleArray {\n    val result = DoubleArray(signal.size)\n    for (i in 0 until signal.size) {\n        var tmp = 0.0\n        for (j in 0 until b.size) {\n            if (i - j < 0) continue\n            tmp += b[j] * signal[i - j]\n        }\n        for (j in 1 until a.size) {\n            if (i - j < 0) continue\n            tmp -= a[j] * result[i - j]\n        }\n        tmp /= a[0]\n        result[i] = tmp\n    }\n    return result\n}\n\nfun main(args: Array<String>) {\n    val a = doubleArrayOf(1.00000000, -2.77555756e-16, 3.33333333e-01, -1.85037171e-17)\n    val b = doubleArrayOf(0.16666667, 0.5, 0.5, 0.16666667)\n\n    val signal = doubleArrayOf(\n        -0.917843918645, 0.141984778794, 1.20536903482, 0.190286794412,\n        -0.662370894973, -1.00700480494, -0.404707073677, 0.800482325044,\n        0.743500089861, 1.01090520172, 0.741527555207, 0.277841675195,\n        0.400833448236, -0.2085993586, -0.172842103641, -0.134316096293,\n        0.0259303398477, 0.490105989562, 0.549391221511, 0.9047198589\n    )\n\n    val result = filter(a, b, signal)\n    for (i in 0 until result.size) {\n        print(\"% .8f\".format(result[i]))\n        print(if ((i + 1) % 5 != 0) \", \" else \"\\n\")\n    }\n}\n"
                }
            ],
            [
                {
                    "language": "Yabasic",
                    "solution": "sub filter(a(), b(), signal(), result())\n    local i, j, tmp\n\n    for i = 0 to arraysize(signal(), 1)\n        tmp = 0\n        for j = 0 to arraysize(b(), 1)\n            if (i-j<0) continue\n            tmp = tmp + b(j) * signal(i-j)\n        next\n        for j = 0 to arraysize(a(), 1)\n            if (i-j<0) continue\n            tmp = tmp - a(j) * result(i-j)\n        next\n        tmp = tmp / a(0)\n        result(i) = tmp\n    next\nend sub\n\ndim a(4), b(4), signal(20), result(20)\n\n// a()\ndata 1, -2.77555756e-16, 3.33333333e-01, -1.85037171e-17\n// b()\ndata 0.16666667, 0.5, 0.5, 0.16666667\n// signal()\ndata -0.917843918645, 0.141984778794, 1.20536903482, 0.190286794412\ndata -0.662370894973, -1.00700480494, -0.404707073677, 0.800482325044\ndata 0.743500089861, 1.01090520172, 0.741527555207, 0.277841675195\ndata 0.400833448236, -0.2085993586, -0.172842103641, -0.134316096293\ndata 0.0259303398477, 0.490105989562, 0.549391221511, 0.9047198589\n\nfor i = 0 to 3 : read a(i) : next\nfor i = 0 to 3 : read b(i) : next\nfor i = 0 to 19 : read signal(i) : next\n\nfilter(a(),b(),signal(),result())\n\nfor i = 0 to 19\n    print result(i) using \"%11.8f\";\n    if mod(i+1, 5) <> 0 then\n        print \", \";\n    else\n        print\n    end if\nnext\n"
                },
                {
                    "language": "Perl",
                    "solution": "use strict;\nuse List::AllUtils 'natatime';\n\nsub TDF_II_filter {\n    our(@signal,@a,@b);\n    local(*signal,*a,*b) = (shift, shift, shift);\n    my @out = (0) x $#signal;\n    for my $i (0..@signal-1) {\n        my $this;\n        map { $this += $b[$_] * $signal[$i-$_] if $i-$_ >= 0 } 0..@b;\n        map { $this -= $a[$_] *    $out[$i-$_] if $i-$_ >= 0 } 0..@a;\n        $out[$i] = $this / $a[0];\n    }\n    @out\n}\n\nmy @signal = (\n    -0.917843918645,  0.141984778794, 1.20536903482,   0.190286794412,\n    -0.662370894973, -1.00700480494, -0.404707073677,  0.800482325044,\n     0.743500089861,  1.01090520172,  0.741527555207,  0.277841675195,\n     0.400833448236, -0.2085993586,  -0.172842103641, -0.134316096293,\n     0.0259303398477, 0.490105989562, 0.549391221511,  0.9047198589\n);\nmy @a = ( 1.00000000, -2.77555756e-16, 3.33333333e-01, -1.85037171e-17 );\nmy @b = ( 0.16666667,  0.5,            0.5,             0.16666667     );\n\nmy @filtered = TDF_II_filter(\\@signal, \\@a, \\@b);\nmy $iter = natatime 5, @filtered;\nwhile( my @values = $iter->() ) {\n    printf(' %10.6f' x 5 . \"\\n\", @values);\n}\n"
                }
            ]
        ]
    },
    {
        "task_name": "Approximate-equality",
        "task_description": "Sometimes, when testing whether the solution to a task (for example, here on Rosetta Code) is correct, the\ndifference in floating point calculations between different language implementations becomes significant. \n\nFor example, a difference between '''32''' bit and '''64''' bit floating point calculations may appear by \nabout the 8th significant digit in base 10 arithmetic.\n\n\n;Task:\nCreate a function which returns true if two floating point numbers are approximately equal. \n\n\nThe function should allow for differences in the magnitude of numbers, so that, for example, \n<br>'''100000000000000.01''' &nbsp; may be approximately equal to &nbsp; '''100000000000000.011''', \n<br>even though &nbsp; '''100.01''' &nbsp; is not approximately equal to &nbsp; '''100.011'''.\n\nIf the language has such a feature in its standard library, this may be used instead of a custom function.\n\nShow the function results with comparisons on the following pairs of values:\n:# &nbsp; &nbsp; 100000000000000.01,                      &nbsp; 100000000000000.011   &nbsp; &nbsp; (note: should return ''true'')\n:# &nbsp; &nbsp; 100.01,                                  &nbsp; 100.011 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (note: should return ''false'')\n:# &nbsp; &nbsp; 10000000000000.001 <big>/</big> 10000.0, &nbsp; 1000000000.0000001000\n:# &nbsp; &nbsp; 0.001,                                   &nbsp; 0.0010000001\n:# &nbsp; &nbsp; 0.000000000000000000000101,              &nbsp; 0.0\n:# &nbsp; &nbsp; &nbsp;sqrt(2) * sqrt(2),                 &nbsp; &nbsp;2.0\n:# &nbsp; &nbsp; -sqrt(2) * sqrt(2),                      &nbsp; -2.0\n:# &nbsp; &nbsp; 3.14159265358979323846,                  &nbsp; 3.14159265358979324\n<br/>\nAnswers should be true for the first example and false in the second, so that just rounding the numbers to a fixed number of decimals should not be enough. Otherwise answers may vary and still be correct. See the Python code for one type of solution.\n<br><br>\n\n__TOC__\n\n",
        "solution_pairs": [
            [
                {
                    "language": "Rust",
                    "solution": "/// Return whether the two numbers `a` and `b` are close.\n/// Closeness is determined by the `epsilon` parameter -\n/// the numbers are considered close if the difference between them\n/// is no more than epsilon * max(abs(a), abs(b)).\nfn isclose(a: f64, b: f64, epsilon: f64) -> bool {\n    (a - b).abs() <= a.abs().max(b.abs()) * epsilon\n}\n\nfn main() {\n    fn sqrt(x: f64) -> f64 { x.sqrt() }\n    macro_rules! test {\n        ($a: expr, $b: expr) => {\n            let operator = if isclose($a, $b, 1.0e-9) { '\u2248' } else { '\u2249' };\n            println!(\"{:>28} {} {}\", stringify!($a), operator, stringify!($b))\n        }\n    }\n\n    test!(100000000000000.01, 100000000000000.011);\n    test!(100.01, 100.011);\n    test!(10000000000000.001/10000.0, 1000000000.0000001000);\n    test!(0.001, 0.0010000001);\n    test!(0.000000000000000000000101, 0.0);\n    test!( sqrt(2.0) * sqrt(2.0), 2.0);\n    test!(-sqrt(2.0) * sqrt(2.0), -2.0);\n    test!(3.14159265358979323846, 3.14159265358979324);\n}\n"
                },
                {
                    "language": "Ruby",
                    "solution": "require \"bigdecimal\"\n\ntestvalues = [[100000000000000.01,           100000000000000.011],\n              [100.01,                       100.011],\n              [10000000000000.001 / 10000.0, 1000000000.0000001000],\n              [0.001,                        0.0010000001],\n              [0.000000000000000000000101,   0.0],\n              [(2**0.5) * (2**0.5),            2.0],\n              [-(2**0.5) * (2**0.5),          -2.0],\n              [BigDecimal(\"3.14159265358979323846\"),       3.14159265358979324],\n              [Float::NAN, Float::NAN,],\n              [Float::INFINITY, Float::INFINITY],\n               ]\n\nclass  Numeric\n  def close_to?(num, tol = Float::EPSILON)\n    return true  if self == num\n    return false if (self.to_f.nan? or num.to_f.nan?)        # NaN is not even close to itself\n    return false if [self, num].count( Float::INFINITY) == 1 # Infinity is only close to itself\n    return false if [self, num].count(-Float::INFINITY) == 1\n    (self-num).abs <= tol * ([self.abs, num.abs].max)\n  end\nend\n\ntestvalues.each do |a,b|\n  puts \"#{a} #{a.close_to?(b) ? '\u2248' : '\u2249'} #{b}\"\nend\n"
                }
            ],
            [
                {
                    "language": "R",
                    "solution": "approxEq <- function(...) isTRUE(all.equal(...))\ntests <- rbind(c(100000000000000.01, 100000000000000.011),\n             c(100.01, 100.011),\n             c(10000000000000.001 / 10000.0, 1000000000.0000001000),\n             c(0.001, 0.0010000001),\n             c(0.000000000000000000000101, 0.0),\n             c(sqrt(2) * sqrt(2), 2.0),\n             c(-sqrt(2) * sqrt(2), -2.0),\n             c(3.14159265358979323846, 3.14159265358979324))\nresults <- mapply(approxEq, tests[, 1], tests[, 2])\n#All that remains is to print out our results in a presentable way:\nprintableTests <- format(tests, scientific = FALSE)\nprint(data.frame(x = printableTests[, 1], y = printableTests[, 2], Equal = results, row.names = paste0(\"Test \", 1:8, \": \")))\n"
                },
                {
                    "language": "D",
                    "solution": "import std.math;\nimport std.stdio;\n\nauto approxEquals = (double a, double b, double epsilon) => abs(a - b) < epsilon;\n\nvoid main() {\n    void test(double a, double b) {\n        double epsilon = 1e-18;\n        writefln(\"%.18f, %.18f => %s\", a, b, a.approxEquals(b, epsilon));\n    }\n\n    test(100000000000000.01, 100000000000000.011);\n    test(100.01, 100.011);\n    test(10000000000000.001 / 10000.0, 1000000000.0000001000);\n    test(0.001, 0.0010000001);\n    test(0.000000000000000000000101, 0.0);\n    test(sqrt(2.0) * sqrt(2.0), 2.0);\n    test(-sqrt(2.0) * sqrt(2.0), -2.0);\n    test(3.14159265358979323846, 3.14159265358979324);\n}\n"
                }
            ],
            [
                {
                    "language": "J",
                    "solution": "   NB. default comparison tolerance matches the python result\n   \".;._2]0 :0\n      100000000000000.01 =   100000000000000.011\n      100.01 =   100.011\n      (10000000000000.001 % 10000.0) =   1000000000.0000001000\n      0.001 =   0.0010000001\n      0.000000000000000000000101 =   0.0\n      (= ([: *~ %:)) 2                    NB. sqrt(2)*sqrt(2)\n      ((= -)~ ([: (* -) %:)) 2            NB. -sqrt(2) * sqrt(2),   -2.0\n      3.14159265358979323846 =   3.14159265358979324\n)\n1 0 1 0 0 1 1 1\n\n\n   NB. tolerance of 1e_12 matches the python result\n   \".;._2]0 :0[CT=:1e_12\n      100000000000000.01 =!.CT   100000000000000.011\n      100.01 =!.CT   100.011\n      (10000000000000.001 % 10000.0) =!.CT   1000000000.0000001000\n      0.001 =!.CT   0.0010000001\n      0.000000000000000000000101 =!.CT   0.0\n      (=!.CT ([: *~ %:)) 2                    NB. sqrt(2)*sqrt(2)\n      ((=!.CT -)~ ([: (* -) %:)) 2            NB. -sqrt(2) * sqrt(2),   -2.0\n      3.14159265358979323846 =!.CT   3.14159265358979324\n)\n1 0 1 0 0 1 1 1\n\n\n   NB. tight tolerance\n   \".;._2]0 :0[CT=:1e_18\n      100000000000000.01 =!.CT   100000000000000.011\n      100.01 =!.CT   100.011\n      (10000000000000.001 % 10000.0) =!.CT   1000000000.0000001000\n      0.001 =!.CT   0.0010000001\n      0.000000000000000000000101 =!.CT   0.0\n      (=!.CT ([: *~ %:)) 2                    NB. sqrt(2)*sqrt(2)\n      ((=!.CT -)~ ([: (* -) %:)) 2            NB. -sqrt(2) * sqrt(2),   -2.0\n      3.14159265358979323846 =!.CT   3.14159265358979324\n)\n1 0 0 0 0 0 0 1\n\n   2 (=!.1e_8) 9\n|domain error\n|   2(=    !.1e_8)9\n"
                },
                {
                    "language": "Rust",
                    "solution": "/// Return whether the two numbers `a` and `b` are close.\n/// Closeness is determined by the `epsilon` parameter -\n/// the numbers are considered close if the difference between them\n/// is no more than epsilon * max(abs(a), abs(b)).\nfn isclose(a: f64, b: f64, epsilon: f64) -> bool {\n    (a - b).abs() <= a.abs().max(b.abs()) * epsilon\n}\n\nfn main() {\n    fn sqrt(x: f64) -> f64 { x.sqrt() }\n    macro_rules! test {\n        ($a: expr, $b: expr) => {\n            let operator = if isclose($a, $b, 1.0e-9) { '\u2248' } else { '\u2249' };\n            println!(\"{:>28} {} {}\", stringify!($a), operator, stringify!($b))\n        }\n    }\n\n    test!(100000000000000.01, 100000000000000.011);\n    test!(100.01, 100.011);\n    test!(10000000000000.001/10000.0, 1000000000.0000001000);\n    test!(0.001, 0.0010000001);\n    test!(0.000000000000000000000101, 0.0);\n    test!( sqrt(2.0) * sqrt(2.0), 2.0);\n    test!(-sqrt(2.0) * sqrt(2.0), -2.0);\n    test!(3.14159265358979323846, 3.14159265358979324);\n}\n"
                }
            ],
            [
                {
                    "language": "Common-Lisp",
                    "solution": "(defun approx-equal (float1 float2 &optional (threshold 0.000001))\n  \"Determine whether float1 and float2 are equal; THRESHOLD is the\nmaximum allowable difference between normalized significands of floats\nwith the same exponent. The significands are scaled appropriately\nbefore comparison for floats with different exponents.\"\n  (multiple-value-bind (sig1 exp1 sign1) (decode-float float1)\n    (multiple-value-bind (sig2 exp2 sign2) (decode-float float2)\n      (let ((cmp1 (float-sign sign1 (scale-float sig1 (floor (- exp1 exp2) 2))))\n            (cmp2 (float-sign sign2 (scale-float sig2 (floor (- exp2 exp1) 2)))))\n        (< (abs (- cmp1 cmp2)) threshold)))))\n"
                },
                {
                    "language": "Pascal",
                    "solution": "program approximateEqual(output);\n\n{\n\t\\brief determines whether two `real` values are approximately equal\n\t\\param x a reference value\n\t\\param y the value to compare with \\param x\n\t\\return true if \\param x is equal or approximately equal to \\param y\n}\nfunction equal(protected x, y: real): Boolean;\n\tfunction approximate: Boolean;\n\t\tfunction d(protected x: real): integer;\n\t\tbegin\n\t\t\td := trunc(ln(abs(x) + minReal) / ln(2)) + 1\n\t\tend;\n\tbegin\n\t\tapproximate := abs(x - y) <= epsReal * (maxReal / (d(x) + d(y)))\n\tend;\nbegin\n\tequal := (x = y) or_else (x * y >= 0.0) and_then approximate\nend;\n\n{ --- auxilliary routines ---------------------------------------------- }\nprocedure test(protected x, y: real);\nconst\n\t{ ANSI escape code for color coding }\n\tCSI = chr(8#33) + '[';\n\ttotalMinimumWidth = 40;\n\tpostRadixDigits = 24;\nbegin\n\twrite(x:totalMinimumWidth:postRadixDigits, '':1, CSI, '1;3');\n\t\n\tif equal(x, y) then\n\tbegin\n\t\tif x = y then\n\t\tbegin\n\t\t\twrite('2m\u2245')\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\twrite('5m\u2246')\n\t\tend\n\tend\n\telse\n\tbegin\n\t\twrite('1m\u2247')\n\tend;\n\t\n\twriteLn(CSI, 'm', '':1, y:totalMinimumWidth:postRadixDigits)\nend;\n\n{ === MAIN ============================================================= }\nvar\n\tn: integer;\n\tx: real;\nbegin\n\t{ Variables were used to thwart compile-time evaluation done }\n\t{ by /some/ compilers potentially confounding the results. }\n\tn := 2;\n\tx := 100000000000000.01;\n\t\n\ttest(x, 100000000000000.011);\n\ttest(100.01, 100.011);\n\ttest(x / 10000.0, 1000000000.0000001000);\n\ttest(0.001, 0.0010000001);\n\ttest(0.000000000000000000000101, 0.0);\n\tx := sqrt(n);\n\ttest(sqr(x), 2.0);\n\ttest((-x) * x, -2.0);\n\ttest(3.14159265358979323846, 3.14159265358979324)\nend.\n"
                }
            ],
            [
                {
                    "language": "Sidef",
                    "solution": "[\n    100000000000000.01, 100000000000000.011,\n    100.01, 100.011,\n    10000000000000.001 / 10000.0, 1000000000.0000001000,\n    0.001, 0.0010000001,\n    0.000000000000000000000101, 0.0,\n    sqrt(2) * sqrt(2), 2.0,\n    -sqrt(2) * sqrt(2), -2.0,\n    sqrt(-2) * sqrt(-2), -2.0,\n    cbrt(3)**3, 3,\n    cbrt(-3)**3, -3,\n    100000000000000003.0, 100000000000000004.0,\n    3.14159265358979323846, 3.14159265358979324\n].each_slice(2, {|a,b|\n    say (\"#{a} \u2245 #{b}: \", a \u2245 b)\n})\n"
                },
                {
                    "language": "C",
                    "solution": "#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n\nbool approxEquals(double value, double other, double epsilon) {\n    return fabs(value - other) < epsilon;\n}\n\nvoid test(double a, double b) {\n    double epsilon = 1e-18;\n    printf(\"%f, %f => %d\\n\", a, b, approxEquals(a, b, epsilon));\n}\n\nint main() {\n    test(100000000000000.01, 100000000000000.011);\n    test(100.01, 100.011);\n    test(10000000000000.001 / 10000.0, 1000000000.0000001000);\n    test(0.001, 0.0010000001);\n    test(0.000000000000000000000101, 0.0);\n    test(sqrt(2.0) * sqrt(2.0), 2.0);\n    test(-sqrt(2.0) * sqrt(2.0), -2.0);\n    test(3.14159265358979323846, 3.14159265358979324);\n    return 0;\n}\n"
                }
            ]
        ]
    },
    {
        "task_name": "Arbitrary-precision-integers-included-",
        "task_description": "Using the in-built capabilities of your language, calculate the integer value of:\n\n         <big><big><math>5^{4^{3^2}}</math></big></big>\n\n*  Confirm that the first and last twenty digits of the answer are:      \n      62060698786608744707...92256259918212890625\n*  Find and show the number of decimal digits in the answer.\n\n<br>\n<small>Note: <ul><li>Do not submit an ''implementation'' of [[wp:arbitrary precision arithmetic|arbitrary precision arithmetic]]. The intention is to show the capabilities of the language as supplied. If a language has a [[Talk:Arbitrary-precision integers (included)#Use of external libraries|single, overwhelming, library]] of varied modules that is endorsed by its home site \u2013 such as [[CPAN]] for Perl or [[Boost]] for C++ \u2013 then that ''may'' be used instead.\n</li><li>Strictly speaking, this should not be solved by fixed-precision numeric libraries where the precision has to be manually set to a large value; although if this is the '''only''' recourse then it may be used with a note explaining that the precision must be set manually to a large enough value.</li></ul></small>\n\n\n;Related tasks:\n* &nbsp; [[Long multiplication]]\n* &nbsp; [[Exponentiation order]]\n* &nbsp; [[Exponentiation_operator|exponentiation operator]]\n* &nbsp; [[Exponentiation with infix operators in (or operating on) the base]]\n<br><br>\n\n",
        "solution_pairs": [
            [
                {
                    "language": "D",
                    "solution": "void main() {\n  import std.stdio, std.bigint, std.conv;\n\n  auto s = text(5.BigInt ^^ 4 ^^ 3 ^^ 2);\n  writefln(\"5^4^3^2 = %s..%s (%d digits)\", s[0..20], s[$-20..$], s.length);\n}\n"
                },
                {
                    "language": "Frink",
                    "solution": "a = 5^4^3^2\nas = \"$a\"     // Coerce to string\nprintln[\"Length=\" + length[as] + \", \" + left[as,20] + \"...\" + right[as,20]]\n"
                }
            ],
            [
                {
                    "language": "Ceylon",
                    "solution": "import ceylon.whole {\n    wholeNumber,\n    two\n}\n\nshared void run() {\n\n    value five = wholeNumber(5);\n    value four = wholeNumber(4);\n    value three = wholeNumber(3);\n\n    value bigNumber = five ^ four ^ three ^ two;\n\n    value firstTwenty = \"62060698786608744707\";\n    value lastTwenty =  \"92256259918212890625\";\n    value bigString = bigNumber.string;\n\n    \"The number must start with ``firstTwenty`` and end with ``lastTwenty``\"\n    assert(bigString.startsWith(firstTwenty), bigString.endsWith(lastTwenty));\n\n    value bigSize = bigString.size;\n    print(\"The first twenty digits are ``bigString[...19]``\");\n    print(\"The last twenty digits are ``bigString[(bigSize - 20)...]``\");\n    print(\"The number of digits in 5^4^3^2 is ``bigSize``\");\n}\n"
                },
                {
                    "language": "Ursa",
                    "solution": "import \"unbounded_int\"\ndecl unbounded_int x\nx.set ((x.valueof 5).pow ((x.valueof 4).pow ((x.valueof 3).pow 2)))\n\ndecl string first last xstr\nset xstr (string x)\n\n# get the first twenty digits\ndecl int i\nfor (set i 0) (< i 20) (inc i)\n\tset first (+ first xstr<i>)\nend for\n\n# get the last twenty digits\nfor (set i (- (size xstr) 20)) (< i (size xstr)) (inc i)\n\tset last (+ last xstr<i>)\nend for\n\nout \"the first and last digits of 5^(4^(3^2)) are \" first \"...\" console\nout last \" (the result was \" (size xstr) \" digits long)\" endl endl console\n\nif (and (and (= first \"62060698786608744707\") (= last \"92256259918212890625\")) (= (size xstr) 183231))\n\tout \"(pass)\" endl console\nelse\n\tout \"FAIL\" endl console\nend if\n"
                }
            ],
            [
                {
                    "language": "Standard-ML",
                    "solution": "let\n  val answer = IntInf.pow (5, IntInf.toInt (IntInf.pow (4, IntInf.toInt (IntInf.pow (3, 2)))))\n  val s = IntInf.toString answer\n  val len = size s\nin\n  print (\"has \" ^ Int.toString len ^ \" digits: \" ^\n         substring (s, 0, 20) ^ \" ... \" ^\n         substring (s, len-20, 20) ^ \"\\n\")\nend;\n"
                },
                {
                    "language": "Clojure",
                    "solution": "(defn exp [n k]\n  (cond\n    (zero? (mod k 2)) (recur (* n n) (/ k 2))\n    (zero? (mod k 3)) (recur (* n n n) (/ k 3))\n    :else (reduce * (repeat k n))))\n"
                }
            ],
            [
                {
                    "language": "REXX",
                    "solution": "/*REXX program calculates and demonstrates  arbitrary precision numbers (using powers). */\nnumeric digits 5                                 /*just use enough digits for 1st time. */\n\n                  #=5** (4** (3** 2) )           /*calculate multiple exponentiations.  */\n\nparse var  #  'E'  pow  .                        /*POW   might be null,  so   N  is OK. */\n\nif pow\\==''  then do                             /*general case:   POW  might be < zero.*/\n                  numeric digits  abs(pow) + 9   /*recalculate with more decimal digits.*/\n                  #=5** (4** (3** 2) )           /*calculate multiple exponentiations.  */\n                  end                            /* [\u2191]  calculation is the real McCoy. */\n\ntrue=62060698786608744707...92256259918212890625 /*what answer is supposed to look like.*/\nrexx= left(#, 20)'...'right(#, 20)               /*the left and right 20 decimal digits.*/\n\nsay  '  true:'    true                           /*show what the  \"true\"  answer is.    */\nsay  '  REXX:'    rexx                           /*  \"    \"   \"    REXX      \"    \"     */\nsay  'digits:'    length(#)                      /*  \"    \"   \"   length  of answer is. */\nsay\nif true == rexx   then say 'passed!'             /*either it passed,  \u00b7\u00b7\u00b7               */\n                  else say 'failed!'             /*    or it didn't.                    */\n                                                 /*stick a fork in it,  we're all done. */\n"
                },
                {
                    "language": "Oforth",
                    "solution": "import: mapping\n\n5 4 3 2 pow pow pow >string dup left( 20 ) . dup right( 20 ) . size .\n"
                }
            ],
            [
                {
                    "language": "Nanoquery",
                    "solution": "value = str(5^(4^(3^2)))\n\nfirst20 = value.substring(0,20)\nlast20 = value.substring(len(value) - 20)\n\nprintln \"The first twenty digits are \" + first20\nprintln \"The last twenty digits are \" + last20\n\nif (first20 = \"62060698786608744707\") && (last20 = \"92256259918212890625\")\n\tprintln \"\\nThese digits are correct.\\n\"\nend\n\nprintln \"The result is \" + len(str(value)) + \" digits long\"\n"
                },
                {
                    "language": "OoRexx",
                    "solution": "--REXX program to show arbitrary precision integers.\nnumeric digits 200000\ncheck = '62060698786608744707...92256259918212890625'\n\nstart = .datetime~new\nn = 5 ** (4 ** (3**2))\ntime = .datetime~new - start\nsay 'elapsed time for the calculation:' time\nsay\nsampl = left(n, 20)\"...\"right(n, 20)\n\nsay ' check:' check\nsay 'Sample:' sampl\nsay 'digits:' length(n)\nsay\n\nif check=sampl then say 'passed!'\n               else say 'failed!'\n"
                }
            ]
        ]
    },
    {
        "task_name": "Archimedean-spiral",
        "task_description": "The [[wp:Archimedean_spiral|Archimedean spiral]] is a spiral named after the Greek mathematician Archimedes. \n\n\nAn Archimedean spiral can be described by the equation:\n\n:<big><math>\\, r=a+b\\theta</math></big>\n\nwith real numbers ''a'' and ''b''.\n\n\n;Task\nDraw an Archimedean spiral.\n<br><br>\n\n",
        "solution_pairs": [
            [
                {
                    "language": "Go",
                    "solution": "package main\n\nimport (\n\t\"image\"\n\t\"image/color\"\n\t\"image/draw\"\n\t\"image/png\"\n\t\"log\"\n\t\"math\"\n\t\"os\"\n)\n\nfunc main() {\n\tconst (\n\t\twidth, height = 600, 600\n\t\tcentre        = width / 2.0\n\t\tdegreesIncr   = 0.1 * math.Pi / 180\n\t\tturns         = 2\n\t\tstop          = 360 * turns * 10 * degreesIncr\n\t\tfileName      = \"spiral.png\"\n\t)\n\n\timg := image.NewNRGBA(image.Rect(0, 0, width, height)) // create new image\n\tbg := image.NewUniform(color.RGBA{255, 255, 255, 255}) // prepare white for background\n\tdraw.Draw(img, img.Bounds(), bg, image.ZP, draw.Src)   // fill the background\n\tfgCol := color.RGBA{255, 0, 0, 255}                    // red plot\n\n\ta := 1.0\n\tb := 20.0\n\n\tfor theta := 0.0; theta < stop; theta += degreesIncr {\n\t\tr := a + b*theta\n\t\tx := r * math.Cos(theta)\n\t\ty := r * math.Sin(theta)\n\t\timg.Set(int(centre+x), int(centre-y), fgCol)\n\t}\n\n\timgFile, err := os.Create(fileName)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer imgFile.Close()\n\n\tif err := png.Encode(imgFile, img); err != nil {\n\t\timgFile.Close()\n\t\tlog.Fatal(err)\n\t}\n}\n"
                },
                {
                    "language": "FOCAL",
                    "solution": "1.1 S A=1.5\n1.2 S B=2\n1.3 S N=250\n1.4 F T=1,N; D 2\n1.5 X FSKP(2*N)\n1.6 Q\n\n2.1 S R=A+B*T; D 3\n2.2 X FPT(2*T,X1+512,Y1+390)\n2.3 S R=A+B*(T+1); D 4\n2.4 X FVEC(2*T+1,X2-X1,Y2-Y1)\n\n3.1 S X1=R*FSIN(.2*T)\n3.2 S Y1=R*FCOS(.2*T)\n\n4.1 S X2=R*FSIN(.2*(T+1))\n4.2 S Y2=R*FCOS(.2*(T+1))\n"
                }
            ],
            [
                {
                    "language": "Scheme",
                    "solution": "(import (scheme base)\n        (scheme complex)\n        (rebottled pstk))\n\n; settings for spiral\n(define *resolution* 0.01)\n(define *count* 2000)\n(define *a* 10)\n(define *b* 10)\n(define *center*\n  (let ((size 200)) ; change this to alter size of display\n    (* size 1+i)))\n\n(define (draw-spiral canvas)\n  (define (coords theta)\n    (let ((r (+ *a* (* *b* theta))))\n      (make-polar r theta)))\n  ;\n  (do ((i 0 (+ i 1))) ; loop to draw spiral\n    ((= i *count*) )\n    (let ((c (+ (coords (* i *resolution*)) *center*)))\n      (canvas 'create 'line\n              (real-part c) (imag-part c)\n              (+ 1 (real-part c)) (imag-part c)))))\n\n(let ((tk (tk-start)))\n  (tk/wm 'title tk \"Archimedean Spiral\")\n  (let ((canvas (tk 'create-widget 'canvas)))\n    (tk/pack canvas)\n    (canvas 'configure\n            'height: (* 2 (real-part *center*))\n            'width: (* 2 (imag-part *center*)))\n    (draw-spiral canvas))\n  (tk-event-loop tk))\n"
                },
                {
                    "language": "Processing",
                    "solution": "float px, py, x, y;\nfloat theta;\nfloat rotation;\n\nvoid setup() {\n  size(300, 300);\n  px = py = x = y = theta = 0;\n  rotation = 0.1;\n  background(255);\n}\n\nvoid draw() {\n  translate(width/2.0, height/2.0);\n  x = theta*cos(theta/PI);\n  y = (theta)*sin(theta/PI);\n  line(x, y, px, py);\n  theta = theta + rotation;\n  px = x;\n  py = y;\n  // check restart\n  if (px>width/2.0) frameCount=-1;\n}\n"
                }
            ],
            [
                {
                    "language": "J",
                    "solution": "require'plot'\n'aspect 1' plot (*^)j.0.01*i.1400\n"
                },
                {
                    "language": "Phix",
                    "solution": "(phixonline)-->\n <span style=\"color: #000080;font-style:italic;\">--\n -- demo\\rosetta\\Archimedean_spiral.exw\n -- ===================================\n --</span>\n <span style=\"color: #008080;\">with</span> <span style=\"color: #008080;\">javascript_semantics</span>\n <span style=\"color: #008080;\">include</span> <span style=\"color: #000000;\">pGUI</span><span style=\"color: #0000FF;\">.</span><span style=\"color: #000000;\">e</span>\n\n <span style=\"color: #004080;\">Ihandle</span> <span style=\"color: #000000;\">dlg</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #000000;\">canvas</span>\n <span style=\"color: #004080;\">cdCanvas</span> <span style=\"color: #000000;\">cddbuffer</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #000000;\">cdcanvas</span>\n\n <span style=\"color: #008080;\">function</span> <span style=\"color: #000000;\">redraw_cb</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #004080;\">Ihandle</span> <span style=\"color: #000080;font-style:italic;\">/*ih*/</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #004080;\">integer</span> <span style=\"color: #0000FF;\">{</span><span style=\"color: #000000;\">w</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #000000;\">h</span><span style=\"color: #0000FF;\">}</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">IupGetIntInt</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">canvas</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #008000;\">\"DRAWSIZE\"</span><span style=\"color: #0000FF;\">),</span>\n             <span style=\"color: #000000;\">a</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #000000;\">0</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #000000;\">b</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #000000;\">5</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #000000;\">cx</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">floor</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">w</span><span style=\"color: #0000FF;\">/</span><span style=\"color: #000000;\">2</span><span style=\"color: #0000FF;\">),</span> <span style=\"color: #000000;\">cy</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">floor</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">h</span><span style=\"color: #0000FF;\">/</span><span style=\"color: #000000;\">2</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #7060A8;\">cdCanvasActivate</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">cddbuffer</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #008080;\">for</span> <span style=\"color: #000000;\">deg</span><span style=\"color: #0000FF;\">=</span><span style=\"color: #000000;\">0</span> <span style=\"color: #008080;\">to</span> <span style=\"color: #000000;\">360</span><span style=\"color: #0000FF;\">*</span><span style=\"color: #000000;\">7</span> <span style=\"color: #008080;\">do</span>\n         <span style=\"color: #004080;\">atom</span> <span style=\"color: #000000;\">rad</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #000000;\">deg</span><span style=\"color: #0000FF;\">*</span><span style=\"color: #004600;\">PI</span><span style=\"color: #0000FF;\">/</span><span style=\"color: #000000;\">180</span><span style=\"color: #0000FF;\">,</span>\n              <span style=\"color: #000000;\">r</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #000000;\">rad</span><span style=\"color: #0000FF;\">*</span><span style=\"color: #000000;\">b</span> <span style=\"color: #0000FF;\">+</span> <span style=\"color: #000000;\">a</span>\n         <span style=\"color: #004080;\">integer</span> <span style=\"color: #000000;\">x</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #000000;\">cx</span> <span style=\"color: #0000FF;\">+</span> <span style=\"color: #7060A8;\">floor</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">r</span><span style=\"color: #0000FF;\">*</span><span style=\"color: #7060A8;\">cos</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">rad</span><span style=\"color: #0000FF;\">)),</span>\n                 <span style=\"color: #000000;\">y</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #000000;\">cy</span> <span style=\"color: #0000FF;\">+</span> <span style=\"color: #7060A8;\">floor</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">r</span><span style=\"color: #0000FF;\">*</span><span style=\"color: #7060A8;\">sin</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">rad</span><span style=\"color: #0000FF;\">))</span>\n         <span style=\"color: #7060A8;\">cdCanvasPixel</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">cddbuffer</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #000000;\">x</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #000000;\">y</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #000000;\">#00FF00</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">for</span>\n     <span style=\"color: #7060A8;\">cdCanvasFlush</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">cddbuffer</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #008080;\">return</span> <span style=\"color: #004600;\">IUP_DEFAULT</span>\n <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">function</span>\n\n <span style=\"color: #008080;\">function</span> <span style=\"color: #000000;\">map_cb</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #004080;\">Ihandle</span> <span style=\"color: #000000;\">ih</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #000000;\">cdcanvas</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">cdCreateCanvas</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #004600;\">CD_IUP</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #000000;\">ih</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #000000;\">cddbuffer</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">cdCreateCanvas</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #004600;\">CD_DBUFFER</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #000000;\">cdcanvas</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #7060A8;\">cdCanvasSetBackground</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">cddbuffer</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #004600;\">CD_WHITE</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #7060A8;\">cdCanvasSetForeground</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">cddbuffer</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #004600;\">CD_RED</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #008080;\">return</span> <span style=\"color: #004600;\">IUP_DEFAULT</span>\n <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">function</span>\n\n <span style=\"color: #008080;\">procedure</span> <span style=\"color: #000000;\">main</span><span style=\"color: #0000FF;\">()</span>\n     <span style=\"color: #7060A8;\">IupOpen</span><span style=\"color: #0000FF;\">()</span>\n     <span style=\"color: #000000;\">canvas</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">IupCanvas</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #008000;\">\"RASTERSIZE=500x500\"</span><span style=\"color: #0000FF;\">)</span> <span style=\"color: #000080;font-style:italic;\">-- initial size</span>\n     <span style=\"color: #7060A8;\">IupSetCallbacks</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">canvas</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #0000FF;\">{</span><span style=\"color: #008000;\">\"MAP_CB\"</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #7060A8;\">Icallback</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #008000;\">\"map_cb\"</span><span style=\"color: #0000FF;\">),</span>\n                              <span style=\"color: #008000;\">\"ACTION\"</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #7060A8;\">Icallback</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #008000;\">\"redraw_cb\"</span><span style=\"color: #0000FF;\">)})</span>\n     <span style=\"color: #000000;\">dlg</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">IupDialog</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">canvas</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #008000;\">`TITLE=\"Archimedean spiral\"`</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #7060A8;\">IupShow</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">dlg</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #7060A8;\">IupSetAttribute</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">canvas</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #008000;\">\"RASTERSIZE\"</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #004600;\">NULL</span><span style=\"color: #0000FF;\">)</span> <span style=\"color: #000080;font-style:italic;\">-- release the minimum limitation</span>\n     <span style=\"color: #008080;\">if</span> <span style=\"color: #7060A8;\">platform</span><span style=\"color: #0000FF;\">()!=</span><span style=\"color: #004600;\">JS</span> <span style=\"color: #008080;\">then</span>\n         <span style=\"color: #7060A8;\">IupMainLoop</span><span style=\"color: #0000FF;\">()</span>\n         <span style=\"color: #7060A8;\">IupClose</span><span style=\"color: #0000FF;\">()</span>\n     <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">if</span>\n <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">procedure</span>\n\n <span style=\"color: #000000;\">main</span><span style=\"color: #0000FF;\">()</span>\n<!--\n"
                }
            ],
            [
                {
                    "language": "VBA",
                    "solution": "Private Sub plot_coordinate_pairs(x As Variant, y As Variant)\n    Dim chrt As Chart\n    Set chrt = ActiveSheet.Shapes.AddChart.Chart\n    With chrt\n        .ChartType = xlXYScatter\n        .HasLegend = False\n        .SeriesCollection.NewSeries\n        .SeriesCollection.Item(1).XValues = x\n        .SeriesCollection.Item(1).Values = y\n    End With\nEnd Sub\nPublic Sub main()\n    Dim x(1000) As Single, y(1000) As Single\n    a = 1\n    b = 9\n    For i = 0 To 1000\n        theta = i * WorksheetFunction.Pi() / 60\n        r = a + b * theta\n        x(i) = r * Cos(theta)\n        y(i) = r * Sin(theta)\n    Next i\n    plot_coordinate_pairs x, y\nEnd Sub\n"
                },
                {
                    "language": "FreeBASIC",
                    "solution": "' version 16-10-2016\n' compile with: fbc -s gui\n\nConst As double      deg2rad = Atn(1) * 4 / 180    ' pi = atn(1) * 4, pi/180\n\nConst As UInteger screensize = 600                 ' size of window in pixels\nConst As Double        turns = 5                   ' number of turns\nConst As UInteger   halfscrn = screensize \\ 2\nConst As uinteger         sf = (turns * (screensize - 100)) / halfscrn\n\nScreenRes screensize, screensize, 32   ' screen 600 * 600 pixels, 4 byte color\n\nDim As Double r, x, y\n\nFor r = 0 To turns * 360 Step 0.05\n  x = Cos(r * deg2rad) * r / sf\n  y = Sin(r * deg2rad) * r / sf\n  PSet(halfscrn + x, halfscrn - y), RGB(255, 255, 255)\nNext\n\n' empty keyboard buffer\nWhile InKey <> \"\" : Wend\nPrint : Print \"hit any key to end program\"\nSleep\nEnd\n"
                }
            ],
            [
                {
                    "language": "M2000-Interpreter",
                    "solution": "module Archimedean_spiral {\n\tsmooth on ' enable GDI+\n\tdef r(\u03b8)=5+3*\u03b8\n\tcls #002222,0\n\tpen #FFFF00\n\trefresh 5000\n\tevery 1000 {\n\t\t\\\\ redifine window (console width and height) and place it to center (symbol ;)\n\t\tWindow 12, random(10, 18)*1000, random(8, 12)*1000;\n\t\tmove scale.x/2, scale.y/2\n\t\tlet N=2, k1=pi/120, k=k1, op=5, op1=1\n\t\tfor i=1 to int(1200*min.data(scale.x, scale.y)/18000)\n\t\t\tpen op\n\t\t\tswap op, op1\n\t\t\tWidth 3 {draw angle k, r(k)*n}\n\t\t\tk+=k1\n\t\tnext\n\t\trefresh 5000\n\t\t\\\\ press space to exit loop\n\t\tif  keypress(32) then exit\n\t}\n\tpen 14\n\tcls 5\n\trefresh 50\n}\nArchimedean_spiral\n"
                },
                {
                    "language": "Frege",
                    "solution": "module Archimedean where\n\nimport Java.IO\nimport Prelude.Math\n\ndata BufferedImage = native java.awt.image.BufferedImage where\n  pure native type_3byte_bgr \"java.awt.image.BufferedImage.TYPE_3BYTE_BGR\" :: Int\n  native new :: Int -> Int -> Int -> STMutable s BufferedImage\n  native createGraphics :: Mutable s BufferedImage -> STMutable s Graphics2D\n\ndata Color = pure native java.awt.Color where\n  pure native orange \"java.awt.Color.orange\" :: Color\n  pure native white \"java.awt.Color.white\" :: Color\n  pure native new :: Int -> Color\n\ndata BasicStroke = pure native java.awt.BasicStroke where\n  pure native new :: Float -> BasicStroke\n\ndata RenderingHints = native java.awt.RenderingHints where\n  pure native key_antialiasing \"java.awt.RenderingHints.KEY_ANTIALIASING\" :: RenderingHints_Key\n  pure native value_antialias_on \"java.awt.RenderingHints.VALUE_ANTIALIAS_ON\" :: Object\n\ndata RenderingHints_Key = pure native java.awt.RenderingHints.Key\n\ndata Graphics2D = native java.awt.Graphics2D where\n  native drawLine :: Mutable s Graphics2D -> Int -> Int -> Int -> Int -> ST s ()\n  native drawOval :: Mutable s Graphics2D -> Int -> Int -> Int -> Int -> ST s ()\n  native fillRect :: Mutable s Graphics2D -> Int -> Int -> Int -> Int -> ST s ()\n  native setColor :: Mutable s Graphics2D -> Color -> ST s ()\n  native setRenderingHint :: Mutable s Graphics2D -> RenderingHints_Key -> Object -> ST s ()\n  native setStroke :: Mutable s Graphics2D -> BasicStroke -> ST s ()\n\ndata ImageIO = mutable native javax.imageio.ImageIO where\n  native write \"javax.imageio.ImageIO.write\" :: MutableIO BufferedImage -> String -> MutableIO File -> IO Bool throws IOException\n\nwidth = 640\ncenter = width `div` 2\n\nroundi = fromIntegral . round\n\ndrawGrid :: Mutable s Graphics2D -> ST s ()\ndrawGrid g = do\n  g.setColor $ Color.new 0xEEEEEE\n  g.setStroke $ BasicStroke.new 2\n  let angle = toRadians 45\n      margin = 10\n      numRings = 8\n      spacing = (width - 2 * margin) `div` (numRings * 2)\n  forM_ [0 .. numRings-1] $ \\i -> do\n    let pos = margin + i * spacing\n        size = width - (2 * margin + i * 2 * spacing)\n        ia = fromIntegral i * angle\n        multiplier = fromIntegral $ (width - 2 * margin) `div` 2\n        x2 = center + (roundi (cos ia * multiplier))\n        y2 = center - (roundi (sin ia * multiplier))\n    g.drawOval pos pos size size\n    g.drawLine center center x2 y2\n\ndrawSpiral :: Mutable s Graphics2D -> ST s ()\ndrawSpiral g = do\n  g.setStroke $ BasicStroke.new 2\n  g.setColor $ Color.orange\n  let degrees = toRadians 0.1\n      end = 360 * 2 * 10 * degrees\n      a = 0\n      b = 20\n      c = 1\n      drSp theta = do\n        let r = a + b * theta ** (1 / c)\n            x = r * cos theta\n            y = r * sin theta\n            theta' = theta + degrees\n        plot g (center + roundi x) (center - roundi y)\n        when (theta' < end) (drSp (theta' + degrees))\n  drSp 0\n\nplot :: Mutable s Graphics2D -> Int -> Int -> ST s ()\nplot g x y = g.drawOval x y 1 1\n\nmain = do\n  buffy <- BufferedImage.new width width BufferedImage.type_3byte_bgr\n  g <- buffy.createGraphics\n  g.setRenderingHint RenderingHints.key_antialiasing RenderingHints.value_antialias_on\n  g.setColor Color.white\n  g.fillRect 0 0 width width\n  drawGrid g\n  drawSpiral g\n  f <- File.new \"SpiralFrege.png\"\n  void $ ImageIO.write buffy \"png\" f\n"
                }
            ]
        ]
    },
    {
        "task_name": "Arena-storage-pool",
        "task_description": "Dynamically allocated objects take their memory from a [[heap]]. \n\nThe memory for an object is provided by an '''allocator''' which maintains the storage pool used for the [[heap]].\n\nOften a call to allocator is denoted as\n<syntaxhighlight lang=\"ada\">P := new T</syntaxhighlight>\nwhere &nbsp; '''T''' &nbsp; is the type of an allocated object, &nbsp; and &nbsp; '''P''' &nbsp; is a [[reference]] to the object.\n\nThe storage pool chosen by the allocator can be determined by either:\n* the object type &nbsp; '''T'''\n* the type of pointer &nbsp; '''P'''\n\n\nIn the former case objects can be allocated only in one storage pool. \n\nIn the latter case objects of the type can be allocated in any storage pool or on the [[stack]].\n\n\n;Task:\nThe task is to show how allocators and user-defined storage pools are supported by the language. \n\nIn particular:\n# define an arena storage pool. &nbsp; An arena is a pool in which objects are allocated individually, but freed by groups.\n# allocate some objects (e.g., integers) in the pool.\n\n\nExplain what controls the storage pool choice in the language.\n<br><br>\n\n",
        "solution_pairs": [
            [
                {
                    "language": "OxygenBasic",
                    "solution": "'==============\nClass ArenaPool\n'==============\n\nstring buf\nsys    pb,ii\n\nmethod Setup(sys n) as sys {buf=nuls n : pb=strptr buf : ii=0 : return pb}\nmethod Alloc(sys n) as sys {method=pb+ii : ii+=n}\nmethod Empty()             {buf=\"\" : pb=0 : ii=0}\n\nend class\n\nmacro Create(type,name,qty,pool)\n  type name[qty] at (pool##.alloc qty * sizeof type)\nend macro\n\n'====\n'DEMO\n'====\n\nArenaPool pool : pool.setup 1000 * sizeof int\n\nCreate int,i,100,pool\nCreate int,j,100,pool\n\nj[51] <= 1,2,3,4,5\n\nprint j[51] j[52] j[53] j[54] j[55] 'result 15\n\npool.empty\n"
                },
                {
                    "language": "Kotlin",
                    "solution": "// Kotlin Native v0.5\n\nimport kotlinx.cinterop.*\n\nfun main(args: Array<String>) {\n    memScoped {\n        val intVar1 = alloc<IntVar>()\n        intVar1.value = 1\n        val intVar2 = alloc<IntVar>()\n        intVar2.value = 2\n        println(\"${intVar1.value} + ${intVar2.value} = ${intVar1.value + intVar2.value}\")\n    }\n    // native memory used by intVar1 & intVar2 is automatically freed when memScoped block ends\n}\n"
                }
            ],
            [
                {
                    "language": "C++",
                    "solution": "#include <cstdlib>\n#include <cassert>\n#include <new>\n\n// This class basically provides a global stack of pools; it is not thread-safe, and pools must be destructed in reverse order of construction\n// (you definitely want something better in production use :-))\nclass Pool\n{\npublic:\n  Pool(std::size_type sz);\n  ~Pool();\n  static Pool& current() { return *cur; }\n  void* allocate(std::size_type sz, std::size_t alignment);\nprivate:\n  char* memory; // char* instead of void* enables pointer arithmetic\n  char* free;\n  char* end;\n  Pool* prev;\n  static Pool* cur;\n\n  // prohibit copying\n  Pool(Pool const&); // not implemented\n  Pool& operator=(Pool const&); // not implemented\n};\n\nPool* pool::cur = 0;\n\nPool::Pool(std::size_type size):\n  memory(static_cast<char*>(::operator new(size))),\n  free(memory),\n  end(memory + size))\n{\n  prev = cur;\n  cur = this;\n}\n\nPool::~Pool()\n{\n  ::operator delete(memory);\n  cur = prev;\n}\n\nvoid* Pool::allocate(std::size_t size, std::size_t alignment)\n{\n  char* start = free;\n\n  // align the pointer\n  std::size_t extra = (start - memory) % aligment;\n  if (extra != 0)\n  {\n    extra = alignment - extra;\n  }\n\n  // test if we can still allocate that much memory\n  if (end - free < size + extra)\n    throw std::bad_alloc();\n\n  // the free memory now starts after the newly allocated object\n  free = start + size + extra;\n  return start;\n}\n\n// this is just a simple C-like struct, except that it uses a specific allocation/deallocation function.\nstruct X\n{\n  int member;\n  void* operator new(std::size_t);\n  void operator delete(void*) {} // don't deallocate memory for single objects\n};\n\nvoid* X::operator new(std::size_t size)\n{\n  // unfortunately C++ doesn't offer a portable way to find out alignment\n  // however, using the size as alignment is always safe (although usually wasteful)\n  return Pool::current().allocate(size, size);\n}\n\n// Example program\nint main()\n{\n  Pool my_pool(3*sizeof(X));\n  X* p1 = new X; // uses the allocator function defined above\n  X* p2 = new X;\n  X* p3 = new X;\n  delete p3; // doesn't really deallocate the memory because operator delete has an empty body\n\n  try\n  {\n    X* p4 = new X; // should fail\n    assert(false);\n  }\n  catch(...)\n  {\n  }\n\n  X* p5 = new X[10]; // uses global array allocation routine because we didn't provide operator new[] and operator delete[]\n  delete[] p5; // global array deallocation\n\n  Pool* my_second_pool(1000); // a large pool\n  X* p6 = new X; // allocate a new object from that pool\n  X* p7 = new X;\n  delete my_second_pool // also deallocates the memory for p6 and p7\n\n} // Here my_pool goes out of scope, deallocating the memory for p1, p2 and p3\n"
                },
                {
                    "language": "Kotlin",
                    "solution": "// Kotlin Native v0.5\n\nimport kotlinx.cinterop.*\n\nfun main(args: Array<String>) {\n    memScoped {\n        val intVar1 = alloc<IntVar>()\n        intVar1.value = 1\n        val intVar2 = alloc<IntVar>()\n        intVar2.value = 2\n        println(\"${intVar1.value} + ${intVar2.value} = ${intVar1.value + intVar2.value}\")\n    }\n    // native memory used by intVar1 & intVar2 is automatically freed when memScoped block ends\n}\n"
                }
            ],
            [
                {
                    "language": "Rust",
                    "solution": "#![feature(rustc_private)]\n\nextern crate arena;\n\nuse arena::TypedArena;\n\nfn main() {\n    // Memory is allocated using the default allocator (currently jemalloc).  The memory is\n    // allocated in chunks, and when one chunk is full another is allocated.  This ensures that\n    // references to an arena don't become invalid when the original chunk runs out of space.  The\n    // chunk size is configurable as an argument to TypedArena::with_capacity if necessary.\n    let arena = TypedArena::new();\n\n    // The arena crate contains two types of arenas: TypedArena and Arena.  Arena is\n    // reflection-basd and slower, but can allocate objects of any type.  TypedArena is faster, and\n    // can allocate only objects of one type.  The type is determined by type inference--if you try\n    // to allocate an integer, then Rust's compiler knows it is an integer arena.\n    let v1 = arena.alloc(1i32);\n\n    // TypedArena returns a mutable reference\n    let v2 = arena.alloc(3);\n    *v2 += 38;\n    println!(\"{}\", *v1 + *v2);\n\n    // The arena's destructor is called as it goes out of scope, at which point it deallocates\n    // everything stored within it at once.\n}\n"
                },
                {
                    "language": "Fortran",
                    "solution": "      SUBROUTINE CHECK(A,N)\t!Inspect matrix A.\n       REAL A(:,:)\t!The matrix, whatever size it is.\n       INTEGER N\t!The order.\n       REAL B(N,N)\t!A scratchpad, size known on entry..\n       INTEGER, ALLOCATABLE::TROUBLE(:)\t!But for this, I'll decide later.\n       INTEGER M\n\n        M = COUNT(A(1:N,1:N).LE.0)\t!Some maximum number of troublemakers.\n\n        ALLOCATE (TROUBLE(1:M**3))\t!Just enough.\n\n        DEALLOCATE(TROUBLE)\t\t!Not necessary.\n      END SUBROUTINE CHECK\t\t!As TROUBLE is declared within CHECK.\n"
                }
            ],
            [
                {
                    "language": "C++",
                    "solution": "T* foo = new(arena) T;\n"
                },
                {
                    "language": "Ada",
                    "solution": "type My_Pointer is access My_Object;\nfor My_Pointer'Storage_Pool use My_Pool;\n"
                }
            ],
            [
                {
                    "language": "Tcl",
                    "solution": "package require Tcl 8.6\noo::class create Pool {\n    superclass oo::class\n    variable capacity pool busy\n    unexport create\n    constructor args {\n\tnext {*}$args\n\tset capacity 100\n\tset pool [set busy {}]\n    }\n    method new {args} {\n\tif {[llength $pool]} {\n\t    set pool [lassign $pool obj]\n\t} else {\n\t    if {[llength $busy] >= $capacity} {\n\t\tthrow {POOL CAPACITY} \"exceeded capacity: $capacity\"\n\t    }\n\t    set obj [next]\n\t    set newobj [namespace current]::[namespace tail $obj]\n\t    rename $obj $newobj\n\t    set obj $newobj\n\t}\n\ttry {\n\t    [info object namespace $obj]::my Init {*}$args\n\t} on error {msg opt} {\n\t    lappend pool $obj\n\t    return -options $opt $msg\n\t}\n\tlappend busy $obj\n\treturn $obj\n    }\n    method ReturnToPool obj {\n\ttry {\n\t    if {\"Finalize\" in [info object methods $obj -all -private]} {\n\t\t[info object namespace $obj]::my Finalize\n\t    }\n\t} on error {msg opt} {\n\t    after 0 [list return -options $opt $msg]\n\t    return false\n\t}\n\tset idx [lsearch -exact $busy $obj]\n\tset busy [lreplace $busy $idx $idx]\n\tif {[llength $pool] + [llength $busy] + 1 <= $capacity} {\n\t    lappend pool $obj\n\t    return true\n\t} else {\n\t    return false\n\t}\n    }\n    method capacity {{value {}}} {\n\tif {[llength [info level 0]] == 3} {\n\t    if {$value < $capacity} {\n\t\twhile {[llength $pool] > 0 && [llength $pool] + [llength $busy] > $value} {\n\t\t    set pool [lassign $pool obj]\n\t\t    rename $obj {}\n\t\t}\n\t    }\n\t    set capacity [expr {$value >> 0}]\n\t} else {\n\t    return $capacity\n\t}\n    }\n    method clearPool {} {\n\tforeach obj $busy {\n\t    $obj destroy\n\t}\n    }\n    method destroy {} {\n\tmy clearPool\n\tnext\n    }\n    self method create {class {definition {}}} {\n\tset cls [next $class $definition]\n\too::define $cls method destroy {} {\n\t    if {![[info object namespace [self class]]::my ReturnToPool [self]]} {\n\t\tnext\n\t    }\n\t}\n\treturn $cls\n    }\n}\n"
                },
                {
                    "language": "C",
                    "solution": "typedef struct mytypeStruct { .... } sMyType, *MyType;\n\nMyType var = malloc(sizeof(sMyType));\n"
                }
            ]
        ]
    },
    {
        "task_name": "Arithmetic-Complex",
        "task_description": "A &nbsp; '''[[wp:Complex number|complex number]]''' &nbsp; is a number which can be written as:\n<big><math>a + b \\times i</math></big> \n(sometimes shown as:\n<big><math>b + a \\times i</math></big>\nwhere &nbsp; <big><math>a</math></big> &nbsp; and &nbsp; <big><math>b</math></big>&nbsp; are real numbers, &nbsp; and &nbsp; [[wp:Imaginary_unit|<big><math>i</math></big>]] &nbsp; is &nbsp; <big>&radic;{{overline|&nbsp;-1&nbsp;}}</big> \n\n\nTypically, complex numbers are represented as a pair of real numbers called the \"imaginary part\" and \"real part\", &nbsp; where the imaginary part is the number to be multiplied by <big><math>i</math></big>.\n\n\n;Task:\n* Show addition, multiplication, negation, and inversion of complex numbers in separate functions. (Subtraction and division operations can be made with pairs of these operations.) \n* Print the results for each operation tested.\n* ''Optional:'' Show complex conjugation.\n\n<br>\nBy definition, the &nbsp; [[wp:complex conjugate|complex conjugate]] &nbsp; of \n<big><math>a + bi</math></big> \nis\n<big><math>a - bi</math></big>\n\n<br>\nSome languages have complex number libraries available. &nbsp; If your language does, show the operations. &nbsp; If your language does not, also show the definition of this type.\n<br><br>\n\n",
        "solution_pairs": [
            [
                {
                    "language": "Zkl",
                    "solution": "var [const] GSL=Import(\"zklGSL\");    // libGSL (GNU Scientific Library)\n(GSL.Z(3,4) + GSL.Z(1,2)).println(); // (4.00+6.00i)\n(GSL.Z(3,4) - GSL.Z(1,2)).println(); // (2.00+2.00i)\n(GSL.Z(3,4) * GSL.Z(1,2)).println(); // (-5.00+10.00i)\n(GSL.Z(3,4) / GSL.Z(1,2)).println(); // (2.20-0.40i)\n(GSL.Z(1,0) / GSL.Z(1,1)).println(); // (0.50-0.50i) // inversion\n(-GSL.Z(3,4)).println(); \t     // (-3.00-4.00i)\nGSL.Z(3,4).conjugate().println();    // (3.00-4.00i)\n"
                },
                {
                    "language": "ZX-Spectrum-Basic",
                    "solution": "5 LET complex=2: LET r=1: LET i=2\n10 DIM a(complex): LET a(r)=1.0: LET a(i)=1.0\n20 DIM b(complex): LET b(r)=PI: LET b(i)=1.2\n30 DIM o(complex)\n40 REM add\n50 LET o(r)=a(r)+b(r)\n60 LET o(i)=a(i)+b(i)\n70 PRINT \"Result of addition is:\": GO SUB 1000\n80 REM mult\n90 LET o(r)=a(r)*b(r)-a(i)*b(i)\n100 LET o(i)=a(i)*b(r)+a(r)*b(i)\n110 PRINT \"Result of multiplication is:\": GO SUB 1000\n120 REM neg\n130 LET o(r)=-a(r)\n140 LET o(i)=-a(i)\n150 PRINT \"Result of negation is:\": GO SUB 1000\n160 LET denom=a(r)^2+a(i)^2\n170 LET o(r)=a(r)/denom\n180 LET o(i)=-a(i)/denom\n190 PRINT \"Result of inversion is:\": GO SUB 1000\n200 STOP\n1000 IF o(i)>=0 THEN PRINT o(r);\" + \";o(i);\"i\": RETURN\n1010 PRINT o(r);\" - \";-o(i);\"i\": RETURN\n"
                }
            ],
            [
                {
                    "language": "Go",
                    "solution": "package main\n\nimport (\n    \"fmt\"\n    \"math/cmplx\"\n)\n\nfunc main() {\n    a := 1 + 1i\n    b := 3.14159 + 1.25i\n    fmt.Println(\"a:      \", a)\n    fmt.Println(\"b:      \", b)\n    fmt.Println(\"a + b:  \", a+b)\n    fmt.Println(\"a * b:  \", a*b)\n    fmt.Println(\"-a:     \", -a)\n    fmt.Println(\"1 / a:  \", 1/a)\n    fmt.Println(\"a\u00cc\u2026:      \", cmplx.Conj(a))\n}\n"
                },
                {
                    "language": "LFE",
                    "solution": "(defrecord complex\n  real\n  img)\n"
                }
            ],
            [
                {
                    "language": "Erlang",
                    "solution": "%% Task: Complex Arithmetic\n%% Author: Abhay Jain\n\n-module(complex_number).\n-export([calculate/0]).\n\n-record(complex, {real, img}).\n\ncalculate() ->\n    A = #complex{real=1, img=3},\n    B = #complex{real=5, img=2},\n\n    Sum = add (A, B),\n    print (Sum),\n\n    Product = multiply (A, B),\n    print (Product),\n\n    Negation = negation (A),\n    print (Negation),\n\n    Inversion = inverse (A),\n    print (Inversion),\n\n    Conjugate = conjugate (A),\n    print (Conjugate).\n\nadd (A, B) ->\n    RealPart = A#complex.real + B#complex.real,\n    ImgPart = A#complex.img + B#complex.img,\n    #complex{real=RealPart, img=ImgPart}.\n\nmultiply (A, B) ->\n    RealPart = (A#complex.real * B#complex.real) - (A#complex.img * B#complex.img),\n    ImgPart = (A#complex.real * B#complex.img) + (B#complex.real * A#complex.img),\n    #complex{real=RealPart, img=ImgPart}.\n\nnegation (A) ->\n    #complex{real=-A#complex.real, img=-A#complex.img}.\n\ninverse (A) ->\n    C = conjugate (A),\n    Mod = (A#complex.real * A#complex.real) + (A#complex.img * A#complex.img),\n    RealPart = C#complex.real / Mod,\n    ImgPart = C#complex.img / Mod,\n    #complex{real=RealPart, img=ImgPart}.\n\nconjugate (A) ->\n    RealPart = A#complex.real,\n    ImgPart = -A#complex.img,\n    #complex{real=RealPart, img=ImgPart}.\n\nprint (A) ->\n    if A#complex.img < 0 ->\n        io:format(\"Ans = ~p~pi~n\", [A#complex.real, A#complex.img]);\n       true ->\n        io:format(\"Ans = ~p+~pi~n\", [A#complex.real, A#complex.img])\n    end.\n"
                },
                {
                    "language": "Ol",
                    "solution": "(define A 0+1i) ; manually entered numbers\n(define B 1+0i)\n\n(print (+ A B))\n; <== 1+i\n\n(print (- A B))\n; <== -1+i\n\n(print (* A B))\n; <== 0+i\n\n(print (/ A B))\n; <== 0+i\n\n\n(define C (complex 2/7 -3)) ; functional way\n\n(print \"real part of \" C \" is \" (car C))\n; <== real part of 2/7-3i is 2/7\n\n(print \"imaginary part of \" C \" is \" (cdr C))\n; <== imaginary part of 2/7-3i is -3\n"
                }
            ],
            [
                {
                    "language": "Action-",
                    "solution": "INCLUDE \"D2:REAL.ACT\" ;from the Action! Tool Kit\n\nDEFINE R_=\"+0\"\nDEFINE I_=\"+6\"\nTYPE Complex=[CARD cr1,cr2,cr3,ci1,ci2,ci3]\n\nBYTE FUNC Positive(REAL POINTER x)\n  BYTE ARRAY tmp\n\n  tmp=x\n  IF (tmp(0)&$80)=$00 THEN\n    RETURN (1)\n  FI\nRETURN (0)\n\nPROC PrintComplex(Complex POINTER x)\n  PrintR(x R_)\n  IF Positive(x I_) THEN\n    Put('+)\n  FI\n  PrintR(x I_) Put('i)\nRETURN\n\nPROC PrintComplexXYZ(Complex POINTER x,y,z CHAR ARRAY s)\n  Print(\"(\") PrintComplex(x)\n  Print(\") \") Print(s)\n  Print(\" (\") PrintComplex(y)\n  Print(\") = \") PrintComplex(z)\n  PutE()\nRETURN\n\nPROC PrintComplexXY(Complex POINTER x,y CHAR ARRAY s)\n  Print(s)\n  Print(\"(\") PrintComplex(x)\n  Print(\") = \") PrintComplex(y)\n  PutE()\nRETURN\n\nPROC ComplexAdd(Complex POINTER x,y,res)\n  RealAdd(x R_,y R_,res R_) ;res.r=x.r+y.r\n  RealAdd(x I_,y I_,res I_) ;res.i=x.i+y.i\nRETURN\n\nPROC ComplexSub(Complex POINTER x,y,res)\n  RealSub(x R_,y R_,res R_) ;res.r=x.r-y.r\n  RealSub(x I_,y I_,res I_) ;res.i=x.i-y.i\nRETURN\n\nPROC ComplexMult(Complex POINTER x,y,res)\n  REAL tmp1,tmp2\n\n  RealMult(x R_,y R_,tmp1)  ;tmp1=x.r*y.r\n  RealMult(x I_,y I_,tmp2)  ;tmp2=x.i*y.i\n  RealSub(tmp1,tmp2,res R_) ;res.r=x.r*y.r-x.i*y.i\n\n  RealMult(x R_,y I_,tmp1)  ;tmp1=x.r*y.i\n  RealMult(x I_,y R_,tmp2)  ;tmp2=x.i*y.r\n  RealAdd(tmp1,tmp2,res I_) ;res.i=x.r*y.i+x.i*y.r\nRETURN\n\nPROC ComplexDiv(Complex POINTER x,y,res)\n  REAL tmp1,tmp2,tmp3,tmp4\n\n  RealMult(x R_,y R_,tmp1)  ;tmp1=x.r*y.r\n  RealMult(x I_,y I_,tmp2)  ;tmp2=x.i*y.i\n  RealAdd(tmp1,tmp2,tmp3)   ;tmp3=x.r*y.r+x.i*y.i\n  RealMult(y R_,y R_,tmp1)  ;tmp1=y.r^2\n  RealMult(y I_,y I_,tmp2)  ;tmp2=y.i^2\n  RealAdd(tmp1,tmp2,tmp4)   ;tmp4=y.r^2+y.i^2\n  RealDiv(tmp3,tmp4,res R_) ;res.r=(x.r*y.r+x.i*y.i)/(y.r^2+y.i^2)\n\n  RealMult(x I_,y R_,tmp1)  ;tmp1=x.i*y.r\n  RealMult(x R_,y I_,tmp2)  ;tmp2=x.r*y.i\n  RealSub(tmp1,tmp2,tmp3)   ;tmp3=x.i*y.r-x.r*y.i\n  RealDiv(tmp3,tmp4,res I_) ;res.i=(x.i*y.r-x.r*y.i)/(y.r^2+y.i^2)\nRETURN\n\nPROC ComplexNeg(Complex POINTER x,res)\n  REAL neg\n\n  ValR(\"-1\",neg)            ;neg=-1\n  RealMult(x R_,neg,res R_) ;res.r=-x.r\n  RealMult(x I_,neg,res I_) ;res.r=-x.r\nRETURN\n\nPROC ComplexInv(Complex POINTER x,res)\n  REAL tmp1,tmp2,tmp3\n\n  RealMult(x R_,x R_,tmp1)  ;tmp1=x.r^2\n  RealMult(x I_,x I_,tmp2)  ;tmp2=x.i^2\n  RealAdd(tmp1,tmp2,tmp3)   ;tmp3=x.r^2+x.i^2\n  RealDiv(x R_,tmp3,res R_) ;res.r=x.r/(x.r^2+x.i^2)\n\n  ValR(\"-1\",tmp1)           ;tmp1=-1\n  RealMult(x I_,tmp1,tmp2)  ;tmp2=-x.i\n  RealDiv(tmp2,tmp3,res I_) ;res.i=-x.i/(x.r^2+x.i^2)\nRETURN\n\nPROC ComplexConj(Complex POINTER x,res)\n  REAL neg\n\n  ValR(\"-1\",neg)            ;neg=-1\n  RealAssign(x R_,res R_)   ;res.r=x.r\n  RealMult(x I_,neg,res I_) ;res.i=-x.i\nRETURN\n\nPROC Main()\n  Complex x,y,res\n\n  IntToReal(5,x R_) IntToReal(3,x I_)\n  IntToReal(4,y R_) ValR(\"-3\",y I_)\n\n  Put(125) PutE() ;clear screen\n\n  ComplexAdd(x,y,res)\n  PrintComplexXYZ(x,y,res,\"+\")\n\n  ComplexSub(x,y,res)\n  PrintComplexXYZ(x,y,res,\"-\")\n\n  ComplexMult(x,y,res)\n  PrintComplexXYZ(x,y,res,\"*\")\n\n  ComplexDiv(x,y,res)\n  PrintComplexXYZ(x,y,res,\"/\")\n\n  ComplexNeg(y,res)\n  PrintComplexXY(y,res,\"        -\")\n\n  ComplexInv(y,res)\n  PrintComplexXY(y,res,\"     1 / \")\n\n  ComplexConj(y,res)\n  PrintComplexXY(y,res,\"     conj\")\nRETURN\n"
                },
                {
                    "language": "Hare",
                    "solution": "use fmt;\nuse math::complex::{c128,addc128,mulc128,divc128,negc128,conjc128};\n\nexport fn main() void = {\n\tlet x: c128 = (1.0, 1.0);\n\tlet y: c128 = (3.14159265, 1.2);\n\n\t// addition\n\tlet (re, im) = addc128(x, y);\n\tfmt::printfln(\"{} + {}i\", re, im)!;\n\t// multiplication\n\tlet (re, im) = mulc128(x, y);\n\tfmt::printfln(\"{} + {}i\", re, im)!;\n\t// inversion\n\tlet (re, im) = divc128((1.0, 0.0), x);\n\tfmt::printfln(\"{} + {}i\", re, im)!;\n\t// negation\n\tlet (re, im) = negc128(x);\n\tfmt::printfln(\"{} + {}i\", re, im)!;\n\t// conjugate\n\tlet (re, im) = conjc128(x);\n\tfmt::printfln(\"{} + {}i\", re, im)!;\n};\n"
                }
            ],
            [
                {
                    "language": "PostScript",
                    "solution": "%Adding two complex numbers\n/addcomp{\n/x exch def\n/y exch def\n/z [0 0] def\nz 0 x 0 get y 0 get add put\nz 1 x 1 get y 1 get add put\nz pstack\n}def\n\n%Subtracting one complex number from another\n/subcomp{\n/x exch def\n/y exch def\n/z [0 0] def\nz 0 x 0 get y 0 get sub put\nz 1 x 1 get y 1 get sub put\nz pstack\n}def\n\n%Multiplying two complex numbers\n/mulcomp{\n/x exch def\n/y exch def\n/z [0 0] def\nz 0 x 0 get y 0 get mul x 1 get y 1 get mul sub  put\nz 1 x 1 get y 0 get mul x 0 get y 1 get mul add put\nz pstack\n}def\n\n%Negating a complex number\n/negcomp{\n/x exch def\n/z [0 0] def\nz 0 x 0 get neg put\nz 1 x 1 get neg put\nz pstack\n}def\n\n%Inverting a complex number\n/invcomp{\n/x exch def\n/z [0 0] def\nz 0 x 0 get x 0 get 2 exp x 1 get 2 exp add div put\nz 0 x 1 get neg x 0 get 2 exp x 1 get 2 exp add div put\nz pstack\n}def\n"
                },
                {
                    "language": "Excel",
                    "solution": "=IMCONJUGATE(C28)\n"
                }
            ]
        ]
    },
    {
        "task_name": "Arithmetic-derivative",
        "task_description": "The '''arithmetic derivative''' of an integer (more specifically, the\n'''Lagarias arithmetic derivative''') is a function defined for integers, based on prime\nfactorization, by analogy with the product rule for the derivative of a function that is\nused in mathematical analysis. Accordingly, for natural numbers n, the arithmetic \nderivative D(n) is defined as follows:\n\n;*D(0) = D(1) = 0.\n;*D(p) = 1 for any prime p.\n;*D(mn) = D(m)n + mD(n) for any m,n \u00e2\u02c6\u02c6 N. (Leibniz rule for derivatives).\n\nAdditionally, for negative integers the arithmetic derivative may be defined as -D(-n) (n < 0).\n\n; Examples\n\nD(2) = 1 and D(3) = 1 (both are prime) so if mn = 2 * 3, D(6) = (1)(3) + (1)(2) = 5.\n\nD(9) = D(3)(3) + D(3)(3) = 6\n\nD(27) = D(3)*9 + D(9)*3 = 9 + 18 = 27\n\nD(30) = D(5)(6) + D(6)(5) = 6 + 5 * 5 = 31.\n\n; Task\n\nFind and show the arithmetic derivatives for -99 through 100.\n\n; Stretch task\n\nFind (the arithmetic derivative of 10^m) then divided by 7, where m is from 1 to 20.\n\n; See also\n\n;* [[oeis:A003415|OEIS:A003415 - a(n) = n' = arithmetic derivative of n.]]\n;*[[wp:Arithmetic_derivative|Wikipedia: Arithmetic Derivative]]\n\n",
        "solution_pairs": [
            [
                {
                    "language": "ALGOL-68",
                    "solution": "BEGIN PROC lagarias = (LONG INT n) LONG INT: # Lagarias arithmetic derivative #\n           IF n < 0\n           THEN -lagarias (-n)\n           ELIF n = 0 OR n = 1\n           THEN 0\n           ELIF PROC small pf = (LONG INT j, k) LONG INT: # Smallest prime factor #\n                     (j %* k = 0 | k | small pf (j, k + 1));\n                LONG INT f = small pf (n, 2); LONG INT q = n % f;\n                q = 1\n           THEN 1\n           ELSE q * lagarias (f) + f * lagarias (q)\n           FI;\n\n      FOR n FROM -99 TO 100\n      DO print ((\"D(\", whole (n, 0), \") = \", whole (lagarias (n), 0), new line))\n      OD;\n      new line (standout);\n      FOR n TO 20\n      DO LONG INT m = LONG 10 ^ n;\n         print ((\"D(\", whole (m, 0), \") / 7 = \", whole (lagarias (m) % 7, 0), new line))\n      OD\nEND\n"
                },
                {
                    "language": "Phix",
                    "solution": "(phixonline)-->\n <span style=\"color: #008080;\">with</span> <span style=\"color: #008080;\">javascript_semantics</span>\n <span style=\"color: #008080;\">include</span> <span style=\"color: #004080;\">mpfr</span><span style=\"color: #0000FF;\">.</span><span style=\"color: #000000;\">e</span>\n <span style=\"color: #008080;\">procedure</span> <span style=\"color: #000000;\">D</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #004080;\">mpz</span> <span style=\"color: #000000;\">n</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #004080;\">integer</span> <span style=\"color: #000000;\">s</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">mpz_cmp_si</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">n</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">0</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #008080;\">if</span> <span style=\"color: #000000;\">s</span><span style=\"color: #0000FF;\"><</span><span style=\"color: #000000;\">0</span> <span style=\"color: #008080;\">then</span> <span style=\"color: #7060A8;\">mpz_neg</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">n</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">n</span><span style=\"color: #0000FF;\">)</span> <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">if</span>\n     <span style=\"color: #008080;\">if</span> <span style=\"color: #7060A8;\">mpz_cmp_si</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">n</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">2</span><span style=\"color: #0000FF;\">)<</span><span style=\"color: #000000;\">0</span> <span style=\"color: #008080;\">then</span>\n         <span style=\"color: #7060A8;\">mpz_set_si</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">n</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">0</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #008080;\">else</span>\n         <span style=\"color: #004080;\">sequence</span> <span style=\"color: #000000;\">f</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">mpz_prime_factors</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">n</span><span style=\"color: #0000FF;\">)</span>\n         <span style=\"color: #004080;\">integer</span> <span style=\"color: #000000;\">c</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">sum</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #7060A8;\">vslice</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">f</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">2</span><span style=\"color: #0000FF;\">)),</span>\n                 <span style=\"color: #000000;\">f1</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #000000;\">f</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">][</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">]</span>\n         <span style=\"color: #008080;\">if</span> <span style=\"color: #000000;\">c</span><span style=\"color: #0000FF;\">=</span><span style=\"color: #000000;\">1</span> <span style=\"color: #008080;\">then</span>\n             <span style=\"color: #7060A8;\">mpz_set_si</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">n</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">)</span>\n         <span style=\"color: #008080;\">elsif</span> <span style=\"color: #000000;\">c</span><span style=\"color: #0000FF;\">=</span><span style=\"color: #000000;\">2</span> <span style=\"color: #008080;\">then</span>\n             <span style=\"color: #7060A8;\">mpz_set_si</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">n</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">f1</span> <span style=\"color: #0000FF;\">+</span> <span style=\"color: #008080;\">iff</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #7060A8;\">length</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">f</span><span style=\"color: #0000FF;\">)=</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">?</span><span style=\"color: #000000;\">f1</span><span style=\"color: #0000FF;\">:</span><span style=\"color: #000000;\">f</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">2</span><span style=\"color: #0000FF;\">][</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">]))</span>\n         <span style=\"color: #008080;\">else</span>\n             <span style=\"color: #7060A8;\">assert</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #7060A8;\">mpz_fdiv_q_ui</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">n</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">n</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">f1</span><span style=\"color: #0000FF;\">)=</span><span style=\"color: #000000;\">0</span><span style=\"color: #0000FF;\">)</span>\n             <span style=\"color: #004080;\">mpz</span> <span style=\"color: #000000;\">d</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">mpz_init_set</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">n</span><span style=\"color: #0000FF;\">)</span>\n             <span style=\"color: #000000;\">D</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">n</span><span style=\"color: #0000FF;\">)</span>\n             <span style=\"color: #7060A8;\">mpz_mul_si</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">n</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">n</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">f1</span><span style=\"color: #0000FF;\">)</span>\n             <span style=\"color: #7060A8;\">mpz_add</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">n</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">n</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">d</span><span style=\"color: #0000FF;\">)</span>\n         <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">if</span>\n         <span style=\"color: #008080;\">if</span> <span style=\"color: #000000;\">s</span><span style=\"color: #0000FF;\"><</span><span style=\"color: #000000;\">0</span> <span style=\"color: #008080;\">then</span> <span style=\"color: #7060A8;\">mpz_neg</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">n</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">n</span><span style=\"color: #0000FF;\">)</span> <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">if</span>\n     <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">if</span>\n <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">procedure</span>\n\n <span style=\"color: #004080;\">sequence</span> <span style=\"color: #000000;\">res</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">repeat</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">0</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">200</span><span style=\"color: #0000FF;\">)</span>\n <span style=\"color: #004080;\">mpz</span> <span style=\"color: #000000;\">n</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">mpz_init</span><span style=\"color: #0000FF;\">()</span>\n <span style=\"color: #008080;\">for</span> <span style=\"color: #000000;\">i</span><span style=\"color: #0000FF;\">=-</span><span style=\"color: #000000;\">99</span> <span style=\"color: #008080;\">to</span> <span style=\"color: #000000;\">100</span> <span style=\"color: #008080;\">do</span>\n     <span style=\"color: #7060A8;\">mpz_set_si</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">n</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">i</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #000000;\">D</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">n</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #000000;\">res</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">i</span><span style=\"color: #0000FF;\">+</span><span style=\"color: #000000;\">100</span><span style=\"color: #0000FF;\">]</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">mpz_get_str</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">n</span><span style=\"color: #0000FF;\">)</span>\n <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">for</span>\n <span style=\"color: #7060A8;\">printf</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #008000;\">\"%s\\n\\n\"</span><span style=\"color: #0000FF;\">,{</span><span style=\"color: #7060A8;\">join_by</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">res</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">10</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #008000;\">\" \"</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">fmt</span><span style=\"color: #0000FF;\">:=</span><span style=\"color: #008000;\">\"%4s\"</span><span style=\"color: #0000FF;\">)})</span>\n <span style=\"color: #008080;\">for</span> <span style=\"color: #000000;\">m</span><span style=\"color: #0000FF;\">=</span><span style=\"color: #000000;\">1</span> <span style=\"color: #008080;\">to</span> <span style=\"color: #000000;\">20</span> <span style=\"color: #008080;\">do</span>\n     <span style=\"color: #7060A8;\">mpz_ui_pow_ui</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">n</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">10</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">m</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #000000;\">D</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">n</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #7060A8;\">assert</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #7060A8;\">mpz_fdiv_q_ui</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">n</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">n</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">7</span><span style=\"color: #0000FF;\">)=</span><span style=\"color: #000000;\">0</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #7060A8;\">printf</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #008000;\">\"D(10^%d)/7 = %s\\n\"</span><span style=\"color: #0000FF;\">,{</span><span style=\"color: #000000;\">m</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #7060A8;\">mpz_get_str</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">n</span><span style=\"color: #0000FF;\">)})</span>\n <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">for</span>\n<!--\n"
                }
            ],
            [
                {
                    "language": "Phix",
                    "solution": "(phixonline)-->\n <span style=\"color: #008080;\">with</span> <span style=\"color: #008080;\">javascript_semantics</span>\n <span style=\"color: #008080;\">include</span> <span style=\"color: #004080;\">mpfr</span><span style=\"color: #0000FF;\">.</span><span style=\"color: #000000;\">e</span>\n <span style=\"color: #008080;\">procedure</span> <span style=\"color: #000000;\">D</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #004080;\">mpz</span> <span style=\"color: #000000;\">n</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #004080;\">integer</span> <span style=\"color: #000000;\">s</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">mpz_cmp_si</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">n</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">0</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #008080;\">if</span> <span style=\"color: #000000;\">s</span><span style=\"color: #0000FF;\"><</span><span style=\"color: #000000;\">0</span> <span style=\"color: #008080;\">then</span> <span style=\"color: #7060A8;\">mpz_neg</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">n</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">n</span><span style=\"color: #0000FF;\">)</span> <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">if</span>\n     <span style=\"color: #008080;\">if</span> <span style=\"color: #7060A8;\">mpz_cmp_si</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">n</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">2</span><span style=\"color: #0000FF;\">)<</span><span style=\"color: #000000;\">0</span> <span style=\"color: #008080;\">then</span>\n         <span style=\"color: #7060A8;\">mpz_set_si</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">n</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">0</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #008080;\">else</span>\n         <span style=\"color: #004080;\">sequence</span> <span style=\"color: #000000;\">f</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">mpz_prime_factors</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">n</span><span style=\"color: #0000FF;\">)</span>\n         <span style=\"color: #004080;\">integer</span> <span style=\"color: #000000;\">c</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">sum</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #7060A8;\">vslice</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">f</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">2</span><span style=\"color: #0000FF;\">)),</span>\n                 <span style=\"color: #000000;\">f1</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #000000;\">f</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">][</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">]</span>\n         <span style=\"color: #008080;\">if</span> <span style=\"color: #000000;\">c</span><span style=\"color: #0000FF;\">=</span><span style=\"color: #000000;\">1</span> <span style=\"color: #008080;\">then</span>\n             <span style=\"color: #7060A8;\">mpz_set_si</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">n</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">)</span>\n         <span style=\"color: #008080;\">elsif</span> <span style=\"color: #000000;\">c</span><span style=\"color: #0000FF;\">=</span><span style=\"color: #000000;\">2</span> <span style=\"color: #008080;\">then</span>\n             <span style=\"color: #7060A8;\">mpz_set_si</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">n</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">f1</span> <span style=\"color: #0000FF;\">+</span> <span style=\"color: #008080;\">iff</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #7060A8;\">length</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">f</span><span style=\"color: #0000FF;\">)=</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">?</span><span style=\"color: #000000;\">f1</span><span style=\"color: #0000FF;\">:</span><span style=\"color: #000000;\">f</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">2</span><span style=\"color: #0000FF;\">][</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">]))</span>\n         <span style=\"color: #008080;\">else</span>\n             <span style=\"color: #7060A8;\">assert</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #7060A8;\">mpz_fdiv_q_ui</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">n</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">n</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">f1</span><span style=\"color: #0000FF;\">)=</span><span style=\"color: #000000;\">0</span><span style=\"color: #0000FF;\">)</span>\n             <span style=\"color: #004080;\">mpz</span> <span style=\"color: #000000;\">d</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">mpz_init_set</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">n</span><span style=\"color: #0000FF;\">)</span>\n             <span style=\"color: #000000;\">D</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">n</span><span style=\"color: #0000FF;\">)</span>\n             <span style=\"color: #7060A8;\">mpz_mul_si</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">n</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">n</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">f1</span><span style=\"color: #0000FF;\">)</span>\n             <span style=\"color: #7060A8;\">mpz_add</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">n</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">n</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">d</span><span style=\"color: #0000FF;\">)</span>\n         <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">if</span>\n         <span style=\"color: #008080;\">if</span> <span style=\"color: #000000;\">s</span><span style=\"color: #0000FF;\"><</span><span style=\"color: #000000;\">0</span> <span style=\"color: #008080;\">then</span> <span style=\"color: #7060A8;\">mpz_neg</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">n</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">n</span><span style=\"color: #0000FF;\">)</span> <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">if</span>\n     <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">if</span>\n <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">procedure</span>\n\n <span style=\"color: #004080;\">sequence</span> <span style=\"color: #000000;\">res</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">repeat</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">0</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">200</span><span style=\"color: #0000FF;\">)</span>\n <span style=\"color: #004080;\">mpz</span> <span style=\"color: #000000;\">n</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">mpz_init</span><span style=\"color: #0000FF;\">()</span>\n <span style=\"color: #008080;\">for</span> <span style=\"color: #000000;\">i</span><span style=\"color: #0000FF;\">=-</span><span style=\"color: #000000;\">99</span> <span style=\"color: #008080;\">to</span> <span style=\"color: #000000;\">100</span> <span style=\"color: #008080;\">do</span>\n     <span style=\"color: #7060A8;\">mpz_set_si</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">n</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">i</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #000000;\">D</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">n</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #000000;\">res</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">i</span><span style=\"color: #0000FF;\">+</span><span style=\"color: #000000;\">100</span><span style=\"color: #0000FF;\">]</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">mpz_get_str</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">n</span><span style=\"color: #0000FF;\">)</span>\n <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">for</span>\n <span style=\"color: #7060A8;\">printf</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #008000;\">\"%s\\n\\n\"</span><span style=\"color: #0000FF;\">,{</span><span style=\"color: #7060A8;\">join_by</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">res</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">10</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #008000;\">\" \"</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">fmt</span><span style=\"color: #0000FF;\">:=</span><span style=\"color: #008000;\">\"%4s\"</span><span style=\"color: #0000FF;\">)})</span>\n <span style=\"color: #008080;\">for</span> <span style=\"color: #000000;\">m</span><span style=\"color: #0000FF;\">=</span><span style=\"color: #000000;\">1</span> <span style=\"color: #008080;\">to</span> <span style=\"color: #000000;\">20</span> <span style=\"color: #008080;\">do</span>\n     <span style=\"color: #7060A8;\">mpz_ui_pow_ui</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">n</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">10</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">m</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #000000;\">D</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">n</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #7060A8;\">assert</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #7060A8;\">mpz_fdiv_q_ui</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">n</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">n</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">7</span><span style=\"color: #0000FF;\">)=</span><span style=\"color: #000000;\">0</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #7060A8;\">printf</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #008000;\">\"D(10^%d)/7 = %s\\n\"</span><span style=\"color: #0000FF;\">,{</span><span style=\"color: #000000;\">m</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #7060A8;\">mpz_get_str</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">n</span><span style=\"color: #0000FF;\">)})</span>\n <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">for</span>\n<!--\n"
                },
                {
                    "language": "XPL0",
                    "solution": "function integer Lagarias (N); \\Lagarias arithmetic derivative\ninteger N;\ninteger F, Q;\n\n        function integer SmallPF (J, K); \\Smallest prime factor\n        integer J, K;\n        return if rem(J/K) = 0 then K else SmallPF(J, K+1);\n\nbegin\nif N < 0\nthen return -Lagarias (-N)\nelse if N = 0 or N = 1\nthen return 0\nelse    begin\n        F := SmallPF (N, 2);  Q := N / F;\n        return if Q = 1\n        then 1\n        else Q * Lagarias (F)  +  F * Lagarias (Q)\n        end;\nend \\Lagarias\\ ;\n\ninteger N;\nbegin\n    for N:= -99 to 100 do begin\n        IntOut(0, Lagarias(N) );\n        if rem(N/10) = 0 then CrLf(0) else ChOut(0, 9\\tab\\);\n    end;\nend\n"
                }
            ],
            [
                {
                    "language": "ALGOL-W",
                    "solution": "begin\n   integer procedure lagarias ( integer value n ) ; % Lagarias arithmetic derivative %\n           if n < 0\n           then -lagarias (-n)\n           else if n = 0 or n = 1\n           then 0\n           else begin\n                integer f, q;\n                integer procedure smallPf ( integer value j, k ) ; % Smallest prime factor %\n                    if j rem k = 0 then k else smallPf (j, k + 1);\n                f := smallPf (n, 2); q := n div f;\n                if q = 1\n                then 1\n                else q * lagarias (f) + f * lagarias (q)\n           end lagarias ;\n\n   for n := -99 until 100 do begin\n       writeon( i_w := 6, s_w := 0, \" \", lagarias (n) );\n       if n rem 10 = 0 then write()\n   end for_n\nend.\n"
                },
                {
                    "language": "Python",
                    "solution": "from sympy.ntheory import factorint\n\ndef D(n):\n    if n < 0:\n        return -D(-n)\n    elif n < 2:\n        return 0\n    else:\n        fdict = factorint(n)\n        if len(fdict) == 1 and 1 in fdict: # is prime\n            return 1\n        return sum([n * e // p for p, e in fdict.items()])\n\nfor n in range(-99, 101):\n    print('{:5}'.format(D(n)), end='\\n' if n % 10 == 0 else '')\n\nprint()\nfor m in range(1, 21):\n    print('(D for 10**{}) divided by 7 is {}'.format(m, D(10 ** m) // 7))\n"
                }
            ],
            [
                {
                    "language": "Factor",
                    "solution": "USING: combinators formatting grouping io kernel math\nmath.primes.factors prettyprint ranges sequences ;\n\n: n' ( m -- n )\n    {\n        { [ dup neg? ] [ neg n' neg ] }\n        { [ dup 2 < ] [ drop 0 ] }\n        { [ factors dup length 1 = ] [ drop 1 ] }\n        [ unclip-slice swap product 2dup n' * spin n' * + ]\n    } cond ;\n\n-99 100 [a..b] [ n' ] map 10 group\n[ [ \"%5d\" printf ] each nl ] each\n"
                },
                {
                    "language": "Wren",
                    "solution": "import \"./big\" for BigInt\nimport \"./fmt\" for Fmt\n\nvar D = Fn.new { |n|\n    if (n < 0) return -D.call(-n)\n    if (n < 2) return BigInt.zero\n    var f = BigInt.primeFactors(n)\n    var c = f.count\n    if (c == 1) return BigInt.one\n    if (c == 2) return f[0] + f[1]\n    var d = n / f[0]\n    return D.call(d) * f[0] + d\n}\n\nvar ad = List.filled(200, 0)\nfor (n in -99..100) ad[n+99] = D.call(BigInt.new(n))\nFmt.tprint(\"$4i\", ad, 10)\nSystem.print()\nfor (m in 1..20) {\n    Fmt.print(\"D(10^$-2d) / 7 = $i\", m, D.call(BigInt.ten.pow(m))/7)\n}\n"
                }
            ],
            [
                {
                    "language": "MiniScript",
                    "solution": "lagarias = function (n) // Lagarias arithmetic derivative\n   if n < 0 then\n       return -lagarias (-n)\n   else if n == 0 or n == 1 then\n       return 0\n   else\n       smallPf = function (j, k) // Smallest prime factor\n           if j % k == 0 then\n               return k\n           else\n               return smallPf (j, k + 1)\n           end if\n       end function\n       f = smallPf (n, 2)\n       q = floor (n / f)\n       if q == 1 then\n           return 1\n       else\n           return q * lagarias (f) + f * lagarias (q)\n       end if\n   end if\nend function\nfmt6 = function (n) // return a 6 character string representation of n\n    s = str( n )\n    if s.len > 5 then\n        return s\n    else\n        return ( \" \" * ( 6 - s.len ) ) + s\n    end if\nend function\nad = \"\"\nfor n in range( -99, 100 )\n    ad = ad + \" \" + fmt6( lagarias (n) )\n    if n % 10 == 0 then\n        print( ad )\n        ad = \"\"\n    end if\nend for\nprint()\nfor n in range( 1, 17 )    // 18, 19 and 20 would overflow ????? TODO: check\n    m = 10 ^ n\n    print( \"D(\" + str(m) + \") / 7 = \" + str( floor (lagarias (m) / 7) ) )\nend for\n"
                },
                {
                    "language": "Nim",
                    "solution": "import std/[strformat, strutils]\nimport integers\n\n\nfunc aDerivative(n: int | Integer): typeof(n) =\n  ## Recursively compute the arithmetic derivative.\n  ## The function works with normal integers or big integers.\n  ## Using a cache to store the derivatives would improve the\n  ## performance, but this is not needed for these tasks.\n  if n < 0: return -aDerivative(-n)\n  if n == 0 or n == 1: return 0\n  if n == 2: return 1\n  var d = 2\n  result = 1\n  while d * d <= n:\n    if n mod d == 0:\n      let q = n div d\n      result = q * aDerivative(d) + d * aDerivative(q)\n      break\n    inc d\n\n\n### Task ###\n\necho \"Arithmetic derivatives for -99 through 100:\"\n\n# We can use an \"int\" variable here.\nvar col = 0\nfor n in -99..100:\n  inc col\n  stdout.write &\"{aDerivative(n):>4}\"\n  stdout.write if col == 10: '\\n' else: ' '\n  if col == 10: col = 0\n\n\n### Stretch task ###\n\necho()\n\n# To avoid overflow, we have to use an \"Integer\" variable.\nvar n = Integer(1)\nfor m in 1..20:\n  n *= 10\n  let a = aDerivative(n)\n  let left = &\"D(10^{m}) / 7\"\n  echo &\"{left:>12} = {a div 7}\"\n"
                }
            ]
        ]
    },
    {
        "task_name": "Arithmetic-evaluation",
        "task_description": "Create a program which parses and evaluates arithmetic expressions.\n\n;Requirements:\n* An [[wp:Abstract_syntax_tree|abstract-syntax tree]] (AST) for the expression must be created from parsing the input. \n* The AST must be used in evaluation, also, so the input may not be directly evaluated (e.g. by calling eval or a similar language feature.) \n* The expression will be a string or list of symbols like \"(1+3)*7\". \n* The four symbols + - * / must be supported as binary operators with conventional precedence rules. \n* Precedence-control parentheses must also be supported.\n<br>\n\n;Note:\nFor those who don't remember, mathematical precedence is as follows:\n* Parentheses\n* Multiplication/Division (left to right)\n* Addition/Subtraction (left to right)\n<br>\n\n;C.f: \n* [[24 game Player]].\n* [[Parsing/RPN calculator algorithm]].\n* [[Parsing/RPN to infix conversion]].\n<br><br>\n\n",
        "solution_pairs": [
            [
                {
                    "language": "Phix",
                    "solution": "(phixonline)-->\n <span style=\"color: #000080;font-style:italic;\">-- demo\\rosetta\\Arithmetic_evaluation.exw</span>\n <span style=\"color: #008080;\">with</span> <span style=\"color: #008080;\">javascript_semantics</span>\n\n <span style=\"color: #004080;\">sequence</span> <span style=\"color: #000000;\">opstack</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #0000FF;\">{}</span>       <span style=\"color: #000080;font-style:italic;\">-- atom elements are literals,\n                             -- sequence elements are subexpressions\n                             -- on completion length(opstack) should be 1</span>\n <span style=\"color: #004080;\">object</span> <span style=\"color: #000000;\">token</span>\n\n <span style=\"color: #008080;\">constant</span> <span style=\"color: #000000;\">op_p_p</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #000000;\">1</span>         <span style=\"color: #000080;font-style:italic;\">--  1: expressions stored as op,p1,p2\n     --   p_op_p             --  0: expressions stored as p1,op,p2\n     --   p_p_op             -- -1: expressions stored as p1,p2,op</span>\n\n <span style=\"color: #004080;\">object</span> <span style=\"color: #000000;\">op</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #000000;\">0</span>   <span style=\"color: #000080;font-style:italic;\">-- 0 if none, else \"+\", \"-\", \"*\", \"/\", \"^\", \"%\", or \"u-\"</span>\n\n <span style=\"color: #004080;\">string</span> <span style=\"color: #000000;\">s</span>        <span style=\"color: #000080;font-style:italic;\">-- the expression being parsed</span>\n <span style=\"color: #004080;\">integer</span> <span style=\"color: #000000;\">ch</span>\n <span style=\"color: #004080;\">integer</span> <span style=\"color: #000000;\">sidx</span>\n\n <span style=\"color: #008080;\">procedure</span> <span style=\"color: #000000;\">err</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #004080;\">string</span> <span style=\"color: #000000;\">msg</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #7060A8;\">printf</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #008000;\">\"%s\\n%s^ %s\\n\\nPressEnter...\"</span><span style=\"color: #0000FF;\">,{</span><span style=\"color: #000000;\">s</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #7060A8;\">repeat</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #008000;\">' '</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">sidx</span><span style=\"color: #0000FF;\">-</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">),</span><span style=\"color: #000000;\">msg</span><span style=\"color: #0000FF;\">})</span>\n     <span style=\"color: #0000FF;\">{}</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">wait_key</span><span style=\"color: #0000FF;\">()</span>\n     <span style=\"color: #7060A8;\">abort</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">0</span><span style=\"color: #0000FF;\">)</span>\n <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">procedure</span>\n\n <span style=\"color: #008080;\">procedure</span> <span style=\"color: #000000;\">nxtch</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #004080;\">object</span> <span style=\"color: #000000;\">msg</span><span style=\"color: #0000FF;\">=</span><span style=\"color: #008000;\">\"eof\"</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #000000;\">sidx</span> <span style=\"color: #0000FF;\">+=</span> <span style=\"color: #000000;\">1</span>\n     <span style=\"color: #008080;\">if</span> <span style=\"color: #000000;\">sidx</span><span style=\"color: #0000FF;\">></span><span style=\"color: #7060A8;\">length</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">s</span><span style=\"color: #0000FF;\">)</span> <span style=\"color: #008080;\">then</span>\n         <span style=\"color: #008080;\">if</span> <span style=\"color: #004080;\">string</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">msg</span><span style=\"color: #0000FF;\">)</span> <span style=\"color: #008080;\">then</span> <span style=\"color: #000000;\">err</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">msg</span><span style=\"color: #0000FF;\">)</span> <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">if</span>\n         <span style=\"color: #000000;\">ch</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #0000FF;\">-</span><span style=\"color: #000000;\">1</span>\n     <span style=\"color: #008080;\">else</span>\n         <span style=\"color: #000000;\">ch</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #000000;\">s</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">sidx</span><span style=\"color: #0000FF;\">]</span>\n     <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">if</span>\n <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">procedure</span>\n\n <span style=\"color: #008080;\">procedure</span> <span style=\"color: #000000;\">skipspaces</span><span style=\"color: #0000FF;\">()</span>\n     <span style=\"color: #008080;\">while</span> <span style=\"color: #7060A8;\">find</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">ch</span><span style=\"color: #0000FF;\">,{</span><span style=\"color: #008000;\">' '</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #008000;\">'\\t'</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #008000;\">'\\r'</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #008000;\">'\\n'</span><span style=\"color: #0000FF;\">})!=</span><span style=\"color: #000000;\">0</span> <span style=\"color: #008080;\">do</span> <span style=\"color: #000000;\">nxtch</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">0</span><span style=\"color: #0000FF;\">)</span> <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">while</span>\n <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">procedure</span>\n\n <span style=\"color: #008080;\">procedure</span> <span style=\"color: #000000;\">get_token</span><span style=\"color: #0000FF;\">()</span>\n <span style=\"color: #004080;\">atom</span> <span style=\"color: #000000;\">n</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #000000;\">fraction</span>\n <span style=\"color: #004080;\">integer</span> <span style=\"color: #000000;\">dec</span>\n     <span style=\"color: #000000;\">skipspaces</span><span style=\"color: #0000FF;\">()</span>\n     <span style=\"color: #008080;\">if</span> <span style=\"color: #000000;\">ch</span><span style=\"color: #0000FF;\">=-</span><span style=\"color: #000000;\">1</span> <span style=\"color: #008080;\">then</span> <span style=\"color: #000000;\">token</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #008000;\">\"eof\"</span> <span style=\"color: #008080;\">return</span> <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">if</span>\n     <span style=\"color: #008080;\">if</span> <span style=\"color: #000000;\">ch</span><span style=\"color: #0000FF;\">>=</span><span style=\"color: #008000;\">'0'</span> <span style=\"color: #008080;\">and</span> <span style=\"color: #000000;\">ch</span><span style=\"color: #0000FF;\"><=</span><span style=\"color: #008000;\">'9'</span> <span style=\"color: #008080;\">then</span>\n         <span style=\"color: #000000;\">n</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #000000;\">ch</span><span style=\"color: #0000FF;\">-</span><span style=\"color: #008000;\">'0'</span>\n         <span style=\"color: #008080;\">while</span> <span style=\"color: #000000;\">1</span> <span style=\"color: #008080;\">do</span>\n             <span style=\"color: #000000;\">nxtch</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">0</span><span style=\"color: #0000FF;\">)</span>\n             <span style=\"color: #008080;\">if</span> <span style=\"color: #000000;\">ch</span><span style=\"color: #0000FF;\"><</span><span style=\"color: #008000;\">'0'</span> <span style=\"color: #008080;\">or</span> <span style=\"color: #000000;\">ch</span><span style=\"color: #0000FF;\">></span><span style=\"color: #008000;\">'9'</span> <span style=\"color: #008080;\">then</span> <span style=\"color: #008080;\">exit</span> <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">if</span>\n             <span style=\"color: #000000;\">n</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #000000;\">n</span><span style=\"color: #0000FF;\">*</span><span style=\"color: #000000;\">10</span><span style=\"color: #0000FF;\">+</span><span style=\"color: #000000;\">ch</span><span style=\"color: #0000FF;\">-</span><span style=\"color: #008000;\">'0'</span>\n         <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">while</span>\n         <span style=\"color: #008080;\">if</span> <span style=\"color: #000000;\">ch</span><span style=\"color: #0000FF;\">=</span><span style=\"color: #008000;\">'.'</span> <span style=\"color: #008080;\">then</span>\n             <span style=\"color: #000000;\">dec</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #000000;\">1</span>\n             <span style=\"color: #000000;\">fraction</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #000000;\">0</span>\n             <span style=\"color: #008080;\">while</span> <span style=\"color: #000000;\">1</span> <span style=\"color: #008080;\">do</span>\n                 <span style=\"color: #000000;\">nxtch</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">0</span><span style=\"color: #0000FF;\">)</span>\n                 <span style=\"color: #008080;\">if</span> <span style=\"color: #000000;\">ch</span><span style=\"color: #0000FF;\"><</span><span style=\"color: #008000;\">'0'</span> <span style=\"color: #008080;\">or</span> <span style=\"color: #000000;\">ch</span><span style=\"color: #0000FF;\">></span><span style=\"color: #008000;\">'9'</span> <span style=\"color: #008080;\">then</span> <span style=\"color: #008080;\">exit</span> <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">if</span>\n                 <span style=\"color: #000000;\">fraction</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #000000;\">fraction</span><span style=\"color: #0000FF;\">*</span><span style=\"color: #000000;\">10</span> <span style=\"color: #0000FF;\">+</span> <span style=\"color: #000000;\">ch</span><span style=\"color: #0000FF;\">-</span><span style=\"color: #008000;\">'0'</span>\n                 <span style=\"color: #000000;\">dec</span> <span style=\"color: #0000FF;\">*=</span> <span style=\"color: #000000;\">10</span>\n             <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">while</span>\n             <span style=\"color: #000000;\">n</span> <span style=\"color: #0000FF;\">+=</span> <span style=\"color: #000000;\">fraction</span><span style=\"color: #0000FF;\">/</span><span style=\"color: #000000;\">dec</span>\n         <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">if</span>\n <span style=\"color: #000080;font-style:italic;\">--      if find(ch,\"eE\") then   -- you get the idea\n --      end if</span>\n         <span style=\"color: #000000;\">token</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #000000;\">n</span>\n         <span style=\"color: #008080;\">return</span>\n     <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">if</span>\n     <span style=\"color: #008080;\">if</span> <span style=\"color: #7060A8;\">find</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">ch</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #008000;\">\"+-/*()^%\"</span><span style=\"color: #0000FF;\">)=</span><span style=\"color: #000000;\">0</span> <span style=\"color: #008080;\">then</span> <span style=\"color: #000000;\">err</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #008000;\">\"syntax error\"</span><span style=\"color: #0000FF;\">)</span> <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">if</span>\n     <span style=\"color: #000000;\">token</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #000000;\">s</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">sidx</span><span style=\"color: #0000FF;\">..</span><span style=\"color: #000000;\">sidx</span><span style=\"color: #0000FF;\">]</span>\n     <span style=\"color: #000000;\">nxtch</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">0</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #008080;\">return</span>\n <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">procedure</span>\n\n <span style=\"color: #008080;\">procedure</span> <span style=\"color: #000000;\">Match</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #004080;\">string</span> <span style=\"color: #000000;\">t</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #008080;\">if</span> <span style=\"color: #000000;\">token</span><span style=\"color: #0000FF;\">!=</span><span style=\"color: #000000;\">t</span> <span style=\"color: #008080;\">then</span> <span style=\"color: #000000;\">err</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">t</span><span style=\"color: #0000FF;\">&</span><span style=\"color: #008000;\">\" expected\"</span><span style=\"color: #0000FF;\">)</span> <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">if</span>\n     <span style=\"color: #000000;\">get_token</span><span style=\"color: #0000FF;\">()</span>\n <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">procedure</span>\n\n <span style=\"color: #008080;\">procedure</span> <span style=\"color: #000000;\">PopFactor</span><span style=\"color: #0000FF;\">()</span>\n     <span style=\"color: #004080;\">object</span> <span style=\"color: #000000;\">p1</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #000000;\">p2</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #000000;\">opstack</span><span style=\"color: #0000FF;\">[$]</span>\n     <span style=\"color: #008080;\">if</span> <span style=\"color: #000000;\">op</span><span style=\"color: #0000FF;\">=</span><span style=\"color: #008000;\">\"u-\"</span> <span style=\"color: #008080;\">then</span>\n         <span style=\"color: #000000;\">p1</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #000000;\">0</span>\n     <span style=\"color: #008080;\">else</span>\n         <span style=\"color: #000000;\">opstack</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #000000;\">opstack</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">..$-</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">]</span>\n         <span style=\"color: #000000;\">p1</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #000000;\">opstack</span><span style=\"color: #0000FF;\">[$]</span>\n     <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">if</span>\n     <span style=\"color: #008080;\">if</span> <span style=\"color: #000000;\">op_p_p</span><span style=\"color: #0000FF;\">=</span><span style=\"color: #000000;\">1</span> <span style=\"color: #008080;\">then</span>\n         <span style=\"color: #000000;\">opstack</span><span style=\"color: #0000FF;\">[$]</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #0000FF;\">{</span><span style=\"color: #000000;\">op</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">p1</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">p2</span><span style=\"color: #0000FF;\">}</span>  <span style=\"color: #000080;font-style:italic;\">-- op_p_p</span>\n     <span style=\"color: #008080;\">elsif</span> <span style=\"color: #000000;\">op_p_p</span><span style=\"color: #0000FF;\">=</span><span style=\"color: #000000;\">0</span> <span style=\"color: #008080;\">then</span>\n         <span style=\"color: #000000;\">opstack</span><span style=\"color: #0000FF;\">[$]</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #0000FF;\">{</span><span style=\"color: #000000;\">p1</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">op</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">p2</span><span style=\"color: #0000FF;\">}</span>  <span style=\"color: #000080;font-style:italic;\">-- p_op_p</span>\n     <span style=\"color: #008080;\">else</span> <span style=\"color: #000080;font-style:italic;\">-- -1</span>\n         <span style=\"color: #000000;\">opstack</span><span style=\"color: #0000FF;\">[$]</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #0000FF;\">{</span><span style=\"color: #000000;\">p1</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">p2</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">op</span><span style=\"color: #0000FF;\">}</span>  <span style=\"color: #000080;font-style:italic;\">-- p_p_op</span>\n     <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">if</span>\n     <span style=\"color: #000000;\">op</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #000000;\">0</span>\n <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">procedure</span>\n\n <span style=\"color: #008080;\">procedure</span> <span style=\"color: #000000;\">PushFactor</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #004080;\">atom</span> <span style=\"color: #000000;\">t</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #008080;\">if</span> <span style=\"color: #000000;\">op</span><span style=\"color: #0000FF;\">!=</span><span style=\"color: #000000;\">0</span> <span style=\"color: #008080;\">then</span> <span style=\"color: #000000;\">PopFactor</span><span style=\"color: #0000FF;\">()</span> <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">if</span>\n     <span style=\"color: #000000;\">opstack</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">append</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">opstack</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">t</span><span style=\"color: #0000FF;\">)</span>\n <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">procedure</span>\n\n <span style=\"color: #008080;\">procedure</span> <span style=\"color: #000000;\">PushOp</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #004080;\">string</span> <span style=\"color: #000000;\">t</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #008080;\">if</span> <span style=\"color: #000000;\">op</span><span style=\"color: #0000FF;\">!=</span><span style=\"color: #000000;\">0</span> <span style=\"color: #008080;\">then</span> <span style=\"color: #000000;\">PopFactor</span><span style=\"color: #0000FF;\">()</span> <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">if</span>\n     <span style=\"color: #000000;\">op</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #000000;\">t</span>\n <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">procedure</span>\n\n <span style=\"color: #008080;\">forward</span> <span style=\"color: #008080;\">procedure</span> <span style=\"color: #000000;\">Expr</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #004080;\">integer</span> <span style=\"color: #000000;\">p</span><span style=\"color: #0000FF;\">)</span>\n\n <span style=\"color: #008080;\">procedure</span> <span style=\"color: #000000;\">Factor</span><span style=\"color: #0000FF;\">()</span>\n     <span style=\"color: #008080;\">if</span> <span style=\"color: #004080;\">atom</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">token</span><span style=\"color: #0000FF;\">)</span> <span style=\"color: #008080;\">then</span>\n         <span style=\"color: #000000;\">PushFactor</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">token</span><span style=\"color: #0000FF;\">)</span>\n         <span style=\"color: #008080;\">if</span> <span style=\"color: #000000;\">ch</span><span style=\"color: #0000FF;\">!=-</span><span style=\"color: #000000;\">1</span> <span style=\"color: #008080;\">then</span>\n             <span style=\"color: #000000;\">get_token</span><span style=\"color: #0000FF;\">()</span>\n         <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">if</span>\n     <span style=\"color: #008080;\">elsif</span> <span style=\"color: #000000;\">token</span><span style=\"color: #0000FF;\">=</span><span style=\"color: #008000;\">\"+\"</span> <span style=\"color: #008080;\">then</span> <span style=\"color: #000080;font-style:italic;\">-- (ignore)</span>\n         <span style=\"color: #000000;\">nxtch</span><span style=\"color: #0000FF;\">()</span>\n         <span style=\"color: #000000;\">Factor</span><span style=\"color: #0000FF;\">()</span>\n     <span style=\"color: #008080;\">elsif</span> <span style=\"color: #000000;\">token</span><span style=\"color: #0000FF;\">=</span><span style=\"color: #008000;\">\"-\"</span> <span style=\"color: #008080;\">then</span>\n         <span style=\"color: #000000;\">get_token</span><span style=\"color: #0000FF;\">()</span>\n <span style=\"color: #000080;font-style:italic;\">--      Factor()</span>\n         <span style=\"color: #000000;\">Expr</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">3</span><span style=\"color: #0000FF;\">)</span> <span style=\"color: #000080;font-style:italic;\">-- makes \"-3^2\" yield -9 (ie -(3^2)) not 9 (ie (-3)^2).</span>\n         <span style=\"color: #008080;\">if</span> <span style=\"color: #000000;\">op</span><span style=\"color: #0000FF;\">!=</span><span style=\"color: #000000;\">0</span> <span style=\"color: #008080;\">then</span> <span style=\"color: #000000;\">PopFactor</span><span style=\"color: #0000FF;\">()</span> <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">if</span>\n         <span style=\"color: #008080;\">if</span> <span style=\"color: #004080;\">integer</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">opstack</span><span style=\"color: #0000FF;\">[$])</span> <span style=\"color: #008080;\">then</span>\n             <span style=\"color: #000000;\">opstack</span><span style=\"color: #0000FF;\">[$]</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #0000FF;\">-</span><span style=\"color: #000000;\">opstack</span><span style=\"color: #0000FF;\">[$]</span>\n         <span style=\"color: #008080;\">else</span>\n             <span style=\"color: #000000;\">PushOp</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #008000;\">\"u-\"</span><span style=\"color: #0000FF;\">)</span>\n         <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">if</span>\n     <span style=\"color: #008080;\">elsif</span> <span style=\"color: #000000;\">token</span><span style=\"color: #0000FF;\">=</span><span style=\"color: #008000;\">\"(\"</span> <span style=\"color: #008080;\">then</span>\n         <span style=\"color: #000000;\">get_token</span><span style=\"color: #0000FF;\">()</span>\n         <span style=\"color: #000000;\">Expr</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">0</span><span style=\"color: #0000FF;\">)</span>\n         <span style=\"color: #000000;\">Match</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #008000;\">\")\"</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #008080;\">else</span>\n         <span style=\"color: #000000;\">err</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #008000;\">\"syntax error\"</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">if</span>\n <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">procedure</span>\n\n <span style=\"color: #008080;\">constant</span> <span style=\"color: #0000FF;\">{</span><span style=\"color: #000000;\">operators</span><span style=\"color: #0000FF;\">,</span>\n           <span style=\"color: #000000;\">precedence</span><span style=\"color: #0000FF;\">,</span>\n           <span style=\"color: #000000;\">associativity</span><span style=\"color: #0000FF;\">}</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">columnize</span><span style=\"color: #0000FF;\">({{</span><span style=\"color: #008000;\">\"^\"</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">3</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">0</span><span style=\"color: #0000FF;\">},</span>\n                                       <span style=\"color: #0000FF;\">{</span><span style=\"color: #008000;\">\"%\"</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">2</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">},</span>\n                                       <span style=\"color: #0000FF;\">{</span><span style=\"color: #008000;\">\"*\"</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">2</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">},</span>\n                                       <span style=\"color: #0000FF;\">{</span><span style=\"color: #008000;\">\"/\"</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">2</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">},</span>\n                                       <span style=\"color: #0000FF;\">{</span><span style=\"color: #008000;\">\"+\"</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">},</span>\n                                       <span style=\"color: #0000FF;\">{</span><span style=\"color: #008000;\">\"-\"</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">},</span>\n                                       <span style=\"color: #0000FF;\">$})</span>\n\n <span style=\"color: #008080;\">procedure</span> <span style=\"color: #000000;\">Expr</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #004080;\">integer</span> <span style=\"color: #000000;\">p</span><span style=\"color: #0000FF;\">)</span>\n <span style=\"color: #000080;font-style:italic;\">--\n -- Parse an expression, using precedence climbing.\n --\n -- p is the precedence level we should parse to, eg/ie\n --      4: Factor only (may as well just call Factor)\n --      3: \"\" and ^\n --      2: \"\" and *,/,%\n --      1: \"\" and +,-\n --      0: full expression (effectively the same as 1)\n --  obviously, parentheses override any setting of p.\n --</span>\n <span style=\"color: #004080;\">integer</span> <span style=\"color: #000000;\">k</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #000000;\">thisp</span>\n     <span style=\"color: #000000;\">Factor</span><span style=\"color: #0000FF;\">()</span>\n     <span style=\"color: #008080;\">while</span> <span style=\"color: #000000;\">1</span> <span style=\"color: #008080;\">do</span>\n         <span style=\"color: #000000;\">k</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">find</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">token</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">operators</span><span style=\"color: #0000FF;\">)</span> <span style=\"color: #000080;font-style:italic;\">-- *,/,+,-</span>\n         <span style=\"color: #008080;\">if</span> <span style=\"color: #000000;\">k</span><span style=\"color: #0000FF;\">=</span><span style=\"color: #000000;\">0</span> <span style=\"color: #008080;\">then</span> <span style=\"color: #008080;\">exit</span> <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">if</span>\n         <span style=\"color: #000000;\">thisp</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #000000;\">precedence</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">k</span><span style=\"color: #0000FF;\">]</span>\n         <span style=\"color: #008080;\">if</span> <span style=\"color: #000000;\">thisp</span><span style=\"color: #0000FF;\"><</span><span style=\"color: #000000;\">p</span> <span style=\"color: #008080;\">then</span> <span style=\"color: #008080;\">exit</span> <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">if</span>\n         <span style=\"color: #000000;\">get_token</span><span style=\"color: #0000FF;\">()</span>\n         <span style=\"color: #000000;\">Expr</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">thisp</span><span style=\"color: #0000FF;\">+</span><span style=\"color: #000000;\">associativity</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">k</span><span style=\"color: #0000FF;\">])</span>\n         <span style=\"color: #000000;\">PushOp</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">operators</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">k</span><span style=\"color: #0000FF;\">])</span>\n     <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">while</span>\n <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">procedure</span>\n\n <span style=\"color: #008080;\">function</span> <span style=\"color: #000000;\">evaluate</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #004080;\">object</span> <span style=\"color: #000000;\">s</span><span style=\"color: #0000FF;\">)</span>\n <span style=\"color: #004080;\">object</span> <span style=\"color: #000000;\">lhs</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #000000;\">rhs</span>\n <span style=\"color: #004080;\">string</span> <span style=\"color: #000000;\">op</span>\n     <span style=\"color: #008080;\">if</span> <span style=\"color: #004080;\">atom</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">s</span><span style=\"color: #0000FF;\">)</span> <span style=\"color: #008080;\">then</span>\n         <span style=\"color: #008080;\">return</span> <span style=\"color: #000000;\">s</span>\n     <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">if</span>\n     <span style=\"color: #008080;\">if</span> <span style=\"color: #000000;\">op_p_p</span><span style=\"color: #0000FF;\">=</span><span style=\"color: #000000;\">1</span> <span style=\"color: #008080;\">then</span>            <span style=\"color: #000080;font-style:italic;\">-- op_p_p</span>\n         <span style=\"color: #0000FF;\">{</span><span style=\"color: #000000;\">op</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">lhs</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">rhs</span><span style=\"color: #0000FF;\">}</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #000000;\">s</span>\n     <span style=\"color: #008080;\">elsif</span> <span style=\"color: #000000;\">op_p_p</span><span style=\"color: #0000FF;\">=</span><span style=\"color: #000000;\">0</span> <span style=\"color: #008080;\">then</span>         <span style=\"color: #000080;font-style:italic;\">-- p_op_p</span>\n         <span style=\"color: #0000FF;\">{</span><span style=\"color: #000000;\">lhs</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">op</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">rhs</span><span style=\"color: #0000FF;\">}</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #000000;\">s</span>\n     <span style=\"color: #008080;\">else</span> <span style=\"color: #000080;font-style:italic;\">-- -1                  -- p_p_op</span>\n         <span style=\"color: #0000FF;\">{</span><span style=\"color: #000000;\">lhs</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">rhs</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">op</span><span style=\"color: #0000FF;\">}</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #000000;\">s</span>\n     <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">if</span>\n     <span style=\"color: #008080;\">if</span> <span style=\"color: #004080;\">sequence</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">lhs</span><span style=\"color: #0000FF;\">)</span> <span style=\"color: #008080;\">then</span> <span style=\"color: #000000;\">lhs</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #000000;\">evaluate</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">lhs</span><span style=\"color: #0000FF;\">)</span> <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">if</span>\n     <span style=\"color: #008080;\">if</span> <span style=\"color: #004080;\">sequence</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">rhs</span><span style=\"color: #0000FF;\">)</span> <span style=\"color: #008080;\">then</span> <span style=\"color: #000000;\">rhs</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #000000;\">evaluate</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">rhs</span><span style=\"color: #0000FF;\">)</span> <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">if</span>\n     <span style=\"color: #008080;\">if</span> <span style=\"color: #000000;\">op</span><span style=\"color: #0000FF;\">=</span><span style=\"color: #008000;\">\"+\"</span> <span style=\"color: #008080;\">then</span>\n         <span style=\"color: #008080;\">return</span> <span style=\"color: #000000;\">lhs</span><span style=\"color: #0000FF;\">+</span><span style=\"color: #000000;\">rhs</span>\n     <span style=\"color: #008080;\">elsif</span> <span style=\"color: #000000;\">op</span><span style=\"color: #0000FF;\">=</span><span style=\"color: #008000;\">\"-\"</span> <span style=\"color: #008080;\">then</span>\n         <span style=\"color: #008080;\">return</span> <span style=\"color: #000000;\">lhs</span><span style=\"color: #0000FF;\">-</span><span style=\"color: #000000;\">rhs</span>\n     <span style=\"color: #008080;\">elsif</span> <span style=\"color: #000000;\">op</span><span style=\"color: #0000FF;\">=</span><span style=\"color: #008000;\">\"*\"</span> <span style=\"color: #008080;\">then</span>\n         <span style=\"color: #008080;\">return</span> <span style=\"color: #000000;\">lhs</span><span style=\"color: #0000FF;\">*</span><span style=\"color: #000000;\">rhs</span>\n     <span style=\"color: #008080;\">elsif</span> <span style=\"color: #000000;\">op</span><span style=\"color: #0000FF;\">=</span><span style=\"color: #008000;\">\"/\"</span> <span style=\"color: #008080;\">then</span>\n         <span style=\"color: #008080;\">return</span> <span style=\"color: #000000;\">lhs</span><span style=\"color: #0000FF;\">/</span><span style=\"color: #000000;\">rhs</span>\n     <span style=\"color: #008080;\">elsif</span> <span style=\"color: #000000;\">op</span><span style=\"color: #0000FF;\">=</span><span style=\"color: #008000;\">\"^\"</span> <span style=\"color: #008080;\">then</span>\n         <span style=\"color: #008080;\">return</span> <span style=\"color: #7060A8;\">power</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">lhs</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">rhs</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #008080;\">elsif</span> <span style=\"color: #000000;\">op</span><span style=\"color: #0000FF;\">=</span><span style=\"color: #008000;\">\"%\"</span> <span style=\"color: #008080;\">then</span>\n         <span style=\"color: #008080;\">return</span> <span style=\"color: #7060A8;\">remainder</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">lhs</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">rhs</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #008080;\">elsif</span> <span style=\"color: #000000;\">op</span><span style=\"color: #0000FF;\">=</span><span style=\"color: #008000;\">\"u-\"</span> <span style=\"color: #008080;\">then</span>\n         <span style=\"color: #008080;\">return</span> <span style=\"color: #0000FF;\">-</span><span style=\"color: #000000;\">rhs</span>\n     <span style=\"color: #008080;\">else</span>\n         <span style=\"color: #0000FF;\">?</span><span style=\"color: #000000;\">9</span><span style=\"color: #0000FF;\">/</span><span style=\"color: #000000;\">0</span>\n     <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">if</span>\n <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">function</span>\n\n <span style=\"color: #000000;\">s</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #008000;\">\"3+4+5+6*7/1*5^2^3\"</span>     <span style=\"color: #000080;font-style:italic;\">-- 16406262</span>\n <span style=\"color: #000000;\">sidx</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #000000;\">0</span>\n <span style=\"color: #000000;\">nxtch</span><span style=\"color: #0000FF;\">()</span>\n <span style=\"color: #000000;\">get_token</span><span style=\"color: #0000FF;\">()</span>\n <span style=\"color: #000000;\">Expr</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">0</span><span style=\"color: #0000FF;\">)</span>\n <span style=\"color: #008080;\">if</span> <span style=\"color: #000000;\">op</span><span style=\"color: #0000FF;\">!=</span><span style=\"color: #000000;\">0</span> <span style=\"color: #008080;\">then</span> <span style=\"color: #000000;\">PopFactor</span><span style=\"color: #0000FF;\">()</span> <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">if</span>\n <span style=\"color: #008080;\">if</span> <span style=\"color: #7060A8;\">length</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">opstack</span><span style=\"color: #0000FF;\">)!=</span><span style=\"color: #000000;\">1</span> <span style=\"color: #008080;\">then</span> <span style=\"color: #000000;\">err</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #008000;\">\"some error\"</span><span style=\"color: #0000FF;\">)</span> <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">if</span>\n <span style=\"color: #7060A8;\">printf</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #008000;\">\"expression: \\\"%s\\\"\\n\"</span><span style=\"color: #0000FF;\">,{</span><span style=\"color: #000000;\">s</span><span style=\"color: #0000FF;\">})</span>\n <span style=\"color: #7060A8;\">puts</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #008000;\">\"AST (flat): \"</span><span style=\"color: #0000FF;\">)</span>\n <span style=\"color: #0000FF;\">?</span><span style=\"color: #000000;\">opstack</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">]</span>\n <span style=\"color: #7060A8;\">puts</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #008000;\">\"AST (tree):\\n\"</span><span style=\"color: #0000FF;\">)</span>\n <span style=\"color: #7060A8;\">ppEx</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">opstack</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">],{</span><span style=\"color: #004600;\">pp_Nest</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">9999</span><span style=\"color: #0000FF;\">})</span>\n <span style=\"color: #7060A8;\">puts</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #008000;\">\"result: \"</span><span style=\"color: #0000FF;\">)</span>\n <span style=\"color: #0000FF;\">?</span><span style=\"color: #000000;\">evaluate</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">opstack</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">])</span>\n <span style=\"color: #0000FF;\">{}</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">wait_key</span><span style=\"color: #0000FF;\">()</span>\n<!--\n"
                },
                {
                    "language": "Kotlin",
                    "solution": "// version 1.2.10\n\n/* if string is empty, returns zero */\nfun String.toDoubleOrZero() = this.toDoubleOrNull() ?: 0.0\n\nfun multiply(s: String): String {\n    val b = s.split('*').map { it.toDoubleOrZero() }\n    return (b[0] * b[1]).toString()\n}\n\nfun divide(s: String): String {\n    val b = s.split('/').map { it.toDoubleOrZero() }\n    return (b[0] / b[1]).toString()\n}\n\nfun add(s: String): String {\n    var t = s.replace(Regex(\"\"\"^\\+\"\"\"), \"\").replace(Regex(\"\"\"\\++\"\"\"), \"+\")\n    val b = t.split('+').map { it.toDoubleOrZero() }\n    return (b[0] + b[1]).toString()\n}\n\nfun subtract(s: String): String {\n    var t = s.replace(Regex(\"\"\"(\\+-|-\\+)\"\"\"), \"-\")\n    if (\"--\" in t) return add(t.replace(\"--\", \"+\"))\n    val b = t.split('-').map { it.toDoubleOrZero() }\n    return (if (b.size == 3) -b[1] - b[2] else b[0] - b[1]).toString()\n}\n\nfun evalExp(s: String): String {\n    var t = s.replace(Regex(\"\"\"[()]\"\"\"), \"\")\n    val reMD = Regex(\"\"\"\\d+\\.?\\d*\\s*[*/]\\s*[+-]?\\d+\\.?\\d*\"\"\")\n    val reM  = Regex( \"\"\"\\*\"\"\")\n    val reAS = Regex(\"\"\"-?\\d+\\.?\\d*\\s*[+-]\\s*[+-]?\\d+\\.?\\d*\"\"\")\n    val reA  = Regex(\"\"\"\\d\\+\"\"\")\n\n    while (true) {\n        val match = reMD.find(t)\n        if (match == null) break\n        val exp = match.value\n        val match2 = reM.find(exp)\n        t = if (match2 != null)\n                t.replace(exp, multiply(exp))\n            else\n                t.replace(exp, divide(exp))\n    }\n\n    while (true) {\n        val match = reAS.find(t)\n        if (match == null) break\n        val exp = match.value\n        val match2 = reA.find(exp)\n        t = if (match2 != null)\n                t.replace(exp, add(exp))\n            else\n                t.replace(exp, subtract(exp))\n    }\n\n    return t\n}\n\nfun evalArithmeticExp(s: String): Double {\n    var t = s.replace(Regex(\"\"\"\\s\"\"\"), \"\").replace(\"\"\"^\\+\"\"\", \"\")\n    val rePara = Regex(\"\"\"\\([^()]*\\)\"\"\")\n    while(true) {\n        val match = rePara.find(t)\n        if (match == null) break\n        val exp = match.value\n        t = t.replace(exp, evalExp(exp))\n    }\n    return evalExp(t).toDoubleOrZero()\n}\n\nfun main(arsg: Array<String>) {\n    listOf(\n        \"2+3\",\n        \"2+3/4\",\n        \"2*3-4\",\n        \"2*(3+4)+5/6\",\n        \"2 * (3 + (4 * 5 + (6 * 7) * 8) - 9) * 10\",\n        \"2*-3--4+-0.25\",\n         \"-4 - 3\",\n         \"((((2))))+ 3 * 5\",\n         \"1 + 2 * (3 + (4 * 5 + 6 * 7 * 8) - 9) / 10\",\n         \"1 + 2*(3 - 2*(3 - 2)*((2 - 4)*5 - 22/(7 + 2*(3 - 1)) - 1)) + 1\"\n    ).forEach { println(\"$it = ${evalArithmeticExp(it)}\") }\n}\n"
                }
            ],
            [
                {
                    "language": "E",
                    "solution": "? arithEvaluate(\"1 + 2\")\n# value: 3\n\n? arithEvaluate(\"(1 + 2) * 10 / 100\")\n# value: 0.3\n\n? arithEvaluate(\"(1 + 2 / 2) * (5 + 5)\")\n# value: 20.0\n"
                },
                {
                    "language": "PicoLisp",
                    "solution": ": (ast \"1+2+3*-4/(1+2)\")\n-> (+ (+ 1 2) (/ (* 3 (- 4)) (+ 1 2)))\n\n: (ast \"(1+2+3)*-4/(1+2)\")\n-> (/ (* (+ (+ 1 2) 3) (- 4)) (+ 1 2))\n"
                }
            ],
            [
                {
                    "language": "OCaml",
                    "solution": "let () =\n  while true do\n    print_string \"Expression: \";\n    let str = read_line() in\n    if str = \"q\" then exit 0;\n    let expr = read_expression str in\n    let res = eval expr in\n    Printf.printf \" = %g\\n%!\" res;\n  done\n"
                },
                {
                    "language": "Ruby",
                    "solution": "exp = \"1 + 2 - 3 * (4 / 6)\"\nputs(\"Original: \" + exp)\n\ntree = infix_exp_to_tree(exp)\nputs(\"Prefix: \" + tree.to_s(:prefix))\nputs(\"Infix: \" + tree.to_s(:infix))\nputs(\"Postfix: \" + tree.to_s(:postfix))\nputs(\"Result: \" + tree.eval.to_s)\n"
                }
            ],
            [
                {
                    "language": "11l",
                    "solution": "T Symbol\n   String id\n   Int lbp\n   Int nud_bp\n   Int led_bp\n   (ASTNode -> ASTNode) nud\n   ((ASTNode, ASTNode) -> ASTNode) led\n\n   F set_nud_bp(nud_bp, nud)\n      .nud_bp = nud_bp\n      .nud = nud\n\n   F set_led_bp(led_bp, led)\n      .led_bp = led_bp\n      .led = led\n\nT ASTNode\n   Symbol& symbol\n   Int value\n   ASTNode? first_child\n   ASTNode? second_child\n\n   F eval()\n      S .symbol.id\n         \u2018(number)\u2019\n            R .value\n         \u2018+\u2019\n            R .first_child.eval() + .second_child.eval()\n         \u2018-\u2019\n            R I .second_child == N {-.first_child.eval()} E .first_child.eval() - .second_child.eval()\n         \u2018*\u2019\n            R .first_child.eval() * .second_child.eval()\n         \u2018/\u2019\n            R .first_child.eval() / .second_child.eval()\n         \u2018(\u2019\n            R .first_child.eval()\n         E\n            assert(0B)\n            R 0\n\n[String = Symbol] symbol_table\n[String] tokens\nV tokeni = -1\nASTNode token_node\n\nF advance(sid = \u2018\u2019)\n   I sid != \u2018\u2019\n      assert(:token_node.symbol.id == sid)\n   :tokeni++\n   :token_node = ASTNode()\n   I :tokeni == :tokens.len\n      :token_node.symbol = :symbol_table[\u2018(end)\u2019]\n      R\n   V token = :tokens[:tokeni]\n   :token_node.symbol = :symbol_table[I token.is_digit() {\u2018(number)\u2019} E token]\n   I token.is_digit()\n      :token_node.value = Int(token)\n\nF expression(rbp = 0)\n   ASTNode t = move(:token_node)\n   advance()\n   V left = t.symbol.nud(move(t))\n   L rbp < :token_node.symbol.lbp\n      t = move(:token_node)\n      advance()\n      left = t.symbol.led(t, move(left))\n   R left\n\nF parse(expr_str) -> ASTNode\n   :tokens = re:\u2018\\s*(\\d+|.)\u2019.find_strings(expr_str)\n   :tokeni = -1\n   advance()\n   R expression()\n\nF symbol(id, bp = 0) -> &\n   I !(id C :symbol_table)\n      V s = Symbol()\n      s.id = id\n      s.lbp = bp\n      :symbol_table[id] = s\n   R :symbol_table[id]\n\nF infix(id, bp)\n   F led(ASTNode self, ASTNode left)\n      self.first_child = left\n      self.second_child = expression(self.symbol.led_bp)\n      R self\n   symbol(id, bp).set_led_bp(bp, led)\n\nF prefix(id, bp)\n   F nud(ASTNode self)\n      self.first_child = expression(self.symbol.nud_bp)\n      R self\n   symbol(id).set_nud_bp(bp, nud)\n\ninfix(\u2018+\u2019, 1)\ninfix(\u2018-\u2019, 1)\ninfix(\u2018*\u2019, 2)\ninfix(\u2018/\u2019, 2)\nprefix(\u2018-\u2019, 3)\n\nF nud(ASTNode self)\n   R self\nsymbol(\u2018(number)\u2019).nud = nud\nsymbol(\u2018(end)\u2019)\n\nF nud_parens(ASTNode self)\n   V expr = expression()\n   advance(\u2018)\u2019)\n   R expr\nsymbol(\u2018(\u2019).nud = nud_parens\nsymbol(\u2018)\u2019)\n\nL(expr_str) [\u2018-2 / 2 + 4 + 3 * 2\u2019,\n             \u20182 * (3 + (4 * 5 + (6 * 7) * 8) - 9) * 10\u2019]\n   print(expr_str\u2018 = \u2019parse(expr_str).eval())\n"
                },
                {
                    "language": "Elena",
                    "solution": "import system'routines;\nimport extensions;\nimport extensions'text;\n\nclass Token\n{\n   object _value;\n\n   int Level : rprop;\n\n   constructor new(int level)\n   {\n      _value := new StringWriter();\n      Level := level + 9;\n   }\n\n   append(ch)\n   {\n      _value.write(ch)\n   }\n\n   Number = _value.toReal();\n}\n\nclass Node\n{\n   object Left  : prop;\n   object Right : prop;\n   int Level    : rprop;\n\n   constructor new(int level)\n   {\n      Level := level\n   }\n}\n\nclass SummaryNode : Node\n{\n   constructor new(int level)\n      <= super new(level + 1);\n\n   Number = Left.Number + Right.Number;\n}\n\nclass DifferenceNode : Node\n{\n   constructor new(int level)\n      <= super new(level + 1);\n\n   Number = Left.Number - Right.Number;\n}\n\nclass ProductNode : Node\n{\n   constructor new(int level)\n      <= super new(level + 2);\n\n   Number = Left.Number * Right.Number;\n}\n\nclass FractionNode : Node\n{\n   constructor new(int level)\n      <= super new(level + 2);\n\n   Number = Left.Number / Right.Number;\n}\n\nclass Expression\n{\n   int Level  :rprop;\n   object Top :prop;\n\n   constructor new(int level)\n   {\n      Level := level\n   }\n\n   object Right\n   {\n      get() = Top;\n\n      set(object node)\n      {\n         Top := node\n      }\n   }\n\n   get Number() => Top;\n}\n\nsingleton operatorState\n{\n   eval(ch)\n   {\n      ch =>\n         $40 {      // (\n            ^ weak self.newBracket().gotoStarting()\n         }\n         ! {\n            ^ weak self.newToken().append(ch).gotoToken()\n         }\n   }\n}\n\nsingleton tokenState\n{\n   eval(ch)\n   {\n      ch =>\n         $41 {      // )\n            ^ weak self.closeBracket().gotoToken()\n         }\n         $42 {      // *\n            ^ weak self.newProduct().gotoOperator()\n         }\n         $43 {      // +\n            ^ weak self.newSummary().gotoOperator()\n         }\n         $45 {      // -\n            ^ weak self.newDifference().gotoOperator()\n         }\n         $47 {      // /\n            ^ weak self.newFraction().gotoOperator()\n         }\n         ! {\n            ^ weak self.append(ch)\n         }\n   }\n}\n\nsingleton startState\n{\n   eval(ch)\n   {\n      ch =>\n         $40 {      // (\n            ^ weak self.newBracket().gotoStarting()\n         }\n         $45 { // -\n            ^ weak self.newToken().append(\"0\").newDifference().gotoOperator()\n         }\n         ! {\n            ^ weak self.newToken().append(ch).gotoToken()\n         }\n   }\n}\n\nclass Scope\n{\n   object _state;\n   int    _level;\n   object _parser;\n   object _token;\n   object _expression;\n\n   constructor new(parser)\n   {\n      _state := startState;\n      _level := 0;\n      _expression := Expression.new(0);\n      _parser := parser\n   }\n\n   newToken()\n   {\n      _token := _parser.appendToken(_expression, _level)\n   }\n\n   newSummary()\n   {\n      _token := nil;\n\n      _parser.appendSummary(_expression, _level)\n   }\n\n   newDifference()\n   {\n      _token := nil;\n\n      _parser.appendDifference(_expression, _level)\n   }\n\n   newProduct()\n   {\n      _token := nil;\n\n      _parser.appendProduct(_expression, _level)\n   }\n\n   newFraction()\n   {\n      _token := nil;\n\n      _parser.appendFraction(_expression, _level)\n   }\n\n   newBracket()\n   {\n      _token := nil;\n\n      _level := _level + 10;\n\n      _parser.appendSubexpression(_expression, _level)\n   }\n\n   closeBracket()\n   {\n      if (_level < 10)\n         { InvalidArgumentException.new(\"Invalid expression\").raise() };\n\n      _level := _level - 10\n   }\n\n   append(ch)\n   {\n      if(ch >= $48 && ch < $58)\n      {\n         _token.append(ch)\n      }\n      else\n      {\n         InvalidArgumentException.new(\"Invalid expression\").raise()\n      }\n   }\n\n   append(string s)\n   {\n      s.forEach::(ch){ self.append(ch) }\n   }\n\n   gotoStarting()\n   {\n      _state := startState\n   }\n\n   gotoToken()\n   {\n      _state := tokenState\n   }\n\n   gotoOperator()\n   {\n      _state := operatorState\n   }\n\n   get Number() => _expression;\n\n   dispatch() => _state;\n}\n\nclass Parser\n{\n   appendToken(object expression, int level)\n   {\n      var token := Token.new(level);\n\n      expression.Top := self.append(expression.Top, token);\n\n      ^ token\n   }\n\n   appendSummary(object expression, int level)\n   {\n      var t := expression.Top;\n\n      expression.Top := self.append(/*expression.Top*/t, SummaryNode.new(level))\n   }\n\n   appendDifference(object expression, int level)\n   {\n      expression.Top := self.append(expression.Top, DifferenceNode.new(level))\n   }\n\n   appendProduct(object expression, int level)\n   {\n      expression.Top := self.append(expression.Top, ProductNode.new(level))\n   }\n\n   appendFraction(object expression, int level)\n   {\n      expression.Top := self.append(expression.Top, FractionNode.new(level))\n   }\n\n   appendSubexpression(object expression, int level)\n   {\n      expression.Top := self.append(expression.Top, Expression.new(level))\n   }\n\n   append(object lastNode, object newNode)\n   {\n      if(nil == lastNode)\n         { ^ newNode };\n\n      if (newNode.Level <= lastNode.Level)\n         { newNode.Left := lastNode; ^ newNode };\n\n      var parent := lastNode;\n      var current := lastNode.Right;\n      while (nil != current && newNode.Level > current.Level)\n         { parent := current; current := current.Right };\n\n      if (nil == current)\n      {\n         parent.Right := newNode\n      }\n      else\n      {\n         newNode.Left := current; parent.Right := newNode\n      };\n\n      ^ lastNode\n   }\n\n   run(text)\n   {\n      var scope := Scope.new(self);\n\n      text.forEach::(ch){ scope.eval(ch) };\n\n      ^ scope.Number\n   }\n}\n\npublic program()\n{\n   var text := new StringWriter();\n   var parser := new Parser();\n\n   while (console.readLine().writeTo(text).Length > 0)\n   {\n      try\n      {\n         console.printLine(\"=\",parser.run(text))\n      }\n      catch(Exception e)\n      {\n         console.writeLine(\"Invalid Expression\")\n      };\n\n      text.clear()\n   }\n}\n"
                }
            ],
            [
                {
                    "language": "Ruby",
                    "solution": "$op_priority = {\"+\" => 0, \"-\" => 0, \"*\" => 1, \"/\" => 1}\n\nclass TreeNode\n  OP_FUNCTION = {\n    \"+\" => lambda {|x, y| x + y},\n    \"-\" => lambda {|x, y| x - y},\n    \"*\" => lambda {|x, y| x * y},\n    \"/\" => lambda {|x, y| x / y}}\n  attr_accessor :info, :left, :right\n\n  def initialize(info)\n    @info = info\n  end\n\n  def leaf?\n    @left.nil? and @right.nil?\n  end\n\n  def to_s(order)\n    if leaf?\n      @info\n    else\n      left_s, right_s = @left.to_s(order), @right.to_s(order)\n\n      strs = case order\n             when :prefix  then [@info, left_s, right_s]\n             when :infix   then [left_s, @info, right_s]\n             when :postfix then [left_s, right_s, @info]\n             else               []\n             end\n\n      \"(\" + strs.join(\" \") + \")\"\n    end\n  end\n\n  def eval\n    if !leaf? and operator?(@info)\n      OP_FUNCTION[@info].call(@left.eval, @right.eval)\n    else\n      @info.to_f\n    end\n  end\nend\n\ndef tokenize(exp)\n  exp\n    .gsub('(', ' ( ')\n    .gsub(')', ' ) ')\n    .gsub('+', ' + ')\n    .gsub('-', ' - ')\n    .gsub('*', ' * ')\n    .gsub('/', ' / ')\n    .split(' ')\nend\n\ndef operator?(token)\n  $op_priority.has_key?(token)\nend\n\ndef pop_connect_push(op_stack, node_stack)\n  temp = op_stack.pop\n  temp.right = node_stack.pop\n  temp.left = node_stack.pop\n  node_stack.push(temp)\nend\n\ndef infix_exp_to_tree(exp)\n  tokens = tokenize(exp)\n  op_stack, node_stack = [], []\n\n  tokens.each do |token|\n    if operator?(token)\n      # clear stack of higher priority operators\n      until (op_stack.empty? or\n             op_stack.last.info == \"(\" or\n             $op_priority[op_stack.last.info] < $op_priority[token])\n        pop_connect_push(op_stack, node_stack)\n      end\n\n      op_stack.push(TreeNode.new(token))\n    elsif token == \"(\"\n      op_stack.push(TreeNode.new(token))\n    elsif token == \")\"\n      while op_stack.last.info != \"(\"\n        pop_connect_push(op_stack, node_stack)\n      end\n\n      # throw away the '('\n      op_stack.pop\n    else\n      node_stack.push(TreeNode.new(token))\n    end\n  end\n\n  until op_stack.empty?\n    pop_connect_push(op_stack, node_stack)\n  end\n\n  node_stack.last\nend\n"
                },
                {
                    "language": "JavaScript",
                    "solution": "function evalArithmeticExp(s) {\n  s = s.replace(/\\s/g,'').replace(/^\\+/,'');\n  var rePara = /\\([^\\(\\)]*\\)/;\n  var exp = s.match(rePara);\n\n  while (exp = s.match(rePara)) {\n    s = s.replace(exp[0], evalExp(exp[0]));\n  }\n  return evalExp(s);\n\n  function evalExp(s) {\n    s = s.replace(/[\\(\\)]/g,'');\n    var reMD = /\\d+\\.?\\d*\\s*[\\*\\/]\\s*[+-]?\\d+\\.?\\d*/;\n    var reM = /\\*/;\n    var reAS = /-?\\d+\\.?\\d*\\s*[\\+-]\\s*[+-]?\\d+\\.?\\d*/;\n    var reA  = /\\d\\+/;\n    var exp;\n\n    while (exp = s.match(reMD)) {\n      s = exp[0].match(reM)? s.replace(exp[0], multiply(exp[0])) : s.replace(exp[0], divide(exp[0]));\n    }\n\n    while (exp = s.match(reAS)) {\n      s = exp[0].match(reA)? s.replace(exp[0], add(exp[0])) : s.replace(exp[0], subtract(exp[0]));\n    }\n\n    return '' + s;\n\n    function multiply(s, b) {\n      b = s.split('*');\n      return b[0] * b[1];\n    }\n\n    function divide(s, b) {\n      b = s.split('/');\n      return b[0] / b[1];\n    }\n\n    function add(s, b) {\n      s = s.replace(/^\\+/,'').replace(/\\++/,'+');\n      b = s.split('+');\n      return Number(b[0]) + Number(b[1]);\n    }\n\n    function subtract(s, b) {\n      s = s.replace(/\\+-|-\\+/g,'-');\n\n      if (s.match(/--/)) {\n        return add(s.replace(/--/,'+'));\n      }\n      b = s.split('-');\n      return b.length == 3? -1 * b[1] - b[2] : b[0] - b[1];\n    }\n  }\n}\n"
                }
            ]
        ]
    },
    {
        "task_name": "Arithmetic-geometric-mean",
        "task_description": ";Task:\nWrite a function to compute the [[wp:Arithmetic-geometric mean|arithmetic-geometric mean]] of two numbers.\n\n\nThe arithmetic-geometric mean of two numbers can be (usefully) denoted as <math>\\mathrm{agm}(a,g)</math>, and is equal to the limit of the sequence:\n: <math>a_0 = a; \\qquad g_0 = g</math>\n: <math>a_{n+1} = \\tfrac{1}{2}(a_n + g_n); \\quad g_{n+1} = \\sqrt{a_n g_n}.</math>\nSince the limit of <math>a_n-g_n</math> tends (rapidly) to zero with iterations, this is an efficient method.\n\nDemonstrate the function by calculating:\n:<math>\\mathrm{agm}(1,1/\\sqrt{2})</math>\n \n\n;Also see:\n* &nbsp; [http://mathworld.wolfram.com/Arithmetic-GeometricMean.html mathworld.wolfram.com/Arithmetic-Geometric Mean]\n<br><br>\n\n",
        "solution_pairs": [
            [
                {
                    "language": "Oforth",
                    "solution": "1 2 sqrt inv agm\n"
                },
                {
                    "language": "V-(Vlang)",
                    "solution": "import math\n\nconst ep = 1e-14\n\nfn agm(aa f64, gg f64) f64 {\n    mut a, mut g := aa, gg\n    for math.abs(a-g) > math.abs(a)*ep {\n        t := a\n        a, g = (a+g)*.5, math.sqrt(t*g)\n    }\n    return a\n}\n\nfn main() {\n    println(agm(1.0, 1.0/math.sqrt2))\n}\n"
                }
            ],
            [
                {
                    "language": "Craft-Basic",
                    "solution": "let a = 1\nlet g = 1 / sqrt(2)\n\ndo\n\n\tlet t = (a + g) / 2\n\tlet g = sqrt(a * g)\n\tlet x = a\n\tlet a = t\n\tlet t = x\n\nloopuntil a = t\n\nprint a\n"
                },
                {
                    "language": "LLVM",
                    "solution": "; This is not strictly LLVM, as it uses the C library function \"printf\".\n; LLVM does not provide a way to print values, so the alternative would be\n; to just load the string into memory, and that would be boring.\n\n; Additional comments have been inserted, as well as changes made from the output produced by clang such as putting more meaningful labels for the jumps\n\n$\"ASSERTION\" = comdat any\n$\"OUTPUT\" = comdat any\n\n@\"ASSERTION\" = linkonce_odr unnamed_addr constant [48 x i8] c\"arithmetic-geometric mean undefined when x*y<0\\0A\\00\", comdat, align 1\n@\"OUTPUT\" = linkonce_odr unnamed_addr constant [42 x i8] c\"The arithmetic-geometric mean is %0.19lf\\0A\\00\", comdat, align 1\n\n;--- The declarations for the external C functions\ndeclare i32 @printf(i8*, ...)\ndeclare void @exit(i32) #1\ndeclare double @sqrt(double) #1\n\ndeclare double @llvm.fabs.f64(double) #2\n\n;----------------------------------------------------------------\n;-- arithmetic geometric mean\ndefine double @agm(double, double) #0 {\n    %3 = alloca double, align 8                     ; allocate local g\n    %4 = alloca double, align 8                     ; allocate local a\n    %5 = alloca double, align 8                     ; allocate iota\n    %6 = alloca double, align 8                     ; allocate a1\n    %7 = alloca double, align 8                     ; allocate g1\n    store double %1, double* %3, align 8            ; store param g in local g\n    store double %0, double* %4, align 8            ; store param a in local a\n    store double 1.000000e-15, double* %5, align 8  ; store 1.0e-15 in iota (1.0e-16 was causing the program to hang)\n\n    %8 = load double, double* %4, align 8           ; load a\n    %9 = load double, double* %3, align 8           ; load g\n    %10 = fmul double %8, %9                        ; a * g\n    %11 = fcmp olt double %10, 0.000000e+00         ; a * g < 0.0\n    br i1 %11, label %enforce, label %loop\n\nenforce:\n    %12 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([48 x i8], [48 x i8]* @\"ASSERTION\", i32 0, i32 0))\n    call void @exit(i32 1) #6\n    unreachable\n\nloop:\n    %13 = load double, double* %4, align 8          ; load a\n    %14 = load double, double* %3, align 8          ; load g\n    %15 = fsub double %13, %14                      ; a - g\n    %16 = call double @llvm.fabs.f64(double %15)    ; fabs(a - g)\n    %17 = load double, double* %5, align 8          ; load iota\n    %18 = fcmp ogt double %16, %17                  ; fabs(a - g) > iota\n    br i1 %18, label %loop_body, label %eom\n\nloop_body:\n    %19 = load double, double* %4, align 8          ; load a\n    %20 = load double, double* %3, align 8          ; load g\n    %21 = fadd double %19, %20                      ; a + g\n    %22 = fdiv double %21, 2.000000e+00             ; (a + g) / 2.0\n    store double %22, double* %6, align 8           ; store %22 in a1\n\n    %23 = load double, double* %4, align 8          ; load a\n    %24 = load double, double* %3, align 8          ; load g\n    %25 = fmul double %23, %24                      ; a * g\n    %26 = call double @sqrt(double %25) #4          ; sqrt(a * g)\n    store double %26, double* %7, align 8           ; store %26 in g1\n\n    %27 = load double, double* %6, align 8          ; load a1\n    store double %27, double* %4, align 8           ; store a1 in a\n\n    %28 = load double, double* %7, align 8          ; load g1\n    store double %28, double* %3, align 8           ; store g1 in g\n\n    br label %loop\n\neom:\n    %29 = load double, double* %4, align 8          ; load a\n    ret double %29                                  ; return a\n}\n\n;----------------------------------------------------------------\n;-- main\ndefine i32 @main() #0 {\n    %1 = alloca double, align 8                     ; allocate x\n    %2 = alloca double, align 8                     ; allocate y\n\n    store double 1.000000e+00, double* %1, align 8  ; store 1.0 in x\n\n    %3 = call double @sqrt(double 2.000000e+00) #4  ; calculate the square root of two\n    %4 = fdiv double 1.000000e+00, %3               ; divide 1.0 by %3\n    store double %4, double* %2, align 8            ; store %4 in y\n\n    %5 = load double, double* %2, align 8           ; reload y\n    %6 = load double, double* %1, align 8           ; reload x\n    %7 = call double @agm(double %6, double %5)     ; agm(x, y)\n\n    %8 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([42 x i8], [42 x i8]* @\"OUTPUT\", i32 0, i32 0), double %7)\n\n    ret i32 0                                       ; finished\n}\n\nattributes #0 = { noinline nounwind optnone uwtable \"correctly-rounded-divide-sqrt-fp-math\"=\"false\" \"disable-tail-calls\"=\"false\" \"less-precise-fpmad\"=\"false\" \"no-frame-pointer-elim\"=\"false\" \"no-infs-fp-math\"=\"false\" \"no-jump-tables\"=\"false\" \"no-nans-fp-math\"=\"false\" \"no-signed-zeros-fp-math\"=\"false\" \"no-trapping-math\"=\"false\" \"stack-protector-buffer-size\"=\"8\" \"target-cpu\"=\"x86-64\" \"target-features\"=\"+fxsr,+mmx,+sse,+sse2,+x87\" \"unsafe-fp-math\"=\"false\" \"use-soft-float\"=\"false\" }\nattributes #1 = { noreturn \"correctly-rounded-divide-sqrt-fp-math\"=\"false\" \"disable-tail-calls\"=\"false\" \"less-precise-fpmad\"=\"false\" \"no-frame-pointer-elim\"=\"false\" \"no-infs-fp-math\"=\"false\" \"no-nans-fp-math\"=\"false\" \"no-signed-zeros-fp-math\"=\"false\" \"no-trapping-math\"=\"false\" \"stack-protector-buffer-size\"=\"8\" \"target-cpu\"=\"x86-64\" \"target-features\"=\"+fxsr,+mmx,+sse,+sse2,+x87\" \"unsafe-fp-math\"=\"false\" \"use-soft-float\"=\"false\" }\nattributes #2 = { nounwind readnone speculatable }\nattributes #4 = { nounwind }\nattributes #6 = { noreturn }\n"
                }
            ],
            [
                {
                    "language": "LFE",
                    "solution": "(defun agm (a g)\n  (agm a g 1.0e-15))\n\n(defun agm (a g tol)\n  (if (=< (- a g) tol)\n    a\n    (agm (next-a a g)\n         (next-g a g)\n         tol)))\n\n(defun next-a (a g)\n  (/ (+ a g) 2))\n\n(defun next-g (a g)\n  (math:sqrt (* a g)))\n"
                },
                {
                    "language": "Go",
                    "solution": "package main\n\nimport (\n    \"fmt\"\n    \"math\"\n)\n\nconst \u03b5 = 1e-14\n\nfunc agm(a, g float64) float64 {\n    for math.Abs(a-g) > math.Abs(a)*\u03b5 {\n        a, g = (a+g)*.5, math.Sqrt(a*g)\n    }\n    return a\n}\n\nfunc main() {\n    fmt.Println(agm(1, 1/math.Sqrt2))\n}\n"
                }
            ],
            [
                {
                    "language": "Haskell",
                    "solution": "-- Return an approximation to the arithmetic-geometric mean of two numbers.\n-- The result is considered accurate when two successive approximations are\n-- sufficiently close, as determined by \"eq\".\nagm :: (Floating a) => a -> a -> ((a, a) -> Bool) -> a\nagm a g eq = snd $ until eq step (a, g)\n  where\n    step (a, g) = ((a + g) / 2, sqrt (a * g))\n\n-- Return the relative difference of the pair.  We assume that at least one of\n-- the values is far enough from 0 to not cause problems.\nrelDiff :: (Fractional a) => (a, a) -> a\nrelDiff (x, y) =\n  let n = abs (x - y)\n      d = (abs x + abs y) / 2\n  in n / d\n\nmain :: IO ()\nmain = do\n  let equal = (< 0.000000001) . relDiff\n  print $ agm 1 (1 / sqrt 2) equal\n"
                },
                {
                    "language": "Wren",
                    "solution": "var eps = 1e-14\n\nvar agm = Fn.new { |a, g|\n    while ((a-g).abs > a.abs * eps) {\n        var t = a\n        a = (a+g)/2\n        g = (t*g).sqrt\n    }\n    return a\n}\n\nSystem.print(agm.call(1, 1/2.sqrt))\n"
                }
            ],
            [
                {
                    "language": "Maple",
                    "solution": "> evalf( GaussAGM( 1, 1 / sqrt( 2 ) ) ); # default precision is 10 digits\n                              0.8472130847\n\n> evalf[100]( GaussAGM( 1, 1 / sqrt( 2 ) ) ); # to 100 digits\n0.847213084793979086606499123482191636481445910326942185060579372659\\\n    7340048341347597232002939946112300\n"
                },
                {
                    "language": "Nim",
                    "solution": "from math import sqrt\nfrom strutils import parseFloat, formatFloat, ffDecimal\n\nproc agm(x,y: float): tuple[resA,resG: float] =\n  var\n    a,g: array[0 .. 23,float]\n\n  a[0] = x\n  g[0] = y\n\n  for n in 1 .. 23:\n    a[n] = 0.5 * (a[n - 1] + g[n - 1])\n    g[n] = sqrt(a[n - 1] * g[n - 1])\n\n  (a[23], g[23])\n\nvar t = agm(1, 1/sqrt(2.0))\n\necho(\"Result A: \" & formatFloat(t.resA, ffDecimal, 24))\necho(\"Result G: \" & formatFloat(t.resG, ffDecimal, 24))\n"
                }
            ]
        ]
    },
    {
        "task_name": "Arithmetic-geometric-mean-Calculate-Pi",
        "task_description": "[http://www.maa.org/sites/default/files/pdf/upload_library/22/Ford/Almkvist-Berndt585-608.pdf Almkvist Berndt 1988] begins with an investigation of why the agm is such an efficient algorithm, and proves that it converges quadratically. This is an efficient method to calculate <math>\\pi</math>.\n\nWith the same notations used in [[Arithmetic-geometric mean]], we can summarize the paper by writing:\n\n<math>\\pi =\n\\frac{4\\; \\mathrm{agm}(1, 1/\\sqrt{2})^2}\n{1 - \\sum\\limits_{n=1}^{\\infty} 2^{n+1}(a_n^2-g_n^2)}\n</math>\n\nThis allows you to make the approximation, for any large &nbsp; '''N''':\n\n<math>\\pi \\approx\n\\frac{4\\; a_N^2}\n{1 - \\sum\\limits_{k=1}^N 2^{k+1}(a_k^2-g_k^2)}\n</math>\n\nThe purpose of this task is to demonstrate how to use this approximation in order to compute a large number of decimals of <math>\\pi</math>.\n\n",
        "solution_pairs": [
            [
                {
                    "language": "Phix",
                    "solution": "(phixonline)-->\n <span style=\"color: #008080;\">with</span> <span style=\"color: #008080;\">javascript_semantics</span>\n <span style=\"color: #7060A8;\">requires</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #008000;\">\"1.0.0\"</span><span style=\"color: #0000FF;\">)</span> <span style=\"color: #000080;font-style:italic;\">-- (mpfr_set_default_prec[ision] has been renamed)</span>\n <span style=\"color: #008080;\">include</span> <span style=\"color: #004080;\">mpfr</span><span style=\"color: #0000FF;\">.</span><span style=\"color: #000000;\">e</span>\n\n <span style=\"color: #7060A8;\">mpfr_set_default_precision</span><span style=\"color: #0000FF;\">(-</span><span style=\"color: #000000;\">200</span><span style=\"color: #0000FF;\">)</span> <span style=\"color: #000080;font-style:italic;\">-- set precision to 200 decimal places</span>\n <span style=\"color: #004080;\">mpfr</span> <span style=\"color: #000000;\">a</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">mpfr_init</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">),</span>\n      <span style=\"color: #000000;\">n</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">mpfr_init</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">),</span>\n      <span style=\"color: #000000;\">g</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">mpfr_init</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">),</span>\n      <span style=\"color: #000000;\">z</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">mpfr_init</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">0.25</span><span style=\"color: #0000FF;\">),</span>\n      <span style=\"color: #000000;\">half</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">mpfr_init</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">0.5</span><span style=\"color: #0000FF;\">),</span>\n      <span style=\"color: #000000;\">x1</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">mpfr_init</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">2</span><span style=\"color: #0000FF;\">),</span>\n      <span style=\"color: #000000;\">x2</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">mpfr_init</span><span style=\"color: #0000FF;\">(),</span>\n      <span style=\"color: #000000;\">v</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">mpfr_init</span><span style=\"color: #0000FF;\">()</span>\n <span style=\"color: #7060A8;\">mpfr_sqrt</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">x1</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">x1</span><span style=\"color: #0000FF;\">)</span>\n <span style=\"color: #7060A8;\">mpfr_div</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">g</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">g</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">x1</span><span style=\"color: #0000FF;\">)</span>    <span style=\"color: #000080;font-style:italic;\">-- g:= 1/sqrt(2)</span>\n <span style=\"color: #004080;\">string</span> <span style=\"color: #000000;\">prev</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #000000;\">curr</span>\n <span style=\"color: #008080;\">for</span> <span style=\"color: #000000;\">i</span><span style=\"color: #0000FF;\">=</span><span style=\"color: #000000;\">1</span> <span style=\"color: #008080;\">to</span> <span style=\"color: #000000;\">18</span> <span style=\"color: #008080;\">do</span>\n     <span style=\"color: #7060A8;\">mpfr_add</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">x1</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">a</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">g</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #7060A8;\">mpfr_mul</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">x1</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">x1</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">half</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #7060A8;\">mpfr_mul</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">x2</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">a</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">g</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #7060A8;\">mpfr_sqrt</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">x2</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">x2</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #7060A8;\">mpfr_sub</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">v</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">x1</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">a</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #7060A8;\">mpfr_mul</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">v</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">v</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">v</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #7060A8;\">mpfr_mul</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">v</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">v</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">n</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #7060A8;\">mpfr_sub</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">z</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">z</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">v</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #7060A8;\">mpfr_add</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">n</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">n</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">n</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #7060A8;\">mpfr_set</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">a</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">x1</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #7060A8;\">mpfr_set</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">g</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">x2</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #7060A8;\">mpfr_mul</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">v</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">a</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">a</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #7060A8;\">mpfr_div</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">v</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">v</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">z</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #000000;\">curr</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">mpfr_get_fixed</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">v</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">200</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #008080;\">if</span> <span style=\"color: #000000;\">i</span><span style=\"color: #0000FF;\">></span><span style=\"color: #000000;\">1</span> <span style=\"color: #008080;\">then</span>\n         <span style=\"color: #008080;\">if</span> <span style=\"color: #000000;\">curr</span><span style=\"color: #0000FF;\">=</span><span style=\"color: #000000;\">prev</span> <span style=\"color: #008080;\">then</span> <span style=\"color: #008080;\">exit</span> <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">if</span>\n         <span style=\"color: #008080;\">for</span> <span style=\"color: #000000;\">j</span><span style=\"color: #0000FF;\">=</span><span style=\"color: #000000;\">3</span> <span style=\"color: #008080;\">to</span> <span style=\"color: #7060A8;\">length</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">curr</span><span style=\"color: #0000FF;\">)</span> <span style=\"color: #008080;\">do</span>\n             <span style=\"color: #008080;\">if</span> <span style=\"color: #000000;\">prev</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">j</span><span style=\"color: #0000FF;\">]!=</span><span style=\"color: #000000;\">curr</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">j</span><span style=\"color: #0000FF;\">]</span> <span style=\"color: #008080;\">then</span>\n                 <span style=\"color: #7060A8;\">printf</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #008000;\">\"iteration %d matches previous to %d places\\n\"</span><span style=\"color: #0000FF;\">,{</span><span style=\"color: #000000;\">i</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">j</span><span style=\"color: #0000FF;\">-</span><span style=\"color: #000000;\">3</span><span style=\"color: #0000FF;\">})</span>\n                 <span style=\"color: #008080;\">exit</span>\n             <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">if</span>\n         <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">for</span>\n     <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">if</span>\n     <span style=\"color: #000000;\">prev</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #000000;\">curr</span>\n <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">for</span>\n <span style=\"color: #008080;\">if</span> <span style=\"color: #000000;\">curr</span><span style=\"color: #0000FF;\">=</span><span style=\"color: #000000;\">prev</span> <span style=\"color: #008080;\">then</span>\n     <span style=\"color: #7060A8;\">printf</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #008000;\">\"identical result to last iteration:\\n%s\\n\"</span><span style=\"color: #0000FF;\">,{</span><span style=\"color: #000000;\">curr</span><span style=\"color: #0000FF;\">})</span>\n <span style=\"color: #008080;\">else</span>\n     <span style=\"color: #7060A8;\">printf</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #008000;\">\"insufficient iterations\\n\"</span><span style=\"color: #0000FF;\">)</span>\n <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">if</span>\n<!--\n"
                },
                {
                    "language": "C-sharp",
                    "solution": "using System;\nusing System.Numerics;\n\nclass AgmPie\n{\n    static BigInteger IntSqRoot(BigInteger valu, BigInteger guess)\n    {\n        BigInteger term; do {\n            term = valu / guess; if (BigInteger.Abs(term - guess) <= 1) break;\n            guess += term; guess >>= 1;\n        } while (true); return guess;\n    }\n\n    static BigInteger ISR(BigInteger term, BigInteger guess)\n    {\n        BigInteger valu = term * guess; do {\n            if (BigInteger.Abs(term - guess) <= 1) break;\n            guess += term; guess >>= 1; term = valu / guess;\n        } while (true); return guess;\n    }\n\n    static BigInteger CalcAGM(BigInteger lam, BigInteger gm, ref BigInteger z,\n                              BigInteger ep)\n    {\n        BigInteger am, zi; ulong n = 1; do {\n            am = (lam + gm) >> 1; gm = ISR(lam, gm);\n            BigInteger v = am - lam; if ((zi = v * v * n) < ep) break;\n            z -= zi; n <<= 1; lam = am;\n        } while (true); return am;\n    }\n\n    static BigInteger BIP(int exp, ulong man = 1)\n    {\n        BigInteger rv = BigInteger.Pow(10, exp); return man == 1 ? rv : man * rv;\n    }\n\n    static void Main(string[] args)\n    {\n        int d = 25000;\n        if (args.Length > 0)\n        {\n            int.TryParse(args[0], out d);\n            if (d < 1 || d > 999999) d = 25000;\n        }\n        DateTime st = DateTime.Now;\n        BigInteger am = BIP(d),\n          gm = IntSqRoot(BIP(d + d - 1, 5),\n                             BIP(d - 15, (ulong)(Math.Sqrt(0.5) * 1e+15))),\n          z = BIP(d + d - 2, 25),\n          agm = CalcAGM(am, gm, ref z, BIP(d + 1)),\n          pi = agm * agm * BIP(d - 2) / z;\n        Console.WriteLine(\"Computation time: {0:0.0000} seconds \",\n                             (DateTime.Now - st).TotalMilliseconds / 1000);\n        string s = pi.ToString();\n        Console.WriteLine(\"{0}.{1}\", s[0], s.Substring(1));\n        if (System.Diagnostics.Debugger.IsAttached) Console.ReadKey();\n    }\n}\n"
                }
            ],
            [
                {
                    "language": "Tcl",
                    "solution": "package require math::bigfloat\nnamespace import math::bigfloat::*\n\nproc agm/\u03c0 {N {precision 8192}} {\n    set 1 [int2float 1 $precision]\n    set 2 [int2float 2 $precision]\n    set n 1\n    set a $1\n    set g [div $1 [sqrt $2]]\n    set z [div $1 [int2float 4 $precision]]\n    for {set i 0} {$i <= $N} {incr i} {\n\tset x0 [div [add $a $g] $2]\n\tset x1 [sqrt [mul $a $g]]\n\tset var [sub $x0 $a]\n\tset z [sub $z [mul [mul $var $n] $var]]\n\tincr n $n\n\tset a $x0\n\tset g $x1\n    }\n    return [tostr [div [mul $a $a] $z]]\n}\n\nputs [agm/\u03c0 17]\n"
                },
                {
                    "language": "FreeBASIC",
                    "solution": "Dim As Short digits = 500\nDim As Double an = 1\nDim As Double bn = Sqr(0.5)\nDim As Double tn = 0.5^2\nDim As Double pn = 1\nDim As Double prevAn\n\nWhile pn <= digits\n    prevAn = an\n    an = (bn + an) / 2\n    bn = Sqr(bn * prevAn)\n    prevAn -= an\n    tn -= (pn * prevAn^2)\n    pn *= 2\nWend\nDim As Double pi = ((an + bn)^2) / (tn * 4)\nPrint pi\n\nSleep\n"
                }
            ],
            [
                {
                    "language": "REXX",
                    "solution": "/*REXX*/\n\nDo d=10 To 13\n  Say d pib(d)\n  End\nDo d=1000 To 1005\n  pi=pib(d)\n  say d left(pi,5)'...'substr(pi,997)\n  End\nExit\npib: Procedure\n/* REXX ---------------------------------------------------------------\n* program calculates the value of pi using the  AGM  algorithm.\n* building on top of version 2\n* reformatted, improved, and using 'my own' sqrt\n* 08.07.2014 Walter Pachl\n*--------------------------------------------------------------------*/\n  Parse Arg d .\n  If d=='' Then\n    d=500                           /* D specified?  Then use default.*/\n  Numeric Digits d+5                /* set the numeric digits to D+5. */\n  a=1\n  n=1\n  z=1/4\n  g=sqrt(1/2)                       /* calculate some initial values. */\n  Do j=1 Until a==old\n    old=a                           /* keep calculating until no noise*/\n    x=(a+g)*.5\n    g=sqrt(a*g)                     /* calculate the next set of terms*/\n    z=z-n*(x-a)**2\n    n=n+n\n    a=x\n    End\n  pi=a**2/z\n  Numeric Digits d                  /* set the  numeric digits  to  D */\n  Return pi+0\n\nsqrt: Procedure\n  Parse Arg x\n  xprec=digits()\n  iprec=xprec+10\n  Numeric Digits iprec\n  r0=x\n  r =1\n  Do i=1 By 1 Until r=r0 | (abs(r*r-x)<10**-iprec)\n    r0 = r\n    r  = (r + x/r) / 2\n    End\n  Numeric Digits xprec\n  Return (r+0)\n"
                },
                {
                    "language": "Scala",
                    "solution": "import java.math.MathContext\n\nimport scala.annotation.tailrec\nimport scala.compat.Platform.currentTime\nimport scala.math.BigDecimal\n\nobject Calculate_Pi extends App {\n  val precision = new MathContext(32768 /*65536*/)\n  val (bigZero, bigOne, bigTwo, bigFour) =\n    (BigDecimal(0, precision), BigDecimal(1, precision), BigDecimal(2, precision), BigDecimal(4, precision))\n\n  def bigSqrt(bd: BigDecimal) = {\n    @tailrec\n    def iter(x0: BigDecimal, x1: BigDecimal): BigDecimal =\n      if (x0 == x1) x1 else iter(x1, (bd / x1 + x1) / bigTwo)\n\n    iter(bigZero, BigDecimal(Math.sqrt(bd.toDouble), precision))\n  }\n\n  @tailrec\n  private def loop(a: BigDecimal, g: BigDecimal, sum: BigDecimal, pow: BigDecimal): BigDecimal = {\n    if (a == g) (bigFour * (a * a)) / (bigOne - sum)\n    else {\n      val (_a, _g, _pow) = ((a + g) / bigTwo, bigSqrt(a * g), pow * bigTwo)\n      loop(_a, _g, sum + ((_a * _a - (_g * _g)) * _pow), _pow)\n    }\n  }\n\n  println(precision)\n  val pi = loop(bigOne, bigOne / bigSqrt(bigTwo), bigZero, bigTwo)\n  println(s\"This are ${pi.toString.length - 1} digits of \u00cf\u20ac:\")\n  val lines = pi.toString().sliding(103, 103).mkString(\"\\n\")\n  println(lines)\n\n  println(s\"Successfully completed without errors. [total ${currentTime - executionStart} ms]\")\n}\n"
                }
            ],
            [
                {
                    "language": "C-sharp",
                    "solution": "using System;\nusing System.Numerics;\n\nclass AgmPie\n{\n    static BigInteger IntSqRoot(BigInteger valu, BigInteger guess)\n    {\n        BigInteger term; do {\n            term = valu / guess; if (BigInteger.Abs(term - guess) <= 1) break;\n            guess += term; guess >>= 1;\n        } while (true); return guess;\n    }\n\n    static BigInteger ISR(BigInteger term, BigInteger guess)\n    {\n        BigInteger valu = term * guess; do {\n            if (BigInteger.Abs(term - guess) <= 1) break;\n            guess += term; guess >>= 1; term = valu / guess;\n        } while (true); return guess;\n    }\n\n    static BigInteger CalcAGM(BigInteger lam, BigInteger gm, ref BigInteger z,\n                              BigInteger ep)\n    {\n        BigInteger am, zi; ulong n = 1; do {\n            am = (lam + gm) >> 1; gm = ISR(lam, gm);\n            BigInteger v = am - lam; if ((zi = v * v * n) < ep) break;\n            z -= zi; n <<= 1; lam = am;\n        } while (true); return am;\n    }\n\n    static BigInteger BIP(int exp, ulong man = 1)\n    {\n        BigInteger rv = BigInteger.Pow(10, exp); return man == 1 ? rv : man * rv;\n    }\n\n    static void Main(string[] args)\n    {\n        int d = 25000;\n        if (args.Length > 0)\n        {\n            int.TryParse(args[0], out d);\n            if (d < 1 || d > 999999) d = 25000;\n        }\n        DateTime st = DateTime.Now;\n        BigInteger am = BIP(d),\n          gm = IntSqRoot(BIP(d + d - 1, 5),\n                             BIP(d - 15, (ulong)(Math.Sqrt(0.5) * 1e+15))),\n          z = BIP(d + d - 2, 25),\n          agm = CalcAGM(am, gm, ref z, BIP(d + 1)),\n          pi = agm * agm * BIP(d - 2) / z;\n        Console.WriteLine(\"Computation time: {0:0.0000} seconds \",\n                             (DateTime.Now - st).TotalMilliseconds / 1000);\n        string s = pi.ToString();\n        Console.WriteLine(\"{0}.{1}\", s[0], s.Substring(1));\n        if (System.Diagnostics.Debugger.IsAttached) Console.ReadKey();\n    }\n}\n"
                },
                {
                    "language": "Julia",
                    "solution": "using Printf\n\nagm1step(x, y) = (x + y) / 2, sqrt(x * y)\n\nfunction approx\u03c0step(x, y, z, n::Integer)\n    a, g = agm1step(x, y)\n    k = n + 1\n    s = z + 2 ^ (k + 1) * (a ^ 2 - g ^ 2)\n    return a, g, s, k\nend\n\napprox\u03c0(a, g, s) = 4a ^ 2 / (1 - s)\n\nfunction testmakepi()\n\tsetprecision(512)\n\ta, g, s, k = BigFloat(1.0), 1 / \u221aBigFloat(2.0), BigFloat(0.0), 0\n\told\u03c0 = BigFloat(0.0)\n\tprintln(\"Approximating \u03c0 using \", precision(BigFloat), \"-bit floats.\")\n\tprintln(\"   k     Error  Result\")\n\tfor i in 1:100\n\t\ta, g, s, k = approx\u03c0step(a, g, s, k)\n\t\test\u03c0 = approx\u03c0(a, g, s)\n\t\tif abs(est\u03c0 - old\u03c0) < 2eps(est\u03c0) break end\n\t\told\u03c0 = est\u03c0\n\t\terr = abs(\u03c0 - est\u03c0)\n\t\t@printf(\"%4d%10.1e%68.60e\\n\", i, err, est\u03c0)\n\tend\nend\n\ntestmakepi()\n"
                }
            ],
            [
                {
                    "language": "Raku",
                    "solution": "constant number-of-decimals = 100;\n\nmulti sqrt(Int $n) {\n  (10**($n.chars div 2), { ($_ + $n div $_) div 2 } ... * == *).tail\n}\n\nmulti sqrt(FatRat $r --> FatRat) {\n  return FatRat.new:\n    sqrt($r.numerator * 10**(number-of-decimals*2) div $r.denominator),\n    10**number-of-decimals;\n}\n\nmy FatRat ($a, $n) = 1.FatRat xx 2;\nmy FatRat $g = sqrt(1/2.FatRat);\nmy $z = .25;\n\nfor ^10 {\n  given [ ($a + $g)/2, sqrt($a * $g) ] {\n    $z -= (.[0] - $a)**2 * $n;\n    $n += $n;\n    ($a, $g) = @$_;\n    say ($a ** 2 / $z).substr: 0, 2 + number-of-decimals;\n  }\n}\n"
                },
                {
                    "language": "D",
                    "solution": "import std.bigint;\nimport std.conv;\nimport std.math;\nimport std.stdio;\n\nBigInt IntSqRoot(BigInt value, BigInt guess) {\n    BigInt term;\n    do {\n        term = value / guess;\n        auto temp = term - guess;\n        if (temp < 0) {\n            temp = -temp;\n        }\n        if (temp <= 1) {\n            break;\n        }\n        guess += term;\n        guess >>= 1;\n        term = value / guess;\n    } while (true);\n    return guess;\n}\n\nBigInt ISR(BigInt term, BigInt guess) {\n    BigInt value = term * guess;\n    do {\n        auto temp = term - guess;\n        if (temp < 0) {\n            temp = -temp;\n        }\n        if (temp <= 1) {\n            break;\n        }\n        guess += term;\n        guess >>= 1;\n        term = value / guess;\n    } while (true);\n    return guess;\n}\n\nBigInt CalcAGM(BigInt lam, BigInt gm, ref BigInt z, BigInt ep) {\n    BigInt am, zi;\n    ulong n = 1;\n    do {\n        am = (lam + gm) >> 1;\n        gm = ISR(lam, gm);\n        BigInt v = am - lam;\n        if ((zi = v * v * n) < ep) {\n            break;\n        }\n        z -= zi;\n        n <<= 1;\n        lam = am;\n    } while(true);\n    return am;\n}\n\nBigInt BIP(int exp, ulong man = 1) {\n    BigInt rv = BigInt(10) ^^ exp;\n    return man == 1 ? rv : man * rv;\n}\n\nvoid main() {\n    int d = 25000;\n    // ignore setting d from commandline for now\n    BigInt am = BIP(d);\n    BigInt gm = IntSqRoot(BIP(d + d - 1, 5), BIP(d - 15, cast(ulong)(sqrt(0.5) * 1e15)));\n    BigInt z = BIP(d + d - 2, 25);\n    BigInt agm = CalcAGM(am, gm, z, BIP(d + 1));\n    BigInt pi = agm * agm * BIP(d - 2) / z;\n\n    string piStr = to!string(pi);\n    writeln(piStr[0], '.', piStr[1..$]);\n}\n"
                }
            ]
        ]
    },
    {
        "task_name": "Arithmetic-Integer",
        "task_description": "{{basic data operation}} \n;Task:\nGet two integers from the user, &nbsp;  and then (for those two integers), display their:\n::::* &nbsp; sum \n::::* &nbsp; difference \n::::* &nbsp; product \n::::* &nbsp; integer quotient\n::::* &nbsp; remainder \n::::* &nbsp; exponentiation &nbsp; (if the operator exists) \n\n<br>\nDon't include error handling. \n\nFor quotient, indicate how it rounds &nbsp; (e.g. towards zero, towards negative infinity, etc.). \n\nFor remainder, indicate whether its sign matches the sign of the first operand or of the second operand, if they are different.\n<br><br>\n\nBonus: Include an example of the integer `divmod` operator. For example: as in [[#Haskell]], [[#Python]] and [[#ALGOL 68]]\n\n",
        "solution_pairs": [
            [
                {
                    "language": "LiveCode",
                    "solution": "-2,4  - power:16,product:-8,quotient:0,remainder:-2,sum:2\n2,-4  - power:0.0625,product:-8,quotient:0,remainder:2,sum:-2\n-2,-4 - power:0.0625,product:8,quotient:0,remainder:-2,sum:-6\n2,4   - power:16,product:8,quotient:0,remainder:2,sum:6\n11,4  - power:14641,product:44,quotient:2,remainder:3,sum:15\n"
                },
                {
                    "language": "Component-Pascal",
                    "solution": "MODULE Arithmetic;\nIMPORT StdLog,DevCommanders,TextMappers;\n\nPROCEDURE DoArithmetic(x,y: INTEGER);\nBEGIN\n        StdLog.String(\"x + y >\");StdLog.Int(x + y);StdLog.Ln;\n        StdLog.String(\"x - y >\");StdLog.Int(x - y);StdLog.Ln;\n        StdLog.String(\"x * y >\");StdLog.Int(x * y);StdLog.Ln;\n        StdLog.String(\"x / y >\");StdLog.Int(x DIV y);StdLog.Ln;\n        StdLog.String(\"x MOD y >\");StdLog.Int(x MOD y);StdLog.Ln;\nEND DoArithmetic;\n\nPROCEDURE Go*;\nVAR\n                params: DevCommanders.Par;\n                s: TextMappers.Scanner;\n                p : ARRAY 2 OF INTEGER;\n                current: INTEGER;\nBEGIN\n        current := 0;\n        params := DevCommanders.par;\n        s.ConnectTo(params.text);\n        s.SetPos(params.beg);\n        s.Scan;\n        WHILE(~s.rider.eot) DO\n                IF (s.type = TextMappers.int) THEN\n                        p[current] := s.int; INC(current);\n                END;\n                s.Scan;\n        END;\n        IF current = 2 THEN DoArithmetic(p[0],p[1]) END;\nEND Go;\nEND Arithmetic.\n"
                }
            ],
            [
                {
                    "language": "TUSCRIPT",
                    "solution": "$$ MODE TUSCRIPT\na=5\nb=3\nc=a+b\nc=a-b\nc=a*b\nc=a/b\nc=a%b\n"
                },
                {
                    "language": "Perl",
                    "solution": "my $a = <>;\nmy $b = <>;\n\nprint\n    \"sum:              \", $a + $b, \"\\n\",\n    \"difference:       \", $a - $b, \"\\n\",\n    \"product:          \", $a * $b, \"\\n\",\n    \"integer quotient: \", int($a / $b), \"\\n\",\n    \"remainder:        \", $a % $b, \"\\n\",\n    \"exponent:         \", $a ** $b, \"\\n\"\n    ;\n"
                }
            ],
            [
                {
                    "language": "Min",
                    "solution": "('+ '- '* 'div 'mod)\n((\"Enter an integer\" ask integer) 2 times) quote-map =>\n(\"$1 -> $2\" rollup concat dup -> quote prepend %) prepend\nmap \"\\n\" join puts!\n"
                },
                {
                    "language": "Prolog",
                    "solution": "print_expression_and_result(M, N, Operator) :-\n    Expression =.. [Operator, M, N],\n    Result is Expression,\n    format('~w ~8|is ~d~n', [Expression, Result]).\n\narithmetic_integer :-\n    read(M),\n    read(N),\n    maplist( print_expression_and_result(M, N), [+,-,*,//,rem,^] ).\n"
                }
            ],
            [
                {
                    "language": "Vedit-macro-language",
                    "solution": "#1 = Get_Num(\"Give number a: \")\n#2 = Get_Num(\"Give number b: \")\nMessage(\"a + b = \") Num_Type(#1 + #2)\nMessage(\"a - b = \") Num_Type(#1 - #2)\nMessage(\"a * b = \") Num_Type(#1 * #2)\nMessage(\"a / b = \") Num_Type(#1 / #2)\nMessage(\"a % b = \") Num_Type(#1 % #2)\n"
                },
                {
                    "language": "Tcl",
                    "solution": "puts \"Please enter two numbers:\"\n\nset x [expr {int([gets stdin])}]; # Force integer interpretation\nset y [expr {int([gets stdin])}]; # Force integer interpretation\n\nputs \"$x + $y = [expr {$x + $y}]\"\nputs \"$x - $y = [expr {$x - $y}]\"\nputs \"$x * $y = [expr {$x * $y}]\"\nputs \"$x / $y = [expr {$x / $y}]\"\nputs \"$x mod $y = [expr {$x % $y}]\"\nputs \"$x 'to the' $y = [expr {$x ** $y}]\"\n"
                }
            ],
            [
                {
                    "language": "Perl",
                    "solution": "my $a = <>;\nmy $b = <>;\n\nprint\n    \"sum:              \", $a + $b, \"\\n\",\n    \"difference:       \", $a - $b, \"\\n\",\n    \"product:          \", $a * $b, \"\\n\",\n    \"integer quotient: \", int($a / $b), \"\\n\",\n    \"remainder:        \", $a % $b, \"\\n\",\n    \"exponent:         \", $a ** $b, \"\\n\"\n    ;\n"
                },
                {
                    "language": "BaCon",
                    "solution": "' Arthimetic/Integer\nDECLARE a%, b%\nINPUT \"Enter integer A: \", a%\nINPUT \"Enter integer B: \", b%\nPRINT\n\nPRINT a%, \" + \", b%, \"     is \", a% + b%\nPRINT a%, \" - \", b%, \"     is \", a% - b%\nPRINT a%, \" * \", b%, \"     is \", a% * b%\nPRINT a%, \" / \", b%, \"     is \", a% / b%, \", trucation toward zero\"\nPRINT \"MOD(\", a%, \", \", b%, \") is \", MOD(a%, b%), \", same sign as first operand\"\nPRINT \"POW(\", a%, \", \", b%, \") is \", INT(POW(a%, b%))\n"
                }
            ]
        ]
    },
    {
        "task_name": "Arithmetic-numbers",
        "task_description": ";Definition\nA positive integer '''n''' is an arithmetic number if the average of its positive divisors is also an integer.\n\nClearly all odd primes '''p''' must be arithmetic numbers because their only divisors are '''1''' and '''p''' whose sum is even and hence their average must be an integer. However, the prime number '''2''' is not an arithmetic number because the average of its divisors is 1.5.\n\n;Example\n30 is an arithmetic number because its 7 divisors are: [1, 2, 3, 5, 6, 10, 15, 30], their sum is 72 and average 9 which is an integer. \n\n;Task\nCalculate and show here:\n\n1. The first 100 arithmetic numbers.\n\n2. The '''x'''th arithmetic number where '''x''' = 1,000 and '''x''' = 10,000.\n\n3. How many of the first '''x''' arithmetic numbers are composite.\n\nNote that, technically, the arithmetic number '''1''' is neither prime nor composite.\n\n;Stretch\nCarry out the same exercise in 2. and 3. above for '''x''' = 100,000 and '''x''' = 1,000,000.\n\n;References\n\n* [[wp:Arithmetic_number|Wikipedia: Arithmetic number]]\n* [[oeis:A003601|OEIS:A003601 - Numbers n such that the average of the divisors of n is an integer]]\n<br><br>\n\n\n",
        "solution_pairs": [
            [
                {
                    "language": "ARM-Assembly",
                    "solution": "/* ARM assembly Raspberry PI  */\n/* program arithnumber.s   */\n\n/************************************/\n/* Constantes                       */\n/************************************/\n/* for this file see task include a file in language ARM assembly*/\n.include \"../constantes.inc\"\n\n.equ NBDIVISORS,             2000\n\n//.include \"../../ficmacros32.inc\"        @ use for developper debugging\n/*******************************************/\n/* Initialized data                        */\n/*******************************************/\n.data\nszMessStartPgm:          .asciz \"Program 32 bits start. \\n\"\nszMessEndPgm:            .asciz \"Program normal end.\\n\"\nszMessErrorArea:         .asciz \"\\033[31mError : area divisors too small.\\n\"\nszMessError:             .asciz \"\\033[31mError  !!!\\n\"\nszMessErrGen:            .asciz \"Error end program.\\n\"\nszMessResultFact:        .asciz \"@ \"\n\nszCarriageReturn:        .asciz \"\\n\"\n\nszMessEntete:            .asciz \"The first 150 arithmetic numbers are:\\n\"\nszMessResult:            .asciz \" @ \"\n\nszMessEntete1:           .asciz \"The 1000 aritmetic number :\"\nszMessEntete2:           .asciz \"The 10000 aritmetic number :\"\nszMessEntete3:           .asciz \"The 100000 aritmetic number :\"\nszMessEntete4:           .asciz \"The 1000000 aritmetic number :\"\nszMessComposite:         .asciz \"Composite number : \"\n/*******************************************/\n/* UnInitialized data                      */\n/*******************************************/\n.bss\n.align 4\nsZoneConv:               .skip 24\ntbZoneDecom:             .skip 4 * NBDIVISORS       // facteur 4 octets\n/*******************************************/\n/*  code section                           */\n/*******************************************/\n.text\n.global main\nmain:                               @ program start\n    ldr r0,iAdrszMessStartPgm       @ display start message\n    bl affichageMess\n\n    ldr r0,iAdrszMessEntete         @ display result message\n    bl affichageMess\n    mov r2,#1                       @ start number\n    mov r3,#0                       @ counter result\n    mov r6,#0                       @ counter result by line\n1:\n    mov r0,r2                       @  number\n    ldr r1,iAdrtbZoneDecom\n    bl testNbArith                  @ test\n    cmp r0,#1                       @ ok ?\n    bne 3f\n    add r3,#1\n    mov r0,r2                       @ number\n    ldr r1,iAdrsZoneConv\n    bl conversion10                 @ convert ascii string\n    ldr r0,iAdrszMessResult\n    ldr r1,iAdrsZoneConv\n    bl strInsertAtCharInc           @ and put in message\n\n    bl affichageMess\n    add r6,r6,#1\n    cmp r6,#6\n    blt 3f\n    mov r6,#0\n    ldr r0,iAdrszCarriageReturn\n    bl affichageMess\n3:\n    add r2,r2,#1\n    cmp r3,#100\n    blt 1b\n    ldr r0,iAdrszCarriageReturn\n    bl affichageMess\n\n    /* count arithmetic number  */\n    mov r2,#1\n    mov r3,#0\n    ldr r5,iN10P4\n    ldr r6,iN10P5\n    ldr r7,iN10P6\n    mov r8,#0                       @ counter composite\n4:\n    mov r0,r2                       @  number\n    ldr r1,iAdrtbZoneDecom\n    bl testNbArith\n    cmp r0,#1\n    bne 6f\n    cmp r1,#1\n    bne 5f\n    add r8,r8,#1\n5:\n    add r3,#1\n6:\n    cmp r3,#1000\n    beq 7f\n    cmp r3,r5                      @ 10000\n    beq 8f\n    cmp r3,r6                      @ 100000\n    beq 9f\n    cmp r3,r7                      @ 1000000\n    beq 10f\n    b 11f\n\n7:\n    ldr r0,iAdrszMessEntete1\n    bl affichageMess\n    mov r0,r2\n    mov r4,r1                        @ save sum\n    ldr r1,iAdrsZoneConv\n    bl conversion10                  @ convert ascii string\n    mov r0,r1\n    bl affichageMess\n    ldr r0,iAdrszMessComposite\n    bl affichageMess\n    mov r0,r8\n    ldr r1,iAdrsZoneConv\n    bl conversion10                  @ convert ascii string\n    mov r0,r1\n    bl affichageMess\n    ldr r0,iAdrszCarriageReturn\n    bl affichageMess\n    b 11f\n8:\n    ldr r0,iAdrszMessEntete2\n    bl affichageMess\n    mov r0,r2\n    mov r4,r1                        @ save sum\n    ldr r1,iAdrsZoneConv\n    bl conversion10                  @ convert ascii string\n    mov r0,r1\n    bl affichageMess\n    ldr r0,iAdrszMessComposite\n    bl affichageMess\n    mov r0,r8\n    ldr r1,iAdrsZoneConv\n    bl conversion10                  @ convert ascii string\n    mov r0,r1\n    bl affichageMess\n    ldr r0,iAdrszCarriageReturn\n    bl affichageMess\n    b 11f\n 9:\n    ldr r0,iAdrszMessEntete3\n    bl affichageMess\n    mov r0,r2\n    mov r4,r1                        @ save sum\n    ldr r1,iAdrsZoneConv\n    bl conversion10                  @ convert ascii string\n    mov r0,r1\n    bl affichageMess\n    ldr r0,iAdrszMessComposite\n    bl affichageMess\n    mov r0,r8\n    ldr r1,iAdrsZoneConv\n    bl conversion10                  @ convert ascii string\n    mov r0,r1\n    bl affichageMess\n    ldr r0,iAdrszCarriageReturn\n    bl affichageMess\n    b 11f\n 10:\n    ldr r0,iAdrszMessEntete4\n    bl affichageMess\n    mov r0,r2\n    mov r4,r1                        @ save sum\n    ldr r1,iAdrsZoneConv\n    bl conversion10                  @ convert ascii string\n    mov r0,r1\n    bl affichageMess\n    ldr r0,iAdrszMessComposite\n    bl affichageMess\n    mov r0,r8\n    ldr r1,iAdrsZoneConv\n    bl conversion10                  @ convert ascii string\n    mov r0,r1\n    bl affichageMess\n    ldr r0,iAdrszCarriageReturn\n    bl affichageMess\n    b 12f\n11:\n    add r2,r2,#1\n    b 4b\n12:\n    ldr r0,iAdrszMessEndPgm         @ display end message\n    bl affichageMess\n    b 100f\n99:                                 @ display error message\n    ldr r0,iAdrszMessError\n    bl affichageMess\n100:                                @ standard end of the program\n    mov r0, #0                      @ return code\n    mov r7, #EXIT                   @ request to exit program\n    svc 0                           @ perform system call\niAdrszMessStartPgm:        .int szMessStartPgm\niAdrszMessEndPgm:          .int szMessEndPgm\niAdrszMessError:           .int szMessError\niAdrszCarriageReturn:      .int szCarriageReturn\niAdrtbZoneDecom:           .int tbZoneDecom\niAdrszMessEntete:          .int szMessEntete\niAdrszMessEntete1:         .int szMessEntete1\niAdrszMessEntete2:         .int szMessEntete2\niAdrszMessEntete3:         .int szMessEntete3\niAdrszMessEntete4:         .int szMessEntete4\niAdrszMessResult:          .int szMessResult\niAdrszMessComposite:       .int szMessComposite\niAdrsZoneConv:             .int sZoneConv\niN10P4:                    .int 10000\niN10P5:                    .int 100000\niN10P6:                    .int 1000000\n\n\n/******************************************************************/\n/*     test if number is aritmetic number                                               */\n/******************************************************************/\n/* r0 contains number */\n/* r1 contains address of divisors area */\n/* r0 return 1 if ok else return 0 */\n/* r1 return 1 if composite */\ntestNbArith:\n    push {r2-r11,lr}             @ save  registers\n    cmp r0,#1                    @ 1 is arithmetique\n    moveq r0,#1\n    moveq r1,#0\n    beq 100f\n    cmp r0,#2                    @ 2 is not aritmetic\n    moveq r0,#0\n    moveq r1,#0\n    beq 100f\n    mov r5,r1\n    mov r8,r0                    @ save number\n    bl isPrime                   @ prime ?\n    cmp r0,#1\n    moveq r0,#1                  @ yes is prime and arithmetic\n    moveq r1,#0                  @ but not composite\n    beq 100f                     @ end\n    mov r1,#1\n    str r1,[r5]                  @ first factor\n    mov r11,#1                   @ divisors sum\n    mov r4,#1                    @ indice divisors table\n    mov r1,#2                    @ first divisor\n    mov r6,#0                    @ previous divisor\n    mov r7,#0                    @ number of same divisors\n1:\n    mov r0,r8                    @ dividende\n    bl division                  @  r1 divisor r2 quotient r3 remainder\n    cmp r3,#0\n    bne 6f                       @ if remainder <> zero  -> no divisor\n    mov r8,r2                    @ else quotient -> new dividende\n    cmp r1,r6                    @ same divisor ?\n    beq 3f                       @ yes\n    mov r7,r4                    @ number factors in table\n    mov r9,#0                    @ indice\n2:                               @ for each new prime factor compute all factors of number\n    ldr r10,[r5,r9,lsl #2 ]      @ load one factor\n    mul r10,r1,r10               @ multiply\n    str r10,[r5,r7,lsl #2]       @ and store in the table\n    add r11,r10                  @ sum of factors\n    add r7,r7,#1                 @ and increment counter\n    add r9,r9,#1                 @ increment index\n    cmp r9,r4                    @ end array factors ?\n    blt 2b\n    mov r4,r7\n    mov r6,r1                    @ new divisor\n    b 7f\n3:                               @ same divisor\n    sub r9,r4,#1\n    mov r7,r4\n4:                               @ for each prime factor compute all factors of number\n    ldr r10,[r5,r9,lsl #2 ]      @ this prime factor is in factor array  ?\n    cmp r10,r1\n    subne r9,#1\n    bne 4b\n    sub r9,r4,r9\n5:\n    ldr r10,[r5,r9,lsl #2 ]\n    mul r10,r1,r10\n    str r10,[r5,r7,lsl #2]       @ and store in the table\n    add r11,r10\n    add r7,r7,#1                 @ and increment counter\n    add r9,r9,#1\n    cmp r9,r4\n    blt 5b\n    mov r4,r7\n    b 7f                         @ and loop\n\n    /* not divisor -> increment next divisor */\n6:\n    cmp r1,#2                    @ if divisor = 2 -> add 1\n    addeq r1,#1\n    addne r1,#2                  @ else add 2\n    b 1b                         @ and loop\n\n    /* divisor -> test if new dividende is prime */\n7:\n    mov r3,r1                    @ save divisor\n    cmp r8,#1                    @ dividende = 1 ? -> end\n    beq 13f\n    mov r0,r8                    @ new dividende is prime ?\n    mov r1,#0\n    bl isPrime                   @ the new dividende is prime ?\n    cmp r0,#1\n    bne 12f                      @ the new dividende is not prime\n\n    cmp r8,r6                    @ else new dividende prime is same divisor ?\n    beq 9f                       @ yes\n                                 @ no -> compute all factors\n    mov r7,r4                    @ number factors in table\n    mov r9,#0                    @ indice\n8:\n    ldr r10,[r5,r9,lsl #2 ]      @ load one factor\n    mul r10,r8,r10               @ multiply\n    str r10,[r5,r7,lsl #2]       @ and store in the table\n    add r11,r10\n    add r7,r7,#1                 @ and increment counter\n    add r9,r9,#1\n    cmp r9,r4\n    blt 8b\n    mov r4,r7\n    mov r7,#0\n    b 13f\n9:\n    sub r9,r4,#1\n    mov r7,r4\n10:\n    ldr r10,[r5,r9,lsl #2 ]\n    cmp r10,r8\n    subne r9,#1\n    bne 10b\n    sub r9,r4,r9\n11:\n    ldr  r10,[r5,r9,lsl #2 ]\n    mul r10,r8,r10\n    str r10,[r5,r7,lsl #2]       @ and store in the table\n    add r11,r10\n    add r7,r7,#1                 @ and increment counter\n    add r9,r9,#1\n    cmp r9,r4\n    blt 11b\n    mov r4,r7\n    b 13f\n\n12:\n    mov r1,r3                    @ current divisor = new divisor\n    cmp r1,r8                    @ current divisor  > new dividende ?\n    ble 1b                       @ no -> loop\n\n    /* end decomposition */\n13:\n    mov r1,r4                    @ control if arithmetic\n    mov r0,r11                   @ compute average\n    bl division\n    mov r1,#1\n    cmp r3,#0                    @ no remainder\n    moveq r0,#1                  @ average is integer\n    beq 100f                     @ no -> end\n    mov r0,#0\n    mov r1,#0\n\n100:\n    pop {r2-r11,pc}              @ restaur registers\n//iAdrszMessNbPrem:           .int szMessNbPrem\n\n/******************************************************************/\n/*     test if number is prime   trial test                       */\n/******************************************************************/\n/* r0 contains the number  */\n/* r0 return 1 if prime else return 0 */\nisPrime:\n    push {r4,lr}                @ save  registers\n    cmp r0,#1                   @ <= 1 ?\n    movls r0,#0                 @ not prime\n    bls 100f\n    cmp r0,#3                   @ 2 and 3 prime\n    movls r0,#1\n    bls 100f\n    tst r0,#1                   @  even ?\n    moveq r0,#0                 @ not prime\n    beq 100f\n    mov r4,r0                   @ save number\n    mov r1,#3                   @ first divisor\n1:\n    mov r0,r4                   @ number\n    bl division\n    add r1,r1,#2                @ increment divisor\n    cmp r3,#0                   @ remainder = zero ?\n    moveq r0,#0                 @ not prime\n    beq 100f\n    cmp r1,r2                   @ divisors<=quotient ?\n    ble 1b                      @ loop\n    mov r0,#1                   @ return prime\n\n100:\n    pop {r4,pc}                 @ restaur registers\n/***************************************************/\n/*      ROUTINES INCLUDE                 */\n/***************************************************/\n/* for this file see task include a file in language ARM assembly*/\n.include \"../affichage.inc\"\n"
                },
                {
                    "language": "Java",
                    "solution": "import java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\npublic final class ArithmeticNumbers {\n\n\tpublic static void main(String[] aArgs) {\n\t\tint arithmeticCount = 0;\n\t\tint compositeCount = 0;\n\t\tint n = 1;\n\t\t\n\t\twhile ( arithmeticCount <= 1_000_000 ) {\n\t\t    Set<Integer> factors = factors(n);\n\t\t    final int sum = factors.stream().mapToInt(Integer::intValue).sum();\n\t\t    if ( sum % factors.size() == 0 ) {\n\t\t        arithmeticCount += 1;\n\t\t        if ( factors.size() > 2 ) {\n\t\t            compositeCount += 1;\n\t\t        }\n\t\t        if ( arithmeticCount <= 100 ) {\n\t\t        \tSystem.out.print(String.format(\"%3d%s\", n, ( arithmeticCount % 10 == 0 ) ? \"\\n\" : \" \"));\n\t\t        }\n\t\t        if ( List.of( 1_000, 10_000, 100_000, 1_000_000 ).contains(arithmeticCount) ) {\n\t\t        \tSystem.out.println();\n\t\t            System.out.println(arithmeticCount + \"th arithmetic number is \" + n);\n\t\t            System.out.println(\"Number of composite arithmetic numbers <= \" + n + \": \" + compositeCount);\n\t\t        }\n\t\t    }\n\t\t    n += 1;\n\t\t}\n\t}\n\t\n\tprivate static Set<Integer> factors(int aNumber) {\n\t\tSet<Integer> result = Stream.of(1, aNumber).collect(Collectors.toCollection(HashSet::new));\n\t    int i = 2;\n\t    int j;\n\t    while ( ( j = aNumber / i ) >= i ) {\n\t        if ( i * j == aNumber ) {\n\t            result.add(i);\n\t            result.add(j);\n\t        }\n\t        i += 1;\n\t    }\n\t    return result;\n\t}\n\n}\n"
                }
            ],
            [
                {
                    "language": "VBScript",
                    "solution": "'arithmetic numbers\n'run with CScript\n\nfunction isarit_compo(i)\n     cnt=0\n     sum=0\n     for j=1 to sqr(i)\n       if (i mod j)=0 then\n          k=i\\j\n\n         if k=j then\n            cnt=cnt+1:sum=sum+j\n         else\n            cnt=cnt+2:sum=sum+j+k\n         end if\n       end if\n     next\n   avg= sum/cnt\n   isarit_compo= array((fix(avg)=avg),-(cnt>2))\nend function\n\nfunction rpad(a,n) rpad=right(space(n)&a,n) :end function\n\ndim s1\nsub print(s)\n  s1=s1& rpad(s,4)\n  if len(s1)=40 then wscript.stdout.writeline s1:s1=\"\"\nend sub\n\n'main program\ncntr=0\ncntcompo=0\ni=1\nwscript.stdout.writeline \"the first 100 arithmetic numbers are:\"\ndo\n  a=isarit_compo(i)\n  if a(0) then\n    cntcompo=cntcompo+a(1)\n    cntr=cntr+1\n    if cntr<=100 then print i\n    if cntr=1000 then wscript.stdout.writeline vbcrlf&\"1000th   : \"&rpad(i,6) & \" nr composites \" &rpad(cntcompo,6)\n    if cntr=10000 then wscript.stdout.writeline vbcrlf& \"10000th  : \"&rpad(i,6) & \" nr composites \" &rpad(cntcompo,6)\n    if cntr=100000 then wscript.stdout.writeline vbcrlf &\"100000th : \"&rpad(i,6) & \" nr composites \" &rpad(cntcompo,6):exit do\n  end if\n  i=i+1\nloop\n"
                },
                {
                    "language": "Pascal",
                    "solution": "program ArithmeiticNumbers;\n\nprocedure ArithmeticNumbers;\nvar N, ArithCnt, CompCnt, DDiv: longint;\nvar DivCnt, Sum, Quot, Rem: longint;\nbegin\nN:= 1;  ArithCnt:= 0;  CompCnt:= 0;\nrepeat\n\tbegin\n\tDDiv:= 1;  DivCnt:= 0;  Sum:= 0;\n\twhile true do\n\t\tbegin\n\t\tQuot:= N div DDiv;\n\t\tRem:=N mod DDiv;\n\t\tif Quot < DDiv then break;\n\t\tif (Quot = DDiv) and (Rem = 0) then //N is a square\n\t\t\tbegin\n\t\t\tSum:= Sum+Quot;\n\t\t\tDivCnt:= DivCnt+1;\n\t\t\tbreak;\n\t\t\tend;\n\t\tif Rem = 0 then\n\t\t\tbegin\n\t\t\tSum:= Sum + DDiv + Quot;\n\t\t\tDivCnt:= DivCnt+2;\n\t\t\tend;\n\t\tDDiv:= DDiv+1;\n\t\tend;\n\tif (Sum mod DivCnt) = 0 then //N is arithmetic\n\t\tbegin\n\t\tArithCnt:= ArithCnt+1;\n\t\tif ArithCnt <= 100 then\n\t\t\tbegin\n\t\t\tWrite(N:4);\n\t\t\tif (ArithCnt mod 20) = 0 then WriteLn;\n\t\t\tend;\n\t\tif DivCnt > 2 then CompCnt:= CompCnt+1;\n\t\tcase ArithCnt of 1000, 10000, 100000, 1000000:\n\t\t\tbegin\n\t\t\tWriteln;\n\t\t\tWrite(N, #9 {tab} );\n\t\t\tWrite(CompCnt);\n\t\t\tend;\n\t \t end;\n\t \tend;\n        N:= N+1;\n        end\nuntil   ArithCnt >= 1000000;\nWriteLn;\nend;\n\nbegin\nArithmeticNumbers;\nWriteLn('Hit Any Key');\n{$IFDEF WINDOWS}ReadLn;{$ENDIF}\nend.\n"
                }
            ],
            [
                {
                    "language": "APL",
                    "solution": "task\u2190{\n    facs   \u2190 \u23780=\u2373|\u22a2\n    aritm  \u2190 (0=\u2262|+/)\u2218facs\n    comp   \u2190 2<(\u2262facs)\n    aritms \u2190 \u2378aritm\u00a8\u237315000\n\n    \u2395\u2190'First 100 arithmetic numbers:'\n    \u2395\u219010 10\u2374aritms\n    {\n        \u2395\u2190''\n        \u2395\u2190'The ',(\u2355\u2375),'th arithmetic number: ',(\u2355aritms[\u2375])\n        ncomps \u2190 +/comp\u00a8\u2375\u2191aritms\n        \u2395\u2190'Of the first ',(\u2355\u2375),' arithmetic numbers, ',(\u2355ncomps),' are composite.'\n    }\u00a810*3 4\n}\n"
                },
                {
                    "language": "J",
                    "solution": "   examples=: 1+I.isArith 1+i.2e6\n   10 10$examples\n  1   3   5   6   7  11  13  14  15  17\n 19  20  21  22  23  27  29  30  31  33\n 35  37  38  39  41  42  43  44  45  46\n 47  49  51  53  54  55  56  57  59  60\n 61  62  65  66  67  68  69  70  71  73\n 77  78  79  83  85  86  87  89  91  92\n 93  94  95  96  97  99 101 102 103 105\n107 109 110 111 113 114 115 116 118 119\n123 125 126 127 129 131 132 133 134 135\n137 138 139 140 141 142 143 145 147 149\n   (1e3-1){examples NB. 0 is first\n1361\n   (1e4-1){examples\n12953\n   +/0=1 p: (1e3 {. examples) -. 1\n782\n   +/0=1 p: (1e4 {. examples) -. 1\n8458\n   +/0=1 p: (1e5 {. examples) -. 1\n88219\n   +/0=1 p: (1e6 {. examples) -. 1\n905043\n"
                }
            ],
            [
                {
                    "language": "VBScript",
                    "solution": "'arithmetic numbers\n'run with CScript\n\nfunction isarit_compo(i)\n     cnt=0\n     sum=0\n     for j=1 to sqr(i)\n       if (i mod j)=0 then\n          k=i\\j\n\n         if k=j then\n            cnt=cnt+1:sum=sum+j\n         else\n            cnt=cnt+2:sum=sum+j+k\n         end if\n       end if\n     next\n   avg= sum/cnt\n   isarit_compo= array((fix(avg)=avg),-(cnt>2))\nend function\n\nfunction rpad(a,n) rpad=right(space(n)&a,n) :end function\n\ndim s1\nsub print(s)\n  s1=s1& rpad(s,4)\n  if len(s1)=40 then wscript.stdout.writeline s1:s1=\"\"\nend sub\n\n'main program\ncntr=0\ncntcompo=0\ni=1\nwscript.stdout.writeline \"the first 100 arithmetic numbers are:\"\ndo\n  a=isarit_compo(i)\n  if a(0) then\n    cntcompo=cntcompo+a(1)\n    cntr=cntr+1\n    if cntr<=100 then print i\n    if cntr=1000 then wscript.stdout.writeline vbcrlf&\"1000th   : \"&rpad(i,6) & \" nr composites \" &rpad(cntcompo,6)\n    if cntr=10000 then wscript.stdout.writeline vbcrlf& \"10000th  : \"&rpad(i,6) & \" nr composites \" &rpad(cntcompo,6)\n    if cntr=100000 then wscript.stdout.writeline vbcrlf &\"100000th : \"&rpad(i,6) & \" nr composites \" &rpad(cntcompo,6):exit do\n  end if\n  i=i+1\nloop\n"
                },
                {
                    "language": "Pascal",
                    "solution": "program ArithmeiticNumbers;\n\nprocedure ArithmeticNumbers;\nvar N, ArithCnt, CompCnt, DDiv: longint;\nvar DivCnt, Sum, Quot, Rem: longint;\nbegin\nN:= 1;  ArithCnt:= 0;  CompCnt:= 0;\nrepeat\n\tbegin\n\tDDiv:= 1;  DivCnt:= 0;  Sum:= 0;\n\twhile true do\n\t\tbegin\n\t\tQuot:= N div DDiv;\n\t\tRem:=N mod DDiv;\n\t\tif Quot < DDiv then break;\n\t\tif (Quot = DDiv) and (Rem = 0) then //N is a square\n\t\t\tbegin\n\t\t\tSum:= Sum+Quot;\n\t\t\tDivCnt:= DivCnt+1;\n\t\t\tbreak;\n\t\t\tend;\n\t\tif Rem = 0 then\n\t\t\tbegin\n\t\t\tSum:= Sum + DDiv + Quot;\n\t\t\tDivCnt:= DivCnt+2;\n\t\t\tend;\n\t\tDDiv:= DDiv+1;\n\t\tend;\n\tif (Sum mod DivCnt) = 0 then //N is arithmetic\n\t\tbegin\n\t\tArithCnt:= ArithCnt+1;\n\t\tif ArithCnt <= 100 then\n\t\t\tbegin\n\t\t\tWrite(N:4);\n\t\t\tif (ArithCnt mod 20) = 0 then WriteLn;\n\t\t\tend;\n\t\tif DivCnt > 2 then CompCnt:= CompCnt+1;\n\t\tcase ArithCnt of 1000, 10000, 100000, 1000000:\n\t\t\tbegin\n\t\t\tWriteln;\n\t\t\tWrite(N, #9 {tab} );\n\t\t\tWrite(CompCnt);\n\t\t\tend;\n\t \t end;\n\t \tend;\n        N:= N+1;\n        end\nuntil   ArithCnt >= 1000000;\nWriteLn;\nend;\n\nbegin\nArithmeticNumbers;\nWriteLn('Hit Any Key');\n{$IFDEF WINDOWS}ReadLn;{$ENDIF}\nend.\n"
                }
            ],
            [
                {
                    "language": "Free-Pascal-Lazarus",
                    "solution": "program ArithmeticNumbers;\n{$OPTIMIZATION ON,ALL}\ntype\n  tPrimeFact = packed record\n                 pfSumOfDivs,\n                 pfRemain  : Uint64;\n                 pfDivCnt  : Uint32;\n                 pfMaxIdx  : Uint32;\n                 pfpotPrimIdx : array[0..9] of word;\n                 pfpotMax  : array[0..11] of byte;//11 instead of 9 for alignment\n               end;\nvar\n  SmallPrimes : array[0..6541] of word;\n\nprocedure InitSmallPrimes;\nvar\n  testPrime,j,p,idx:Uint32;\nbegin\n  SmallPrimes[0] := 2;\n  SmallPrimes[1] := 3;\n  idx := 1;\n  testPrime := 5;\n  repeat\n    For j := 1 to idx do\n    begin\n      p := SmallPrimes[j];\n      if p*p>testPrime then\n        BREAK;\n      if testPrime mod p = 0 then\n      Begin\n        p := 0;\n        BREAK;\n      end;\n    end;\n    if p <> 0 then\n    begin\n      inc(idx);\n      SmallPrimes[idx]:= testPrime;\n    end;\n    inc(testPrime,2);\n  until testPrime >= 65535;\nend;\n\nprocedure smplPrimeDecomp(var PrimeFact:tPrimeFact;n:Uint32);\nvar\n  pr,i,pot,fac,q :NativeUInt;\nBegin\n  with PrimeFact do\n  Begin\n    pfDivCnt := 1;\n    pfSumOfDivs := 1;\n    pfRemain := n;\n    pfMaxIdx := 0;\n    pfpotPrimIdx[0] := 1;\n    pfpotMax[0] := 0;\n\n    i := 0;\n    while i < High(SmallPrimes) do\n    begin\n      pr := SmallPrimes[i];\n      q := n DIV pr;\n      //if n < pr*pr\n      if pr > q then\n         BREAK;\n      if n = pr*q then\n      Begin\n        pfpotPrimIdx[pfMaxIdx] := i;\n        pot := 0;\n        fac := pr;\n        repeat\n          n := q;\n          q := n div pr;\n          pot+=1;\n          fac *= pr;\n        until n <> pr*q;\n        pfpotMax[pfMaxIdx] := pot;\n        pfDivCnt *= pot+1;\n        pfSumOfDivs *= (fac-1)DIV(pr-1);\n        inc(pfMaxIdx);\n      end;\n      inc(i);\n    end;\n    pfRemain := n;\n    if n > 1 then\n    Begin\n      pfDivCnt *= 2;\n      pfSumOfDivs *= n+1\n    end;\n  end;\nend;\n\nfunction IsArithmetic(const PrimeFact:tPrimeFact):boolean;inline;\nbegin\n  with PrimeFact do\n    IsArithmetic := pfSumOfDivs mod pfDivCnt = 0;\nend;\n\nvar\n  pF :TPrimeFact;\n  i,cnt,primeCnt,lmt : Uint32;\nbegin\n  InitSmallPrimes;\n\n  writeln('First 100 arithemetic numbers');\n  cnt := 0;\n  i := 1;\n  repeat\n    smplPrimeDecomp(pF,i);\n    if IsArithmetic(pF) then\n    begin\n      write(i:4);\n      inc(cnt);\n      if cnt MOD 20 =0 then\n        writeln;\n    end;\n    inc(i);\n  until cnt = 100;\n  writeln;\n\n  writeln('   Arithemetic numbers');\n  writeln('   Index   number composite');\n  cnt := 0;\n  primeCnt := 0;\n  lmt := 10;\n  i := 1;\n  repeat\n    smplPrimeDecomp(pF,i);\n    if IsArithmetic(pF) then\n    begin\n      inc(cnt);\n      if pF.pfRemain = i then\n        inc(primeCnt);\n    end;\n    if cnt = lmt then\n    begin\n      writeln(lmt:8,i:9,lmt-primeCnt:10);\n      lmt := lmt*10;\n    end;\n    inc(i);\n  until lmt>1000000;\n  {$IFdef WINDOWS}\n  WriteLn('Hit <ENTER>');ReadLn;\n  {$ENDIF}\nend.\n"
                },
                {
                    "language": "Pascal",
                    "solution": "program ArithmeiticNumbers;\n\nprocedure ArithmeticNumbers;\nvar N, ArithCnt, CompCnt, DDiv: longint;\nvar DivCnt, Sum, Quot, Rem: longint;\nbegin\nN:= 1;  ArithCnt:= 0;  CompCnt:= 0;\nrepeat\n\tbegin\n\tDDiv:= 1;  DivCnt:= 0;  Sum:= 0;\n\twhile true do\n\t\tbegin\n\t\tQuot:= N div DDiv;\n\t\tRem:=N mod DDiv;\n\t\tif Quot < DDiv then break;\n\t\tif (Quot = DDiv) and (Rem = 0) then //N is a square\n\t\t\tbegin\n\t\t\tSum:= Sum+Quot;\n\t\t\tDivCnt:= DivCnt+1;\n\t\t\tbreak;\n\t\t\tend;\n\t\tif Rem = 0 then\n\t\t\tbegin\n\t\t\tSum:= Sum + DDiv + Quot;\n\t\t\tDivCnt:= DivCnt+2;\n\t\t\tend;\n\t\tDDiv:= DDiv+1;\n\t\tend;\n\tif (Sum mod DivCnt) = 0 then //N is arithmetic\n\t\tbegin\n\t\tArithCnt:= ArithCnt+1;\n\t\tif ArithCnt <= 100 then\n\t\t\tbegin\n\t\t\tWrite(N:4);\n\t\t\tif (ArithCnt mod 20) = 0 then WriteLn;\n\t\t\tend;\n\t\tif DivCnt > 2 then CompCnt:= CompCnt+1;\n\t\tcase ArithCnt of 1000, 10000, 100000, 1000000:\n\t\t\tbegin\n\t\t\tWriteln;\n\t\t\tWrite(N, #9 {tab} );\n\t\t\tWrite(CompCnt);\n\t\t\tend;\n\t \t end;\n\t \tend;\n        N:= N+1;\n        end\nuntil   ArithCnt >= 1000000;\nWriteLn;\nend;\n\nbegin\nArithmeticNumbers;\nWriteLn('Hit Any Key');\n{$IFDEF WINDOWS}ReadLn;{$ENDIF}\nend.\n"
                }
            ]
        ]
    },
    {
        "task_name": "Arithmetic-Rational",
        "task_description": ";Task:\nCreate a reasonably complete implementation of rational arithmetic in the particular language using the idioms of the language.\n\n\n;Example:\nDefine a new type called '''frac''' with binary operator \"//\" of two integers that returns a '''structure''' made up of the numerator and the denominator (as per a rational number).\n\nFurther define the appropriate rational unary '''operators''' '''abs''' and '-', with the binary '''operators''' for addition '+', subtraction '-', multiplication '&times;', division '/', integer division '&divide;', modulo division, the comparison operators (e.g. '<', '&le;', '>', & '&ge;') and equality operators (e.g. '=' & '&ne;').\n\nDefine standard coercion '''operators''' for casting '''int''' to '''frac''' etc.\n\nIf space allows, define standard increment and decrement '''operators''' (e.g. '+:=' & '-:=' etc.).\n\nFinally test the operators:\nUse the new type '''frac''' to find all [[Perfect Numbers|perfect numbers]] less than 2<sup>19</sup> by summing the reciprocal of the factors.\n\n\n;Related tasks:\n* &nbsp; [[Perfect Numbers]]\n* &nbsp; [[Check Machin-like formulas]]\n<br><br>\n\n",
        "solution_pairs": [
            [
                {
                    "language": "Zkl",
                    "solution": "class Rational{  // Weenie Rational class, can handle BigInts\n   fcn init(_a,_b){ var a=_a, b=_b; normalize(); }\n   fcn toString{\n      if(b==1) a.toString()\n      else     \"%d//%d\".fmt(a,b)\n   }\n   var [proxy] isZero=fcn{ a==0 };\n   fcn normalize{  // divide a and b by gcd\n      g:= a.gcd(b);\n      a/=g; b/=g;\n      if(b<0){ a=-a; b=-b; } // denominator > 0\n      self\n   }\n   fcn abs       { a=a.abs(); self }\n   fcn __opNegate{ a=-a;      self }\t\t\t    // -Rat\n   fcn __opAdd(n){\n      if(Rational.isChildOf(n)) self(a*n.b + b*n.a, b*n.b); // Rat + Rat\n      else self(b*n + a, b);\t\t\t\t    // Rat + Int\n   }\n   fcn __opSub(n){ self(a*n.b - b*n.a, b*n.b) }\t\t    // Rat - Rat\n   fcn __opMul(n){\n      if(Rational.isChildOf(n)) self(a*n.a, b*n.b);\t    // Rat * Rat\n      else self(a*n, b);\t\t\t\t    // Rat * Int\n   }\n   fcn __opDiv(n){ self(a*n.b,b*n.a) }\t\t\t    // Rat / Rat\n   fcn __opEQ(r){\t\t\t\t       // Rat==Rat, Rat==n\n      if(Rational.isChildOf(r)) a==r.a and b=r.b;\n      else\t\t\tb==1   and a==r;\n   }\n}\n"
                },
                {
                    "language": "Phix",
                    "solution": "(phixonline)-->\n <span style=\"color: #008080;\">include</span> <span style=\"color: #000000;\">builtins</span><span style=\"color: #0000FF;\">/</span><span style=\"color: #004080;\">mpfr</span><span style=\"color: #0000FF;\">.</span><span style=\"color: #000000;\">e</span>\n <span style=\"color: #008080;\">function</span> <span style=\"color: #000000;\">is_perfect</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #004080;\">integer</span> <span style=\"color: #000000;\">num</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #004080;\">mpq</span> <span style=\"color: #000000;\">tot</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">mpq_init</span><span style=\"color: #0000FF;\">(),</span>\n         <span style=\"color: #000000;\">fth</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">mpq_init</span><span style=\"color: #0000FF;\">()</span>\n     <span style=\"color: #004080;\">sequence</span> <span style=\"color: #000000;\">f</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">factors</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">num</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #008080;\">for</span> <span style=\"color: #000000;\">i</span><span style=\"color: #0000FF;\">=</span><span style=\"color: #000000;\">1</span> <span style=\"color: #008080;\">to</span> <span style=\"color: #7060A8;\">length</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">f</span><span style=\"color: #0000FF;\">)</span> <span style=\"color: #008080;\">do</span>\n         <span style=\"color: #7060A8;\">mpq_set_si</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">fth</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">f</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">i</span><span style=\"color: #0000FF;\">])</span>\n         <span style=\"color: #7060A8;\">mpq_add</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">tot</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">tot</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">fth</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">for</span>\n     <span style=\"color: #008080;\">return</span> <span style=\"color: #7060A8;\">mpq_cmp_si</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">tot</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">2</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">)=</span><span style=\"color: #000000;\">0</span>\n <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">function</span>\n\n <span style=\"color: #008080;\">procedure</span> <span style=\"color: #000000;\">get_perfect_numbers</span><span style=\"color: #0000FF;\">()</span>\n     <span style=\"color: #004080;\">atom</span> <span style=\"color: #000000;\">t0</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">time</span><span style=\"color: #0000FF;\">()</span>\n     <span style=\"color: #004080;\">integer</span> <span style=\"color: #000000;\">lim</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">power</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">2</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #008080;\">iff</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #7060A8;\">platform</span><span style=\"color: #0000FF;\">()=</span><span style=\"color: #004600;\">JS</span><span style=\"color: #0000FF;\">?</span><span style=\"color: #000000;\">13</span><span style=\"color: #0000FF;\">:</span><span style=\"color: #000000;\">19</span><span style=\"color: #0000FF;\">))</span>\n     <span style=\"color: #008080;\">for</span> <span style=\"color: #000000;\">i</span><span style=\"color: #0000FF;\">=</span><span style=\"color: #000000;\">2</span> <span style=\"color: #008080;\">to</span> <span style=\"color: #000000;\">lim</span> <span style=\"color: #008080;\">do</span>\n         <span style=\"color: #008080;\">if</span> <span style=\"color: #000000;\">is_perfect</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">i</span><span style=\"color: #0000FF;\">)</span> <span style=\"color: #008080;\">then</span>\n             <span style=\"color: #7060A8;\">printf</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #008000;\">\"perfect: %d\\n\"</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">i</span><span style=\"color: #0000FF;\">)</span>\n         <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">if</span>\n     <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">for</span>\n     <span style=\"color: #7060A8;\">printf</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #008000;\">\"elapsed: %3.2f seconds\\n\"</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #7060A8;\">time</span><span style=\"color: #0000FF;\">()-</span><span style=\"color: #000000;\">t0</span><span style=\"color: #0000FF;\">)</span>\n\n     <span style=\"color: #004080;\">integer</span> <span style=\"color: #000000;\">pn5</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">power</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">2</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">12</span><span style=\"color: #0000FF;\">)*(</span><span style=\"color: #7060A8;\">power</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">2</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">13</span><span style=\"color: #0000FF;\">)-</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">)</span> <span style=\"color: #000080;font-style:italic;\">-- 5th perfect number</span>\n     <span style=\"color: #008080;\">if</span> <span style=\"color: #000000;\">is_perfect</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">pn5</span><span style=\"color: #0000FF;\">)</span> <span style=\"color: #008080;\">then</span>\n         <span style=\"color: #7060A8;\">printf</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #008000;\">\"perfect: %d\\n\"</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">pn5</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">if</span>\n <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">procedure</span>\n\n <span style=\"color: #000000;\">get_perfect_numbers</span><span style=\"color: #0000FF;\">()</span>\n<!--\n"
                }
            ],
            [
                {
                    "language": "Jq",
                    "solution": "# a and b are assumed to be non-zero integers\ndef gcd(a; b):\n  # subfunction expects [a,b] as input\n  # i.e. a ~ .[0] and b ~ .[1]\n  def rgcd: if .[1] == 0 then .[0]\n         else [.[1], .[0] % .[1]] | rgcd\n         end;\n  [a,b] | rgcd;\n\n# To take advantage of gojq's support for accurate integer division:\ndef idivide($j):\n  . as $i\n  | ($i % $j) as $mod\n  | ($i - $mod) / $j ;\n\n# To take advantage of gojq's arbitrary-precision integer arithmetic:\ndef power($b): . as $in | reduce range(0;$b) as $i (1; . * $in);\n\n# $p should be an integer or a rational\n# $q should be a non-zero integer or a rational\n# Output:  a Rational: $p // $q\ndef r($p;$q):\n  def r: if type == \"number\" then {n: ., d: 1} else . end;\n  # The remaining subfunctions assume all args are Rational\n  def n: if .d < 0 then {n: -.n, d: -.d} else . end;\n  def rdiv($a;$b):\n    ($a.d * $b.n) as $denom\n    | if $denom==0 then \"r: division by 0\" | error\n    else r($a.n * $b.d; $denom)\n    end;\n  if $q == 1 and ($p|type) == \"number\" then {n: $p, d: 1}\n  elif $q == 0 then \"r: denominator cannot be 0\" | error\n  else if ($p|type == \"number\") and ($q|type == \"number\")\n       then gcd($p;$q) as $g\n       | {n: ($p/$g), d: ($q/$g)} | n\n       else rdiv($p|r; $q|r)\n       end\n  end;\n\n# Polymorphic (integers and rationals in general)\ndef requal($a; $b):\n  if $a | type == \"number\" and $b | type == \"number\" then $a == $b\n  else r($a;1) == r($b;1)\n  end;\n\n# Input: a Rational\n# Output: a Rational with a denominator that has no more than $digits digits\n# and such that |rBefore - rAfter| < 1/(10|power($digits)\n# where $digits should be a positive integer.\ndef rround($digits):\n  if .d | length > $digits\n  then (10|power($digits)) as $p\n  | .d as $d\n  | r($p * .n | idivide($d); $p)\n  else . end;\n\n# Polymorphic; see also radd/0\ndef radd($a; $b):\n  def r: if type == \"number\" then {n: ., d: 1} else . end;\n    ($a|r) as {n: $na, d: $da}\n  | ($b|r) as {n: $nb, d: $db}\n  | r( ($na * $db) + ($nb * $da); $da * $db );\n\n# Polymorphic; see also rmult/0\ndef rmult($a; $b):\n  def r: if type == \"number\" then {n: ., d: 1} else . end;\n    ($a|r) as {n: $na, d: $da}\n  | ($b|r) as {n: $nb, d: $db}\n  | r( $na * $nb; $da * $db ) ;\n\n# Input: an array of rationals (integers and/or Rationals)\n# Output: a Rational computed using left-associativity\ndef rmult:\n  if length == 0 then r(1;1)\n  elif length == 1 then r(.[0]; 1)  # ensure the result is Rational\n  else .[0] as $first\n  | reduce .[1:][] as $x ($first; rmult(.; $x))\n  end;\n\n# Input: an array of rationals (integers and/or Rationals)\n# Output: a Rational computed using left-associativity\ndef radd:\n  if length == 0 then r(0;1)\n  elif length == 1 then r(.[0]; 1) # ensure the result is Rational\n  else .[0] as $first\n  | reduce .[1:][] as $x ($first; radd(. ; $x))\n  end;\n\ndef rabs: r(.;1) | r(.n|length; .d|length);\n\ndef rminus: r(-1 * .n; .d);\n\ndef rminus($a; $b): radd($a; rmult(-1; $b));\n\n# Note that rinv does not check for division by 0\ndef rinv: r(1; .);\n\ndef rdiv($a; $b): r($a; $b);\n\n# Input: an integer or a Rational, $p\n# Output: $p < $q\ndef rlessthan($q):\n  # lt($b) assumes . and $b have the same sign\n  def lt($b):\n    . as $a\n    | ($a.n * $b.d) < ($b.n * $a.d);\n\n  if $q|type == \"number\" then rlessthan(r($q;1))\n  else if type == \"number\" then r(.;1) else . end\n  | if .n < 0\n    then if ($q.n >= 0) then true\n         else . as $p | ($q|rminus | rlessthan($p|rminus))\n         end\n    else lt($q)\n    end\n  end;\n\ndef rgreaterthan($q):\n  . as $p | $q | rlessthan($p);\n\ndef rlessthanOrEqual($q): requal(.;$q) or rlessthan($q);\ndef rgreaterthanOrEqual($q): requal(.;$q) or rgreaterthan($q);\n\n# Input: non-negative integer or Rational\ndef rsqrt(precision):\n  r(.;1) as $n\n  | (precision + 1) as $digits\n  | def update: rmult( r(1;2); radd(.x; rdiv($n; .x))) | rround($digits);\n\n  | def update: rmult( r(1;2); radd(.x; rdiv($n; .x)));\n\n  r(1; 10|power(precision)) as $p\n  | { x: .}\n  | .root = update\n  | until( rminus(.root; .x) | rabs | rlessthan($p);\n      .x = .root\n      | .root = update )\n  | .root ;\n\n# Use native floats\n# q.v. r_to_decimal(precision)\ndef r_to_decimal: .n / .d;\n\n# Input: a Rational, or {n, d} in general, or an integer.\n# Output: a string representation of the input as a decimal number.\n# If the input is a number, it is simply converted to a string.\n# Otherwise, $precision determines the number of digits after the decimal point,\n# obtained by truncating, but trailing 0s are omitted.\n# Examples assuming $digits is 5:\n#  -0//1 => \"0\"\n#   2//1 => \"2\"\n#   1//2 => \"0.5\"\n#   1//3 => \"0.33333\"\n#   7//9 => \"0.77777\"\n#   1//100 => \"0.01\"\n#  -1//10 => \"-0.1\"\n#   1//1000000 => \"0.\"\ndef r_to_decimal($digits):\n  if .n == 0 # captures the annoying case of -0\n  then \"0\"\n  elif type == \"number\" then tostring\n  elif .d < 0 then {n: -.n, d: -.d}|r_to_decimal($digits)\n  elif .n < 0\n  then \"-\" + ((.n = -.n) | r_to_decimal($digits))\n  else (10|power($digits)) as $p\n  | .d as $d\n  | if $d == 1 then .n|tostring\n    else ($p * .n | idivide($d) | tostring) as $n\n    | ($n|length) as $nlength\n    | (if $nlength > $digits then $n[0:$nlength-$digits] + \".\" + $n[$nlength-$digits:]\n       else \"0.\" + (\"0\"*($digits - $nlength) + $n)\n       end) | sub(\"0+$\";\"\")\n    end\n  end;\n\n# Assume . is an integer or in canonical form\ndef rfloor:\n  if type == \"number\" then r(.;1)\n  elif 0 == .n or (0 < .n and .n < .d) then r(0;1)\n  elif 0 < .n or (.n % .d == 0) then .d as $d | r(.n | idivide($d); 1)\n  else rminus( r( - .n; .d) | rfloor | rminus; 1)\n  end;\n\n# pretty print ala Julia\ndef rpp: \"\\(.n) // \\(.d)\";\n"
                },
                {
                    "language": "Sidef",
                    "solution": "for n in (1 .. 2**19) {\n    var frac = 0\n\n    n.divisors.each {|d|\n        frac += 1/d\n    }\n\n    if (frac.is_int) {\n        say \"Sum of reciprocal divisors of #{n} = #{frac} exactly #{\n            frac == 2 ? '- perfect!' : ''\n        }\"\n    }\n}\n"
                }
            ],
            [
                {
                    "language": "Fortran",
                    "solution": "module module_rational\n\n  implicit none\n  private\n  public :: rational\n  public :: rational_simplify\n  public :: assignment (=)\n  public :: operator (//)\n  public :: operator (+)\n  public :: operator (-)\n  public :: operator (*)\n  public :: operator (/)\n  public :: operator (<)\n  public :: operator (<=)\n  public :: operator (>)\n  public :: operator (>=)\n  public :: operator (==)\n  public :: operator (/=)\n  public :: abs\n  public :: int\n  public :: modulo\n  type rational\n    integer :: numerator\n    integer :: denominator\n  end type rational\n  interface assignment (=)\n    module procedure assign_rational_int, assign_rational_real\n  end interface\n  interface operator (//)\n    module procedure make_rational\n  end interface\n  interface operator (+)\n    module procedure rational_add\n  end interface\n  interface operator (-)\n    module procedure rational_minus, rational_subtract\n  end interface\n  interface operator (*)\n    module procedure rational_multiply\n  end interface\n  interface operator (/)\n    module procedure rational_divide\n  end interface\n  interface operator (<)\n    module procedure rational_lt\n  end interface\n  interface operator (<=)\n    module procedure rational_le\n  end interface\n  interface operator (>)\n    module procedure rational_gt\n  end interface\n  interface operator (>=)\n    module procedure rational_ge\n  end interface\n  interface operator (==)\n    module procedure rational_eq\n  end interface\n  interface operator (/=)\n    module procedure rational_ne\n  end interface\n  interface abs\n    module procedure rational_abs\n  end interface\n  interface int\n    module procedure rational_int\n  end interface\n  interface modulo\n    module procedure rational_modulo\n  end interface\n\ncontains\n\n  recursive function gcd (i, j) result (res)\n    integer, intent (in) :: i\n    integer, intent (in) :: j\n    integer :: res\n    if (j == 0) then\n      res = i\n    else\n      res = gcd (j, modulo (i, j))\n    end if\n  end function gcd\n\n  function rational_simplify (r) result (res)\n    type (rational), intent (in) :: r\n    type (rational) :: res\n    integer :: g\n    g = gcd (r % numerator, r % denominator)\n    res = r % numerator / g // r % denominator / g\n  end function rational_simplify\n\n  function make_rational (numerator, denominator) result (res)\n    integer, intent (in) :: numerator\n    integer, intent (in) :: denominator\n    type (rational) :: res\n    res = rational (numerator, denominator)\n  end function make_rational\n\n  subroutine assign_rational_int (res, i)\n    type (rational), intent (out), volatile :: res\n    integer, intent (in) :: i\n    res = i // 1\n  end subroutine assign_rational_int\n\n  subroutine assign_rational_real (res, x)\n    type (rational), intent(out), volatile :: res\n    real, intent (in) :: x\n    integer :: x_floor\n    real :: x_frac\n    x_floor = floor (x)\n    x_frac = x - x_floor\n    if (x_frac == 0) then\n      res = x_floor // 1\n    else\n      res = (x_floor // 1) + (1 // floor (1 / x_frac))\n    end if\n  end subroutine assign_rational_real\n\n  function rational_add (r, s) result (res)\n    type (rational), intent (in) :: r\n    type (rational), intent (in) :: s\n    type (rational) :: res\n    res = r % numerator * s % denominator + r % denominator * s % numerator // &\n        & r % denominator * s % denominator\n  end function rational_add\n\n  function rational_minus (r) result (res)\n    type (rational), intent (in) :: r\n    type (rational) :: res\n    res = - r % numerator // r % denominator\n  end function rational_minus\n\n  function rational_subtract (r, s) result (res)\n    type (rational), intent (in) :: r\n    type (rational), intent (in) :: s\n    type (rational) :: res\n    res = r % numerator * s % denominator - r % denominator * s % numerator // &\n        & r % denominator * s % denominator\n  end function rational_subtract\n\n  function rational_multiply (r, s) result (res)\n    type (rational), intent (in) :: r\n    type (rational), intent (in) :: s\n    type (rational) :: res\n    res = r % numerator * s % numerator // r % denominator * s % denominator\n  end function rational_multiply\n\n  function rational_divide (r, s) result (res)\n    type (rational), intent (in) :: r\n    type (rational), intent (in) :: s\n    type (rational) :: res\n    res = r % numerator * s % denominator // r % denominator * s % numerator\n  end function rational_divide\n\n  function rational_lt (r, s) result (res)\n    type (rational), intent (in) :: r\n    type (rational), intent (in) :: s\n    type (rational) :: r_simple\n    type (rational) :: s_simple\n    logical :: res\n    r_simple = rational_simplify (r)\n    s_simple = rational_simplify (s)\n    res = r_simple % numerator * s_simple % denominator < &\n        & s_simple % numerator * r_simple % denominator\n  end function rational_lt\n\n  function rational_le (r, s) result (res)\n    type (rational), intent (in) :: r\n    type (rational), intent (in) :: s\n    type (rational) :: r_simple\n    type (rational) :: s_simple\n    logical :: res\n    r_simple = rational_simplify (r)\n    s_simple = rational_simplify (s)\n    res = r_simple % numerator * s_simple % denominator <= &\n        & s_simple % numerator * r_simple % denominator\n  end function rational_le\n\n  function rational_gt (r, s) result (res)\n    type (rational), intent (in) :: r\n    type (rational), intent (in) :: s\n    type (rational) :: r_simple\n    type (rational) :: s_simple\n    logical :: res\n    r_simple = rational_simplify (r)\n    s_simple = rational_simplify (s)\n    res = r_simple % numerator * s_simple % denominator > &\n        & s_simple % numerator * r_simple % denominator\n  end function rational_gt\n\n  function rational_ge (r, s) result (res)\n    type (rational), intent (in) :: r\n    type (rational), intent (in) :: s\n    type (rational) :: r_simple\n    type (rational) :: s_simple\n    logical :: res\n    r_simple = rational_simplify (r)\n    s_simple = rational_simplify (s)\n    res = r_simple % numerator * s_simple % denominator >= &\n        & s_simple % numerator * r_simple % denominator\n  end function rational_ge\n\n  function rational_eq (r, s) result (res)\n    type (rational), intent (in) :: r\n    type (rational), intent (in) :: s\n    logical :: res\n    res = r % numerator * s % denominator == s % numerator * r % denominator\n  end function rational_eq\n\n  function rational_ne (r, s) result (res)\n    type (rational), intent (in) :: r\n    type (rational), intent (in) :: s\n    logical :: res\n    res = r % numerator * s % denominator /= s % numerator * r % denominator\n  end function rational_ne\n\n  function rational_abs (r) result (res)\n    type (rational), intent (in) :: r\n    type (rational) :: res\n    res = sign (r % numerator, r % denominator) // r % denominator\n  end function rational_abs\n\n  function rational_int (r) result (res)\n    type (rational), intent (in) :: r\n    integer :: res\n    res = r % numerator / r % denominator\n  end function rational_int\n\n  function rational_modulo (r) result (res)\n    type (rational), intent (in) :: r\n    integer :: res\n    res = modulo (r % numerator, r % denominator)\n  end function rational_modulo\n\nend module module_rational\n"
                },
                {
                    "language": "Go",
                    "solution": "package main\n\nimport (\n    \"fmt\"\n    \"math\"\n    \"math/big\"\n)\n\nfunc main() {\n    var recip big.Rat\n    max := int64(1 << 19)\n    for candidate := int64(2); candidate < max; candidate++ {\n        sum := big.NewRat(1, candidate)\n        max2 := int64(math.Sqrt(float64(candidate)))\n        for factor := int64(2); factor <= max2; factor++ {\n            if candidate%factor == 0 {\n                sum.Add(sum, recip.SetFrac64(1, factor))\n                if f2 := candidate / factor; f2 != factor {\n                    sum.Add(sum, recip.SetFrac64(1, f2))\n                }\n            }\n        }\n        if sum.Denom().Int64() == 1 {\n            perfectstring := \"\"\n            if sum.Num().Int64() == 1 {\n                perfectstring = \"perfect!\"\n            }\n            fmt.Printf(\"Sum of recipr. factors of %d = %d exactly %s\\n\",\n                candidate, sum.Num().Int64(), perfectstring)\n        }\n    }\n}\n"
                }
            ],
            [
                {
                    "language": "Nim",
                    "solution": "import math\n\nproc `^`[T](base, exp: T): T =\n  var (base, exp) = (base, exp)\n  result = 1\n\n  while exp != 0:\n    if (exp and 1) != 0:\n      result *= base\n    exp = exp shr 1\n    base *= base\n\nproc gcd[T](u, v: T): T =\n  if v != 0:\n    gcd(v, u mod v)\n  else:\n    u.abs\n\nproc lcm[T](a, b: T): T =\n  a div gcd(a, b) * b\n\ntype Rational* = tuple[num, den: int64]\n\nproc fromInt*(x: SomeInteger): Rational =\n  result.num = x\n  result.den = 1\n\nproc frac*(x: var Rational) =\n  let common = gcd(x.num, x.den)\n  x.num = x.num div common\n  x.den = x.den div common\n\nproc `+` *(x, y: Rational): Rational =\n  let common = lcm(x.den, y.den)\n  result.num = common div x.den * x.num + common div y.den * y.num\n  result.den = common\n  result.frac\n\nproc `+=` *(x: var Rational, y: Rational) =\n  let common = lcm(x.den, y.den)\n  x.num = common div x.den * x.num + common div y.den * y.num\n  x.den = common\n  x.frac\n\nproc `-` *(x: Rational): Rational =\n  result.num = -x.num\n  result.den = x.den\n\nproc `-` *(x, y: Rational): Rational =\n  x + -y\n\nproc `-=` *(x: var Rational, y: Rational) =\n  x += -y\n\nproc `*` *(x, y: Rational): Rational =\n  result.num = x.num * y.num\n  result.den = x.den * y.den\n  result.frac\n\nproc `*=` *(x: var Rational, y: Rational) =\n  x.num *= y.num\n  x.den *= y.den\n  x.frac\n\nproc reciprocal*(x: Rational): Rational =\n  result.num = x.den\n  result.den = x.num\n\nproc `div`*(x, y: Rational): Rational =\n  x * y.reciprocal\n\nproc toFloat*(x: Rational): float =\n  x.num.float / x.den.float\n\nproc toInt*(x: Rational): int64 =\n  x.num div x.den\n\nproc cmp*(x, y: Rational): int =\n  cmp x.toFloat, y.toFloat\n\nproc `<` *(x, y: Rational): bool =\n  x.toFloat < y.toFloat\n\nproc `<=` *(x, y: Rational): bool =\n  x.toFloat <= y.toFloat\n\nproc abs*(x: Rational): Rational =\n  result.num = abs x.num\n  result.den = abs x.den\n\nfor candidate in 2'i64 .. <((2'i64)^19):\n  var sum: Rational = (1'i64, candidate)\n  for factor in 2'i64 .. pow(candidate.float, 0.5).int64:\n    if candidate mod factor == 0:\n      sum += (1'i64, factor) + (1'i64, candidate div factor)\n  if sum.den == 1:\n    echo \"Sum of recipr. factors of \",candidate,\" = \",sum.num,\" exactly \",\n      if sum.num == 1: \"perfect!\" else: \"\"\n"
                },
                {
                    "language": "J",
                    "solution": "   I.is_perfect_rational@\"0 i.2^19\n6 28 496 8128\n   I.is_perfect_rational@x:@\"0 i.2^19x\n6 28 496 8128\n"
                }
            ],
            [
                {
                    "language": "Elisa",
                    "solution": "use RationalNumbers;\n\nPerfectNumbers( Limit = integer) -> multi(integer);\nPerfectNumbers( Limit) =\n  \t      [ Candidate = 2 .. Limit;\n\t\tSum:= Rational(1,Candidate);\n\t\t[ Divisor = 2 .. integer(sqrt(real(Candidate)));\n\t\t  if mod(Candidate, Divisor) == 0 then\n\t\t\tSum := Sum + Rational(1, Divisor) + Rational(Divisor, Candidate);\n\t\t];\n\t\tif Sum == Rational(1,1) then Candidate\n              ];\n\nPerfectNumbers(10000)?\n"
                },
                {
                    "language": "ERRE",
                    "solution": "PROGRAM RATIONAL_ARITH\n\n!\n! for rosettacode.org\n!\n\nTYPE RATIONAL=(NUM,DEN)\n\nDIM SUM:RATIONAL,ONE:RATIONAL,KF:RATIONAL\n\nDIM A:RATIONAL,B:RATIONAL\nPROCEDURE ABS(A.->A.)\n      A.NUM=ABS(A.NUM)\nEND PROCEDURE\n\nPROCEDURE NEG(A.->A.)\n      A.NUM=-A.NUM\nEND PROCEDURE\n\nPROCEDURE ADD(A.,B.->A.)\n      LOCAL T\n      T=A.DEN*B.DEN\n      A.NUM=A.NUM*B.DEN+B.NUM*A.DEN\n      A.DEN=T\nEND PROCEDURE\n\nPROCEDURE SUB(A.,B.->A.)\n      LOCAL T\n      T=A.DEN*B.DEN\n      A.NUM=A.NUM*B.DEN-B.NUM*A.DEN\n      A.DEN=T\nEND PROCEDURE\n\nPROCEDURE MULT(A.,B.->A.)\n      A.NUM*=B.NUM  A.DEN*=B.DEN\nEND PROCEDURE\n\nPROCEDURE DIVIDE(A.,B.->A.)\n      A.NUM*=B.DEN\n      A.DEN*=B.NUM\nEND PROCEDURE\n\nPROCEDURE EQ(A.,B.->RES%)\n      RES%=A.NUM*B.DEN=B.NUM*A.DEN\nEND PROCEDURE\n\nPROCEDURE LT(A.,B.->RES%)\n      RES%=A.NUM*B.DEN<B.NUM*A.DEN\nEND PROCEDURE\n\nPROCEDURE GT(A.,B.->RES%)\n      RES%=A.NUM*B.DEN>B.NUM*A.DEN\nEND PROCEDURE\n\nPROCEDURE NE(A.,B.->RES%)\n      RES%=A.NUM*B.DEN<>B.NUM*A.DEN\nEND PROCEDURE\n\nPROCEDURE LE(A.,B.->RES%)\n      RES%=A.NUM*B.DEN<=B.NUM*A.DEN\nEND PROCEDURE\n\nPROCEDURE GE(A.,B.->RES%)\n      RES%=A.NUM*B.DEN>=B.NUM*A.DEN\nEND PROCEDURE\n\nPROCEDURE NORMALIZE(A.->A.)\n      LOCAL A,B,T\n      A=A.NUM   B=A.DEN\n      WHILE B<>0 DO\n        T=A\n        A=B\n        B=T-B*INT(T/B)\n      END WHILE\n      A.NUM/=A  A.DEN/=A\n      IF A.DEN<0 THEN A.NUM*=-1 A.DEN*=-1 END IF\nEND PROCEDURE\n\nBEGIN\n    ONE.NUM=1 ONE.DEN=1\n    FOR N=2 TO 2^19-1 DO\n      SUM.NUM=1 SUM.DEN=N\n      FOR K=2 TO SQR(N) DO\n        IF N=K*INT(N/K) THEN\n          KF.NUM=1 KF.DEN=K\n          ADD(SUM.,KF.->SUM.)\n          NORMALIZE(SUM.->SUM.)\n          KF.DEN=INT(N/K)\n          ADD(SUM.,KF.->SUM.)\n          NORMALIZE(SUM.->SUM.)\n        END IF\n      END FOR\n      EQ(SUM.,ONE.->RES%)\n      IF RES% THEN PRINT(N;\" is perfect\") END IF\n   END FOR\nEND PROGRAM\n"
                }
            ]
        ]
    },
    {
        "task_name": "Array-concatenation",
        "task_description": ";Task:\nShow how to concatenate two arrays in your language. \n\n\nIf this is as simple as <code><var>array1</var> + <var>array2</var></code>, so be it.\n<br><br>\n\n",
        "solution_pairs": [
            [
                {
                    "language": "Rapira",
                    "solution": "arr1 := <* 1, 2, 3 *>\narr2 := <* 4, 5, 6 *>\noutput: arr1 + arr2\n"
                },
                {
                    "language": "C-sharp",
                    "solution": "using System;\n\nnamespace RosettaCode\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int[] a = { 1, 2, 3 };\n            int[] b = { 4, 5, 6 };\n\n            int[] c = new int[a.Length + b.Length];\n            a.CopyTo(c, 0);\n            b.CopyTo(c, a.Length);\n\n            foreach(int n in c)\n            {\n                Console.WriteLine(n.ToString());\n            }\n        }\n    }\n}\n"
                }
            ],
            [
                {
                    "language": "Little",
                    "solution": "void main() {\n    int a[] = {0, 1, 2, 3, 4};\n    int b[] = {5, 6, 7, 8, 9};\n    int c[] = {(expand)a, (expand)b};\n    puts(c);\n}\n"
                },
                {
                    "language": "IDL",
                    "solution": " > b = transpose(b)\n > help,b\n      B               INT       = Array[1, 3]\n > print,b\n       4\n       5\n       6\n > print,[a,b]\n Unable to concatenate variables because the dimensions do not agree: B.\n Execution halted at: $MAIN$\n > print,[[a],[b]]\n Unable to concatenate variables because the dimensions do not agree: B.\n Execution halted at: $MAIN$\n"
                }
            ],
            [
                {
                    "language": "ReScript",
                    "solution": "Js.Array2.concat([\"a\", \"b\"], [\"c\", \"d\", \"e\"]) == [\"a\", \"b\", \"c\", \"d\", \"e\"]\n"
                },
                {
                    "language": "Java",
                    "solution": "int[] concat(int[] arrayA, int[] arrayB) {\n    int[] array = new int[arrayA.length + arrayB.length];\n    System.arraycopy(arrayA, 0, array, 0, arrayA.length);\n    System.arraycopy(arrayB, 0, array, arrayA.length, arrayB.length);\n    return array;\n}\n"
                }
            ],
            [
                {
                    "language": "K",
                    "solution": "   ab:3 3#\"abcdefghi\"\n(\"abc\"\n \"def\"\n \"ghi\")\n\n   dd:3 3#\"012345678\"\n(\"012\"\n \"345\"\n \"678\")\n\n   ab,dd\n(\"abc\"\n \"def\"\n \"ghi\"\n \"012\"\n \"345\"\n \"678\")\n\n   +ab,dd   / flip (transpose) join\n(\"adg036\"\n \"beh147\"\n \"cfi258\")\n\n   ab,'dd   / eachpair join\n(\"abc012\"\n \"def345\"\n \"ghi678\")\n\n   +(+ab),dd\n(\"abc036\"\n \"def147\"\n \"ghi258\")\n"
                },
                {
                    "language": "EGL",
                    "solution": "program ArrayConcatenation\n    function main()\n        a int[] = [ 1, 2, 3 ];\n\tb int[] = [ 4, 5, 6 ];\n\tc int[];\n\tc.appendAll(a);\n\tc.appendAll(b);\n\t\t\n\tfor (i int from 1 to c.getSize())\n\t    SysLib.writeStdout(\"Element \" :: i :: \" = \" :: c[i]);\n\tend\n    end\nend\n"
                }
            ],
            [
                {
                    "language": "PureBasic",
                    "solution": "Procedure displayArray(Array a(1), msg.s)\n  Protected i\n  Print(msg + \" [\")\n  For i = 0 To ArraySize(a())\n    Print(Str(a(i)))\n    If i <> ArraySize(a())\n      Print(\", \")\n    EndIf\n  Next\n  PrintN(\"]\")\nEndProcedure\n\nProcedure randomElements(Array a(1), lo, hi)\n  Protected i\n  For i = 0 To ArraySize(a())\n    a(i) = random(hi - lo) + lo\n  Next\nEndProcedure\n\nProcedure arrayConcat(Array a(1), Array b(1), Array c(1))\n  Protected i, newSize = ArraySize(a()) + ArraySize(b()) + 1\n  Dim c(newSize)\n  For i = 0 To ArraySize(a())\n    c(i) = a(i)\n  Next\n  For i = 0 To ArraySize(b())\n    c(i + ArraySize(a()) + 1) = b(i)\n  Next\nEndProcedure\n\n\nIf OpenConsole()\n  Dim a(random(3) + 1)\n  Dim b(random(3) + 1)\n  Dim c(0) ;array will be resized by arrayConcat()\n\n  randomElements(a(), -5, 5)\n  randomElements(b(), -5, 5)\n  displayArray(a(), \"a:\")\n  displayArray(b(), \"b:\")\n  arrayConcat(a(), b(), c())\n  displayArray(c(), \"concat of a[] + b[]:\")\n\n  Print(#CRLF$ + #CRLF$ + \"Press ENTER to exit\")\n  Input()\n  CloseConsole()\nEndIf\n"
                },
                {
                    "language": "Nial",
                    "solution": "    link a b\n+-+-+-+-+-+-+\n|1|2|3|4|5|6|\n+-+-+-+-+-+-+\n"
                }
            ]
        ]
    },
    {
        "task_name": "Array-length",
        "task_description": ";Task:\nDetermine the amount of elements in an array.\n\n\nAs an example use an array holding the strings 'apple' and 'orange'.\n\n\n{{Template:Strings}}\n<br><br>\n\n",
        "solution_pairs": [
            [
                {
                    "language": "C",
                    "solution": "#define ARRAY_LENGTH(A) (sizeof(A) / sizeof(A[0]))\n"
                },
                {
                    "language": "Dragon",
                    "solution": "select \"std\"\n\na = [\"apple\",\"orange\"]\nb = length(a)\n\nshow b\n"
                }
            ],
            [
                {
                    "language": "Clipper-XBase++",
                    "solution": "/*\n * nizchka: March - 2016\n * This is a Clipper/XBase++ of RosettaCode Array_Length\n */\n\nPROCEDURE MAIN()\n        LOCAL FRUIT := { \"apples\",\"oranges\" }\n\n        ? LEN(FRUIT)\nRETURN\n"
                },
                {
                    "language": "Pony",
                    "solution": "actor Main\n    new create(env:Env)=>\n        var c=Array[String](2)\n        c.push(\"apple\")\n        c.push(\"orange\")\n        env.out.print(\"Array c is \" + c.size().string() + \" elements long!\")\n"
                }
            ],
            [
                {
                    "language": "Lua",
                    "solution": "-- For tables as simple arrays, use the # operator:\nfruits = {\"apple\", \"orange\"}\nprint(#fruits)\n\n-- Note the # symbol does not work for non-integer-indexed tables:\nfruits = {fruit1 = \"apple\", fruit2 = \"orange\"}\nprint(#fruits)\n\n-- For this you can use this short function:\nfunction size (tab)\n  local count = 0\n  for k, v in pairs(tab) do\n    count = count + 1\n  end\n  return count\nend\n\nprint(size(fruits))\n"
                },
                {
                    "language": "K",
                    "solution": "#(\"apple\";\"orange\")\n"
                }
            ],
            [
                {
                    "language": "MiniZinc",
                    "solution": "array[int] of int: arr = [1,2,3];\nvar int: size = length(arr);\n\nsolve satisfy;\n\noutput [show(size),\"\\n\"];\n"
                },
                {
                    "language": "Racket",
                    "solution": "#lang racket/base\n(length '(\"apple\" \"orange\")) ;; list\n(vector-length #(\"apple\" \"orange\")) ;; vector\n"
                }
            ],
            [
                {
                    "language": "Visual-Basic",
                    "solution": "' declared in a module\nPublic Function LengthOfArray(ByRef arr As Variant) As Long\n  If IsArray(arr) Then\n     LengthOfArray = UBound(arr) - LBound(arr) + 1\n  Else\n     LengthOfArray = -1\n  End If\nEnd Function\n\n' somewhere in the programm\n' example 1\n  Dim arr As Variant\n\n  arr = Array(\"apple\", \"orange\")\n\n  Debug.Print LengthOfArray(arr) ' prints 2 as result\n\n' example 2\n  Dim arr As Variant\n\n  ReDim arr(-2 To -1)\n  arr(-2) = \"apple\"\n  arr(-1) = \"orange\"\n\n  Debug.Print LengthOfArray(arr) ' prints 2 as result\n"
                },
                {
                    "language": "EchoLisp",
                    "solution": "(length '(\"apple\" \"orange\")) ;; list\n   \u2192 2\n(vector-length #(\"apple\" \"orange\")) ;; vector\n   \u2192 2\n"
                }
            ]
        ]
    },
    {
        "task_name": "Arrays",
        "task_description": "This task is about arrays.\n \nFor hashes or associative arrays, please see [[Creating an Associative Array]]. \n\nFor a definition and in-depth discussion of what an array is, see [[Array]].\n\n\n;Task:\nShow basic array syntax in your language. \n\nBasically, create an array, assign a value to it, and retrieve an element &nbsp; (if available, show both fixed-length arrays and\ndynamic arrays, pushing a value into it).\n\nPlease discuss at Village Pump: &nbsp; {{vp|Arrays}}.  \n\nPlease merge code in from these obsolete tasks:\n:::* &nbsp; [[Creating an Array]]\n:::* &nbsp; [[Assigning Values to an Array]]\n:::* &nbsp; [[Retrieving an Element of an Array]]\n\n\n;Related tasks:\n* &nbsp; [[Collections]]\n* &nbsp; [[Creating an Associative Array]]\n* &nbsp; [[Two-dimensional array (runtime)]]\n<br><br>\n\n",
        "solution_pairs": [
            [
                {
                    "language": "AppleScript",
                    "solution": "use AppleScript version \"2.4\" -- Mac OS 10.10 (Yosemite) or later.\nuse framework \"Foundation\" -- Allows access to NSArrays and other Foundation classes.\n\nset myList to {1, \"foo\", 2.57, missing value, {1, 2, 3}} -- AppleScript list.\nset myNSArray to current application's NSArray's arrayWithArray:myList -- Bridge the list to an NSArray.\nset arrayLength to myNSArray's |count|() -- Get the array's length using its 'count' property.\n--> 5\n"
                },
                {
                    "language": "Clojure",
                    "solution": ";clojure is a language built with immutable/persistent data structures. there is no concept of changing what a vector/list\n;is, instead clojure creates a new array with an added value using (conj...)\n;in the example below the my-list does not change.\n\n\nuser=> (def my-list (list 1 2 3 4 5))\n\nuser=> my-list\n(1 2 3 4 5)\n\nuser=> (first my-list)\n1\n\nuser=> (nth my-list 3)\n4\n\nuser=> (conj my-list 100) ;adding to a list always adds to the head of the list\n(100 1 2 3 4 5)\n\nuser=> my-list ;it is impossible to change the list pointed to by my-list\n(1 2 3 4 5)\n\nuser=> (def my-new-list (conj my-list 100))\n\nuser=> my-new-list\n(100 1 2 3 4 5)\n\nuser=> (cons 200 my-new-list) ;(cons makes a new list, (conj will make a new object of the same type as the one it is given\n(200 100 1 2 3 4 5)\n\nuser=> (def my-vec [1 2 3 4 5 6])\n\nuser=> (conj my-vec 300) ;adding to a vector always adds to the end of the vector\n[1 2 3 4 5 6 300]\n"
                }
            ],
            [
                {
                    "language": "AppleScript",
                    "solution": "use AppleScript version \"2.4\" -- Mac OS 10.10 (Yosemite) or later.\nuse framework \"Foundation\" -- Allows access to NSArrays and other Foundation classes.\n\nset myList to {1, \"foo\", 2.57, missing value, {1, 2, 3}} -- AppleScript list.\nset myNSArray to current application's NSArray's arrayWithArray:myList -- Bridge the list to an NSArray.\nset arrayLength to myNSArray's |count|() -- Get the array's length using its 'count' property.\n--> 5\n"
                },
                {
                    "language": "SPL",
                    "solution": "a[1] = 2.5\na[2] = 3\na[3] = \"Result is \"\n#.output(a[3],a[1]+a[2])\n"
                }
            ],
            [
                {
                    "language": "E",
                    "solution": "? def flex := numbers.diverge()\n# value: [1, 2].diverge()\n\n? flex.push(-3)\n? flex\n# value: [1, 2, -3].diverge()\n\n? numbers\n# value: [1, 2]\n\n? flex.snapshot()\n# value: [1, 2, -3]\n"
                },
                {
                    "language": "PHP",
                    "solution": "$arr = ['apple', 'orange'];\narray_push($arr, 'pear');\nprint implode(',', $arr); // Returns apple,orange,pear\n"
                }
            ],
            [
                {
                    "language": "REXX",
                    "solution": "/*REXX program  demonstrates  array usage:   sparse and disjointed.     */\n  yyy = -55                            /*REXX must use this mechanism\u00b7\u00b7\u00b7*/\na.yyy = 1e9                            /*\u00b7\u00b7\u00b7 when assigning neg indices.*/\n\na.1 = 1000\na.2 = 2000.0001\na.7 = 7000\na.2012 = 'out here in left field.'\na.cat = 'civet, but not a true cat \u2500\u2500\u2500 belonging to the family Viverridae'\na.civet = \"A.K.A.: toddycats\"\n/*\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n  \u2502 Array elements need not be continuous (nor even defined).   They   \u2502\n  \u2502 can hold any manner of numbers,  or strings (which can include any \u2502\n  \u2502 characters,  including    null    or    '00'x   characters).       \u2502\n  \u2502                                                                    \u2502\n  \u2502 Array elements need not be numeric, as the above code demonstrates.\u2502\n  \u2502 Indeed, the element \"name\" can be ANYTHING,  even non-displayable  \u2502\n  \u2502 characters.    To illustrate  [\u2193]:                                 \u2502\n  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518*/\nstuff=')g.u.t.s(  or  \u00bd of an intestine!'\na.stuff=44\n/*\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n  \u2502 where the element name has special characters:  blanks,  and the   \u2502\n  \u2502 glyph of  one-half (\u00bd),  as well as the symbol used in REXX to     \u2502\n  \u2502 identify stemmed arrays (the period).                              \u2502\n  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518*/\n                                       /*stick a fork in it, we're done.*/\n"
                },
                {
                    "language": "Fortran",
                    "solution": "a = 0\n"
                }
            ],
            [
                {
                    "language": "CoffeeScript",
                    "solution": "array1 = []\narray1[0] = \"Dillenidae\"\narray1[1] = \"animus\"\narray1[2] = \"Kona\"\nalert \"Elements of array1: \" + array1 # Dillenidae,animus,Kona\n\narray2 = [\"Cepphus\", \"excreta\", \"Gansu\"]\nalert \"Value of array2[1]: \" + array2[1] # excreta\n"
                },
                {
                    "language": "Lasso",
                    "solution": "// Create a staticarray containing 5 items\nlocal(mystaticArray) = staticarray('a','b','c','d','e')\n\n// Retreive an item\n#mystaticArray->get(3) // c\n\n// Set an item\n#mystaticArray->get(3) = 'changed' // a, b, changed, d, e\n\n// Create an empty static array with a length of 32\nlocal(mystaticArray) = staticarray_join(32,void)\n"
                }
            ]
        ]
    },
    {
        "task_name": "Ascending-primes",
        "task_description": "Generate and show all primes with strictly ascending decimal digits.\n\nAside: Try solving without peeking at existing solutions. I had a weird idea for generating\na prime sieve faster, which needless to say didn't pan out. The solution may be p(r)etty trivial\nbut generating them quickly is at least mildly interesting.\nTip: filtering all 7,027,260 primes below 123,456,789 probably won't kill you, but there is\nat least one significantly better and much faster way, needing a mere 511 odd/prime tests.\n\n\n;See also\n;* [[oeis:A052015|OEIS:A052015 - Primes with distinct digits in ascending order]]\n\n\n;Related:\n*[[Primes with digits in nondecreasing order]] (infinite series allowing duplicate digits, whereas this isn't and doesn't)\n*[[Pandigital prime]] (whereas this is the smallest, with gaps in the used digits being permitted)\n*[[Descending primes]]\n\n\n",
        "solution_pairs": [
            [
                {
                    "language": "FutureBasic",
                    "solution": "local fn IsPrime( n as NSUInteger ) as BOOL\n  BOOL       isPrime = YES\n  NSUInteger i\n\n  if n < 2        then exit fn = NO\n  if n = 2        then exit fn = YES\n  if n mod 2 == 0 then exit fn = NO\n  for i = 3 to int(n^.5) step 2\n    if n mod i == 0 then exit fn = NO\n  next\nend fn = isPrime\n\nvoid local fn AscendingPrimes( limit as long )\n  long i, n, mask, num, count = 0\n\n  for i = 0 to limit -1\n    n = 0 : mask = i : num = 1\n    while ( mask )\n      if mask & 1 then n = n * 10 + num\n      mask = mask >> 1\n      num++\n    wend\n    mda(i) = n\n  next\n\n  mda_sort @\"compare:\"\n\n  for i = 1 to mda_count (0) - 1\n    n = mda_integer(i)\n    if ( fn IsPrime( n ) )\n      printf @\"%10ld\\b\", n\n      count++\n      if count mod 10 == 0 then print\n    end if\n  next\n  printf @\"\\n\\tThere are %ld ascending primes.\", count\nend fn\n\nwindow 1, @\"Ascending Primes\", ( 0, 0, 780, 230 )\nprint\n\nCFTimeInterval t\nt = fn CACurrentMediaTime\nfn AscendingPrimes( 512 )\nprintf @\"\\n\\tCompute time: %.3f ms\\n\",(fn CACurrentMediaTime-t)*1000\n\nHandleEvents\n"
                },
                {
                    "language": "PicoLisp",
                    "solution": "(de prime? (N)\n   (or\n      (= N 2)\n      (and\n         (> N 1)\n         (bit? 1 N)\n         (for (D 3  T  (+ D 2))\n            (T (> D (sqrt N)) T)\n            (T (=0 (% N D)) NIL) ) ) ) )\n(let\n   (D 2\n      L (1 2 2 . (4 2 4 2 4 6 2 6 .))\n      Lst\n      (make\n         (while (>= 23456789 D)\n            (and\n               (prime? D)\n               (apply < (chop D))\n               (link D) )\n            (inc 'D (++ L)) ) ) )\n   (let Fmt (need 10 10)\n      (while (cut 10 'Lst)\n         (apply tab @ Fmt) ) ) )\n"
                }
            ],
            [
                {
                    "language": "OCaml",
                    "solution": "let is_prime n =\n  let rec test x =\n    let q = n / x in x > q || x * q <> n && n mod (x + 2) <> 0 && test (x + 6)\n  in if n < 5 then n lor 1 = 3 else n land 1 <> 0 && n mod 3 <> 0 && test 5\n\nlet ascending_ints =\n  let rec range10 m d = if d < 10 then m + d :: range10 m (succ d) else [] in\n  let up n = range10 (n * 10) (succ (n mod 10)) in\n  let rec next l = if l = [] then [] else l @ next (List.concat_map up l) in\n  next [0]\n\nlet () =\n  List.filter is_prime ascending_ints\n  |> List.iter (Printf.printf \" %u\") |> print_newline\n"
                },
                {
                    "language": "SparForte",
                    "solution": "#!/usr/local/bin/spar\n\npragma annotate( summary, \"primes_asc\" );\npragma annotate( description, \"Generate and show all primes with strictly ascending decimal digits\" );\npragma annotate( description, \"Translation of Pascal\" );\npragma annotate( see_also, \"https://rosettacode.org/wiki/Ascending_primes\" );\npragma annotate( author, \"Ken O. Burtch\" );\n\npragma software_model( nonstandard );\npragma restriction( no_external_commands );\n\nprocedure primes_asc is\n  maxsize : constant natural := 1000;\n\n  queue : array(1..maxsize) of natural;\n  primes: array(1..maxsize) of natural;\n\n  b : natural;\n  e : natural;\n  n : natural;\n  v : natural;\n\nfunction is_prime(num: integer) return boolean is\n    found : boolean;\n    num_root : natural;\n    k : natural;\n  begin\n    if num = 2 then\n      found;\n    elsif (num = 1) or (num mod 2 = 0) then\n      found := false;\n    else\n      num_root := numerics.truncation(numerics.sqrt(num));\n      found;\n      k := 3;\n      while found and (k <= num_root) loop\n        if num mod k = 0 then\n          found := false;\n        else\n          k := @ + 2;\n        end if;\n      end loop;\n   end if;\n    return found;\n  end is_prime;\n\nbegin\n  b := 1;\n  e := 1;\n  n := 0;\n\n  for k in 1..9 loop\n    queue(e) := k;\n    e := e + 1;\n  end loop;\n\n  while b < e loop\n    v := queue(b);\n    b := @ + 1;\n    if is_prime(v) then\n      n := @ + 1;\n      primes(n) := v;\n    end if;\n\n    for k in v mod 10 + 1..9 loop\n      queue(e) := v * 10 + k;\n      e := @ + 1;\n    end loop;\n  end loop;\n\n  for k in 1..n loop\n    put(primes(k), \"ZZZZZZZZ9\");\n    if k mod 8 = 0 then\n       new_line;\n    end if;\n  end loop;\n  new_line;\nend primes_asc;\n"
                }
            ],
            [
                {
                    "language": "Java",
                    "solution": "/*\n *  Ascending primes\n *\n *  Generate and show all primes with strictly ascending decimal digits.\n *\n *\n *  Solution\n *\n *  We only consider positive numbers in the range 1 to 123456789. We would\n *  get 7027260 primes, because there are so many primes smaller than 123456789\n *  (see also Wolfram Alpha).On the other hand, there are only 511 distinct\n *  positive integers having their digits arranged in ascending order.\n *  Therefore, it is better to start with numbers that have properly arranged\n *  digits and then check if they are prime numbers.The method of generating\n *  a sequence of such numbers is not indifferent.We want this sequence to be\n *  monotonically increasing, because then additional sorting of results will\n *  be unnecessary. It turns out that by using a queue we can easily get the\n *  desired effect. Additionally, the algorithm then does not use recursion\n *  (although the program probably does not have to comply with the MISRA\n *  standard). The problem to be solved is the queue size, the a priori\n *  assumption that 1000 is good enough, but a bit magical.\n */\n\npackage example.rossetacode.ascendingprimes;\n\nimport java.util.Arrays;\n\npublic class Program implements Runnable {\n\n    public static void main(String[] args) {\n        long t1 = System.nanoTime();\n        new Program().run();\n        long t2 = System.nanoTime();\n        System.out.println(\n                \"total time consumed = \" + (t2 - t1) * 1E-6 + \" milliseconds\");\n    }\n\n    public void run() {\n\n        final int MAX_SIZE = 1000;\n        final int[] queue = new int[MAX_SIZE];\n        int begin = 0;\n        int end = 0;\n\n        for (int k = 1; k <= 9; k++) {\n            queue[end++] = k;\n        }\n\n        while (begin < end) {\n            int n = queue[begin++];\n            for (int k = n % 10 + 1; k <= 9; k++) {\n                queue[end++] = n * 10 + k;\n            }\n        }\n\n        // We can use a parallel stream (and then sort the results)\n        // to use multiple cores.\n        //\n        System.out.println(Arrays.stream(queue).filter(this::isPrime).boxed().toList());\n    }\n\n    private boolean isPrime(int n) {\n        if (n == 2) {\n            return true;\n        }\n        if (n == 1 || n % 2 == 0) {\n            return false;\n        }\n        int root = (int) Math.sqrt(n);\n        for (int k = 3; k <= root; k += 2) {\n            if (n % k == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n"
                },
                {
                    "language": "PicoLisp",
                    "solution": "(de prime? (N)\n   (or\n      (= N 2)\n      (and\n         (> N 1)\n         (bit? 1 N)\n         (for (D 3  T  (+ D 2))\n            (T (> D (sqrt N)) T)\n            (T (=0 (% N D)) NIL) ) ) ) )\n(let\n   (D 2\n      L (1 2 2 . (4 2 4 2 4 6 2 6 .))\n      Lst\n      (make\n         (while (>= 23456789 D)\n            (and\n               (prime? D)\n               (apply < (chop D))\n               (link D) )\n            (inc 'D (++ L)) ) ) )\n   (let Fmt (need 10 10)\n      (while (cut 10 'Lst)\n         (apply tab @ Fmt) ) ) )\n"
                }
            ],
            [
                {
                    "language": "AWK",
                    "solution": "# syntax: GAWK -f ASCENDING_PRIMES.AWK\nBEGIN {\n    start = 1\n    stop = 23456789\n    for (i=start; i<=stop; i++) {\n      if (is_prime(i)) {\n        primes++\n        leng = length(i)\n        flag = 1\n        for (j=1; j<leng; j++) {\n          if (substr(i,j,1) >= substr(i,j+1,1)) {\n            flag = 0\n            break\n          }\n        }\n        if (flag) {\n          printf(\"%9d%1s\",i,++count%10?\"\":\"\\n\")\n        }\n      }\n    }\n    printf(\"\\n%d-%d: %d primes, %d ascending primes\\n\",start,stop,primes,count)\n    exit(0)\n}\nfunction is_prime(n,  d) {\n    d = 5\n    if (n < 2) { return(0) }\n    if (n % 2 == 0) { return(n == 2) }\n    if (n % 3 == 0) { return(n == 3) }\n    while (d*d <= n) {\n      if (n % d == 0) { return(0) }\n      d += 2\n      if (n % d == 0) { return(0) }\n      d += 4\n    }\n    return(1)\n}\n"
                },
                {
                    "language": "Quackery",
                    "solution": "  [ 0 swap witheach\n      [ swap 10 * + ] ]                 is digits->n ( [ --> n )\n\n  []\n  ' [ 1 2 3 4 5 6 7 8 9 ] powerset\n  witheach\n    [ digits->n dup isprime\n      iff join else drop ]\n  sort echo\n"
                }
            ],
            [
                {
                    "language": "FutureBasic",
                    "solution": "local fn IsPrime( n as NSUInteger ) as BOOL\n  BOOL       isPrime = YES\n  NSUInteger i\n\n  if n < 2        then exit fn = NO\n  if n = 2        then exit fn = YES\n  if n mod 2 == 0 then exit fn = NO\n  for i = 3 to int(n^.5) step 2\n    if n mod i == 0 then exit fn = NO\n  next\nend fn = isPrime\n\nvoid local fn AscendingPrimes( limit as long )\n  long i, n, mask, num, count = 0\n\n  for i = 0 to limit -1\n    n = 0 : mask = i : num = 1\n    while ( mask )\n      if mask & 1 then n = n * 10 + num\n      mask = mask >> 1\n      num++\n    wend\n    mda(i) = n\n  next\n\n  mda_sort @\"compare:\"\n\n  for i = 1 to mda_count (0) - 1\n    n = mda_integer(i)\n    if ( fn IsPrime( n ) )\n      printf @\"%10ld\\b\", n\n      count++\n      if count mod 10 == 0 then print\n    end if\n  next\n  printf @\"\\n\\tThere are %ld ascending primes.\", count\nend fn\n\nwindow 1, @\"Ascending Primes\", ( 0, 0, 780, 230 )\nprint\n\nCFTimeInterval t\nt = fn CACurrentMediaTime\nfn AscendingPrimes( 512 )\nprintf @\"\\n\\tCompute time: %.3f ms\\n\",(fn CACurrentMediaTime-t)*1000\n\nHandleEvents\n"
                },
                {
                    "language": "Arturo",
                    "solution": "ascending?: function [x][\n    initial: digits x\n    and? [equal? sort initial initial][equal? size initial size unique initial]\n]\n\ncandidates: select (1..1456789) ++ [\n    12345678, 12345679, 12345689, 12345789, 12346789,\n    12356789, 12456789, 13456789, 23456789, 123456789\n] => prime?\n\nascendingNums: select candidates => ascending?\n\nloop split.every:10 ascendingNums 'nums [\n    print map nums 'num -> pad to :string num 10\n]\n"
                }
            ]
        ]
    },
    {
        "task_name": "ASCII-art-diagram-converter",
        "task_description": "Given the RFC 1035 message diagram from Section 4.1.1 (Header section format) as a string:\nhttp://www.ietf.org/rfc/rfc1035.txt\n\n +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n |                      ID                       |\n +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n |QR|   Opcode  |AA|TC|RD|RA|   Z    |   RCODE   |\n +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n |                    QDCOUNT                    |\n +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n |                    ANCOUNT                    |\n +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n |                    NSCOUNT                    |\n +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n |                    ARCOUNT                    |\n +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\nWhere (every column of the table is 1 bit):\n\n ID is 16 bits\n QR = Query (0) or Response (1)\n Opcode = Four bits defining kind of query:\n   0:    a standard query (QUERY)\n   1:    an inverse query (IQUERY)\n   2:    a server status request (STATUS)\n   3-15: reserved for future use\n AA = Authoritative Answer bit\n TC = Truncation bit\n RD = Recursion Desired bit\n RA = Recursion Available bit\n Z = Reserved\n RCODE = Response code\n QC = Question Count\n ANC = Answer Count\n AUC = Authority Count\n ADC = Additional Count\n\nWrite a function, member function, class or template that accepts a similar multi-line string as input to define a data structure or something else able to decode or store a header with that specified bit structure.\n\nIf your language has macros, introspection, code generation, or powerful enough templates, then accept such string at compile-time to define the header data structure statically.\n\nSuch \"Header\" function or template should accept a table with 8, 16, 32 or 64 columns, and any number of rows. For simplicity the only allowed symbols to define the table are + - | (plus, minus, pipe), and whitespace. Lines of the input string composed just of whitespace should be ignored. Leading and trailing whitespace in the input string should be ignored, as well as  before and after each table row. The box for each bit of the diagram takes four chars \"+--+\". The code should perform a little of validation of the input string, but for brevity a full validation is not required.\n\nBonus: perform a thoroughly validation of the input string.\n\n",
        "solution_pairs": [
            [
                {
                    "language": "Wren",
                    "solution": "import \"./dynamic\" for Tuple\nimport \"./fmt\" for Fmt\nimport \"./big\" for BigInt\n\nvar Result = Tuple.create(\"Result\", [\"name\", \"size\", \"start\", \"end\"])\n\nvar validate = Fn.new { |diagram|\n    var lines = []\n    for (line in diagram.split(\"\\n\")) {\n        line = line.trim(\" \\t\")\n        if (line != \"\") lines.add(line)\n    }\n    if (lines.count == 0) Fiber.abort(\"diagram has no non-empty lines!\")\n    var width = lines[0].count\n    var cols = ((width - 1) / 3).floor\n    if (cols != 8 && cols != 16 && cols != 32 && cols != 64) {\n        Fiber.abort(\"number of columns should be 8, 16, 32 or 64\")\n    }\n    if (lines.count%2 == 0) {\n        Fiber.abort(\"number of non-empty lines should be odd\")\n    }\n    if (lines[0] != \"+--\" * cols + \"+\") Fiber.abort(\"incorrect header line\")\n    var i = 0\n    for (line in lines) {\n        if (i == 0) {\n            continue\n        } else if (i%2 == 0) {\n            if (line != lines[0]) Fiber.abort(\"incorrect separator line\")\n        } else if (line.count != width) {\n            Fiber.abort(\"inconsistent line widths\")\n        } else if (line[0] != \"|\" || line[width-1] != \"|\") {\n            Fiber.abort(\"non-separator lines must begin and end with '|'\")\n        }\n        i = i + 1\n    }\n    return lines\n}\n\nvar decode = Fn.new { |lines|\n    System.print(\"Name     Bits  Start  End\")\n    System.print(\"=======  ====  =====  ===\")\n    var start = 0\n    var width = lines[0].count\n    var results = []\n    var i = 0\n    for (line in lines) {\n        if (i%2 == 0) {\n            i = i + 1\n            continue\n        }\n        line = line[1...width-1]\n        for (name in line.split(\"|\")) {\n            var size = ((name.count + 1) / 3).floor\n            name = name.trim()\n            var r = Result.new(name, size, start, start + size - 1)\n            results.add(r)\n            Fmt.print(\"$-7s   $2d    $3d   $3d\", r.name, r.size, r.start, r.end)\n            start = start + size\n        }\n        i = i + 1\n    }\n    return results\n}\n\nvar hex2bin = Fn.new { |hex|\n    var z = BigInt.fromBaseString(hex, 16)\n    return Fmt.swrite(\"$0%(4*hex.count)s\", z.toBaseString(2))\n}\n\nvar unpack = Fn.new { |results, hex|\n    System.print(\"\\nTest string in hex:\")\n    System.print(hex)\n    System.print(\"\\nTest string in binary:\")\n    var bin = hex2bin.call(hex)\n    System.print(bin)\n    System.print(\"\\nUnpacked:\\n\")\n    System.print(\"Name     Size  Bit pattern\")\n    System.print(\"=======  ====  ================\")\n    for (res in results) {\n        Fmt.print(\"$-7s   $2d   $s\", res.name, res.size, bin[res.start..res.end])\n    }\n}\n\nvar diagram = \"\"\"\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n     |                      ID                       |\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n    |QR|   Opcode  |AA|TC|RD|RA|   Z    |   RCODE   |\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n    |                    QDCOUNT                    |\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\n    |                    ANCOUNT                    |\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n    |                    NSCOUNT                    |\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n    |                    ARCOUNT                    |\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\"\"\"\nvar lines = validate.call(diagram)\nSystem.print(\"Diagram after trimming whitespace and removal of blank lines:\\n\")\nfor (line in lines) System.print(line)\nSystem.print(\"\\nDecoded:\\n\")\nvar results = decode.call(lines)\nvar hex = \"78477bbf5496e12e1bf169a4\" // test string\nunpack.call(results, hex)\n"
                },
                {
                    "language": "Go",
                    "solution": "package main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"math/big\"\n    \"strings\"\n)\n\ntype result struct {\n    name  string\n    size  int\n    start int\n    end   int\n}\n\nfunc (r result) String() string {\n    return fmt.Sprintf(\"%-7s   %2d    %3d   %3d\", r.name, r.size, r.start, r.end)\n}\n\nfunc validate(diagram string) []string {\n    var lines []string\n    for _, line := range strings.Split(diagram, \"\\n\") {\n        line = strings.Trim(line, \" \\t\")\n        if line != \"\" {\n            lines = append(lines, line)\n        }\n    }\n    if len(lines) == 0 {\n        log.Fatal(\"diagram has no non-empty lines!\")\n    }\n    width := len(lines[0])\n    cols := (width - 1) / 3\n    if cols != 8 && cols != 16 && cols != 32 && cols != 64 {\n        log.Fatal(\"number of columns should be 8, 16, 32 or 64\")\n    }\n    if len(lines)%2 == 0 {\n        log.Fatal(\"number of non-empty lines should be odd\")\n    }\n    if lines[0] != strings.Repeat(\"+--\", cols)+\"+\" {\n        log.Fatal(\"incorrect header line\")\n    }\n    for i, line := range lines {\n        if i == 0 {\n            continue\n        } else if i%2 == 0 {\n            if line != lines[0] {\n                log.Fatal(\"incorrect separator line\")\n            }\n        } else if len(line) != width {\n            log.Fatal(\"inconsistent line widths\")\n        } else if line[0] != '|' || line[width-1] != '|' {\n            log.Fatal(\"non-separator lines must begin and end with '|'\")\n        }\n    }\n    return lines\n}\n\nfunc decode(lines []string) []result {\n    fmt.Println(\"Name     Bits  Start  End\")\n    fmt.Println(\"=======  ====  =====  ===\")\n    start := 0\n    width := len(lines[0])\n    var results []result\n    for i, line := range lines {\n        if i%2 == 0 {\n            continue\n        }\n        line := line[1 : width-1]\n        for _, name := range strings.Split(line, \"|\") {\n            size := (len(name) + 1) / 3\n            name = strings.TrimSpace(name)\n            res := result{name, size, start, start + size - 1}\n            results = append(results, res)\n            fmt.Println(res)\n            start += size\n        }\n    }\n    return results\n}\n\nfunc unpack(results []result, hex string) {\n    fmt.Println(\"\\nTest string in hex:\")\n    fmt.Println(hex)\n    fmt.Println(\"\\nTest string in binary:\")\n    bin := hex2bin(hex)\n    fmt.Println(bin)\n    fmt.Println(\"\\nUnpacked:\\n\")\n    fmt.Println(\"Name     Size  Bit pattern\")\n    fmt.Println(\"=======  ====  ================\")\n    for _, res := range results {\n        fmt.Printf(\"%-7s   %2d   %s\\n\", res.name, res.size, bin[res.start:res.end+1])\n    }\n}\n\nfunc hex2bin(hex string) string {\n    z := new(big.Int)\n    z.SetString(hex, 16)\n    return fmt.Sprintf(\"%0*b\", 4*len(hex), z)\n}\n\nfunc main() {\n    const diagram = `\n        +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n         |                      ID                       |\n        +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n        |QR|   Opcode  |AA|TC|RD|RA|   Z    |   RCODE   |\n        +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n        |                    QDCOUNT                    |\n        +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\n        |                    ANCOUNT                    |\n        +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n        |                    NSCOUNT                    |\n        +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n        |                    ARCOUNT                    |\n        +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n    `\n    lines := validate(diagram)\n    fmt.Println(\"Diagram after trimming whitespace and removal of blank lines:\\n\")\n    for _, line := range lines {\n        fmt.Println(line)\n    }\n    fmt.Println(\"\\nDecoded:\\n\")\n    results := decode(lines)\n    hex := \"78477bbf5496e12e1bf169a4\" // test string\n    unpack(results, hex)\n}\n"
                }
            ],
            [
                {
                    "language": "Java",
                    "solution": "import java.math.BigInteger;\nimport java.util.ArrayList;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic class AsciiArtDiagramConverter {\n\n    private static final String TEST = \"+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\\r\\n\" +\n            \"|                      ID                       |\\r\\n\" +\n            \"+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\\r\\n\" +\n            \"|QR|   Opcode  |AA|TC|RD|RA|   Z    |   RCODE   |\\r\\n\" +\n            \"+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\\r\\n\" +\n            \"|                    QDCOUNT                    |\\r\\n\" +\n            \"+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\\r\\n\" +\n            \"|                    ANCOUNT                    |\\r\\n\" +\n            \"+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\\r\\n\" +\n            \"|                    NSCOUNT                    |\\r\\n\" +\n            \"+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\\r\\n\" +\n            \"|                    ARCOUNT                    |\\r\\n\" +\n            \"+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\";\n\n    public static void main(String[] args) {\n        validate(TEST);\n        display(TEST);\n        Map<String,List<Integer>> asciiMap = decode(TEST);\n        displayMap(asciiMap);\n        displayCode(asciiMap, \"78477bbf5496e12e1bf169a4\");\n    }\n\n    private static void displayCode(Map<String,List<Integer>> asciiMap, String hex) {\n        System.out.printf(\"%nTest string in hex:%n%s%n%n\", hex);\n\n        String bin = new BigInteger(hex,16).toString(2);\n\n        //  Zero pad in front as needed\n        int length = 0;\n        for ( String code : asciiMap.keySet() ) {\n            List<Integer> pos = asciiMap.get(code);\n            length += pos.get(1) - pos.get(0) + 1;\n        }\n        while ( length > bin.length() ) {\n            bin = \"0\" + bin;\n        }\n        System.out.printf(\"Test string in binary:%n%s%n%n\", bin);\n\n        System.out.printf(\"Name      Size  Bit Pattern%n\");\n        System.out.printf(\"-------- -----  -----------%n\");\n        for ( String code : asciiMap.keySet() ) {\n            List<Integer> pos = asciiMap.get(code);\n            int start = pos.get(0);\n            int end   = pos.get(1);\n            System.out.printf(\"%-8s    %2d  %s%n\", code, end-start+1, bin.substring(start, end+1));\n        }\n\n    }\n\n\n    private static void display(String ascii) {\n        System.out.printf(\"%nDiagram:%n%n\");\n        for ( String s : TEST.split(\"\\\\r\\\\n\") ) {\n            System.out.println(s);\n        }\n    }\n\n    private static void displayMap(Map<String,List<Integer>> asciiMap) {\n        System.out.printf(\"%nDecode:%n%n\");\n\n\n        System.out.printf(\"Name      Size  Start    End%n\");\n        System.out.printf(\"-------- -----  -----  -----%n\");\n        for ( String code : asciiMap.keySet() ) {\n            List<Integer> pos = asciiMap.get(code);\n            System.out.printf(\"%-8s    %2d     %2d     %2d%n\", code, pos.get(1)-pos.get(0)+1, pos.get(0), pos.get(1));\n        }\n\n    }\n\n    private static Map<String,List<Integer>> decode(String ascii) {\n        Map<String,List<Integer>> map = new LinkedHashMap<>();\n        String[] split = TEST.split(\"\\\\r\\\\n\");\n        int size = split[0].indexOf(\"+\", 1) - split[0].indexOf(\"+\");\n        int length = split[0].length() - 1;\n        for ( int i = 1 ; i < split.length ; i += 2 ) {\n            int barIndex = 1;\n            String test = split[i];\n            int next;\n            while ( barIndex < length && (next = test.indexOf(\"|\", barIndex)) > 0 ) {\n                //  List is start and end of code.\n                List<Integer> startEnd = new ArrayList<>();\n                startEnd.add((barIndex/size) + (i/2)*(length/size));\n                startEnd.add(((next-1)/size) + (i/2)*(length/size));\n                String code = test.substring(barIndex, next).replace(\" \", \"\");\n                map.put(code, startEnd);\n                //  Next bar\n                barIndex = next + 1;\n            }\n        }\n\n        return map;\n    }\n\n    private static void validate(String ascii) {\n        String[] split = TEST.split(\"\\\\r\\\\n\");\n        if ( split.length % 2 != 1 ) {\n            throw new RuntimeException(\"ERROR 1:  Invalid number of input lines.  Line count = \" + split.length);\n        }\n        int size = 0;\n        for ( int i = 0 ; i < split.length ; i++ ) {\n            String test = split[i];\n            if ( i % 2 == 0 ) {\n                //  Start with +, an equal number of -, end with +\n                if ( ! test.matches(\"^\\\\+([-]+\\\\+)+$\") ) {\n                    throw new RuntimeException(\"ERROR 2:  Improper line format.  Line = \" + test);\n                }\n                if ( size == 0 ) {\n                    int firstPlus = test.indexOf(\"+\");\n                    int secondPlus = test.indexOf(\"+\", 1);\n                    size = secondPlus - firstPlus;\n                }\n                if ( ((test.length()-1) % size) != 0 ) {\n                    throw new RuntimeException(\"ERROR 3:  Improper line format.  Line = \" + test);\n                }\n                //  Equally spaced splits of +, -\n                for ( int j = 0 ; j < test.length()-1 ; j += size ) {\n                    if ( test.charAt(j) != '+' ) {\n                        throw new RuntimeException(\"ERROR 4:  Improper line format.  Line = \" + test);\n                    }\n                    for ( int k = j+1 ; k < j + size ; k++ ) {\n                        if ( test.charAt(k) != '-' ) {\n                            throw new RuntimeException(\"ERROR 5:  Improper line format.  Line = \" + test);\n                        }\n                    }\n                }\n            }\n            else {\n                //  Vertical bar, followed by optional spaces, followed by name, followed by optional spaces, followed by vdrtical bar\n                if ( ! test.matches(\"^\\\\|(\\\\s*[A-Za-z]+\\\\s*\\\\|)+$\") ) {\n                    throw new RuntimeException(\"ERROR 6:  Improper line format.  Line = \" + test);\n                }\n                for ( int j = 0 ; j < test.length()-1 ; j += size ) {\n                    for ( int k = j+1 ; k < j + size ; k++ ) {\n                        //  Vertical bar only at boundaries\n                        if ( test.charAt(k) == '|' ) {\n                            throw new RuntimeException(\"ERROR 7:  Improper line format.  Line = \" + test);\n                        }\n                    }\n                }\n\n            }\n        }\n    }\n\n}\n"
                },
                {
                    "language": "Tcl",
                    "solution": "namespace eval asciipacket {\n    proc assert {expr} {    ;# for \"static\" assertions that throw nice errors\n        if {![uplevel 1 [list expr $expr]]} {\n            raise {ASSERT ERROR} \"{$expr} {[subst -noc $expr]}\"\n        }\n    }\n\n    proc b2h {data} {       ;# format a binary string in hex digits\n        binary scan $data H* hex; set hex\n    }\n\n    proc parse {s} {\n        set result {}                       ;# we will return a dictionary\n        set s [string trim $s]              ;# remove whitespace\n        set s [split $s \\n]                 ;# split into lines\n        set s [lmap x $s {string trim $x}]  ;# trim whitespace from each line\n        set s [lassign $s border0]          ;# pop off top border row\n                                            ;# calculate chars per row, chars per bit\n        set rowlen [llength [string map {+ \\ } $border0]]\n        set bitlen [expr {([string length $border0] - 1) / $rowlen}]\n        assert {$bitlen * $rowlen + 1 == [string length $border0]}\n\n        foreach {row border} $s {\n            assert {$border eq $border0}\n            set row [string trim $row |]\n            foreach field [split $row |] {\n                set len [string length |$field]\n                assert {$len % $bitlen == 0}\n                set name [string trim $field]\n                set nbits [expr {$len / $bitlen}]\n                assert {![dict exists $result $name]}\n                dict set result $name $nbits\n            }\n        }\n        return $result\n    }\n\n    proc encode {schema values} {\n        set bincodes {1 B 8 c 16 S 32 W}    ;# see binary(n)\n        set binfmt \"\"                       ;# format string\n        set binargs \"\"                      ;# positional args\n        dict for {name bitlen} $schema {\n            set val [dict get $values $name]\n            if {[dict exists $bincodes $bitlen]} {\n                set fmt \"[dict get $bincodes $bitlen]\"\n            } else {\n                set val [format %0${bitlen}b $val]\n                set fmt \"B${bitlen}\"\n            }\n            append binfmt $fmt\n            lappend binargs $val\n        }\n        binary format $binfmt {*}$binargs\n    }\n\n\n    proc decode {schema data} {\n        set result   {}                     ;# we will return a dict\n        set bincodes {1 B 8 c 16 S 32 W}    ;# see binary(n)\n        set binfmt   \"\"                     ;# format string\n        set binargs  \"\"                     ;# positional args\n        dict for {name bitlen} $schema {\n            if {[dict exists $bincodes $bitlen]} {\n                set fmt \"[dict get $bincodes $bitlen]u\" ;# note unsigned\n            } else {\n                set fmt \"B${bitlen}\"\n            }\n            append binfmt $fmt\n            lappend binargs $name\n        }\n        binary scan $data $binfmt {*}$binargs\n        foreach _ $binargs {\n            dict set result $_ [set $_]\n        }\n        return $result\n    }\n}\n"
                }
            ],
            [
                {
                    "language": "Raku",
                    "solution": "grammar RFC1025 {\n    rule  TOP {  <.line-separator> [<line> <.line-separator>]+ }\n    rule  line-separator { <.ws> '+--'+ '+' }\n    token line  { <.ws> '|' +%% <field>  }\n    token field  { \\s* <label> \\s* }\n    token label { \\w+[\\s+\\w+]* }\n}\n\nsub bits ($item) { ($item.chars + 1) div 3 }\n\nsub deconstruct ($bits, %struct) {\n    map { $bits.substr(.<from>, .<bits>) }, @(%struct<fields>);\n}\n\nsub interpret ($header) {\n    my $datagram = RFC1025.parse($header);\n    my %struct;\n    for $datagram.<line> -> $line {\n        FIRST %struct<line-width> = $line.&bits;\n        state $from = 0;\n        %struct<fields>.push: %(:bits(.&bits), :ID(.<label>.Str), :from($from.clone), :to(($from+=.&bits)-1))\n          for $line<field>;\n    }\n    %struct\n}\n\nuse experimental :pack;\n\nmy $diagram = q:to/END/;\n\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n    |                      ID                       |\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n    |QR|   Opcode  |AA|TC|RD|RA|   Z    |   RCODE   |\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n    |                    QDCOUNT                    |\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n    |                    ANCOUNT                    |\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n    |                    NSCOUNT                    |\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n    |                    ARCOUNT                    |\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\nEND\n\nmy %structure = interpret($diagram);\n\nsay 'Line width: ', %structure<line-width>, ' bits';\nprintf(\"Name: %7s, bit count: %2d, bit %2d to bit %2d\\n\", .<ID>, .<bits>, .<from>, .<to>) for @(%structure<fields>);\nsay \"\\nGenerate a random 12 byte \\\"header\\\"\";\nsay my $buf = Buf.new((^0xFF .roll) xx 12);\nsay \"\\nShow it converted to a bit string\";\nsay my $bitstr = $buf.unpack('C*')\u00c2\u00bb.fmt(\"%08b\").join;\nsay \"\\nAnd unpack it\";\nprintf(\"%7s, %02d bits: %s\\n\", %structure<fields>[$_]<ID>,  %structure<fields>[$_]<bits>,\n  deconstruct($bitstr, %structure)[$_]) for ^@(%structure<fields>);\n"
                },
                {
                    "language": "C++",
                    "solution": "    static constexpr char missingFieldArt[] = R\"(\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n    |                      ID                       |\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n    |QR|   Opcode  |AA|TC|RD|RA|    Z   |   RCODE   |\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n    |                    QDCOUNT                    |\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n    |                                               |\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n    |                    NSCOUNT                    |\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n    |                    ARCOUNT                    |\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+)\";\n"
                }
            ],
            [
                {
                    "language": "Tcl",
                    "solution": "namespace eval asciipacket {\n    proc assert {expr} {    ;# for \"static\" assertions that throw nice errors\n        if {![uplevel 1 [list expr $expr]]} {\n            raise {ASSERT ERROR} \"{$expr} {[subst -noc $expr]}\"\n        }\n    }\n\n    proc b2h {data} {       ;# format a binary string in hex digits\n        binary scan $data H* hex; set hex\n    }\n\n    proc parse {s} {\n        set result {}                       ;# we will return a dictionary\n        set s [string trim $s]              ;# remove whitespace\n        set s [split $s \\n]                 ;# split into lines\n        set s [lmap x $s {string trim $x}]  ;# trim whitespace from each line\n        set s [lassign $s border0]          ;# pop off top border row\n                                            ;# calculate chars per row, chars per bit\n        set rowlen [llength [string map {+ \\ } $border0]]\n        set bitlen [expr {([string length $border0] - 1) / $rowlen}]\n        assert {$bitlen * $rowlen + 1 == [string length $border0]}\n\n        foreach {row border} $s {\n            assert {$border eq $border0}\n            set row [string trim $row |]\n            foreach field [split $row |] {\n                set len [string length |$field]\n                assert {$len % $bitlen == 0}\n                set name [string trim $field]\n                set nbits [expr {$len / $bitlen}]\n                assert {![dict exists $result $name]}\n                dict set result $name $nbits\n            }\n        }\n        return $result\n    }\n\n    proc encode {schema values} {\n        set bincodes {1 B 8 c 16 S 32 W}    ;# see binary(n)\n        set binfmt \"\"                       ;# format string\n        set binargs \"\"                      ;# positional args\n        dict for {name bitlen} $schema {\n            set val [dict get $values $name]\n            if {[dict exists $bincodes $bitlen]} {\n                set fmt \"[dict get $bincodes $bitlen]\"\n            } else {\n                set val [format %0${bitlen}b $val]\n                set fmt \"B${bitlen}\"\n            }\n            append binfmt $fmt\n            lappend binargs $val\n        }\n        binary format $binfmt {*}$binargs\n    }\n\n\n    proc decode {schema data} {\n        set result   {}                     ;# we will return a dict\n        set bincodes {1 B 8 c 16 S 32 W}    ;# see binary(n)\n        set binfmt   \"\"                     ;# format string\n        set binargs  \"\"                     ;# positional args\n        dict for {name bitlen} $schema {\n            if {[dict exists $bincodes $bitlen]} {\n                set fmt \"[dict get $bincodes $bitlen]u\" ;# note unsigned\n            } else {\n                set fmt \"B${bitlen}\"\n            }\n            append binfmt $fmt\n            lappend binargs $name\n        }\n        binary scan $data $binfmt {*}$binargs\n        foreach _ $binargs {\n            dict set result $_ [set $_]\n        }\n        return $result\n    }\n}\n"
                },
                {
                    "language": "AArch64-Assembly",
                    "solution": "/* ARM assembly AARCH64 Raspberry PI 3B or android 64 bits */\n/*  program asciiDiagram64.s   */\n\n/*******************************************/\n/* Constantes file                         */\n/*******************************************/\n/* for this file see task include a file in language AArch64 assembly*/\n.include \"../includeConstantesARM64.inc\"\n\n/*******************************************/\n/* Structures                               */\n/********************************************/\n/* Structure result  */\n    .struct  0\nres_name:                     //\n    .struct  res_name + 8\nres_startzone:                     //\n    .struct  res_startzone + 8\nres_endzone:                     //\n    .struct  res_endzone + 8\nres_size:                     //\n    .struct  res_size + 8\nres_end:\n\n/*********************************/\n/* Initialized data              */\n/*********************************/\n.data\nszMessDiagram:         .asciz \"Display diagramm :\\n\"\nszMessValBin:          .asciz \"\\nBinary Value  :\\n\"\nszMessValZone:         .asciz \"\\nZones values : \\n\"\nszMessResultTab:       .asciz \"Name @ start @ end @ size @ \\n\"\nszMessSplitZone:       .asciz \"Name @ value : @ \\n\"\n\nszMessErrSep:          .asciz \"Error : no s\u00e9parator in first position of line.\\n\"\nszMessErrlong:         .asciz \"Error : string hexa size not multiple to 4. \\n\"\nszCarriageReturn:      .asciz \"\\n\"\n\nszLine1:   .asciz \"+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\"\n           .equ LGLINE,  . - szLine1\nszLine2:   .asciz \"|                      ID                       |\"\nszLine3:   .asciz \"+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\"\nszLine4:   .asciz \"|QR|   Opcode  |AA|TC|RD|RA|   Z    |   RCODE   |\"\nszLine5:   .asciz \"+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\"\nszLine6:   .asciz \"|                    QDCOUNT                    |\"\nszLine7:   .asciz \"+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\"\nszLine8:   .asciz \"|                    ANCOUNT                    |\"\nszLine9:   .asciz \"+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\"\nszLine10:  .asciz \"|                    NSCOUNT                    |\"\nszLine11:  .asciz \"+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\"\nszLine12:  .asciz \"|                    ARCOUNT                    |\"\nszLine13:  .asciz \"+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\"\n           .equ NBLINES,  (. - szLine1) /  LGLINE\nbSeparator:  .byte '|'\n\nszValueHex:    .asciz \"78477bbf5496e12e1bf169a4\"\nszValueHexTest: .asciz \"0ABCDEFabcdef123\"\n/*********************************/\n/* UnInitialized data            */\n/*********************************/\n.bss\nsZoneConv:        .skip 24\ntbZones:          .skip res_end * NBLINES * 5\nsBuffer:          .skip 100\n/*********************************/\n/*  code section                 */\n/*********************************/\n.text\n.global main\nmain:                                 // entry of program\n    ldr x0,qAdrszMessDiagram\n    bl affichageMess\n    ldr x1,qAdrszLine1\n    mov x3,#LGLINE\n    mov x2,#0\n1:                                    // display diagram lines\n    madd x0,x2,x3,x1\n    bl affichageMess\n    ldr x0,qAdrszCarriageReturn\n    bl affichageMess\n    add x2,x2,#1\n    cmp x2,#NBLINES\n    blt 1b\n\n    ldr x0,qAdrszLine1          // first line address of diagram\n    bl decode                   // decode the diagram\n    mov x8,x0                   // save result number\n    mov x3,#0                   // indice\n    mov x4,#res_end             // one result size\n    ldr x5,qAdrtbZones          // table result address\n2:\n    madd x6,x3,x4,x5             // compute result offset\n    ldr x1,[x6,#res_name]       // zone name\n    ldr x0,qAdrszMessResultTab\n    bl strInsertAtCharInc       // insertion in message\n    mov x7,x0\n    ldr x0,[x6,#res_startzone]\n    ldr x1,qAdrsZoneConv\n    bl conversion10             // call decimal conversion\n    mov x0,x7\n    ldr x1,qAdrsZoneConv        // insert value conversion in message\n    bl strInsertAtCharInc\n    mov x7,x0\n    ldr x0,[x6,#res_endzone]\n    ldr x1,qAdrsZoneConv        // else display odd message\n    bl conversion10             // call decimal conversion\n    mov x0,x7\n    ldr x1,qAdrsZoneConv        // insert value conversion in message\n    bl strInsertAtCharInc\n    mov x7,x0\n    ldr x0,[x6,#res_size]\n    ldr x1,qAdrsZoneConv        // else display odd message\n    bl conversion10             // call decimal conversion\n    mov x0,x7\n    ldr x1,qAdrsZoneConv        // insert value conversion in message\n    bl strInsertAtCharInc\n    mov x7,x0\n    bl affichageMess\n    bl libererPlace             // liberation heap area\n    add x3,x3,#1\n    cmp x3,x8\n    blt 2b\n\n    ldr x0,qAdrtbZones\n    ldr x1,qAdrszValueHex\n    //ldr x1,qAdrszValueHexTest\n    bl extractValue             // convert string value hexa in binary string\n    mov x7,x0                   // string binary address\n    ldr x0,qAdrszMessValZone\n    bl affichageMess\n\n    mov x0,x7\n    ldr x1,qAdrtbZones\n    mov x2,x8                    // result number\n    bl splitZone\n\n100:                             // standard end of the program\n    mov x0, #0                   // return code\n    mov x8, #EXIT                // request to exit program\n    svc #0                       // perform the system call\n\nqAdrszCarriageReturn:     .quad szCarriageReturn\nqAdrszMessResultTab:      .quad szMessResultTab\nqAdrszMessDiagram:        .quad szMessDiagram\nqAdrszMessValZone:        .quad szMessValZone\nqAdrsZoneConv:            .quad sZoneConv\nqAdrszLine1:              .quad szLine1\nqAdrszValueHex:           .quad szValueHex\nqAdrszValueHexTest:       .quad szValueHexTest\n/***************************************************/\n/*     decode lines                                */\n/***************************************************/\n// x0 contains diagram address\n// x0 return result counter\ndecode:\n    stp x1,lr,[sp,-16]!         // save  registres\n    stp x2,x3,[sp,-16]!         // save  registres\n    stp x4,x5,[sp,-16]!         // save  registres\n    stp x6,x7,[sp,-16]!         // save  registres\n    mov x5,x0\n    mov x7,#LGLINE           // size line diagram\n    ldr x3,qAdrbSeparator    // s\u00e9parator\n    ldrb w3,[x3]\n    ldr x1,qAdrtbZones       // result table address\n    mov x2,#0                // result counter\n    mov x6,#1                // line 2\n1:\n    madd x0,x6,x7,x5         // compute line offset\n    ldrb w4,[x0]             // load one byte\n    cmp w4,w3                // separator ?\n    bne 99f                  // no -> error\n    bl decodeOneLine         // decode a line\n    mov x2,x0                // new result number\n    add x6,x6,#2             // new line\n    cmp x6,#NBLINES          // end ?\n    blt 1b\n\n    mov x0,x2                // return result counter\n    b 100f\n99:\n    ldr x0,qAdrszMessErrSep\n    bl affichageMess\n    mov x0,#-1\n100:\n    ldp x6,x7,[sp],16         // restaur des  2 registres\n    ldp x4,x5,[sp],16         // restaur des  2 registres\n    ldp x2,x3,[sp],16         // restaur des  2 registres\n    ldp x1,lr,[sp],16         // restaur des  2 registres\n    ret\nqAdrbSeparator:            .quad bSeparator\nqAdrszMessErrSep:          .quad szMessErrSep\nqAdrtbZones:               .quad tbZones\n/***************************************************/\n/*     decode one line               */\n/***************************************************/\n// x0 contains line diagram address\n// x1 contains table result\n// x2 contains result number\n// x3 contains s\u00e9parator\n// x0 return new result number\ndecodeOneLine:\n    stp x1,lr,[sp,-16]!         // save  registres\n    stp x2,x3,[sp,-16]!         // save  registres\n    stp x4,x5,[sp,-16]!         // save  registres\n    stp x6,x7,[sp,-16]!         // save  registres\n    stp x8,x9,[sp,-16]!         // save  registres\n    stp x10,x11,[sp,-16]!         // save  registres\n    stp x12,x13,[sp,-16]!         // save  registres\n    mov x11,x0          // save address diagram\n    mov x7,x1           // save address table result\n    mov x4,x2           // save result counter\n    mov x0,#0           // zone size\n    mov x5,#-1          // name text begin address\n    mov x6,x3           // s\u00e9parator\n    mov x8,#res_end\n    mov x10,#0          // zone start\n    mov x12,#1          // character indice\n1:\n    ldrb w1,[x11,x12]   // load one byte\n    cmp w1,#0           // line end ?\n    beq 10f\n    cmp w1,w6           // separator ?\n    beq 3f\n    cmp w1,#' '         // space ?\n    bne 2f\n    cmp x5,#0           // text name found ?\n    mov x1,#0\n    blt 11f\n    strb w1,[x11,x12]   // yes -> 0 final text\n11:\n    add x0,x0,#1        // increment zone size\n    add x12,x12,#1      // new byte\n    b 1b                // and loop\n2:\n    cmp x5,#0           // text name found ?\n    add x1,x11,x12      // no -> start zone\n    csel x5,x1,x5,lt\n    add x0,x0,#1        // increment zone size\n    add x12,x12,#1      // new byte\n    b 1b                // and loop\n3:                      // separator\n    cmp x5,#0           // zone name ?\n    blt 31f\n    mov x1,#0\n    strb w1,[x11,x12] // yes -> 0 final\n31:\n    madd x9,x4,x8,x7     // compute result offset\n    str x5,[x9,#res_name] // store address start name\n    add x0,x0,#1        // compute zone size\n    cmp x0,#3\n    mov x1,#2\n    mov x5,#3\n    csel x1,x5,x1,gt\n    udiv x2,x0,x1    // / by size characters zone\n    str x2,[x9,#res_size]\n    cmp x4,#0           // first result ?\n    csel x10,xzr,x10,eq\n    beq 4f\n    sub x10,x9,x8       // else start zone = prev end zone + 1\n    ldr x10,[x10,#res_endzone]\n    add x10,x10,#1\n4:\n    str x10,[x9,#res_startzone]\n    add x10,x10,x2      // end zone = start zone + size - 1\n    sub x10,x10,#1\n    str x10,[x9,#res_endzone]\n    add x4,x4,#1        // increment counter result\n    mov x0,#0           // raz size zone\n    add x10,x10,#1      // next byte\n    mov x5,#-1          // no text name\n    add x12,x12,#1      // next byte\n    b 1b                // and loop\n10:\n    mov x0,x4           // return result counter\n100:\n    ldp x12,x13,[sp],16         // restaur des  2 registres\n    ldp x10,x11,[sp],16         // restaur des  2 registres\n    ldp x8,x9,[sp],16         // restaur des  2 registres\n    ldp x6,x7,[sp],16         // restaur des  2 registres\n    ldp x4,x5,[sp],16         // restaur des  2 registres\n    ldp x2,x3,[sp],16         // restaur des  2 registres\n    ldp x1,lr,[sp],16         // restaur des  2 registres\n    ret\n/***************************************************/\n/*     convert strinh value hexa in binary string   */\n/***************************************************/\n// x0 contains diagram address\n// x1 contains string hex value\nextractValue:\n    stp x1,lr,[sp,-16]!         // save  registres\n    stp x2,x3,[sp,-16]!         // save  registres\n    stp x4,x5,[sp,-16]!         // save  registres\n    stp x6,x7,[sp,-16]!         // save  registres\n    stp x8,x9,[sp,-16]!         // save  registres\n    mov x5,x0                   // save address\n    ldr x0,qAdrszMessValBin\n    bl affichageMess\n    mov x6,x1                   // save address string hexa\n    mov x2,#0\n    mov x3,#0\n1:                              // compute string size\n    ldrb w4,[x1,x2]             // load byte\n    cmp w4,#0                   // end string ?\n    cinc x2,x2,ne\n    bne 1b\n    lsr x8,x2,#2                // control if multiple of 4\n    lsl x3,x8,#2\n    cmp x3,x2\n    bne 99f                     // no -> error\n    lsl x0,x2,#3                // compute size string * 8\n    add x0,x0,#1                // zero final\n    bl reserverPlace            // reserve array on the heap\n    mov x7,x0                   // address of heap array\n    mov x1,x0                   // for routine\n    mov x0,x6                   // address string value hexa\n    bl conversionBin            // conversion string hexa -> binary\n    mov x0,x7\n    bl affichageMess\n    ldr x0,qAdrszCarriageReturn\n    bl affichageMess\n\n    mov x0,x7                   // return address string binary\n    b 100f\n99:\n    ldr x0,qAdrszMessErrlong\n    bl affichageMess\n    mov x0,#-1\n100:\n    ldp x8,x9,[sp],16         // restaur des  2 registres\n    ldp x6,x7,[sp],16         // restaur des  2 registres\n    ldp x4,x5,[sp],16         // restaur des  2 registres\n    ldp x2,x3,[sp],16         // restaur des  2 registres\n    ldp x1,lr,[sp],16         // restaur des  2 registres\n    ret\nqAdrszMessValBin:       .quad szMessValBin\nqAdrszMessErrlong:      .quad szMessErrlong\n/***************************************************/\n/*     decode lines               */\n/***************************************************/\n// x0 contains address string binary\n// x1 contains table zones address\n// x2 contains result number\nsplitZone:\n    stp x1,lr,[sp,-16]!         // save  registres\n    stp x2,x3,[sp,-16]!         // save  registres\n    stp x4,x5,[sp,-16]!         // save  registres\n    stp x6,x7,[sp,-16]!         // save  registres\n    stp x8,x9,[sp,-16]!         // save  registres\n    stp x10,x11,[sp,-16]!         // save  registres\n    stp x12,x13,[sp,-16]!         // save  registres\n    mov x5,x0\n    mov x6,x1\n    mov x3,#0                // indice table\n    mov x4,#0                // indice string\n    mov x8,#res_end\n1:                           // loop\n    madd x7,x3,x8,x6          // compute result offset\n    ldr x0,[x7,#res_startzone]\n    ldr x1,[x7,#res_size]    // zone size\n    ldr x12,qAdrsBuffer\n    mov x9,#0\n    add x0,x0,x5\n2:                           // copy bytes\n    ldrb w10,[x0,x9]\n    strb w10,[x12,x9]\n    add x9,x9,#1\n    cmp x9,x1                // zone size maxi ?\n    blt 2b                   // no -> loop\n    mov x10,#0               // 0 final\n    strb w10,[x12,x9]\n                             // dislay name and value\n    ldr x0,qAdrszMessSplitZone\n    ldr x1,[x7,#res_name]\n    bl strInsertAtCharInc\n    mov x1,x12\n    bl strInsertAtCharInc\n    bl affichageMess\n    bl libererPlace\n    add x3,x3,#1\n    cmp x3,x2                // end result ?\n    blt 1b                   //  no -> loop\n100:\n\n    ldp x12,x13,[sp],16         // restaur des  2 registres\n    ldp x10,x11,[sp],16         // restaur des  2 registres\n    ldp x8,x9,[sp],16         // restaur des  2 registres\n    ldp x6,x7,[sp],16         // restaur des  2 registres\n    ldp x4,x5,[sp],16         // restaur des  2 registres\n    ldp x2,x3,[sp],16         // restaur des  2 registres\n    ldp x1,lr,[sp],16         // restaur des  2 registres\n    ret\nqAdrszMessSplitZone:     .quad szMessSplitZone\nqAdrsBuffer:             .quad sBuffer\n/***************************************************/\n/*     conversion chaine hexa en                   */\n/***************************************************/\n// x0 contains string address\n// x1 contains buffer address\nconversionBin:\n    stp x1,lr,[sp,-16]!         // save  registres\n    stp x2,x3,[sp,-16]!         // save  registres\n    stp x4,x5,[sp,-16]!         // save  registres\n    stp x6,x7,[sp,-16]!         // save  registres\n    stp x8,x9,[sp,-16]!         // save  registres\n    mov x2,#0\n    mov x3,#0\n1:\n    ldrb w4,[x0,x2]\n    cmp w4,#0                  // string end\n    beq 10f\n    subs w4,w4,#0x30           // conversion digits\n    blt 5f\n    cmp w4,#10\n    blt 2f                     // digits 0 \u00e0 9 OK\n    cmp w4,#18                 // < A ?\n    blt 5f\n    cmp w4,#24\n    sub w5,w4,#8               // letters A-F\n    csel w4,w5,w4,lt\n    blt 2f\n    cmp w4,#49                 // < a ?\n    blt 5f\n    cmp w4,#54                 // > f ?\n    bgt 5f\n    sub w4,w4,#39              // letters  a-f\n2:                             // x4 contains value on right 4 bits\n    mov x5,#0\n    add x3,x3,#4               // size ' bits\n    sub x7,x3,#1               // store indice\n3:\n    tst x4,#1                  // test first right bit\n    mov x6,#48                 //    character '0'\n    mov x8,#49                 //    character '1'\n    csel x6,x8,x6,ne\n    lsr x4,x4,1\n    strb w6,[x1,x7]            // character ->   display zone\n    sub x7,x7,#1               // prev position\n    add x5,x5,#1               // next bit\n    cmp x5,#4                  // end ?\n    blt 3b\n5:                             // loop to next byte\n    add x2,x2,#1\n    b 1b\n10:\n    mov x6,#0\n    strb w6,[x1,x3]            // z\u00e9ro final\n100:\n    ldp x8,x9,[sp],16         // restaur des  2 registres\n    ldp x6,x7,[sp],16         // restaur des  2 registres\n    ldp x4,x5,[sp],16         // restaur des  2 registres\n    ldp x2,x3,[sp],16         // restaur des  2 registres\n    ldp x1,lr,[sp],16         // restaur des  2 registres\n    ret\n/********************************************************/\n/*        File Include fonctions                        */\n/********************************************************/\n/* for this file see task include a file in language AArch64 assembly */\n.include \"../includeARM64.inc\"\n"
                }
            ],
            [
                {
                    "language": "Java",
                    "solution": "import java.math.BigInteger;\nimport java.util.ArrayList;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic class AsciiArtDiagramConverter {\n\n    private static final String TEST = \"+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\\r\\n\" +\n            \"|                      ID                       |\\r\\n\" +\n            \"+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\\r\\n\" +\n            \"|QR|   Opcode  |AA|TC|RD|RA|   Z    |   RCODE   |\\r\\n\" +\n            \"+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\\r\\n\" +\n            \"|                    QDCOUNT                    |\\r\\n\" +\n            \"+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\\r\\n\" +\n            \"|                    ANCOUNT                    |\\r\\n\" +\n            \"+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\\r\\n\" +\n            \"|                    NSCOUNT                    |\\r\\n\" +\n            \"+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\\r\\n\" +\n            \"|                    ARCOUNT                    |\\r\\n\" +\n            \"+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\";\n\n    public static void main(String[] args) {\n        validate(TEST);\n        display(TEST);\n        Map<String,List<Integer>> asciiMap = decode(TEST);\n        displayMap(asciiMap);\n        displayCode(asciiMap, \"78477bbf5496e12e1bf169a4\");\n    }\n\n    private static void displayCode(Map<String,List<Integer>> asciiMap, String hex) {\n        System.out.printf(\"%nTest string in hex:%n%s%n%n\", hex);\n\n        String bin = new BigInteger(hex,16).toString(2);\n\n        //  Zero pad in front as needed\n        int length = 0;\n        for ( String code : asciiMap.keySet() ) {\n            List<Integer> pos = asciiMap.get(code);\n            length += pos.get(1) - pos.get(0) + 1;\n        }\n        while ( length > bin.length() ) {\n            bin = \"0\" + bin;\n        }\n        System.out.printf(\"Test string in binary:%n%s%n%n\", bin);\n\n        System.out.printf(\"Name      Size  Bit Pattern%n\");\n        System.out.printf(\"-------- -----  -----------%n\");\n        for ( String code : asciiMap.keySet() ) {\n            List<Integer> pos = asciiMap.get(code);\n            int start = pos.get(0);\n            int end   = pos.get(1);\n            System.out.printf(\"%-8s    %2d  %s%n\", code, end-start+1, bin.substring(start, end+1));\n        }\n\n    }\n\n\n    private static void display(String ascii) {\n        System.out.printf(\"%nDiagram:%n%n\");\n        for ( String s : TEST.split(\"\\\\r\\\\n\") ) {\n            System.out.println(s);\n        }\n    }\n\n    private static void displayMap(Map<String,List<Integer>> asciiMap) {\n        System.out.printf(\"%nDecode:%n%n\");\n\n\n        System.out.printf(\"Name      Size  Start    End%n\");\n        System.out.printf(\"-------- -----  -----  -----%n\");\n        for ( String code : asciiMap.keySet() ) {\n            List<Integer> pos = asciiMap.get(code);\n            System.out.printf(\"%-8s    %2d     %2d     %2d%n\", code, pos.get(1)-pos.get(0)+1, pos.get(0), pos.get(1));\n        }\n\n    }\n\n    private static Map<String,List<Integer>> decode(String ascii) {\n        Map<String,List<Integer>> map = new LinkedHashMap<>();\n        String[] split = TEST.split(\"\\\\r\\\\n\");\n        int size = split[0].indexOf(\"+\", 1) - split[0].indexOf(\"+\");\n        int length = split[0].length() - 1;\n        for ( int i = 1 ; i < split.length ; i += 2 ) {\n            int barIndex = 1;\n            String test = split[i];\n            int next;\n            while ( barIndex < length && (next = test.indexOf(\"|\", barIndex)) > 0 ) {\n                //  List is start and end of code.\n                List<Integer> startEnd = new ArrayList<>();\n                startEnd.add((barIndex/size) + (i/2)*(length/size));\n                startEnd.add(((next-1)/size) + (i/2)*(length/size));\n                String code = test.substring(barIndex, next).replace(\" \", \"\");\n                map.put(code, startEnd);\n                //  Next bar\n                barIndex = next + 1;\n            }\n        }\n\n        return map;\n    }\n\n    private static void validate(String ascii) {\n        String[] split = TEST.split(\"\\\\r\\\\n\");\n        if ( split.length % 2 != 1 ) {\n            throw new RuntimeException(\"ERROR 1:  Invalid number of input lines.  Line count = \" + split.length);\n        }\n        int size = 0;\n        for ( int i = 0 ; i < split.length ; i++ ) {\n            String test = split[i];\n            if ( i % 2 == 0 ) {\n                //  Start with +, an equal number of -, end with +\n                if ( ! test.matches(\"^\\\\+([-]+\\\\+)+$\") ) {\n                    throw new RuntimeException(\"ERROR 2:  Improper line format.  Line = \" + test);\n                }\n                if ( size == 0 ) {\n                    int firstPlus = test.indexOf(\"+\");\n                    int secondPlus = test.indexOf(\"+\", 1);\n                    size = secondPlus - firstPlus;\n                }\n                if ( ((test.length()-1) % size) != 0 ) {\n                    throw new RuntimeException(\"ERROR 3:  Improper line format.  Line = \" + test);\n                }\n                //  Equally spaced splits of +, -\n                for ( int j = 0 ; j < test.length()-1 ; j += size ) {\n                    if ( test.charAt(j) != '+' ) {\n                        throw new RuntimeException(\"ERROR 4:  Improper line format.  Line = \" + test);\n                    }\n                    for ( int k = j+1 ; k < j + size ; k++ ) {\n                        if ( test.charAt(k) != '-' ) {\n                            throw new RuntimeException(\"ERROR 5:  Improper line format.  Line = \" + test);\n                        }\n                    }\n                }\n            }\n            else {\n                //  Vertical bar, followed by optional spaces, followed by name, followed by optional spaces, followed by vdrtical bar\n                if ( ! test.matches(\"^\\\\|(\\\\s*[A-Za-z]+\\\\s*\\\\|)+$\") ) {\n                    throw new RuntimeException(\"ERROR 6:  Improper line format.  Line = \" + test);\n                }\n                for ( int j = 0 ; j < test.length()-1 ; j += size ) {\n                    for ( int k = j+1 ; k < j + size ; k++ ) {\n                        //  Vertical bar only at boundaries\n                        if ( test.charAt(k) == '|' ) {\n                            throw new RuntimeException(\"ERROR 7:  Improper line format.  Line = \" + test);\n                        }\n                    }\n                }\n\n            }\n        }\n    }\n\n}\n"
                },
                {
                    "language": "J",
                    "solution": "require'strings'\n\nsoul=: -. {.\nnormalize=: [:soul' ',dltb;._2\n\nmask=: 0: _1} '+' = {.\npartition=: '|' = mask #\"1 soul\nlabels=: ;@(([: <@}: <@dltb;._1)\"1~ '|'&=)@soul\nnames=: ;:^:(0 = L.)\n\nunpacker=:1 :0\n  p=. , partition normalize m\n  p #.;.1 (8#2) ,@:#: ]\n)\n\npacker=:1 :0\n  w=. -#;.1 ,partition normalize m\n  _8 (#.\\ ;) w ({. #:)&.> ]\n)\n\ngetter=:1 :0\n  nm=. labels normalize m\n  (nm i. names@[) { ]\n)\n\nsetter=:1 :0\n  q=. ''''\n  n=. q,~q,;:inv labels normalize m\n  1 :('(',n,' i.&names m)}')\n)\n\nstarter=:1 :0\n  0\"0 labels normalize m\n)\n"
                }
            ]
        ]
    },
    {
        "task_name": "Assertions",
        "task_description": "Assertions are a way of breaking out of code when there is an error or an unexpected input. \n\nSome languages throw [[exceptions]] and some treat it as a break point.\n\n\n;Task:\nShow an assertion in your language by asserting that an integer variable is equal to '''42'''.\n<br><br>\n\n",
        "solution_pairs": [
            [
                {
                    "language": "C-sharp",
                    "solution": "Imports System.Diagnostics\n' Note: VB Visual Studio projects have System.Diagnostics imported by default,\n' along with several other namespaces.\n\nModule Program\n    Sub Main()\n        Dim a As Integer = 0\n\n        Console.WriteLine(\"Before\")\n\n        ' Always hit.\n        Trace.Assert(a = 42, \"Trace assertion failed: The Answer was incorrect\")\n\n        Console.WriteLine(\"After Trace.Assert\")\n\n        ' Only hit in debug builds.\n        Debug.Assert(a = 42, \"Debug assertion failed: The Answer was incorrect\")\n\n        Console.WriteLine(\"After Debug.Assert\")\n    End Sub\nEnd Module\n"
                },
                {
                    "language": "PARI-GP",
                    "solution": "if (!equalis(a, 42)) pari_err_BUG(\"this_function_name (expected a = 42)\");\n"
                }
            ],
            [
                {
                    "language": "Racket",
                    "solution": "#lang racket\n\n(define x 80)\n(unless (= x 42)\n  (error \"a is not 42\")) ; will error\n"
                },
                {
                    "language": "Forth",
                    "solution": "variable a\n: assert   a @ 42 <> throw ;\n\n41 a ! assert\n"
                }
            ],
            [
                {
                    "language": "Oforth",
                    "solution": ": testInteger(n, m)\n   assert: [ n isInteger ]\n   assert: [ n 42 == ]\n\n   System.Out \"Assertions are ok, parameters are : \" << n << \", \" << m << cr ;\n"
                },
                {
                    "language": "FBSL",
                    "solution": "#APPTYPE CONSOLE\n\nDECLARE asserter\n\nFUNCTION Assert(expression)\n    DIM cmd AS STRING = \"DIM asserter AS INTEGER = (\" & expression & \")\"\n    EXECLINE(cmd, 1)\n    IF asserter = 0 THEN PRINT \"Assertion: \", expression, \" failed\"\nEND FUNCTION\n\nAssert(\"1<2\")\nAssert(\"1>2\")\n\nPAUSE\n"
                }
            ],
            [
                {
                    "language": "VBScript",
                    "solution": "dim i\ni = 43\nAssert i=42, \"There's got to be more to life than this!\"\n"
                },
                {
                    "language": "M2000-Interpreter",
                    "solution": "Module Assert {\n      \\\\ This is a global object named Rec\n      Global Group Rec {\n      Private:\n            document doc$=\"Error List at \"+date$(today)+\" \"+time$(now)+{\n            }\n      Public:\n            lastfilename$=\"noname.err\"\n            Module Error(a$) {\n                  if a$=\"\" then exit\n                  .doc$<=\"     \"+a$+{\n                  }\n                  flush error\n            }\n            Module Reset {\n                  Clear .doc$\n            }\n            Module Display {\n                  Report  .doc$\n            }\n            Module SaveIt {\n                  .lastfilename$<=replace$(\"/\", \"-\",\"Err\"+date$(today)+str$(now, \"-nn-mm\")+\".err\")\n                  Save.Doc .doc$,.lastfilename$\n            }\n      }\n      Module Checkit {\n            Function Error1 (x) {\n                  if x<10 then  Print \"Normal\" : exit\n                  =130   ' error code\n            }\n            Call Error1(5)\n            Try ok {\n                  Call Error1(100)\n            }\n            If not Ok then Rec.Error Error$ : Flush Error\n\n            Test \"breakpoint A\"   ' open Control form, show code as executed, press next or close it\n\n            Try {\n                  Test\n                  Report \"Run this\"\n                  Error \"Hello\"\n                  Report \"Not run this\"\n            }\n            Rec.Error Error$\n\n            Module Error1 (x) {\n                  if x<10 then  Print \"Normal\" : exit\n                  Error \"Big Error\"\n            }\n            Try ok {\n                   Error1 100\n            }\n            If Error then Rec.Error Error$\n      }\n      Checkit\n      Rec.Display\n      Rec.SaveIt\n      win \"notepad.exe\", dir$+Rec.lastfilename$\n}\nAssert\n"
                }
            ],
            [
                {
                    "language": "Jq",
                    "solution": "def assert(exp; $msg):\n  def m: $msg | if type == \"string\" then . else [.[]] | join(\":\") end;\n  if env.JQ_ASSERT then\n    (exp as $e | if $e then . else . as $in | \"assertion violation @ \\(m) => \\($e)\" | debug | $in end)\n  else . end;\n\ndef assert(exp):\n  if env.JQ_ASSERT then\n    (exp as $e | if $e then . else . as $in | \"assertion violation: \\($e)\" | debug | $in end)\n   else . end;\n\ndef asserteq(x;y;$msg):\n  def m: $msg | if type == \"string\" then . else [.[]] | join(\":\") end;\n  def s: (if $msg then m + \": \" else \"\" end) + \"\\(x) != \\(y)\";\n  if env.JQ_ASSERT then\n     if x == y then .\n     else . as $in | \"assertion violation @ \\(s)\" | debug | $in\n     end\n   else . end;\n"
                },
                {
                    "language": "Scheme",
                    "solution": "(let ((x 42))\n  (assert (and (integer? x) (= x 42))))\n"
                }
            ]
        ]
    },
    {
        "task_name": "Associative-array-Creation",
        "task_description": ";Task:\nThe goal is to create an [[associative array]] (also known as a dictionary, map, or hash).\n\n\nRelated tasks:\n* [[Associative arrays/Iteration]]\n* [[Hash from two arrays]]\n\n\n{{Template:See also lists}}\n<br><br>\n\n",
        "solution_pairs": [
            [
                {
                    "language": "Gosu",
                    "solution": "// empty map\nvar emptyMap = new HashMap<String, Integer>()\n\n// map initialization\nvar map = {\"Scott\"->50, \"Carson\"->40, \"Luca\"->30, \"Kyle\"->38}\n\n// map key/value assignment\nmap[\"Scott\"] = 51\n\n// get a value\nvar x = map[\"Scott\"]\n\n// remove an entry\nmap.remove(\"Scott\")\n\n// loop and maps\nfor(entry in map.entrySet()) {\n  print(\"Key: ${entry.Key}, Value: ${entry.Value}\")\n}\n\n// functional iteration\nmap.eachKey(\\ k ->print(map[k]))\nmap.eachValue(\\ v ->print(v))\nmap.eachKeyAndValue(\\ k, v -> print(\"Key: ${v}, Value: ${v}\"))\nvar filtered = map.filterByValues(\\ v ->v < 50)\n\n// any object can be treated as an associative array\nclass Person {\n  var name: String\n  var age: int\n}\n// access properties on Person dynamically via associative array syntax\nvar scott = new Person()\nscott[\"name\"] = \"Scott\"\nscott[\"age\"] = 29\n"
                },
                {
                    "language": "SQL",
                    "solution": "REM Create a table to associate keys with values\nCREATE TABLE  associative_array ( KEY_COLUMN VARCHAR2(10), VALUE_COLUMN VARCHAR2(100)); .\nREM Insert a Key Value Pair\nINSERT (KEY_COLUMN, VALUE_COLUMN) VALUES ( 'VALUE','KEY');.\nREM Retrieve a key value pair\nSELECT aa.value_column FROM associative_array aa where aa.key_column = 'KEY';\n"
                }
            ],
            [
                {
                    "language": "Java",
                    "solution": "Comparator<String> comparator = new Comparator<String>() {\n    public int compare(String stringA, String stringB) {\n        if (stringA.compareTo(stringB) > 0) {\n            return -1;\n        } else if (stringA.compareTo(stringB) < 0) {\n            return 1;\n        }\n        return 0;\n    }\n};\n"
                },
                {
                    "language": "Ecstasy",
                    "solution": "Map<String, Int> map = new HashMap();\nmap[\"foo\"] = 5;      // or: map.put(\"foo\", 5)\nmap[\"bar\"] = 10;\nmap[\"baz\"] = 15;\nmap[\"foo\"] = 6;      // replaces previous value of 5\n"
                }
            ],
            [
                {
                    "language": "PARI-GP",
                    "solution": "mapput(M, \"key\", \"value\");\nmapput(M, 17, \"different value\");\nmapput(M, \"key2\", Pi);\nmapget(M, \"key2\") \\\\ returns Pi\nmapisdefined(M, \"key3\") \\\\ returns 0\nmapdelete(M, \"key2\");\n"
                },
                {
                    "language": "Rust",
                    "solution": "use std::collections::HashMap;\nfn main() {\n    let mut olympic_medals = HashMap::new();\n    olympic_medals.insert(\"United States\", (1072, 859, 749));\n    olympic_medals.insert(\"Soviet Union\", (473, 376, 355));\n    olympic_medals.insert(\"Great Britain\", (246, 276, 284));\n    olympic_medals.insert(\"Germany\", (252, 260, 270));\n    println!(\"{:?}\", olympic_medals);\n}\n"
                }
            ],
            [
                {
                    "language": "Objective-C",
                    "solution": "NSString *name = [dict objectForKey:@\"name\"];\nunsigned age = [dict objectForKey:@\"age\"] unsignedIntValue];\nid missing = [dict objectForKey:@\"missing\"];\n"
                },
                {
                    "language": "Tcl",
                    "solution": "# Create in bulk\nset d [dict create  foo 5  bar 10  baz 15]\n\n# Create/update one element\ndict set d foo 5\n\n# Access one value\nset value [dict get $d foo]\n\n# Output all values\ndict for {key value} $d {\n    puts $value\n}\n# Alternatively...\nforeach value [dict values $d] {\n    puts $value\n}\n\n# Output the whole dictionary (since it is a Tcl value itself)\nputs $d\n"
                }
            ],
            [
                {
                    "language": "Java",
                    "solution": "Comparator<String> comparator = new Comparator<String>() {\n    public int compare(String stringA, String stringB) {\n        if (stringA.compareTo(stringB) > 0) {\n            return -1;\n        } else if (stringA.compareTo(stringB) < 0) {\n            return 1;\n        }\n        return 0;\n    }\n};\n"
                },
                {
                    "language": "PicoLisp",
                    "solution": "(put 'A 'foo 5)\n(put 'A 'bar 10)\n(put 'A 'baz 15)\n(put 'A 'foo 20)\n\n: (get 'A 'bar)\n-> 10\n\n: (get 'A 'foo)\n-> 20\n\n: (show 'A)\nA NIL\n   foo 20\n   bar 10\n   baz 15\n"
                }
            ]
        ]
    },
    {
        "task_name": "Associative-array-Iteration",
        "task_description": "Show how to iterate over the key-value pairs of an associative array, and print each pair out. \n\nAlso show how to iterate just over the keys, or the values, if there is a separate way to do that in your language.\n\n\n{{Template:See also lists}}\n<br><br>\n\n",
        "solution_pairs": [
            [
                {
                    "language": "FutureBasic",
                    "solution": "void local fn DoIt\n  CFDictionaryRef dict = @{@\"A\":@\"Alpha\", @\"B\":@\"Bravo\", @\"C\":@\"Charlie\", @\"D\":@\"Delta\"}\n  CFStringRef     key\n  CFTypeRef       obj\n\n  EnumeratorRef keyEnumerator = fn DictionaryKeyEnumerator( dict )\n  key = fn EnumeratorNextObject( keyEnumerator )\n  while ( key )\n    print key,dict[key]\n    key = fn EnumeratorNextObject( keyEnumerator )\n  wend\n\n  print\n\n  EnumeratorRef objectEnumerator = fn DictionaryObjectEnumerator( dict )\n  obj = fn EnumeratorNextObject( objectEnumerator )\n  while ( obj )\n    print obj\n    obj = fn EnumeratorNextObject( objectEnumerator )\n  wend\nend fn\n\nfn DoIt\n\nHandleEvents\n"
                },
                {
                    "language": "Babel",
                    "solution": "births ('Roosevelt' 'Kennedy') lumapls ! lsnum !\n"
                }
            ],
            [
                {
                    "language": "LiveCode",
                    "solution": "Keys:\napples\npears\noranges\nbananas\nValues 1:\t3,5,6,none,\nValues2:\t3,none,6,5,\nKey:Values\napples:3\nbananas:none\noranges:6\npears:5\n"
                },
                {
                    "language": "Maple",
                    "solution": "> for i in entries( T ) do print( i) end:\n                                  [1]\n\n                                  [3]\n\n                                  [2]\n"
                }
            ],
            [
                {
                    "language": "PowerShell",
                    "solution": "$h.Keys | ForEach-Object { Write-Host Key: $_ }\n\nforeach ($k in $h.Keys) {\n    Write-Host Key: $k\n}\n"
                },
                {
                    "language": "Scheme",
                    "solution": ";; Create an associative array (hash-table) whose keys are strings:\n(define table (hash-table 'string=?\n  '(\"hello\" . 0) '(\"world\" . 22) '(\"!\" . 999)))\n\n;; Iterate over the table, passing the key and the value of each entry\n;; as arguments to a function:\n(hash-table-for-each\n  table\n  ;; Create by \"partial application\" a function that accepts 2 arguments,\n  ;; the key and the value:\n  (pa$ format #t \"Key = ~a, Value = ~a\\n\"))\n"
                }
            ],
            [
                {
                    "language": "PowerShell",
                    "solution": "$h.Values | ForEach-Object { Write-Host Value: $_ }\n\nforeach ($v in $h.Values) {\n    Write-Host Value: $v\n}\n"
                },
                {
                    "language": "Slate",
                    "solution": "define: #pairs -> ({'hello' -> 1. 'world' -> 2. '!' -> 3. 'another!' -> 3} as: Dictionary).\npairs keysAndValuesDo: [| :key :value |\n  inform: '(k, v) = (' ; key printString ; ', ' ; value printString ; ')'\n].\n\npairs keysDo: [| :key |\n  inform: '(k, v) = (' ; key printString ; ', ' ; (pairs at: key) printString ; ')'\n].\n\npairs do: [| :value |\n  inform: 'value = ' ; value printString\n].\n"
                }
            ],
            [
                {
                    "language": "Ring",
                    "solution": "# Project : Associative array/Iteration\n\nlst = [[\"hello\", 13], [\"world\", 31], [\"!\", 71]]\nfor n = 1 to len(lst)\n    see lst[n][1] + \" : \" + lst[n][2] + nl\nnext\n"
                },
                {
                    "language": "Groovy",
                    "solution": "def map = [lastName: \"Anderson\", firstName: \"Thomas\", nickname: \"Neo\", age: 24, address: \"everywhere\"]\n\nprintln \"Entries:\"\nmap.each { println it }\n\nprintln()\nprintln \"Keys:\"\nmap.keySet().each { println it }\n\nprintln()\nprintln \"Values:\"\nmap.values().each { println it }\n"
                }
            ]
        ]
    },
    {
        "task_name": "Associative-array-Merging",
        "task_description": ";Task:\nDefine two associative arrays, where one represents the following \"base\" data:\n\n::::: {| class=\"wikitable\"\n|+\n| '''Key''' || '''Value'''\n|-\n| \"name\" || \"Rocket Skates\"\n|-\n| \"price\" || 12.75\n|-\n| \"color\" || \"yellow\"\n|}\n\nAnd the other represents \"update\" data:\n\n::::: {| class=\"wikitable\"\n|+\n| '''Key''' || '''Value'''\n|-\n| \"price\" || 15.25\n|-\n| \"color\" || \"red\"\n|-\n| \"year\" || 1974\n|}\n\nMerge these into a new associative array that contains every key found in either of the source ones.  Each key should map to the value in the second (update) table if that exists, or else to the value in the first (base) table.  If possible, do this in a way that does not mutate the original two associative arrays.  Obviously this should be done in a way that would work for any data, not just the specific data given here, but in this example the result should be:\n\n::::: {| class=\"wikitable\"\n|+\n| '''Key''' || '''Value'''\n|-\n| \"name\" || \"Rocket Skates\"\n|-\n| \"price\" || 15.25\n|-\n| \"color\" || \"red\"\n|-\n| \"year\" || 1974\n|}\n<br><br>\n\n",
        "solution_pairs": [
            [
                {
                    "language": "Elixir",
                    "solution": "base = %{name: \"Rocket Skates\", price: 12.75, color: \"yellow\"}\nupdate = %{price: 15.25, color: \"red\", year: 1974}\nresult = Map.merge(base, update)\nIO.inspect(result)\n"
                },
                {
                    "language": "BaCon",
                    "solution": "DECLARE base$, update$, merge$ ASSOC STRING\n\nbase$(\"name\") = \"Rocket Skates\"\nbase$(\"price\") = \"12.75\"\nbase$(\"color\") = \"yellow\"\n\nPRINT \"Base array\"\nFOR x$ IN OBTAIN$(base$)\n    PRINT x$, \" : \", base$(x$)\nNEXT\n\nupdate$(\"price\") = \"15.25\"\nupdate$(\"color\") = \"red\"\nupdate$(\"year\") = \"1974\"\n\nPRINT NL$, \"Update array\"\nFOR x$ IN OBTAIN$(update$)\n    PRINT x$, \" : \", update$(x$)\nNEXT\n\nmerge$() = base$()\nmerge$() = update$()\n\nPRINT NL$, \"Merged array\"\nFOR x$ IN OBTAIN$(merge$)\n    PRINT x$, \" : \", merge$(x$)\nNEXT\n"
                }
            ],
            [
                {
                    "language": "Lua",
                    "solution": "base = {name=\"Rocket Skates\", price=12.75, color=\"yellow\"}\nupdate = {price=15.25, color=\"red\", year=1974}\n\n--[[ clone the base data ]]--\nresult = {}\nfor key,val in pairs(base) do\n    result[key] = val\nend\n\n--[[ copy in the update data ]]--\nfor key,val in pairs(update) do\n    result[key] = val\nend\n\n--[[ print the result ]]--\nfor key,val in pairs(result) do\n    print(string.format(\"%s: %s\", key, val))\nend\n"
                },
                {
                    "language": "VBA",
                    "solution": "Private Type Associative\n    Key As String\n    Value As Variant\nEnd Type\nSub Main_Array_Associative()\nDim BaseArray(2) As Associative, UpdateArray(2) As Associative\n    FillArrays BaseArray, UpdateArray\n    ReDim Result(UBound(BaseArray)) As Associative\n    MergeArray Result, BaseArray, UpdateArray\n    PrintOut Result\nEnd Sub\nPrivate Sub MergeArray(Res() As Associative, Base() As Associative, Update() As Associative)\nDim i As Long, Respons As Long\n    Res = Base\n    For i = LBound(Update) To UBound(Update)\n        If Exist(Respons, Base, Update(i).Key) Then\n            Res(Respons).Value = Update(i).Value\n        Else\n            ReDim Preserve Res(UBound(Res) + 1)\n            Res(UBound(Res)).Key = Update(i).Key\n            Res(UBound(Res)).Value = Update(i).Value\n        End If\n    Next\nEnd Sub\nPrivate Function Exist(R As Long, B() As Associative, K As String) As Boolean\nDim i As Long\n    Do\n        If B(i).Key = K Then\n            Exist = True\n            R = i\n        End If\n        i = i + 1\n    Loop While i <= UBound(B) And Not Exist\nEnd Function\nPrivate Sub FillArrays(B() As Associative, U() As Associative)\n    B(0).Key = \"name\"\n    B(0).Value = \"Rocket Skates\"\n    B(1).Key = \"price\"\n    B(1).Value = 12.75\n    B(2).Key = \"color\"\n    B(2).Value = \"yellow\"\n    U(0).Key = \"price\"\n    U(0).Value = 15.25\n    U(1).Key = \"color\"\n    U(1).Value = \"red\"\n    U(2).Key = \"year\"\n    U(2).Value = 1974\nEnd Sub\nPrivate Sub PrintOut(A() As Associative)\nDim i As Long\n    Debug.Print \"Key\", \"Value\"\n    For i = LBound(A) To UBound(A)\n        Debug.Print A(i).Key, A(i).Value\n    Next i\n    Debug.Print \"-----------------------------\"\nEnd Sub\n"
                }
            ],
            [
                {
                    "language": "Smalltalk",
                    "solution": "base := Dictionary withAssociations:{\n         'name'-> 'Rocket Skates' .\n         'price' -> 12.75 .\n         'color' -> 'yellow' }.\n\nupdate := Dictionary withAssociations:{\n         'price' -> 15.25 .\n         'color' -> 'red' .\n         'year' -> 1974 }.\n\nresult := Dictionary new\n             declareAllFrom:base;\n             declareAllFrom:update.\n\nTranscript showCR: result.\n"
                },
                {
                    "language": "J",
                    "solution": "merge=: ,.    NB. use: update merge original\ncompress=: #\"1~ ~:@:keys\nkeys=: {.\nvalues=: {:\nget=: [: > ((i.~ keys)~ <)~ { values@:]   NB. key get (associative array)\npair=: [: |: <;._2;._2\n"
                }
            ],
            [
                {
                    "language": "AppleScript",
                    "solution": "set baseRecord to {|name|:\"Rocket Skates\", price:12.75, |color|:\"yellow\"}\nset updateRecord to {price:15.25, |color|:\"red\", |year|:1974}\n\nset mergedRecord to updateRecord & baseRecord\nreturn mergedRecord\n"
                },
                {
                    "language": "J",
                    "solution": "merge=: ,.    NB. use: update merge original\ncompress=: #\"1~ ~:@:keys\nkeys=: {.\nvalues=: {:\nget=: [: > ((i.~ keys)~ <)~ { values@:]   NB. key get (associative array)\npair=: [: |: <;._2;._2\n"
                }
            ],
            [
                {
                    "language": "Arturo",
                    "solution": "details: #[name: \"Rocket Skates\" price: 12.75 colour: 'yellow]\nnewDetails: extend details #[price: 15.25 colour: 'red year: 1974]\n\nprint newDetails\n"
                },
                {
                    "language": "REXX",
                    "solution": "/*REXX program merges two associative arrays  (requiring an external list of indices).  */\n$.=                                              /*define default value(s) for arrays.  */\n@.wAAn= 21;      @.wKey= 7;       @.wVal= 7      /*max widths of:  AAname, keys, values.*/\ncall defAA  'base',     \"name Rocket Skates\",   'price 12.75',   \"color yellow\"\ncall defAA  'update',   \"price 15.25\",          \"color red\",     'year 1974'\ncall show   'base'\ncall show   'update'\ncall show   'new'\nexit                                             /*stick a fork in it,  we're all done. */\n/*\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500*/\ndefAA: procedure expose $. @.;  parse arg AAn;      new= 'new'   /*get AA name; set NEW.*/\n         do j=2  to arg();   parse value arg(j)  with  key val   /*obtain key and value.*/\n         $.AAn.key= val                          /*assign a  value  to a  key for AAn.  */\n         if wordpos(key, $.AAN.?keys)==0  then $.AAn.?keys= $.AAn.?keys key\n                                                 /* [\u2191]  add to key list if not in list.*/\n         $.new.key= val                          /*assign a  value  to a  key for \"new\".*/\n         if wordpos(key, $.new.?keys)==0  then $.new.?keys= $.new.?keys key\n                                                 /* [\u2191]  add to key list if not in list.*/\n         @.wKey= max(@.wKey, length(key) )       /*find max width of a name of a  key.  */\n         @.wVal= max(@.wVal, length(val) )       /*  \"   \"    \"    \" \"   \"   \" \"  value.*/\n         @.wAA = max(@.wAAn, length(AAn) )       /*  \"   \"    \"    \" \"   \"   \"    array.*/\n         end   /*j*/\n       return\n/*\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500*/\nshow:  procedure expose $. @.;  parse arg AAn;      say;     _= '\u2550'    /*set title char.*/\n         do j=1  for words($.AAn.?keys)                                /*process keys.  */\n         if j==1  then say  center('associate array', @.wAAn,     _)  ,\n                            center(\"key\"            , @.wKey,     _)  ,\n                            center('value'          , @.wVal + 2, _)\n         key= word($.AAn.?keys, j)                              /*get the name of a key.*/\n         say center(AAn, @.wAAn)  right(key, @.wKey)  $.AAn.key /*show some information.*/\n         end   /*j*/\n       return\n"
                }
            ]
        ]
    },
    {
        "task_name": "Atomic-updates",
        "task_description": ";Task:\nDefine a data type consisting of a fixed number of 'buckets', each containing a nonnegative integer value, which supports operations to:\n# get the current value of any bucket\n# remove a specified amount from one specified bucket and add it to another, preserving the total of all bucket values, and [[wp:Clamping (graphics)|clamping]] the transferred amount to ensure the values remain non-negative\n\n----\n\nIn order to exercise this data type, create one set of buckets, and start three concurrent tasks:\n# As often as possible, pick two buckets and make their values closer to equal.\n# As often as possible, pick two buckets and arbitrarily redistribute their values.\n# At whatever rate is convenient, display (by any means) the total value and, optionally, the individual values of each bucket.\n\n<br>\nThe display task need not be explicit; use of e.g. a debugger or trace tool is acceptable provided it is simple to set up to provide the display.\n\n----\n\nThis task is intended as an exercise in ''atomic'' operations. &nbsp; The sum of the bucket values must be preserved even if the two tasks attempt to perform transfers simultaneously, and a straightforward solution is to ensure that at any time, only one transfer is actually occurring \u00e2\u20ac\u201d that the transfer operation is ''atomic''.\n<br><br>\n\n",
        "solution_pairs": [
            [
                {
                    "language": "Common-Lisp",
                    "solution": "(ql:quickload '(:alexandria :stmx :bordeaux-threads))\n\n(defpackage :atomic-updates\n  (:use :cl))\n\n(in-package :atomic-updates)\n\n(defvar *buckets* nil)\n(defvar *running* nil)\n\n(defun distribute (ratio a b)\n  \"Atomically redistribute the values of buckets A and B by RATIO.\"\n  (stmx:atomic\n   (let* ((sum (+ (stmx:$ a) (stmx:$ b)))\n          (a2 (truncate (* ratio sum))))\n     (setf (stmx:$ a) a2)\n     (setf (stmx:$ b) (- sum a2)))))\n\n(defun runner (ratio-func)\n  \"Continously distribute to two different elements in *BUCKETS* with the\nvalue returned from RATIO-FUNC.\"\n  (loop while *running*\n     do (let ((a (alexandria:random-elt *buckets*))\n              (b (alexandria:random-elt *buckets*)))\n          (unless (eq a b)\n            (distribute (funcall ratio-func) a b)))))\n\n(defun print-buckets ()\n  \"Atomically get the bucket values and print out their metrics.\"\n  (let ((buckets (stmx:atomic (map 'vector 'stmx:$ *buckets*))))\n    (format t \"Buckets: ~a~%Sum: ~a~%\" buckets (reduce '+ buckets))))\n\n(defun scenario ()\n  (setf *buckets* (coerce (loop repeat 20 collect (stmx:tvar 10)) 'vector))\n  (setf *running* t)\n  (bt:make-thread (lambda () (runner (constantly 0.5))))\n  (bt:make-thread (lambda () (runner (lambda () (random 1.0))))))\n"
                },
                {
                    "language": "Zkl",
                    "solution": "class C{\n   const N=10;\n   var [const]\n      buckets=(1).pump(N,List).copy(),  //(1,2,3...)\n      pipe = Thread.Pipe(), cnt=Atomic.Int();\n   fcn init{\n      pipe.write(buckets);\n      \"Initial sum: \".println(values().sum());\n   }\n   fcn transferArb{  // transfer arbitary amount from 1 bucket to another\n      b1:=(0).random(N); b2:=(0).random(N);\n      v:=pipe.read();\n         t:=(0).random(v[b1]); v[b1]=v[b1]-t; v[b2]=v[b2]+t;\n      pipe.write(v);\n      cnt.inc();\n   }\n   fcn transferEq{  // try to make two buckets equal\n      b1:=(0).random(N); b2:=(0).random(N);\n      v:=pipe.read();\n         v1:=v[b1]; v2:=v[b2]; t:=(v1-v2).abs()/2;\n\t if (v1<v2) t = -t;\n\t v[b1]=v1-t; v[b2]=v2+t;\n      pipe.write(v);\n      cnt.inc();\n   }\n   fcn values{\n      v:=pipe.read(); v2:=v.copy(); pipe.write(v);\n      v2;\n   }\n}\n"
                }
            ],
            [
                {
                    "language": "PicoLisp",
                    "solution": "(seed (in \"/dev/urandom\" (rd 8)))\n\n(de *Buckets . 15)   # Number of buckets\n\n# E/R model\n(class +Bucket +Entity)\n(rel key (+Key +Number))   # Key  1 .. *Buckets\n(rel val (+Number))        # Value 1 .. 999\n\n# Create new DB file\n(pool (tmp \"buckets.db\"))\n\n# Create *Buckets buckets with values between 1 and 999\n(for K *Buckets\n   (new T '(+Bucket)  'key K  'val (rand 1 999)) )\n(commit)\n\n# Pick a random bucket\n(de pickBucket ()\n   (db 'key '+Bucket (rand 1 *Buckets)) )\n\n# First process\n(unless (fork)\n   (seed *Pid)                                  # Ensure local random sequence\n   (loop\n      (let (B1 (pickBucket)  B2 (pickBucket))   # Pick two buckets 'B1' and 'B2'\n         (dbSync)                               # Atomic DB operation\n         (let (V1 (; B1 val)  V2 (; B2 val))    # Get current values\n            (cond\n               ((> V1 V2)\n                  (dec> B1 'val)                # Make them closer to equal\n                  (inc> B2 'val) )\n               ((> V2 V1)\n                  (dec> B2 'val)\n                  (inc> B1 'val) ) ) )\n         (commit 'upd)                          # Close transaction\n         (wait 1) ) ) )\n\n# Second process\n(unless (fork)\n   (seed *Pid)                                  # Ensure local random sequence\n   (loop\n      (let (B1 (pickBucket)  B2 (pickBucket))   # Pick two buckets 'B1' and 'B2'\n         (unless (== B1 B2)                     # Found two different ones?\n            (dbSync)                            # Atomic DB operation\n            (let (V1 (; B1 val)  V2 (; B2 val)) # Get current values\n               (cond\n                  ((> V1 V2 0)\n                     (inc> B1 'val)             # Redistribute them\n                     (dec> B2 'val) )\n                  ((> V2 V1 0)\n                     (inc> B2 'val)\n                     (dec> B1 'val) ) ) )\n            (commit 'upd)                       # Close transaction\n            (wait 1) ) ) ) )\n\n# Third process\n(unless (fork)\n   (loop\n      (let Lst (collect 'key '+Bucket)          # Get all buckets\n         (for This Lst                          # Print current values\n            (printsp (: val)) )\n         (prinl                                 # and total sum\n            \"-- Total: \"\n            (sum '((This) (: val)) Lst) ) )\n      (wait 2000) ) )                           # Sleep two seconds\n\n(wait)\n"
                },
                {
                    "language": "Clojure",
                    "solution": "(defn equalize [m a b]\n  (let [{a-val a b-val b} m\n        diff (- a-val b-val)\n        amt (/ diff 2)]\n    (xfer m a b amt)))\n\n(defn randomize [m a b]\n  (let [{a-val a b-val b} m\n        min-val (min a-val b-val)\n        amt (rand-int (- min-val) min-val)]\n    (xfer m a b amt)))\n\n(defn test-conc [f data a b n name]\n  (dotimes [i n]\n    (swap! data f a b)\n    (println (str \"total is \" (reduce + (vals @data)) \" after \" name \" iteration \" i))))\n\n(def thread-eq (Thread. #(test-conc equalize *data* :a :b 1000 \"equalize\")))\n(def thread-rand (Thread. #(test-conc randomize *data* :a :b 1000 \"randomize\")))\n\n(.start thread-eq)\n(.start thread-rand)\n"
                }
            ],
            [
                {
                    "language": "Perl",
                    "solution": "use strict;\nuse 5.10.0;\n\nuse threads 'yield';\nuse threads::shared;\n\nmy @a :shared = (100) x 10;\nmy $stop :shared = 0;\n\nsub pick2 {\n\tmy $i = int(rand(10));\n\tmy $j;\n\t$j = int(rand(10)) until $j != $i;\n\t($i, $j)\n}\n\nsub even {\n\tlock @a;\n\tmy ($i, $j) = pick2;\n\tmy $sum = $a[$i] + $a[$j];\n\t$a[$i] = int($sum / 2);\n\t$a[$j] = $sum - $a[$i];\n}\n\nsub rand_move {\n\tlock @a;\n\tmy ($i, $j) = pick2;\n\n\tmy $x = int(rand $a[$i]);\n\t$a[$i] -= $x;\n\t$a[$j] += $x;\n}\n\nsub show {\n\tlock @a;\n\tmy $sum = 0;\n\t$sum += $_ for (@a);\n\tprintf \"%4d\", $_ for @a;\n\tprint \" total $sum\\n\";\n}\n\nmy $t1 = async { even\t\tuntil $stop }\nmy $t2 = async { rand_move\tuntil $stop }\nmy $t3 = async {\n\tfor (1 .. 10) {\n\t\tshow;\n\t\tsleep(1);\n\t}\n\t$stop = 1;\n};\n\n$t1->join; $t2->join; $t3->join;\n"
                },
                {
                    "language": "Racket",
                    "solution": "#lang racket\n\n(struct bucket (value [lock #:auto])\n  #:auto-value #f\n  #:mutable\n  #:transparent)\n\n(define *buckets* (build-vector 10 (\u03bb (i) (bucket 100))))\n\n(define (show-buckets)\n  (let* ([values (for/list ([b *buckets*]) (bucket-value b))]\n         [total (apply + values)])\n    (append values (list '- total))))\n\n(define *equalizations* 0)\n(define *randomizations* 0)\n(define *blocks* 0)\n\n(define (show-stats)\n  (let ([n (length *log*)]\n        [log (reverse *log*)])\n    (printf \"Equalizations ~a, Randomizations ~a, Transfers: ~a, Blocks ~a\\n\"\n              *equalizations* *randomizations* n *blocks*)\n    (for ([i (in-range 10)])\n      (define j (min (floor (* i (/ n 9))) (sub1 n)))\n      (printf \"~a (~a). \" (add1 i) (add1 j))\n      (displayln (list-ref log j)))))\n\n(define *log* (list (show-buckets)))\n\n(define-syntax-rule (inc! x) (set! x (add1 x)))\n\n(define (get-bucket i) (vector-ref *buckets* i))\n\n(define (get-value i) (bucket-value (get-bucket i)))\n(define (set-value! i v) (set-bucket-value! (get-bucket i) v))\n\n(define (locked? i) (bucket-lock (vector-ref *buckets* i)))\n(define (lock! i v) (set-bucket-lock! (get-bucket i) v))\n(define (unlock! i) (lock! i #f))\n\n(define *clamp-lock* #f)\n\n(define (clamp i j)\n  (cond [*clamp-lock* (inc! *blocks*)\n                      #f]\n        [else (set! *clamp-lock* #t)\n              (let ([result #f]\n                    [g (gensym)])\n                (unless (locked? i)\n                  (lock! i g)\n                  (cond [(locked? j) (unlock! i)]\n                        [else (lock! j g)\n                              (set! result #t)]))\n                (unless result (inc! *blocks*))\n                (set! *clamp-lock* #f)\n                result)]))\n\n(define (unclamp i j)\n  (unlock! i)\n  (unlock! j))\n\n(define (transfer i j amount)\n  (let* ([lock1 (locked? i)]\n         [lock2 (locked? j)]\n         [a (get-value i)]\n         [b (get-value j)]\n         [c (- a amount)]\n         [d (+ b amount)])\n    (cond [(< c 0) (error 'transfer \"Removing too much.\")]\n          [(< d 0) (error 'transfer \"Stealing too much.\")]\n          [(and lock1 (equal? lock1 lock2)) (set-value! i c)\n                                            (set-value! j d)\n                                            (set! *log*\n                                                  (cons (show-buckets) *log*))]\n          [else (error 'transfer \"Lock problem\")])))\n\n(define (equalize i j)\n  (when (clamp i j)\n    (let ([a (get-value i)]\n          [b (get-value j)])\n      (unless (= a b)\n        (transfer i j (if (> a b)\n                          (floor (/ (- a b) 2))\n                          (- (floor (/ (- b a) 2)))))\n        (inc! *equalizations*)))\n        (unclamp i j)))\n\n(define (randomize i j)\n  (when (clamp i j)\n    (let* ([a (get-value i)]\n           [b (get-value j)]\n           [t (+ a b)]\n           [r (if (= t 0) 0 (random t))])\n      (unless (= r 0)\n        (transfer i j (- a r))\n        (inc! *randomizations*)))\n    (unclamp i j)))\n\n(thread (\u03bb () (for ([_ (in-range 500000)]) (equalize (random 10) (random 10)))))\n(thread (\u03bb () (for ([_ (in-range 500000)]) (randomize (random 10) (random 10)))))\n"
                }
            ],
            [
                {
                    "language": "Haskell",
                    "solution": "global mtx\n\nprocedure main(A)\n    nBuckets := integer(A[1]) | 10\n    nShows := integer(A[2]) | 4\n    showBuckets := A[3]\n    mtx := mutex()\n    every !(buckets := list(nBuckets)) := ?100\n\n    thread repeat {\n        every (b1|b2) := ?nBuckets   # OK if same!\n        critical mtx: xfer((buckets[b1] - buckets[b2])/2, b1, b2)\n        }\n    thread repeat {\n        every (b1|b2) := ?nBuckets   # OK if same!\n        critical mtx: xfer(integer(?buckets[b1]), b1, b2)\n        }\n    wait(thread repeat {\n        delay(500)\n        critical mtx: {\n            every (sum := 0) +:= !buckets\n            writes(\"Sum: \",sum)\n            if \\showBuckets then every writes(\" -> \"|right(!buckets, 4))\n            }\n        write()\n        if (nShows -:= 1) <= 0 then break\n        })\nend\n\nprocedure xfer(x,b1,b2)\n    buckets[b1] -:= x\n    buckets[b2] +:= x\nend\n"
                },
                {
                    "language": "Lasso",
                    "solution": "define atomic => thread {\n    data\n        private buckets = staticarray_join(10, void),\n        private lock = 0\n\n    public onCreate => {\n        loop(.buckets->size) => {\n            .`buckets`->get(loop_count) = math_random(0, 1000)\n        }\n    }\n\n    public buckets => .`buckets`\n\n    public bucket(index::integer) => .`buckets`->get(#index)\n\n    public transfer(source::integer, dest::integer, amount::integer) => {\n        #source == #dest\n            ? return\n\n        #amount = math_min(#amount, .`buckets`->get(#source))\n        .`buckets`->get(#source) -= #amount\n        .`buckets`->get(#dest)   += #amount\n    }\n\n    public numBuckets => .`buckets`->size\n\n    public lock => {\n        .`lock` == 1\n            ? return false\n\n        .`lock` = 1\n        return true\n    }\n    public unlock => {\n        .`lock` = 0\n    }\n}\n\nlocal(initial_total) = (with b in atomic->buckets sum #b)\nlocal(total) = #initial_total\n\n// Make 2 buckets close to equal\nlocal(_) = split_thread => {\n    local(bucket1) = math_random(1, atomic->numBuckets)\n    local(bucket2) = math_random(1, atomic->numBuckets)\n    local(value1)  = atomic->bucket(#bucket1)\n    local(value2)  = atomic->bucket(#bucket2)\n\n    if(#value1 >= #value2) => {\n        atomic->transfer(#bucket1, #bucket2, (#value1 - #value2) / 2)\n    else\n        atomic->transfer(#bucket2, #bucket1, (#value2 - #value1) / 2)\n    }\n\n    currentCapture->restart\n}\n\n// Randomly distribute 2 buckets\nlocal(_) = split_thread => {\n    local(bucket1) = math_random(1, atomic->numBuckets)\n    local(bucket2) = math_random(1, atomic->numBuckets)\n    local(value1)  = atomic->bucket(#bucket1)\n\n    atomic->transfer(#bucket1, #bucket2, math_random(1, #value1))\n\n    currentCapture->restart\n}\n\nlocal(buckets)\nwhile(#initial_total == #total) => {\n    sleep(2000)\n    #buckets = atomic->buckets\n    #total   = with b in #buckets sum #b\n    stdoutnl(#buckets->asString + \" -- total: \" + #total)\n}\nstdoutnl(`ERROR: totals no longer match: ` + #initial_total + ', ' + #total)\n"
                }
            ],
            [
                {
                    "language": "Groovy",
                    "solution": "class Buckets {\n\n    def cells = []\n    final n\n\n    Buckets(n, limit=1000, random=new Random()) {\n        this.n = n\n        (0..<n).each {\n            cells << random.nextInt(limit)\n        }\n    }\n\n    synchronized getAt(i) {\n        cells[i]\n    }\n\n    synchronized transfer(from, to, amount) {\n        assert from in (0..<n) && to in (0..<n)\n        def cappedAmt = [cells[from], amount].min()\n        cells[from] -= cappedAmt\n        cells[to] += cappedAmt\n    }\n\n    synchronized String toString() { cells.toString() }\n}\n\ndef random = new Random()\n\ndef buckets = new Buckets(5)\n\ndef makeCloser = { i, j ->\n    synchronized(buckets) {\n        def targetDiff = (buckets[i]-buckets[j]).intdiv(2)\n        if (targetDiff < 0) {\n            buckets.transfer(j, i, -targetDiff)\n        } else {\n            buckets.transfer(i, j, targetDiff)\n        }\n    }\n}\n\ndef randomize = { i, j ->\n    synchronized(buckets) {\n        def targetLimit = buckets[i] + buckets[j]\n        def targetI = random.nextInt(targetLimit + 1)\n        if (targetI < buckets[i]) {\n            buckets.transfer(i, j, buckets[i] - targetI)\n        } else {\n            buckets.transfer(j, i, targetI - buckets[i])\n        }\n    }\n}\n\nThread.start {\n    def start = System.currentTimeMillis()\n    while (start + 10000 > System.currentTimeMillis()) {\n        def i = random.nextInt(buckets.n)\n        def j = random.nextInt(buckets.n)\n        makeCloser(i, j)\n    }\n}\n\nThread.start {\n    def start = System.currentTimeMillis()\n    while (start + 10000 > System.currentTimeMillis()) {\n        def i = random.nextInt(buckets.n)\n        def j = random.nextInt(buckets.n)\n        randomize(i, j)\n    }\n}\n\ndef start = System.currentTimeMillis()\nwhile (start + 10000 > System.currentTimeMillis()) {\n    synchronized(buckets) {\n        def sum = buckets.cells.sum()\n        println \"${new Date()}: checksum: ${sum} buckets: ${buckets}\"\n    }\n    Thread.sleep(500)\n}\n"
                },
                {
                    "language": "Perl",
                    "solution": "use strict;\nuse 5.10.0;\n\nuse threads 'yield';\nuse threads::shared;\n\nmy @a :shared = (100) x 10;\nmy $stop :shared = 0;\n\nsub pick2 {\n\tmy $i = int(rand(10));\n\tmy $j;\n\t$j = int(rand(10)) until $j != $i;\n\t($i, $j)\n}\n\nsub even {\n\tlock @a;\n\tmy ($i, $j) = pick2;\n\tmy $sum = $a[$i] + $a[$j];\n\t$a[$i] = int($sum / 2);\n\t$a[$j] = $sum - $a[$i];\n}\n\nsub rand_move {\n\tlock @a;\n\tmy ($i, $j) = pick2;\n\n\tmy $x = int(rand $a[$i]);\n\t$a[$i] -= $x;\n\t$a[$j] += $x;\n}\n\nsub show {\n\tlock @a;\n\tmy $sum = 0;\n\t$sum += $_ for (@a);\n\tprintf \"%4d\", $_ for @a;\n\tprint \" total $sum\\n\";\n}\n\nmy $t1 = async { even\t\tuntil $stop }\nmy $t2 = async { rand_move\tuntil $stop }\nmy $t3 = async {\n\tfor (1 .. 10) {\n\t\tshow;\n\t\tsleep(1);\n\t}\n\t$stop = 1;\n};\n\n$t1->join; $t2->join; $t3->join;\n"
                }
            ]
        ]
    },
    {
        "task_name": "Attractive-numbers",
        "task_description": "A number is an &nbsp; ''attractive number'' &nbsp; if the number of its prime factors (whether distinct or not) is also prime.\n\n\n;Example:\nThe number &nbsp; '''20''', &nbsp; whose prime decomposition is &nbsp; '''2 &times; 2 &times; 5''', &nbsp; is an &nbsp; ''attractive number'' &nbsp; because the number of its prime factors &nbsp; ('''3''') &nbsp; is also prime.\n\n\n;Task:\nShow sequence items up to &nbsp; '''120'''.\n\n\n;Reference:\n:* &nbsp; The OEIS entry: &nbsp; [[oeis:A063989|A063989: Numbers with a prime number of prime divisors]].\n<br><br>\n\n",
        "solution_pairs": [
            [
                {
                    "language": "C-sharp",
                    "solution": "using System;\n\nnamespace AttractiveNumbers {\n    class Program {\n        const int MAX = 120;\n\n        static bool IsPrime(int n) {\n            if (n < 2) return false;\n            if (n % 2 == 0) return n == 2;\n            if (n % 3 == 0) return n == 3;\n            int d = 5;\n            while (d * d <= n) {\n                if (n % d == 0) return false;\n                d += 2;\n                if (n % d == 0) return false;\n                d += 4;\n            }\n            return true;\n        }\n\n        static int PrimeFactorCount(int n) {\n            if (n == 1) return 0;\n            if (IsPrime(n)) return 1;\n            int count = 0;\n            int f = 2;\n            while (true) {\n                if (n % f == 0) {\n                    count++;\n                    n /= f;\n                    if (n == 1) return count;\n                    if (IsPrime(n)) f = n;\n                } else if (f >= 3) {\n                    f += 2;\n                } else {\n                    f = 3;\n                }\n            }\n        }\n\n        static void Main(string[] args) {\n            Console.WriteLine(\"The attractive numbers up to and including {0} are:\", MAX);\n            int i = 1;\n            int count = 0;\n            while (i <= MAX) {\n                int n = PrimeFactorCount(i);\n                if (IsPrime(n)) {\n                    Console.Write(\"{0,4}\", i);\n                    if (++count % 20 == 0) Console.WriteLine();\n                }\n                ++i;\n            }\n            Console.WriteLine();\n        }\n    }\n}\n"
                },
                {
                    "language": "Maxima",
                    "solution": "attractivep(n):=block(ifactors(n),apply(\"+\",map(second,%%)),if primep(%%) then true)$\nsublist(makelist(i,i,120),attractivep);\n"
                }
            ],
            [
                {
                    "language": "JavaScript",
                    "solution": "(() => {\n    'use strict';\n\n    // attractiveNumbers :: () -> Gen [Int]\n    const attractiveNumbers = () =>\n        // An infinite series of attractive numbers.\n        filter(\n            compose(isPrime, length, primeFactors)\n        )(enumFrom(1));\n\n\n    // ----------------------- TEST -----------------------\n    // main :: IO ()\n    const main = () =>\n        showCols(10)(\n            takeWhile(ge(120))(\n                attractiveNumbers()\n            )\n        );\n\n\n    // ---------------------- PRIMES ----------------------\n\n    // isPrime :: Int -> Bool\n    const isPrime = n => {\n        // True if n is prime.\n        if (2 === n || 3 === n) {\n            return true\n        }\n        if (2 > n || 0 === n % 2) {\n            return false\n        }\n        if (9 > n) {\n            return true\n        }\n        if (0 === n % 3) {\n            return false\n        }\n        return !enumFromThenTo(5)(11)(\n            1 + Math.floor(Math.pow(n, 0.5))\n        ).some(x => 0 === n % x || 0 === n % (2 + x));\n    };\n\n\n    // primeFactors :: Int -> [Int]\n    const primeFactors = n => {\n        // A list of the prime factors of n.\n        const\n            go = x => {\n                const\n                    root = Math.floor(Math.sqrt(x)),\n                    m = until(\n                        ([q, _]) => (root < q) || (0 === (x % q))\n                    )(\n                        ([_, r]) => [step(r), 1 + r]\n                    )([\n                        0 === x % 2 ? (\n                            2\n                        ) : 3,\n                        1\n                    ])[0];\n                return m > root ? (\n                    [x]\n                ) : ([m].concat(go(Math.floor(x / m))));\n            },\n            step = x => 1 + (x << 2) - ((x >> 1) << 1);\n        return go(n);\n    };\n\n\n    // ---------------- GENERIC FUNCTIONS -----------------\n\n    // chunksOf :: Int -> [a] -> [[a]]\n    const chunksOf = n =>\n        xs => enumFromThenTo(0)(n)(\n            xs.length - 1\n        ).reduce(\n            (a, i) => a.concat([xs.slice(i, (n + i))]),\n            []\n        );\n\n\n    // compose (<<<) :: (b -> c) -> (a -> b) -> a -> c\n    const compose = (...fs) =>\n        fs.reduce(\n            (f, g) => x => f(g(x)),\n            x => x\n        );\n\n\n    // enumFrom :: Enum a => a -> [a]\n    function* enumFrom(x) {\n        // A non-finite succession of enumerable\n        // values, starting with the value x.\n        let v = x;\n        while (true) {\n            yield v;\n            v = 1 + v;\n        }\n    }\n\n\n    // enumFromThenTo :: Int -> Int -> Int -> [Int]\n    const enumFromThenTo = x1 =>\n        x2 => y => {\n            const d = x2 - x1;\n            return Array.from({\n                length: Math.floor(y - x2) / d + 2\n            }, (_, i) => x1 + (d * i));\n        };\n\n\n    // filter :: (a -> Bool) -> Gen [a] -> [a]\n    const filter = p => xs => {\n        function* go() {\n            let x = xs.next();\n            while (!x.done) {\n                let v = x.value;\n                if (p(v)) {\n                    yield v\n                }\n                x = xs.next();\n            }\n        }\n        return go(xs);\n    };\n\n\n    // ge :: Ord a => a -> a -> Bool\n    const ge = x =>\n        // True if x >= y\n        y => x >= y;\n\n\n    // justifyRight :: Int -> Char -> String -> String\n    const justifyRight = n =>\n        // The string s, preceded by enough padding (with\n        // the character c) to reach the string length n.\n        c => s => n > s.length ? (\n            s.padStart(n, c)\n        ) : s;\n\n\n    // last :: [a] -> a\n    const last = xs =>\n        // The last item of a list.\n        0 < xs.length ? xs.slice(-1)[0] : undefined;\n\n\n    // length :: [a] -> Int\n    const length = xs =>\n        // Returns Infinity over objects without finite\n        // length. This enables zip and zipWith to choose\n        // the shorter argument when one is non-finite,\n        // like cycle, repeat etc\n        (Array.isArray(xs) || 'string' === typeof xs) ? (\n            xs.length\n        ) : Infinity;\n\n\n    // map :: (a -> b) -> [a] -> [b]\n    const map = f =>\n        // The list obtained by applying f\n        // to each element of xs.\n        // (The image of xs under f).\n        xs => (\n            Array.isArray(xs) ? (\n                xs\n            ) : xs.split('')\n        ).map(f);\n\n\n    // showCols :: Int -> [a] -> String\n    const showCols = w => xs => {\n        const\n            ys = xs.map(str),\n            mx = last(ys).length;\n        return unlines(chunksOf(w)(ys).map(\n            row => row.map(justifyRight(mx)(' ')).join(' ')\n        ))\n    };\n\n\n    // str :: a -> String\n    const str = x =>\n        x.toString();\n\n\n    // takeWhile :: (a -> Bool) -> Gen [a] -> [a]\n    const takeWhile = p => xs => {\n        const ys = [];\n        let\n            nxt = xs.next(),\n            v = nxt.value;\n        while (!nxt.done && p(v)) {\n            ys.push(v);\n            nxt = xs.next();\n            v = nxt.value\n        }\n        return ys;\n    };\n\n\n    // unlines :: [String] -> String\n    const unlines = xs =>\n        // A single string formed by the intercalation\n        // of a list of strings with the newline character.\n        xs.join('\\n');\n\n\n    // until :: (a -> Bool) -> (a -> a) -> a -> a\n    const until = p => f => x => {\n        let v = x;\n        while (!p(v)) v = f(v);\n        return v;\n    };\n\n    // MAIN ---\n    return main();\n})();\n"
                },
                {
                    "language": "11l",
                    "solution": "F is_prime(n)\n   I n < 2\n      R 0B\n   L(i) 2 .. Int(sqrt(n))\n      I n % i == 0\n         R 0B\n   R 1B\n\nF get_pfct(=n)\n   V i = 2\n   [Int] factors\n   L i * i <= n\n      I n % i\n         i++\n      E\n         n I/= i\n         factors.append(i)\n   I n > 1\n      factors.append(n)\n   R factors.len\n\n[Int] pool\n\nL(each) 0..120\n   pool.append(get_pfct(each))\n\n[Int] r\nL(each) pool\n   I is_prime(each)\n      r.append(L.index)\n\nprint(r.map(String).join(\u2018,\u2019))\n"
                }
            ],
            [
                {
                    "language": "Kotlin",
                    "solution": "// Version 1.3.21\n\nconst val MAX = 120\n\nfun isPrime(n: Int) : Boolean {\n    if (n < 2) return false\n    if (n % 2 == 0) return n == 2\n    if (n % 3 == 0) return n == 3\n    var d : Int = 5\n    while (d * d <= n) {\n        if (n % d == 0) return false\n        d += 2\n        if (n % d == 0) return false\n        d += 4\n    }\n    return true\n}\n\nfun countPrimeFactors(n: Int) =\n    when {\n        n == 1  -> 0\n        isPrime(n) -> 1\n        else -> {\n            var nn = n\n            var count = 0\n            var f = 2\n            while (true) {\n                if (nn % f == 0) {\n                    count++\n                    nn /= f\n                    if (nn == 1) break\n                    if (isPrime(nn)) f = nn\n                } else if (f >= 3) {\n                    f += 2\n                } else {\n                    f = 3\n                }\n            }\n            count\n        }\n    }\n\nfun main() {\n    println(\"The attractive numbers up to and including $MAX are:\")\n    var count = 0\n    for (i in 1..MAX) {\n        val n = countPrimeFactors(i)\n        if (isPrime(n)) {\n            System.out.printf(\"%4d\", i)\n            if (++count % 20 == 0) println()\n        }\n    }\n    println()\n}\n"
                },
                {
                    "language": "Nanoquery",
                    "solution": "MAX = 120\n\ndef is_prime(n)\n\td = 5\n\tif (n < 2)\n\t\treturn false\n\tend\n\tif (n % 2) = 0\n\t\treturn n = 2\n\tend\n\tif (n % 3) = 0\n\t\treturn n = 3\n\tend\n\n\twhile (d * d) <= n\n\t\tif n % d = 0\n\t\t\treturn false\n\t\tend\n\t\td += 2\n\t\tif n % d = 0\n\t\t\treturn false\n\t\tend\n\t\td += 4\n\tend\n\n\treturn true\nend\n\ndef count_prime_factors(n)\n\tcount = 0; f = 2\n\tif n = 1\n\t\treturn 0\n\tend\n\tif is_prime(n)\n\t\treturn 1\n\tend\n\t\n\twhile true\n\t\tif (n % f) = 0\n\t\t\tcount += 1\n\t\t\tn /= f\n\t\t\tif n = 1\n\t\t\t\treturn count\n\t\t\tend\n\t\t\tif is_prime(n)\n\t\t\t\tf = n\n\t\t\tend\n\t\telse if f >= 3\n\t\t\tf += 2\n\t\telse\n\t\t\tf = 3\n\t\tend\n\tend\nend\n\ni = 0; n = 0; count = 0\nprintln format(\"The attractive numbers up to and including %d are:\\n\", MAX)\nfor i in range(1, MAX)\n\tn = count_prime_factors(i)\n\tif is_prime(n)\n\t\tprint format(\"%4d\", i)\n\t\tcount += 1\n\t\tif (count % 20) = 0\n\t\t\tprintln\n\t\tend\n\tend\nend\nprintln\n"
                }
            ],
            [
                {
                    "language": "Ring",
                    "solution": "# Project: Attractive Numbers\n\ndecomp = []\nnump = 0\nsee \"Attractive Numbers up to 120:\" + nl\nwhile nump < 120\ndecomp = []\nnump = nump + 1\nfor i = 1 to nump\n    if isPrime(i) and nump%i = 0\n       add(decomp,i)\n       dec = nump/i\n       while dec%i = 0\n             add(decomp,i)\n             dec = dec/i\n       end\n    ok\nnext\nif isPrime(len(decomp))\n   see string(nump) + \" = [\"\nfor n = 1 to len(decomp)\n    if n < len(decomp)\n       see string(decomp[n]) + \"*\"\n    else\n       see string(decomp[n]) + \"] - \" + len(decomp) + \" is prime\" + nl\n    ok\nnext\nok\nend\n\n\nfunc isPrime(num)\n     if (num <= 1) return 0 ok\n     if (num % 2 = 0) and num != 2 return 0 ok\n     for i = 3 to floor(num / 2) -1 step 2\n         if (num % i = 0) return 0 ok\n     next\n     return 1\n"
                },
                {
                    "language": "Comal",
                    "solution": "0010 FUNC factors#(n#) CLOSED\n0020   count#:=0\n0030   WHILE n# MOD 2=0 DO n#:=n# DIV 2;count#:+1\n0040   fac#:=3\n0050   WHILE fac#<=n# DO\n0060     WHILE n# MOD fac#=0 DO n#:=n# DIV fac#;count#:+1\n0070     fac#:+2\n0080   ENDWHILE\n0090   RETURN count#\n0100 ENDFUNC factors#\n0110 //\n0120 ZONE 4\n0130 seen#:=0\n0140 FOR i#:=2 TO 120 DO\n0150   IF factors#(factors#(i#))=1 THEN\n0160     PRINT i#,\n0170     seen#:+1\n0180     IF seen# MOD 18=0 THEN PRINT\n0190   ENDIF\n0200 ENDFOR i#\n0210 PRINT\n0220 END\n"
                }
            ],
            [
                {
                    "language": "Python",
                    "solution": "'''Attractive numbers'''\n\nfrom itertools import chain, count, takewhile\nfrom functools import reduce\n\n\n# attractiveNumbers :: () -> [Int]\ndef attractiveNumbers():\n    '''A non-finite stream of attractive numbers.\n       (OEIS A063989)\n    '''\n    return filter(\n        compose(\n            isPrime,\n            len,\n            primeDecomposition\n        ),\n        count(1)\n    )\n\n\n# TEST ----------------------------------------------------\ndef main():\n    '''Attractive numbers drawn from the range [1..120]'''\n    for row in chunksOf(15)(list(\n            takewhile(\n                lambda x: 120 >= x,\n                attractiveNumbers()\n            )\n    )):\n        print(' '.join(map(\n            compose(justifyRight(3)(' '), str),\n            row\n        )))\n\n\n# GENERAL FUNCTIONS ---------------------------------------\n\n# chunksOf :: Int -> [a] -> [[a]]\ndef chunksOf(n):\n    '''A series of lists of length n, subdividing the\n       contents of xs. Where the length of xs is not evenly\n       divible, the final list will be shorter than n.\n    '''\n    return lambda xs: reduce(\n        lambda a, i: a + [xs[i:n + i]],\n        range(0, len(xs), n), []\n    ) if 0 < n else []\n\n\n# compose :: ((a -> a), ...) -> (a -> a)\ndef compose(*fs):\n    '''Composition, from right to left,\n       of a series of functions.\n    '''\n    return lambda x: reduce(\n        lambda a, f: f(a),\n        fs[::-1], x\n    )\n\n\n# We only need light implementations\n# of prime functions here:\n\n# primeDecomposition :: Int -> [Int]\ndef primeDecomposition(n):\n    '''List of integers representing the\n       prime decomposition of n.\n    '''\n    def go(n, p):\n        return [p] + go(n // p, p) if (\n            0 == n % p\n        ) else []\n    return list(chain.from_iterable(map(\n        lambda p: go(n, p) if isPrime(p) else [],\n        range(2, 1 + n)\n    )))\n\n\n# isPrime :: Int -> Bool\ndef isPrime(n):\n    '''True if n is prime.'''\n    if n in (2, 3):\n        return True\n    if 2 > n or 0 == n % 2:\n        return False\n    if 9 > n:\n        return True\n    if 0 == n % 3:\n        return False\n\n    return not any(map(\n        lambda x: 0 == n % x or 0 == n % (2 + x),\n        range(5, 1 + int(n ** 0.5), 6)\n    ))\n\n\n# justifyRight :: Int -> Char -> String -> String\ndef justifyRight(n):\n    '''A string padded at left to length n,\n       using the padding character c.\n    '''\n    return lambda c: lambda s: s.rjust(n, c)\n\n\n# MAIN ---\nif __name__ == '__main__':\n    main()\n"
                },
                {
                    "language": "JavaScript",
                    "solution": "(() => {\n    'use strict';\n\n    // attractiveNumbers :: () -> Gen [Int]\n    const attractiveNumbers = () =>\n        // An infinite series of attractive numbers.\n        filter(\n            compose(isPrime, length, primeFactors)\n        )(enumFrom(1));\n\n\n    // ----------------------- TEST -----------------------\n    // main :: IO ()\n    const main = () =>\n        showCols(10)(\n            takeWhile(ge(120))(\n                attractiveNumbers()\n            )\n        );\n\n\n    // ---------------------- PRIMES ----------------------\n\n    // isPrime :: Int -> Bool\n    const isPrime = n => {\n        // True if n is prime.\n        if (2 === n || 3 === n) {\n            return true\n        }\n        if (2 > n || 0 === n % 2) {\n            return false\n        }\n        if (9 > n) {\n            return true\n        }\n        if (0 === n % 3) {\n            return false\n        }\n        return !enumFromThenTo(5)(11)(\n            1 + Math.floor(Math.pow(n, 0.5))\n        ).some(x => 0 === n % x || 0 === n % (2 + x));\n    };\n\n\n    // primeFactors :: Int -> [Int]\n    const primeFactors = n => {\n        // A list of the prime factors of n.\n        const\n            go = x => {\n                const\n                    root = Math.floor(Math.sqrt(x)),\n                    m = until(\n                        ([q, _]) => (root < q) || (0 === (x % q))\n                    )(\n                        ([_, r]) => [step(r), 1 + r]\n                    )([\n                        0 === x % 2 ? (\n                            2\n                        ) : 3,\n                        1\n                    ])[0];\n                return m > root ? (\n                    [x]\n                ) : ([m].concat(go(Math.floor(x / m))));\n            },\n            step = x => 1 + (x << 2) - ((x >> 1) << 1);\n        return go(n);\n    };\n\n\n    // ---------------- GENERIC FUNCTIONS -----------------\n\n    // chunksOf :: Int -> [a] -> [[a]]\n    const chunksOf = n =>\n        xs => enumFromThenTo(0)(n)(\n            xs.length - 1\n        ).reduce(\n            (a, i) => a.concat([xs.slice(i, (n + i))]),\n            []\n        );\n\n\n    // compose (<<<) :: (b -> c) -> (a -> b) -> a -> c\n    const compose = (...fs) =>\n        fs.reduce(\n            (f, g) => x => f(g(x)),\n            x => x\n        );\n\n\n    // enumFrom :: Enum a => a -> [a]\n    function* enumFrom(x) {\n        // A non-finite succession of enumerable\n        // values, starting with the value x.\n        let v = x;\n        while (true) {\n            yield v;\n            v = 1 + v;\n        }\n    }\n\n\n    // enumFromThenTo :: Int -> Int -> Int -> [Int]\n    const enumFromThenTo = x1 =>\n        x2 => y => {\n            const d = x2 - x1;\n            return Array.from({\n                length: Math.floor(y - x2) / d + 2\n            }, (_, i) => x1 + (d * i));\n        };\n\n\n    // filter :: (a -> Bool) -> Gen [a] -> [a]\n    const filter = p => xs => {\n        function* go() {\n            let x = xs.next();\n            while (!x.done) {\n                let v = x.value;\n                if (p(v)) {\n                    yield v\n                }\n                x = xs.next();\n            }\n        }\n        return go(xs);\n    };\n\n\n    // ge :: Ord a => a -> a -> Bool\n    const ge = x =>\n        // True if x >= y\n        y => x >= y;\n\n\n    // justifyRight :: Int -> Char -> String -> String\n    const justifyRight = n =>\n        // The string s, preceded by enough padding (with\n        // the character c) to reach the string length n.\n        c => s => n > s.length ? (\n            s.padStart(n, c)\n        ) : s;\n\n\n    // last :: [a] -> a\n    const last = xs =>\n        // The last item of a list.\n        0 < xs.length ? xs.slice(-1)[0] : undefined;\n\n\n    // length :: [a] -> Int\n    const length = xs =>\n        // Returns Infinity over objects without finite\n        // length. This enables zip and zipWith to choose\n        // the shorter argument when one is non-finite,\n        // like cycle, repeat etc\n        (Array.isArray(xs) || 'string' === typeof xs) ? (\n            xs.length\n        ) : Infinity;\n\n\n    // map :: (a -> b) -> [a] -> [b]\n    const map = f =>\n        // The list obtained by applying f\n        // to each element of xs.\n        // (The image of xs under f).\n        xs => (\n            Array.isArray(xs) ? (\n                xs\n            ) : xs.split('')\n        ).map(f);\n\n\n    // showCols :: Int -> [a] -> String\n    const showCols = w => xs => {\n        const\n            ys = xs.map(str),\n            mx = last(ys).length;\n        return unlines(chunksOf(w)(ys).map(\n            row => row.map(justifyRight(mx)(' ')).join(' ')\n        ))\n    };\n\n\n    // str :: a -> String\n    const str = x =>\n        x.toString();\n\n\n    // takeWhile :: (a -> Bool) -> Gen [a] -> [a]\n    const takeWhile = p => xs => {\n        const ys = [];\n        let\n            nxt = xs.next(),\n            v = nxt.value;\n        while (!nxt.done && p(v)) {\n            ys.push(v);\n            nxt = xs.next();\n            v = nxt.value\n        }\n        return ys;\n    };\n\n\n    // unlines :: [String] -> String\n    const unlines = xs =>\n        // A single string formed by the intercalation\n        // of a list of strings with the newline character.\n        xs.join('\\n');\n\n\n    // until :: (a -> Bool) -> (a -> a) -> a -> a\n    const until = p => f => x => {\n        let v = x;\n        while (!p(v)) v = f(v);\n        return v;\n    };\n\n    // MAIN ---\n    return main();\n})();\n"
                }
            ]
        ]
    },
    {
        "task_name": "Average-loop-length",
        "task_description": "Let <code>f</code> be a uniformly-randomly chosen mapping from the numbers 1..N to the numbers 1..N (note: not necessarily a permutation of 1..N; the mapping could produce a number in more than one way or not at all). At some point, the sequence <code>1, f(1), f(f(1))...</code> will contain a <em>repetition</em>, a number that occurring for the second time in the sequence.\n\n\n;Task:\nWrite a program or a script that estimates, for each <code>N</code>, the average length until the first such repetition.\n\nAlso calculate this expected length using an analytical formula, and optionally compare the simulated result with the theoretical one.\n\n\nThis problem comes from the end of Donald Knuth's [http://www.youtube.com/watch?v=cI6tt9QfRdo Christmas tree lecture 2011].\n\nExample of expected output:\n\n<pre> N    average    analytical    (error)\n===  =========  ============  =========\n  1     1.0000        1.0000  (  0.00%)\n  2     1.4992        1.5000  (  0.05%)\n  3     1.8784        1.8889  (  0.56%)\n  4     2.2316        2.2188  (  0.58%)\n  5     2.4982        2.5104  (  0.49%)\n  6     2.7897        2.7747  (  0.54%)\n  7     3.0153        3.0181  (  0.09%)\n  8     3.2429        3.2450  (  0.07%)\n  9     3.4536        3.4583  (  0.14%)\n 10     3.6649        3.6602  (  0.13%)\n 11     3.8091        3.8524  (  1.12%)\n 12     3.9986        4.0361  (  0.93%)\n 13     4.2074        4.2123  (  0.12%)\n 14     4.3711        4.3820  (  0.25%)\n 15     4.5275        4.5458  (  0.40%)\n 16     4.6755        4.7043  (  0.61%)\n 17     4.8877        4.8579  (  0.61%)\n 18     4.9951        5.0071  (  0.24%)\n 19     5.1312        5.1522  (  0.41%)\n 20     5.2699        5.2936  (  0.45%)</pre>\n<br>\n\n",
        "solution_pairs": [
            [
                {
                    "language": "J",
                    "solution": "   ana=: +/@(!@[ % !@- * ^) 1+i.\n   ana\"0]1 2 3 4 5 6\n1 1.5 1.88889 2.21875 2.5104 2.77469\n"
                },
                {
                    "language": "EasyLang",
                    "solution": "func average n reps .\n   for r to reps\n      f[] = [ ]\n      for i to n\n         f[] &= randint n\n      .\n      seen[] = [ ]\n      len seen[] n\n      x = 1\n      while seen[x] = 0\n         seen[x] = 1\n         x = f[x]\n         count += 1\n      .\n   .\n   return count / reps\n.\nfunc analytical n .\n   s = 1\n   t = 1\n   for i = n - 1 downto 1\n      t = t * i / n\n      s += t\n   .\n   return s\n.\nprint \" N  average analytical (error)\"\nprint \"=== ======= ========== =======\"\nfor n to 20\n   avg = average n 1e6\n   ana = analytical n\n   err = (avg - ana) / ana * 100\n   numfmt 0 2\n   write n\n   numfmt 4 9\n   print avg & ana & err & \"%\"\n.\n"
                }
            ],
            [
                {
                    "language": "J",
                    "solution": "   (+/ % #)@,@((#.inv i.@^~) ([: # (] ~.@, {:@] { [)^:_)\"1 0/ i.)1\n1\n   (+/ % #)@,@((#.inv i.@^~) ([: # (] ~.@, {:@] { [)^:_)\"1 0/ i.)2\n1.5\n   (+/ % #)@,@((#.inv i.@^~) ([: # (] ~.@, {:@] { [)^:_)\"1 0/ i.)3\n1.88889\n   (+/ % #)@,@((#.inv i.@^~) ([: # (] ~.@, {:@] { [)^:_)\"1 0/ i.)4\n2.21875\n   (+/ % #)@,@((#.inv i.@^~) ([: # (] ~.@, {:@] { [)^:_)\"1 0/ i.)5\n2.5104\n   (+/ % #)@,@((#.inv i.@^~) ([: # (] ~.@, {:@] { [)^:_)\"1 0/ i.)6\n2.77469\n"
                },
                {
                    "language": "J",
                    "solution": "   0 0 ([: # (] ~.@, {:@] { [)^:_) 1\n2\n"
                }
            ],
            [
                {
                    "language": "D",
                    "solution": "import std.stdio, std.random, std.math, std.algorithm, std.range, std.format;\n\nreal analytical(in int n) pure nothrow @safe /*@nogc*/ {\n    enum aux = (int k) => reduce!q{a * b}(1.0L, iota(n - k + 1, n + 1));\n    return iota(1, n + 1)\n           .map!(k => (aux(k) * k ^^ 2) / (real(n) ^^ (k + 1)))\n           .sum;\n}\n\nsize_t loopLength(size_t maxN)(in int size, ref Xorshift rng) {\n    __gshared static bool[maxN + 1] seen;\n    seen[0 .. size + 1] = false;\n    int current = 1;\n    size_t steps = 0;\n    while (!seen[current]) {\n        seen[current] = true;\n        current = uniform(1, size + 1, rng);\n        steps++;\n    }\n    return steps;\n}\n\nvoid main() {\n    enum maxN  = 40;\n    enum nTrials = 300_000;\n    auto rng = Xorshift(unpredictableSeed);\n    writeln(\" n    average    analytical     (error)\");\n    writeln(\"===  =========  ============  ==========\");\n\n    foreach (immutable n; 1 .. maxN + 1) {\n        long total = 0;\n        foreach (immutable _; 0 .. nTrials)\n            total += loopLength!maxN(n, rng);\n        immutable average = total / real(nTrials);\n        immutable an = n.analytical;\n        immutable percentError = abs(an - average) / an * 100;\n        immutable errorS = format(\"%2.4f\", percentError);\n        writefln(\"%3d  %9.5f  %12.5f  (%7s%%)\",\n                 n, average, an, errorS);\n    }\n}\n"
                },
                {
                    "language": "Zkl",
                    "solution": "const N=20;\n\n(\" N    average    analytical    (error)\").println();\n(\"===  =========  ============  =========\").println();\nforeach n in ([1..N]){\n   a := avg(n);\n   b := ana(n);\n   \"%3d  %9.4f  %12.4f  (%6.2f%%)\".fmt(\n            n, a, b, ((a-b)/b*100)).println();\n}\n\nfcn f(n){ (0).random(n) }\n\nfcn avg(n){\n   tests := 0d10_000;\n   sum := 0;\n   do(tests){\n      v:=(0).pump(n,List,T(Void,False)).copy();\n      while(1){\n         z := f(n);\n         if(v[z]) break;\n\t v[z] = True;\n\t sum += 1;\n      }\n   }\n   return(sum.toFloat() / tests);\n}\n\nfcn fact(n) { (1).reduce(n,fcn(N,n){N*n},1.0) } //-->Float\nfcn ana(n){\n   n=n.toFloat();\n   (1).reduce(n,'wrap(sum,i){ sum+fact(n)/n.pow(i)/fact(n-i) },0.0);\n}\n"
                }
            ],
            [
                {
                    "language": "Kotlin",
                    "solution": "const val NMAX  = 20\nconst val TESTS = 1000000\nval rand = java.util.Random()\n\nfun avg(n: Int): Double {\n    var sum = 0\n    for (t in 0 until TESTS) {\n        val v = BooleanArray(NMAX)\n        var x = 0\n        while (!v[x]) {\n            v[x] = true\n            sum++\n            x = rand.nextInt(n)\n        }\n    }\n    return sum.toDouble() / TESTS\n}\n\nfun ana(n: Int): Double {\n    val nn = n.toDouble()\n    var term = 1.0\n    var sum = 1.0\n    for (i in n - 1 downTo 1) {\n        term *= i / nn\n        sum += term\n    }\n    return sum\n}\n\nfun main(args: Array<String>) {\n    println(\" N    average    analytical    (error)\")\n    println(\"===  =========  ============  =========\")\n    for (n in 1..NMAX) {\n        val a = avg(n)\n        val b = ana(n)\n        println(String.format(\"%3d   %6.4f   %10.4f      (%4.2f%%)\", n, a, b, Math.abs(a - b) / b * 100.0))\n    }\n}\n"
                },
                {
                    "language": "J",
                    "solution": "   (~.@, {&0 0@{:)^:_] 0\n0\n   (~.@, {&0 0@{:)^:_] 1\n1 0\n"
                }
            ],
            [
                {
                    "language": "PicoLisp",
                    "solution": "(scl 4)\n(seed (in \"/dev/urandom\" (rd 8)))\n\n(de fact (N)\n   (if (=0 N) 1 (apply * (range 1 N))) )\n\n(de analytical (N)\n   (sum\n      '((I)\n         (/\n            (* (fact N) 1.0)\n            (** N I)\n            (fact (- N I)) ) )\n      (range 1 N) ) )\n\n(de testing (N)\n   (let (C 0  N (dec N)  X 0  B 0  I 1000000)\n      (do I\n         (zero B)\n         (one X)\n         (while (=0 (& B X))\n            (inc 'C)\n            (setq\n               B (| B X)\n               X (** 2 (rand 0 N)) ) ) )\n      (*/ C 1.0 I) ) )\n\n(let F (2 8 8 6)\n   (tab F \"N\" \"Avg\" \"Exp\" \"Diff\")\n   (for I 20\n      (let (A (testing I)  B (analytical I))\n         (tab F\n            I\n            (round A 4)\n            (round B 4)\n            (round\n               (*\n                  (abs (- (*/ A 1.0 B) 1.0))\n                  100 )\n               2 ) ) ) ) )\n\n(bye)\n"
                },
                {
                    "language": "Tcl",
                    "solution": "# Generate a list of the numbers increasing from $a to $b\nproc range {a b} {\n    for {set result {}} {$a <= $b} {incr a} {lappend result $a}\n    return $result\n}\n\n# Computing the expected value analytically\nproc tcl::mathfunc::factorial n {\n    ::tcl::mathop::* {*}[range 2 $n]\n}\nproc Analytical {n} {\n    set sum 0.0\n    foreach x [range 1 $n] {\n\tset sum [expr {$sum + factorial($n) / factorial($n-$x) / double($n)**$x}]\n    }\n    return $sum\n}\n\n# Determining an approximation to the value experimentally\nproc Experimental {n numTests} {\n    set count 0\n    set u0 [lrepeat $n 1]\n    foreach run [range 1 $numTests] {\n\tset unseen $u0\n\tfor {set i 0} {[lindex $unseen $i]} {incr count} {\n\t    lset unseen $i 0\n\t    set i [expr {int(rand()*$n)}]\n\t}\n    }\n    return [expr {$count / double($numTests)}]\n}\n\n# Tabulate the results in exactly the original format\nputs \" N    average    analytical    (error)\"\nputs \"===  =========  ============  =========\"\nforeach n [range 1 20] {\n    set a [Analytical $n]\n    set e [Experimental $n 100000]\n    puts [format \"%3d  %9.4f  %12.4f  (%6.2f%%)\" $n $e $a [expr {abs($e-$a)/$a*100.0}]]\n}\n"
                }
            ]
        ]
    },
    {
        "task_name": "Averages-Arithmetic-mean",
        "task_description": ";Task\n\nWrite a program to find the [[wp:arithmetic mean|mean]] (arithmetic average) of a numeric vector. \n\nIn case of a zero-length input, since the mean of an empty set of numbers is ill-defined, the program may choose to behave in any way it deems appropriate, though if the programming language has an established convention for conveying math errors or undefined values, it's preferable to follow it.\n\n{{task heading|See also}}\n\n{{Related tasks/Statistical measures}}\n\n<br><hr>\n\n",
        "solution_pairs": [
            [
                {
                    "language": "GEORGE",
                    "solution": "R (n) P ;\n0\n1, n rep (i)\n   R P +\n]\nn div\nP\n"
                },
                {
                    "language": "Vala",
                    "solution": "double arithmetic(double[] list){\n\tdouble mean;\n\tdouble sum = 0;\n\t\n\tif (list.length == 0)\n\t\treturn 0.0;\n\tforeach(double number in list){\n\t\tsum += number;\n\t} // foreach\n\t\n\tmean = sum / list.length;\n\t\n\treturn mean;\n} // end arithmetic mean\n\npublic static void main(){\n\tdouble[] test = {1.0, 2.0, 5.0, -5.0, 9.5, 3.14159};\n\tdouble[] zero_len = {};\n\t\n\tdouble mean = arithmetic(test);\n\tdouble mean_zero = arithmetic(zero_len);\n\t\n\tstdout.printf(\"%s\\n\", mean.to_string());\n\tstdout.printf(\"%s\\n\", mean_zero.to_string());\n}\n"
                }
            ],
            [
                {
                    "language": "VBA",
                    "solution": "Private Function mean(v() As Double, ByVal leng As Integer) As Variant\n    Dim sum As Double, i As Integer\n    sum = 0: i = 0\n    For i = 0 To leng - 1\n        sum = sum + vv\n    Next i\n    If leng = 0 Then\n        mean = CVErr(xlErrDiv0)\n    Else\n        mean = sum / leng\n    End If\nEnd Function\nPublic Sub main()\n    Dim v(4) As Double\n    Dim i As Integer, leng As Integer\n    v(0) = 1#\n    v(1) = 2#\n    v(2) = 2.178\n    v(3) = 3#\n    v(4) = 3.142\n    For leng = 5 To 0 Step -1\n        Debug.Print \"mean[\";\n        For i = 0 To leng - 1\n            Debug.Print IIf(i, \"; \" & v(i), \"\" & v(i));\n        Next i\n        Debug.Print \"] = \"; mean(v, leng)\n    Next leng\nEnd Sub\n"
                },
                {
                    "language": "GEORGE",
                    "solution": "R (n) P ;\n0\n1, n rep (i)\n   R P +\n]\nn div\nP\n"
                }
            ],
            [
                {
                    "language": "Factor",
                    "solution": "( scratchpad ) { 2 3 5 } arithmetic-mean >float\n3.333333333333333\n"
                },
                {
                    "language": "Smalltalk",
                    "solution": "| numbers |\n\nnumbers := #(1 2 3 4 5 6 7 8).\n(numbers sum / numbers size) displayNl.\n"
                }
            ],
            [
                {
                    "language": "UNIX-Shell",
                    "solution": "mean() {\n\tif expr $# >/dev/null; then\n\t\t(count=0\n\t\t sum=0\n\t\t while expr $# \\> 0 >/dev/null; do\n\t\t\tsum=`expr $sum + \"$1\"`\n\t\t\tresult=$?\n\t\t\texpr $result \\> 1 >/dev/null && exit $result\n\n\t\t\tcount=`expr $count + 1`\n\t\t\tshift\n\t\t done\n\t\t expr $sum / $count)\n\telse\n\t\techo 0\n\tfi\n}\n\nprintf \"test 1: \"; mean\t\t\t\t# 0\nprintf \"test 2: \"; mean 300\t\t\t# 300\nprintf \"test 3: \"; mean 300 100 400\t\t# 266\nprintf \"test 4: \"; mean -400 400 -1300 200\t# -275\nprintf \"test 5: \"; mean -\t\t\t# expr: syntax error\nprintf \"test 6: \"; mean 1 2 A 3\t\t\t# expr: non-numeric argument\n"
                },
                {
                    "language": "C++",
                    "solution": "#include <iterator>\n#include <algorithm>\n\ntemplate <typename Iterator>\ndouble mean(Iterator begin, Iterator end)\n{\n    if (begin == end)\n        return 0;\n    return std::accumulate(begin, end, 0.0) / std::distance(begin, end);\n}\n"
                }
            ],
            [
                {
                    "language": "0815",
                    "solution": "{x{+=<:2:x/%<:d:~$<:01:~><:02:~><:03:~><:04:~><:05:~><:06:~><:07:~><:08:\n~><:09:~><:0a:~><:0b:~><:0c:~><:0d:~><:0e:~><:0f:~><:10:~><:11:~><:12:~>\n<:13:~><:14:~><:15:~><:16:~><:17:~><:18:~><:19:~><:ffffffffffffffff:~>{x\n{+>}:8f:{&={+>{~>&=x<:ffffffffffffffff:/#:8f:{{=<:19:x/%\n"
                },
                {
                    "language": "V-(Vlang)",
                    "solution": "import math\nimport arrays\n\nfn main() {\n    for v in [\n        []f64{},                         // mean returns ok = false\n        [math.inf(1), math.inf(1)], // answer is +Inf\n\n        // answer is NaN, and mean returns ok = true, indicating NaN\n        // is the correct result\n        [math.inf(1), math.inf(-1)],\n\n        [f64(3), 1, 4, 1, 5, 9],\n\n        [f64(10), 9, 8, 7, 6, 5, 4, 3, 2, 1, 0, 0, 0, 0, .11],\n        [f64(10), 20, 30, 40, 50, -100, 4.7, -11e2],\n    ] {\n        println(\"Vector: $v\")\n        m := arrays.fold(v, 0.0, fn(r f64, v f64) f64 { return r+v })/v.len\n        println(\"Mean of $v.len numbers is $m\\n\")\n    }\n}\n"
                }
            ]
        ]
    },
    {
        "task_name": "Averages-Mean-angle",
        "task_description": "When calculating the [[wp:Mean of circular quantities|average or mean of an angle]] one has to take into account how angles wrap around so that any angle in degrees plus any integer multiple of 360 degrees is a measure of the same angle.\n\nIf one wanted an average direction of the wind over two readings where the first reading was of 350 degrees and the second was of 10 degrees then the average of the numbers is 180 degrees, whereas if you can note that 350 degrees is equivalent to -10 degrees and so you have two readings at 10 degrees either side of zero degrees leading to a more fitting mean angle of zero degrees.\n\nTo calculate the mean angle of several angles:\n# Assume all angles are on the unit circle and convert them to complex numbers expressed in real and imaginary form.\n# Compute the mean of the complex numbers.\n# Convert the complex mean to polar coordinates whereupon the phase of the complex mean is the required angular mean.\n\n<br>\n(Note that, since the mean is the sum divided by the number of numbers, and division by a positive real number does not affect the angle, you can also simply compute the sum for step 2.)\n\nYou can alternatively use this formula:\n\n: Given the angles <math>\\alpha_1,\\dots,\\alpha_n</math> the mean is computed by\n\n::<math>\\bar{\\alpha} = \\operatorname{atan2}\\left(\\frac{1}{n}\\cdot\\sum_{j=1}^n \\sin\\alpha_j, \\frac{1}{n}\\cdot\\sum_{j=1}^n \\cos\\alpha_j\\right) </math>\n\n;Task\n\n# write a function/method/subroutine/... that given a list of angles in degrees returns their mean angle. <br> (You should use a built-in function if you have one that does this for degrees or radians). \n# Use the function to compute the means of these lists of angles (in degrees): \n#* &nbsp; [350, 10]  \n#* &nbsp; [90, 180, 270, 360] \n#* &nbsp; [10, 20, 30]\n# Show your output here.\n\n{{task heading|See also}}\n\n{{Related tasks/Statistical measures}}\n\n<br><hr>\n\n",
        "solution_pairs": [
            [
                {
                    "language": "C",
                    "solution": "#include<math.h>\n#include<stdio.h>\n\ndouble\nmeanAngle (double *angles, int size)\n{\n  double y_part = 0, x_part = 0;\n  int i;\n\n  for (i = 0; i < size; i++)\n    {\n      x_part += cos (angles[i] * M_PI / 180);\n      y_part += sin (angles[i] * M_PI / 180);\n    }\n\n  return atan2 (y_part / size, x_part / size) * 180 / M_PI;\n}\n\nint\nmain ()\n{\n  double angleSet1[] = { 350, 10 };\n  double angleSet2[] = { 90, 180, 270, 360};\n  double angleSet3[] = { 10, 20, 30};\n\n  printf (\"\\nMean Angle for 1st set : %lf degrees\", meanAngle (angleSet1, 2));\n  printf (\"\\nMean Angle for 2nd set : %lf degrees\", meanAngle (angleSet2, 4));\n  printf (\"\\nMean Angle for 3rd set : %lf degrees\\n\", meanAngle (angleSet3, 3));\n  return 0;\n}\n"
                },
                {
                    "language": "J",
                    "solution": "rfd=: 1r180p1&*                                          NB. convert angle to radians from degrees\ntoComplex=: *.inv                                        NB. maps integer pairs as length, complex angle (in radians)\nmean=: +/ % #                                            NB. calculate arithmetic mean\nroundComplex=: (* * |)&.+.                               NB. discard an extraneous least significant bit of precision from a complex value whose magnitude is in the vicinity of 1\navgAngleR=: _1 { [: roundComplex@mean&.toComplex 1 ,. ]  NB. calculate average angle in radians\navgAngleD=: 360|avgAngleR&.rfd                           NB. calculate average angle in degrees\n"
                }
            ],
            [
                {
                    "language": "Zkl",
                    "solution": "fcn meanA(a1,a2,etc){\n   as:=vm.arglist.pump(List,\"toFloat\",\"toRad\");\n   n:=as.len();\n   (as.apply(\"sin\").sum(0.0)/n)\n   .atan2(as.apply(\"cos\").sum(0.0)/n)\n   .toDeg()\n}\n"
                },
                {
                    "language": "Rust",
                    "solution": "use std::f64;\n// the macro is from\n// http://stackoverflow.com/questions/30856285/assert-eq-with-floating-\n// point-numbers-and-delta\nfn mean_angle(angles: &[f64]) -> f64 {\n    let length: f64 = angles.len() as f64;\n    let cos_mean: f64 = angles.iter().fold(0.0, |sum, i| sum + i.to_radians().cos()) / length;\n    let sin_mean: f64 = angles.iter().fold(0.0, |sum, i| sum + i.to_radians().sin()) / length;\n    (sin_mean).atan2(cos_mean).to_degrees()\n}\n\nfn main() {\n    let angles1 = [350.0_f64, 10.0];\n    let angles2 = [90.0_f64, 180.0, 270.0, 360.0];\n    let angles3 = [10.0_f64, 20.0, 30.0];\n    println!(\"Mean Angle for {:?}  is {:.5} degrees\",\n             &angles1,\n             mean_angle(&angles1));\n    println!(\"Mean Angle for {:?}  is {:.5} degrees\",\n             &angles2,\n             mean_angle(&angles2));\n    println!(\"Mean Angle for {:?}  is {:.5} degrees\",\n             &angles3,\n             mean_angle(&angles3));\n}\n\nmacro_rules! assert_diff{\n    ($x: expr,$y : expr, $diff :expr)=>{\n        if ( $x - $y ).abs() > $diff {\n            panic!(\"floating point difference is to big {}\", $x - $y );\n        }\n    }\n}\n\n#[test]\nfn calculate() {\n    let angles1 = [350.0_f64, 10.0];\n    let angles2 = [90.0_f64, 180.0, 270.0, 360.0];\n    let angles3 = [10.0_f64, 20.0, 30.0];\n    assert_diff!(0.0, mean_angle(&angles1), 0.001);\n    assert_diff!(-90.0, mean_angle(&angles2), 0.001);\n    assert_diff!(20.0, mean_angle(&angles3), 0.001);\n}\n"
                }
            ],
            [
                {
                    "language": "Racket",
                    "solution": "#lang racket\n\n(define (mean-angle \u03b1s)\n  (radians->degrees\n   (mean-angle/radians\n    (map degrees->radians \u03b1s))))\n\n(define (mean-angle/radians \u03b1s)\n  (define n (length \u03b1s))\n  (atan (* (/ 1 n) (for/sum ([\u03b1_j \u03b1s]) (sin \u03b1_j)))\n        (* (/ 1 n) (for/sum ([\u03b1_j \u03b1s]) (cos \u03b1_j)))))\n\n(mean-angle '(350 0 10))\n(mean-angle '(90 180 270 360))\n(mean-angle '(10 20 30))\n"
                },
                {
                    "language": "Scheme",
                    "solution": "(import (srfi 1 lists))  ;; use 'fold' from library\n\n(define (average l)\n  (/ (fold + 0 l) (length l)))\n\n(define pi 3.14159265358979323846264338327950288419716939937510582097)\n\n(define (radians a)\n  (* pi 1/180 a))\n\n(define (degrees a)\n  (* 180 (/ 1 pi) a))\n\n(define (mean-angle angles)\n  (let* ((angles (map radians angles))\n         (cosines (map cos angles))\n         (sines (map sin angles)))\n    (degrees (atan (average sines) (average cosines)))))\n\n(for-each (lambda (angles)\n            (display \"The mean angle of \") (display angles)\n            (display \" is \") (display (mean-angle angles)) (newline))\n          '((350 10) (90 180 270 360) (10 20 30)))\n"
                }
            ],
            [
                {
                    "language": "Vala",
                    "solution": "double meanAngle(double[] angles) {\n  double y_part = 0.0;\n  double x_part = 0.0;\n\n  for (int i = 0; i < angles.length; i++) {\n    x_part += Math.cos(angles[i] * Math.PI / 180.0);\n    y_part += Math.sin(angles[i] * Math.PI / 180.0);\n  }\n\n  return Math.atan2(y_part / angles.length, x_part / angles.length) * 180 / Math.PI;\n}\n\nvoid main() {\n  double[] angleSet1 = {350.0, 10.0};\n  double[] angleSet2 = {90.0, 180.0, 270.0, 360.0};\n  double[] angleSet3 = {10.0, 20.0, 30.0};\n\n  print(\"\\nMean Angle for 1st set :  %lf degrees\", meanAngle(angleSet1));\n  print(\"\\nMean Angle for 2nd set : %lf degrees\", meanAngle(angleSet2));\n  print(\"\\nMean Angle for 3rd set :  %lf degrees\\n\", meanAngle(angleSet3));\n}\n"
                },
                {
                    "language": "J",
                    "solution": "   avgAngleD 10 350\n0\n   avgAngleD 90 180 270 360 NB. result not meaningful\n0\n   avgAngleD 10 20 30\n20\n   avgAngleD 20 350\n5\n   avgAngleD 10 340\n355\n"
                }
            ],
            [
                {
                    "language": "Swift",
                    "solution": "import Foundation\n\n@inlinable public func d2r<T: FloatingPoint>(_ f: T) -> T { f * .pi / 180 }\n@inlinable public func r2d<T: FloatingPoint>(_ f: T) -> T { f * 180 / .pi }\n\npublic func meanOfAngles(_ angles: [Double]) -> Double {\n  let cInv = 1 / Double(angles.count)\n  let (s, c) =\n    angles.lazy\n      .map(d2r)\n      .map({ (sin($0), cos($0)) })\n      .reduce(into: (0.0, 0.0), { $0.0 += $1.0; $0.1 += $1.1 })\n\n  return r2d(atan2(cInv * s, cInv * c))\n}\n\nlet fmt = { String(format: \"%lf\", $0) }\n\nprint(\"Mean of angles (350, 10) => \\(fmt(meanOfAngles([350, 10])))\")\nprint(\"Mean of angles (90, 180, 270, 360) => \\(fmt(meanOfAngles([90, 180, 270, 360])))\")\nprint(\"Mean of angles (10, 20, 30) => \\(fmt(meanOfAngles([10, 20, 30])))\")\n"
                },
                {
                    "language": "Maple",
                    "solution": "> MeanAngle( [ 350, 10 ] *~ Unit(arcdeg) );\n                                   0.\n\n> MeanAngle( [ 90, 180, 270, 360 ] *~ Unit(arcdeg) );\n                                   0.\n\n> MeanAngle( [ 10, 20, 30 ] *~ Unit(arcdeg) );\n                              20.00000000\n"
                }
            ]
        ]
    },
    {
        "task_name": "Averages-Mean-time-of-day",
        "task_description": ";Task\n\nA particular activity of bats occurs at these times of the day:\n:<tt>23:00:17</tt>, <tt>23:40:20</tt>, <tt>00:12:45</tt>, <tt>00:17:19</tt>\n\nUsing the idea that there are twenty-four hours in a day, \nwhich is analogous to there being 360 degrees in a circle, \nmap times of day to and from angles; \nand using the ideas of [[Averages/Mean angle]] \ncompute and show the average time of the nocturnal activity \nto an accuracy of one second of time.\n\n{{task heading|See also}}\n\n{{Related tasks/Statistical measures}}\n\n<hr>\n\n",
        "solution_pairs": [
            [
                {
                    "language": "Raku",
                    "solution": "sub tod2rad($_) { [+](.comb(/\\d+/) Z* 3600,60,1) * tau / 86400 }\n\nsub rad2tod ($r) {\n    my $x = $r * 86400 / tau;\n    (($x xx 3 Z/ 3600,60,1) Z% 24,60,60).fmt('%02d',':');\n}\n\nsub phase ($c) { $c.polar[1] }\n\nsub mean-time (@t) { rad2tod phase [+] map { cis tod2rad $_ }, @t }\n\nmy @times = [\"23:00:17\", \"23:40:20\", \"00:12:45\", \"00:17:19\"];\n\nsay \"{ mean-time(@times) } is the mean time of @times[]\";\n"
                },
                {
                    "language": "Swift",
                    "solution": "import Foundation\n\n@inlinable public func d2r<T: FloatingPoint>(_ f: T) -> T { f * .pi / 180 }\n@inlinable public func r2d<T: FloatingPoint>(_ f: T) -> T { f * 180 / .pi }\n\npublic func meanOfAngles(_ angles: [Double]) -> Double {\n  let cInv = 1 / Double(angles.count)\n  let (y, x) =\n    angles.lazy\n      .map(d2r)\n      .map({ (sin($0), cos($0)) })\n      .reduce(into: (0.0, 0.0), { $0.0 += $1.0; $0.1 += $1.1 })\n\n  return r2d(atan2(cInv * y, cInv * x))\n}\n\nstruct DigitTime {\n  var hour: Int\n  var minute: Int\n  var second: Int\n\n  init?(fromString str: String) {\n    let split = str.components(separatedBy: \":\").compactMap(Int.init)\n\n    guard split.count == 3 else {\n      return nil\n    }\n\n    (hour, minute, second) = (split[0], split[1], split[2])\n  }\n\n  init(fromDegrees angle: Double) {\n    let totalSeconds = 24 * 60 * 60 * angle / 360\n\n    second = Int(totalSeconds.truncatingRemainder(dividingBy: 60))\n    minute = Int((totalSeconds.truncatingRemainder(dividingBy: 3600) - Double(second)) / 60)\n    hour = Int(totalSeconds / 3600)\n  }\n\n  func toDegrees() -> Double {\n    return 360 * Double(hour) / 24.0 + 360 * Double(minute) / (24 * 60.0) + 360 * Double(second) / (24 * 3600.0)\n  }\n}\n\nextension DigitTime: CustomStringConvertible {\n  var description: String { String(format: \"%02i:%02i:%02i\", hour, minute, second) }\n}\n\nlet times = [\"23:00:17\", \"23:40:20\", \"00:12:45\", \"00:17:19\"].compactMap(DigitTime.init(fromString:))\n\nguard times.count == 4 else {\n  fatalError()\n}\n\nlet meanTime = DigitTime(fromDegrees: 360 + meanOfAngles(times.map({ $0.toDegrees() })))\n\nprint(\"Given times \\(times), the mean time is \\(meanTime)\")\n"
                }
            ],
            [
                {
                    "language": "EchoLisp",
                    "solution": ";; string hh:mm:ss to radians\n(define (time->radian time)\n    (define-values (h m s) (map string->number (string-split time \":\")))\n    (+  (* h (/ PI 12)) (* m (/ PI 12 60)) (* s (/ PI 12 3600))))\n\t\t\t\n;; radians to string hh:mm;ss\n(define (radian->time rad)\n\t(when (< rad 0) (+= rad (* 2 PI)))\n\t(define t (round (/ (* 12 3600 rad) PI)))\n\t(define h (quotient t 3600))\n\t(define m (quotient (- t (* h 3600)) 60))\n\t(define s (- t (* 3600 h) (* 60 m)))\n\t(string-join (map number->string (list h m s)) \":\"))\n\t\n(define (mean-time times)\n\t(radian->time\n\t (angle\n\t  (for/sum ((t times)) (make-polar 1 (time->radian t))))))\n\t\n(mean-time '{\"23:00:17\" \"23:40:20\" \"00:12:45\" \"00:17:19\"})\n    \u00e2\u2020\u2019  \"23:47:43\"\n"
                },
                {
                    "language": "F-Sharp",
                    "solution": "open System\nopen System.Numerics\n\nlet deg2rad d = d * Math.PI / 180.\nlet rad2deg r = r * 180. / Math.PI\nlet makeComplex = fun r ->  Complex.FromPolarCoordinates(1., r)\n// 1 msec = 10000 ticks\nlet time2deg = TimeSpan.Parse >> (fun ts -> ts.Ticks) >> (float) >> (*) (10e-9/24.)\nlet deg2time = (*) (24. * 10e7) >> (int64) >> TimeSpan\n\n[<EntryPoint>]\nlet main argv =\n    let msg = \"Average time for [\" + (String.Join(\"; \",argv)) + \"] is\"\n    argv\n    |> Seq.map (time2deg >> deg2rad >> makeComplex)\n    |> Seq.fold (fun x y -> Complex.Add(x,y)) Complex.Zero\n    |> fun c -> c.Phase |> rad2deg\n    |> fun d -> if d < 0. then d + 360. else d\n    |> deg2time |> fun t -> t.ToString(@\"hh\\:mm\\:ss\")\n    |> printfn \"%s: %s\" msg\n    0\n"
                }
            ],
            [
                {
                    "language": "EchoLisp",
                    "solution": ";; string hh:mm:ss to radians\n(define (time->radian time)\n    (define-values (h m s) (map string->number (string-split time \":\")))\n    (+  (* h (/ PI 12)) (* m (/ PI 12 60)) (* s (/ PI 12 3600))))\n\t\t\t\n;; radians to string hh:mm;ss\n(define (radian->time rad)\n\t(when (< rad 0) (+= rad (* 2 PI)))\n\t(define t (round (/ (* 12 3600 rad) PI)))\n\t(define h (quotient t 3600))\n\t(define m (quotient (- t (* h 3600)) 60))\n\t(define s (- t (* 3600 h) (* 60 m)))\n\t(string-join (map number->string (list h m s)) \":\"))\n\t\n(define (mean-time times)\n\t(radian->time\n\t (angle\n\t  (for/sum ((t times)) (make-polar 1 (time->radian t))))))\n\t\n(mean-time '{\"23:00:17\" \"23:40:20\" \"00:12:45\" \"00:17:19\"})\n    \u00e2\u2020\u2019  \"23:47:43\"\n"
                },
                {
                    "language": "VBA",
                    "solution": "Public Sub mean_time()\n    Dim angles() As Double\n    s = [{\"23:00:17\",\"23:40:20\",\"00:12:45\",\"00:17:19\"}]\n    For i = 1 To UBound(s)\n        s(i) = 360 * TimeValue(s(i))\n    Next i\n    Debug.Print Format(mean_angle(s) / 360 + 1, \"hh:mm:ss\")\nEnd Sub\n"
                }
            ],
            [
                {
                    "language": "Go",
                    "solution": "package main\n\nimport (\n    \"errors\"\n    \"fmt\"\n    \"log\"\n    \"math\"\n    \"time\"\n)\n\nvar inputs = []string{\"23:00:17\", \"23:40:20\", \"00:12:45\", \"00:17:19\"}\n\nfunc main() {\n    tList := make([]time.Time, len(inputs))\n    const clockFmt = \"15:04:05\"\n    var err error\n    for i, s := range inputs {\n        tList[i], err = time.Parse(clockFmt, s)\n        if err != nil {\n            log.Fatal(err)\n        }\n    }\n    mean, err := meanTime(tList)\n    if err != nil {\n        log.Fatal(err)\n    }\n    fmt.Println(mean.Format(clockFmt))\n}\n\nfunc meanTime(times []time.Time) (mean time.Time, err error) {\n    if len(times) == 0 {\n        err = errors.New(\"meanTime: no times specified\")\n        return\n    }\n    var ssum, csum float64\n    for _, t := range times {\n        h, m, s := t.Clock()\n        n := t.Nanosecond()\n        fSec := (float64((h*60+m)*60+s) + float64(n)*1e-9)\n        sin, cos := math.Sincos(fSec * math.Pi / (12 * 60 * 60))\n        ssum += sin\n        csum += cos\n    }\n    if ssum == 0 && csum == 0 {\n        err = errors.New(\"meanTime: mean undefined\")\n        return\n    }\n    _, dayFrac := math.Modf(1 + math.Atan2(ssum, csum)/(2*math.Pi))\n    return mean.Add(time.Duration(dayFrac * 24 * float64(time.Hour))), nil\n}\n"
                },
                {
                    "language": "Sidef",
                    "solution": "func time2deg(t) {\n  (var m = t.match(/^(\\d\\d):(\\d\\d):(\\d\\d)$/)) || die \"invalid time\"\n  var (hh,mm,ss) = m.cap.map{.to_i}...\n  ((hh ~~ 24.range) && (mm ~~ 60.range) && (ss ~~ 60.range)) || die \"invalid time\"\n  (hh*3600 + mm*60 + ss) * 360 / 86400\n}\n\u00a0\nfunc deg2time(d) {\n  var sec = ((d % 360) * 86400 / 360)\n  \"%02d:%02d:%02d\" % (sec/3600, (sec%3600)/60, sec%60)\n}\n\u00a0\nfunc mean_time(times) {\n  deg2time(mean_angle(times.map {|t| time2deg(t)}))\n}\n\u00a0\nsay mean_time([\"23:00:17\", \"23:40:20\", \"00:12:45\", \"00:17:19\"])\n"
                }
            ],
            [
                {
                    "language": "EchoLisp",
                    "solution": ";; string hh:mm:ss to radians\n(define (time->radian time)\n    (define-values (h m s) (map string->number (string-split time \":\")))\n    (+  (* h (/ PI 12)) (* m (/ PI 12 60)) (* s (/ PI 12 3600))))\n\t\t\t\n;; radians to string hh:mm;ss\n(define (radian->time rad)\n\t(when (< rad 0) (+= rad (* 2 PI)))\n\t(define t (round (/ (* 12 3600 rad) PI)))\n\t(define h (quotient t 3600))\n\t(define m (quotient (- t (* h 3600)) 60))\n\t(define s (- t (* 3600 h) (* 60 m)))\n\t(string-join (map number->string (list h m s)) \":\"))\n\t\n(define (mean-time times)\n\t(radian->time\n\t (angle\n\t  (for/sum ((t times)) (make-polar 1 (time->radian t))))))\n\t\n(mean-time '{\"23:00:17\" \"23:40:20\" \"00:12:45\" \"00:17:19\"})\n    \u00e2\u2020\u2019  \"23:47:43\"\n"
                },
                {
                    "language": "ALGOL-68",
                    "solution": "BEGIN # Mean time of day mapping time to angles                      #\n\n    # code from the Averages/Mean angle task - angles are in degrees #\n    PROC mean angle = ([]REAL angles)REAL:\n    (\n      INT size = UPB angles - LWB angles + 1;\n      REAL y part := 0, x part := 0;\n      FOR i FROM LWB angles TO UPB angles DO\n          x part +:= cos (angles[i] * pi / 180);\n          y part +:= sin (angles[i] * pi / 180)\n      OD;\n\n      arc tan2 (y part / size, x part / size) * 180 / pi\n    );\n    # end code from the Averages/Mean angle task                     #\n\n    MODE TIME = STRUCT( INT hh, mm, ss );\n\n    OP   TOANGLE = ( TIME t )REAL: ( ( ( ( ( ss OF t / 60 ) + mm OF t ) / 60 ) + hh OF t ) * 360 ) / 24;\n    OP   TOTIME  = ( REAL a )TIME:\n         BEGIN\n            REAL t  := ( a * 24 ) / 360;\n            WHILE t <  0 DO t +:= 24 OD;\n            WHILE t > 24 DO t -:= 24 OD;\n            INT  hh  = ENTIER t;\n            t      -:= hh *:= 60;\n            INT  mm  = ENTIER t;\n            INT  ss  = ENTIER ( ( t - mm ) * 60 );\n            ( hh, mm, ss )\n         END # TOTIME # ;\n\n    PROC mean time = ( []TIME times )TIME:\n         BEGIN\n            [ LWB times : UPB times ]REAL angles;\n            FOR i FROM LWB times TO UPB times DO angles[ i ] := TOANGLE times[ i ] OD;\n            TOTIME mean angle( angles )\n         END # mean time # ;\n\n    OP   SHOW = ( TIME t )VOID:\n         BEGIN\n            PROC d2 = ( INT n )STRING: IF n < 10 THEN \"0\" ELSE \"\" FI + whole( n, 0 );\n            print( ( d2( hh OF t ), \":\", d2( mm OF t ), \":\", d2( ss OF t ) ) )\n         END # show time # ;\n\n    SHOW mean time( ( ( 23,00,17 ), ( 23,40,20 ), ( 00,12,45 ), ( 00,17,19 ) ) )\nEND\n"
                }
            ]
        ]
    },
    {
        "task_name": "Averages-Median",
        "task_description": ";Task\n\nWrite a program to find the &nbsp; [[wp:Median|median]] &nbsp; value of a vector of floating-point numbers. \n\nThe program need not handle the case where the vector is empty, but ''must'' handle the case where there are an even number of elements. &nbsp; In that case, return the average of the two middle values.\n\nThere are several approaches to this. &nbsp; One is to sort the elements, and then pick the element(s) in the middle. \n\nSorting would take at least &nbsp; <big><span style=\"font-family: serif\">O(''n''\u200alog''n'')</span></big>. &nbsp; Another approach would be to build a priority queue from the elements, and then extract half of the elements to get to the middle element(s). &nbsp; This would also take &nbsp; <big><span style=\"font-family: serif\">O(''n''\u200alog''n'')</span></big>. &nbsp; The best solution is to use the &nbsp; [[wp:Selection algorithm|selection algorithm]] &nbsp; to find the median in &nbsp; <big><span style=\"font-family: serif\">O(''n'')</span></big> &nbsp; time.\n\n{{task heading|See also}}\n[[Quickselect_algorithm]]\n{{Related tasks/Statistical measures}}\n\n<hr>\n\n",
        "solution_pairs": [
            [
                {
                    "language": "Excel",
                    "solution": "=MEDIAN(A1:A10)\n"
                },
                {
                    "language": "OoRexx",
                    "solution": "call testMedian .array~of(10, 9, 8, 7, 6, 5, 4, 3, 2, 1)\ncall testMedian .array~of(10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0, 0, 0, 0, .11)\ncall testMedian .array~of(10, 20, 30, 40, 50, -100, 4.7, -11e2)\ncall testMedian .array~new\n\n::routine testMedian\n  use arg numbers\n  say \"numbers =\" numbers~toString(\"l\", \", \")\n  say \"median =\" median(numbers)\n  say\n\n::routine median\n  use arg numbers\n\n  if numbers~isempty then return 0\n  -- make a copy so the sort does not alter the\n  -- original set.  This also means this will\n  -- work with lists and queues as well\n  numbers = numbers~makearray\n\n  -- sort and return the middle element\n  numbers~sortWith(.numbercomparator~new)\n  size = numbers~items\n  -- this handles the odd value too\n  return numbers[size%2 + size//2]\n\n\n-- a custom comparator that sorts strings as numeric values rather than\n-- strings\n::class numberComparator subclass comparator\n::method compare\n  use strict arg left, right\n  -- perform the comparison on the names.  By subtracting\n  -- the two and returning the sign, we give the expected\n  -- results for the compares\n  return (left - right)~sign\n"
                }
            ],
            [
                {
                    "language": "Ursala",
                    "solution": "#cast %eW\n\nexamples =\n\nmedian~~ (\n   <9.3,-2.0,4.0,7.3,8.1,4.1,-6.3,4.2,-1.0,-8.4>,\n   <8.3,-3.6,5.7,2.3,9.3,5.4,-2.3,6.3,9.9>)\n"
                },
                {
                    "language": "HicEst",
                    "solution": "REAL :: n=10, vec(n)\n\nvec = RAN(1)\nSORT(Vector=vec, Sorted=vec) ! in-place Merge-Sort\n\nIF( MOD(n,2) ) THEN  ! odd n\n    median = vec( CEILING(n/2) )\nELSE\n    median = ( vec(n/2) + vec(n/2 + 1) ) / 2\nENDIF\n"
                }
            ],
            [
                {
                    "language": "Mathematica",
                    "solution": "mymedian[{1, 5, 3, 2, 4}]\nmymedian[{1, 5, 3, 6, 4, 2}]\n"
                },
                {
                    "language": "Racket",
                    "solution": "#lang racket\n(define (median numbers)\n  (define sorted (list->vector (sort (vector->list numbers) <)))\n  (define count (vector-length numbers))\n  (if (zero? count)\n      #f\n      (/ (+ (vector-ref sorted (floor (/ (sub1 count) 2)))\n            (vector-ref sorted (floor (/ count 2))))\n         2)))\n\n(median '#(5 3 4)) ;; 4\n(median '#()) ;; #f\n(median '#(5 4 2 3)) ;; 7/2\n(median '#(3 4 1 -8.4 7.2 4 1 1.2)) ;; 2.1\n"
                }
            ],
            [
                {
                    "language": "Elena",
                    "solution": "import system'routines;\nimport system'math;\nimport extensions;\n\nextension op\n{\n    get Median()\n    {\n        var sorted := self.ascendant();\n\n        var len := sorted.Length;\n        if (len == 0)\n        {\n            ^ nil\n        }\n        else\n        {\n            var middleIndex := len / 2;\n            if (len.mod(2) == 0)\n            {\n                ^ (sorted[middleIndex - 1] + sorted[middleIndex]) / 2\n            }\n            else\n            {\n                ^ sorted[middleIndex]\n            }\n        }\n    }\n}\n\npublic program()\n{\n    var a1 := new real[]{4.1r, 5.6r, 7.2r, 1.7r, 9.3r, 4.4r, 3.2r};\n    var a2 := new real[]{4.1r, 7.2r, 1.7r, 9.3r, 4.4r, 3.2r};\n\n    console.printLine(\"median of (\",a1.asEnumerable(),\") is \",a1.Median);\n    console.printLine(\"median of (\",a2.asEnumerable(),\") is \",a2.Median);\n\n    console.readChar()\n}\n"
                },
                {
                    "language": "C",
                    "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\n#define MAX_ELEMENTS 1000000\n\n/* Return the k-th smallest item in array x of length len */\ndouble quick_select(int k, double *x, int len)\n{\n   inline void swap(int a, int b)\n   {\n      double t = x[a];\n      x[a] = x[b], x[b] = t;\n   }\n\n   int left = 0, right = len - 1;\n   int pos, i;\n   double pivot;\n\n   while (left < right)\n   {\n      pivot = x[k];\n      swap(k, right);\n      for (i = pos = left; i < right; i++)\n      {\n         if (x[i] < pivot)\n         {\n            swap(i, pos);\n            pos++;\n         }\n      }\n      swap(right, pos);\n      if (pos == k) break;\n      if (pos < k) left = pos + 1;\n      else right = pos - 1;\n   }\n   return x[k];\n}\n\nint main(void)\n{\n   int i, length;\n   double *x, median;\n\n   /* Initialize random length double array with random doubles */\n   srandom(time(0));\n   length = random() % MAX_ELEMENTS;\n   x = malloc(sizeof(double) * length);\n   for (i = 0; i < length; i++)\n   {\n      // shifted by RAND_MAX for negative values\n      // divide by a random number for floating point\n      x[i] = (double)(random() - RAND_MAX / 2) / (random() + 1); // + 1 to not divide by 0\n   }\n\n\n   if (length % 2 == 0) // Even number of elements, median is average of middle two\n   {\n      median = (quick_select(length / 2, x, length) + quick_select(length / 2 - 1, x, length / 2)) / 2;\n   }\n   else // select middle element\n   {\n      median = quick_select(length / 2, x, length);\n   }\n\n\n   /* Sanity testing of median */\n   int less = 0, more = 0, eq = 0;\n   for (i = 0; i < length; i++)\n   {\n      if (x[i] < median) less ++;\n      else if (x[i] > median) more ++;\n      else eq ++;\n   }\n   printf(\"length: %d\\nmedian: %lf\\n<: %d\\n>: %d\\n=: %d\\n\", length, median, less, more, eq);\n\n   free(x);\n   return 0;\n}\n"
                }
            ],
            [
                {
                    "language": "Pascal",
                    "solution": "Program AveragesMedian(output);\n\ntype\n  TDoubleArray = array of double;\n\nprocedure bubbleSort(var list: TDoubleArray);\nvar\n  i, j, n: integer;\n  t: double;\nbegin\n  n := length(list);\n  for i := n downto 2 do\n    for j := 0 to i - 1 do\n      if list[j] > list[j + 1] then\n      begin\n        t := list[j];\n        list[j] := list[j + 1];\n        list[j + 1] := t;\n      end;\nend;\n\nfunction Median(aArray: TDoubleArray): double;\nvar\n  lMiddleIndex: integer;\nbegin\n  bubbleSort(aArray);\n  lMiddleIndex := (high(aArray) - low(aArray)) div 2;\n  if Odd(Length(aArray)) then\n    Median := aArray[lMiddleIndex + 1]\n  else\n    Median := (aArray[lMiddleIndex + 1] + aArray[lMiddleIndex]) / 2;\nend;\n\nvar\n  A: TDoubleArray;\n  i: integer;\n\nbegin\n  randomize;\n  setlength(A, 7);\n  for i := low(A) to high(A) do\n  begin\n    A[i] := 100 * random;\n    write (A[i]:7:3, ' ');\n  end;\n  writeln;\n  writeln('Median: ', Median(A):7:3);\n\n  setlength(A, 6);\n  for i := low(A) to high(A) do\n  begin\n    A[i] := 100 * random;\n    write (A[i]:7:3, ' ');\n  end;\n  writeln;\n  writeln('Median: ', Median(A):7:3);\nend.\n"
                },
                {
                    "language": "C",
                    "solution": "length: 992021\nmedian: 0.000473\n<: 496010\n>: 496010\n=: 1\n"
                }
            ]
        ]
    },
    {
        "task_name": "Averages-Mode",
        "task_description": ";Task\n\nWrite a program to find the [[wp:Mode (statistics)|mode]] value of a collection. \n\nThe case where the collection is empty may be ignored. Care must be taken to handle the case where the mode is non-unique.\n\nIf it is not appropriate or possible to support a general collection, use a vector (array), if possible. If it is not appropriate or possible to support an unspecified value type, use integers.\n\n{{task heading|See also}}\n\n{{Related tasks/Statistical measures}}\n\n<hr>\n\n",
        "solution_pairs": [
            [
                {
                    "language": "Clojure",
                    "solution": "(defn modes [coll]\n  (let [distrib (frequencies coll)\n        [value freq] [first second] ; name the key/value pairs in the distrib (map) entries\n        sorted (sort-by (comp - freq) distrib)\n        maxfq (freq (first sorted))]\n    (map value (take-while #(= maxfq (freq %)) sorted))))\n"
                },
                {
                    "language": "Fortran",
                    "solution": "program mode_test\n  use Qsort_Module only Qsort => sort\n  implicit none\n\n  integer, parameter    :: S = 10\n  integer, dimension(S) :: a1 = (/ -1, 7, 7, 2, 2, 2, -1, 7, -3, -3 /)\n  integer, dimension(S) :: a2 = (/  1, 1, 1, 1, 1, 0, 2, 2, 2, 2 /)\n  integer, dimension(S) :: a3 = (/  0, 0, -1, -1, 9, 9, 3, 3, 7, 7 /)\n\n  integer, dimension(S) :: o\n  integer               :: l, trash\n\n  print *, stat_mode(a1)\n\n  trash = stat_mode(a1, o, l)\n  print *, o(1:l)\n  trash = stat_mode(a2, o, l)\n  print *, o(1:l)\n  trash = stat_mode(a3, o, l)\n  print *, o(1:l)\n\ncontains\n\n  ! stat_mode returns the lowest (if not unique) mode\n  ! others can hold other modes, if the mode is not unique\n  ! if others is provided, otherslen should be provided too, and\n  ! it says how many other modes are there.\n  ! ok can be used to know if the return value has a meaning\n  ! or the mode can't be found (void arrays)\n  integer function stat_mode(a, others, otherslen, ok)\n    integer, dimension(:), intent(in) :: a\n    logical, optional, intent(out)    :: ok\n    integer, dimension(size(a,1)), optional, intent(out) :: others\n    integer, optional, intent(out)    :: otherslen\n\n    ! ta is a copy of a, we sort ta modifying it, freq\n    ! holds the frequencies and idx the index (for ta) so that\n    ! the value appearing freq(i)-time is ta(idx(i))\n    integer, dimension(size(a, 1)) :: ta, freq, idx\n    integer                        :: rs, i, tm, ml, tf\n\n    if ( present(ok) ) ok = .false.\n\n    select case ( size(a, 1) )\n    case (0)  ! no mode... ok is false\n       return\n    case (1)\n       if ( present(ok) ) ok = .true.\n       stat_mode = a(1)\n       return\n    case default\n       if ( present(ok) ) ok = .true.\n       ta = a         ! copy the array\n       call sort(ta)  ! sort it in place (cfr. sort algos on RC)\n       freq = 1\n       idx = 0\n       rs = 1         ! rs will be the number of different values\n\n       do i = 2, size(ta, 1)\n          if ( ta(i-1) == ta(i) ) then\n             freq(rs) = freq(rs) + 1\n          else\n             idx(rs) = i-1\n             rs = rs + 1\n          end if\n       end do\n       idx(rs) = i-1\n\n       ml = maxloc(freq(1:rs), 1)  ! index of the max value of freq\n       tf = freq(ml)               ! the max frequency\n       tm = ta(idx(ml))            ! the value with that freq\n\n       ! if we want all the possible modes, we provide others\n       if ( present(others) ) then\n          i = 1\n          others(1) = tm\n          do\n             freq(ml) = 0\n             ml = maxloc(freq(1:rs), 1)\n             if ( tf == freq(ml) ) then ! the same freq\n                i = i + 1               ! as the max one\n                others(i) = ta(idx(ml))\n             else\n                exit\n             end if\n          end do\n\n          if ( present(otherslen) ) then\n             otherslen = i\n          end if\n\n       end if\n       stat_mode = tm\n    end select\n\n  end function stat_mode\n\nend program mode_test\n"
                }
            ],
            [
                {
                    "language": "Perl",
                    "solution": "use strict;\nuse List::Util qw(max);\n\nsub mode\n{\n    my %c;\n    foreach my $e ( @_ ) {\n\t$c{$e}++;\n    }\n    my $best = max(values %c);\n    return grep { $c{$_} == $best } keys %c;\n}\n"
                },
                {
                    "language": "Action-",
                    "solution": "DEFINE MAX=\"100\"\nINT ARRAY keys(MAX)\nINT ARRAY values(MAX)\nBYTE count\n\nPROC PrintArray(INT ARRAY a INT size)\n  INT i\n\n  Put('[)\n  FOR i=0 TO size-1\n  DO\n    IF i>0 THEN Put(' ) FI\n    PrintI(a(i))\n  OD\n  Put(']) PutE()\nRETURN\n\nPROC ClearMap()\n  count=0\nRETURN\n\nPROC AddToMap(INT a)\n  INT i,index\n\n  index=-1\n  IF count>0 THEN\n    FOR i=0 TO count-1\n    DO\n      IF keys(i)=a THEN\n        index=i EXIT\n      FI\n    OD\n  FI\n  IF index=-1 THEN\n    keys(count)=a\n    values(count)=1\n    count==+1\n  ELSE\n    values(index)==+1\n  FI\nRETURN\n\nPROC Mode(INT ARRAY a INT aSize INT ARRAY m INT POINTER mSize)\n  INT i,mx\n\n  ClearMap()\n  FOR i=0 TO aSize-1\n  DO\n    AddToMap(a(i))\n  OD\n\n  mx=0\n  FOR i=0 TO count-1\n  DO\n    IF values(i)>mx THEN\n      mx=values(i)\n    FI\n  OD\n\n  mSize^=0\n  FOR i=0 TO count-1\n  DO\n    IF values(i)=mx THEN\n      m(mSize^)=keys(i)\n      mSize^==+1\n    FI\n  OD\nRETURN\n\nPROC Test(INT ARRAY a INT size)\n  INT ARRAY m(MAX)\n  INT mSize\n\n  PrintE(\"Array:\") PrintArray(a,size)\n  Mode(a,size,m,@mSize)\n  PrintE(\"Mode:\") PrintArray(m,mSize)\n  PutE()\nRETURN\n\nPROC Main()\n  INT ARRAY a=[1 3 5 7 3 1 3 7 7 3 3]\n  INT ARRAY b=[7 13 5 13 7 2 7 10 13]\n  INT ARRAY c=[5]\n\n  Test(a,11)\n  Test(b,9)\n  Test(c,1)\nRETURN\n"
                }
            ],
            [
                {
                    "language": "Swift",
                    "solution": "// Extend the Collection protocol. Any type that conforms to extension where its Element type conforms to Hashable will automatically gain this method.\nextension Collection where Element: Hashable {\n\n    /// Return a Mode of the function, or nil if none exist.\n    func mode() -> Element? {\n        var frequencies = [Element: Int]()\n\n        // Standard for loop. Can also use the forEach(_:) or reduce(into:) methods on self.\n        for element in self {\n            frequencies[element] = (frequencies[element] ?? 0) + 1\n        }\n\n        // The max(by:) method used here to find one of the elements with the highest associated count.\n        if let ( mode, _ ) = frequencies.max(by: { $0.value < $1.value }) {\n            return mode\n        } else {\n            return nil\n        }\n    }\n\n}\n\n[\"q\", \"a\", \"a\", \"a\", \"a\", \"b\", \"b\", \"z\", \"c\", \"c\", \"c\"].mode() // returns \"a\"\n[1, 1, 2, 3, 3, 3, 3, 4, 4, 4].mode() // returns 3\n\nlet emptyArray: [Int] = []\nemptyArray.mode() // returns nil\n"
                },
                {
                    "language": "Octave",
                    "solution": "a = [1, 3, 6, 6, 6, 6, 7, 7, 12, 12, 17];\nmode2(a)\nmode(a)\n\na = [1, 1, 2, 4, 4];\nmode2(a)    % returns 1 and 4\nmode(a)     % returns 1 only\n"
                }
            ],
            [
                {
                    "language": "BBC-BASIC",
                    "solution": "      DIM a(10), b(4)\n      a() = 1, 3, 6, 6, 6, 6, 7, 7, 12, 12, 17\n      b() = 1, 2, 4, 4, 1\n\n      DIM modes(10)\n      PRINT \"Mode(s) of a() = \" ;\n      FOR i% = 1 TO FNmodes(a(), modes())\n        PRINT ; modes(i%) \" \" ;\n      NEXT\n      PRINT\n      PRINT \"Mode(s) of b() = \" ;\n      FOR i% = 1 TO FNmodes(b(), modes())\n        PRINT ; modes(i%) \" \" ;\n      NEXT\n      PRINT\n      END\n\n      DEF FNmodes(a(), m())\n      LOCAL I%, J%, N%, c%(), max%\n      N% = DIM(a(),1)\n      IF N% = 0 THEN m(1) = a(0) : = 1\n      DIM c%(N%)\n      FOR I% = 0 TO N%-1\n        FOR J% = I%+1 TO N%\n          IF a(I%) = a(J%) c%(I%) += 1\n        NEXT\n        IF c%(I%) > max% max% = c%(I%)\n      NEXT I%\n      J% = 0\n      FOR I% = 0 TO N%\n        IF c%(I%) = max% J% += 1 : m(J%) = a(I%)\n      NEXT\n      = J%\n"
                },
                {
                    "language": "Scheme",
                    "solution": "(define (mode collection)\n    (define (helper collection counts)\n        (if (null? collection)\n            counts\n            (helper (remove (car collection) collection)\n                    (cons (cons (car collection)\n                                (appearances (car collection) collection)) counts))))\n    (map car\n         (filter (lambda (x) (= (cdr x) (apply max (map cdr (helper collection '())))))\n                 (helper collection '())))\n"
                }
            ],
            [
                {
                    "language": "AppleScript",
                    "solution": "use AppleScript version \"2.3.1\" -- Mac OS X 10.9 (Mavericks) or later (for these 'use' commands).\nuse sorter : script \"Shell sort\" -- https://www.rosettacode.org/wiki/Sorting_algorithms/Shell_sort#AppleScript\n\non modeOf(listOrRecord)\n    -- Extract and sort numbers and text separately, then concatenate the results to get a single list of values.\n    set theNumbers to listOrRecord's numbers\n    tell sorter to sort(theNumbers, 1, -1)\n    set theTexts to listOrRecord's text\n    tell sorter to sort(theTexts, 1, -1)\n    script o\n        property values : theNumbers & theTexts\n        property mode : {}\n    end script\n\n    -- Identify the most frequently occurring value(s).\n    if (o's values is not {}) then\n        set i to 1\n        set currentValue to beginning of o's values\n        set maxCount to 1\n        repeat with j from 2 to (count o's values)\n            set thisValue to item j of o's values\n            if (thisValue is not currentValue) then\n                set thisCount to j - i\n                if (thisCount > maxCount) then\n                    set o's mode to {currentValue}\n                    set maxCount to thisCount\n                else if (thisCount = maxCount) then\n                    set end of o's mode to currentValue\n                end if\n                set i to j\n                set currentValue to thisValue\n            end if\n        end repeat\n        if (j + 1 - i > maxCount) then\n            set o's mode to {currentValue}\n        else if (j + 1 - i = maxCount) then\n            set end of o's mode to currentValue\n        end if\n    end if\n\n    return o's mode\nend modeOf\n\n-- Test code:\n-- With a list:\nmodeOf({12, 4, \"rhubarb\", 88, \"rhubarb\", 17, \"custard\", 4.0, 4, 88, \"rhubarb\"})\n--> {4, \"rhubarb\"}\n\n-- With a record:\nmodeOf({a:12, b:4, c:\"rhubarb\", d:88, e:\"rhubarb\", f:17, g:\"custard\", h:4.0, i:4, j:88})\n--> {4}\n"
                },
                {
                    "language": "JavaScript",
                    "solution": "function mode(ary) {\n    var counter = {};\n    var mode = [];\n    var max = 0;\n    for (var i in ary) {\n        if (!(ary[i] in counter))\n            counter[ary[i]] = 0;\n        counter[ary[i]]++;\n\n        if (counter[ary[i]] == max)\n            mode.push(ary[i]);\n        else if (counter[ary[i]] > max) {\n            max = counter[ary[i]];\n            mode = [ary[i]];\n        }\n    }\n    return mode;\n}\n\nmode([1, 3, 6, 6, 6, 6, 7, 7, 12, 12, 17]);  // [6]\nmode([1, 2, 4, 4, 1]);  // [1,4]\n"
                }
            ]
        ]
    },
    {
        "task_name": "Averages-Pythagorean-means",
        "task_description": ";Task\n\nCompute all three of the [[wp:Pythagorean means|Pythagorean means]] of the set of integers <big>1</big> through <big>10</big> (inclusive).\n\nShow that <big><math>A(x_1,\\ldots,x_n) \\geq G(x_1,\\ldots,x_n) \\geq H(x_1,\\ldots,x_n)</math></big> for this set of positive integers.\n\n*  The most common of the three means, the [[Averages/Arithmetic mean|arithmetic mean]], is the sum of the list divided by its length:\n: <big><math> A(x_1, \\ldots, x_n) = \\frac{x_1 + \\cdots + x_n}{n}</math></big>\n\n* The [[wp:Geometric mean|geometric mean]] is the <math>n</math>th root of the product of the list:\n: <big><math> G(x_1, \\ldots, x_n) = \\sqrt[n]{x_1 \\cdots x_n} </math></big>\n\n* The [[wp:Harmonic mean|harmonic mean]] is <math>n</math> divided by the sum of the reciprocal of each item in the list:\n: <big><math> H(x_1, \\ldots, x_n) = \\frac{n}{\\frac{1}{x_1} + \\cdots + \\frac{1}{x_n}} </math></big>\n\n\n\n{{task heading|See also}}\n\n{{Related tasks/Statistical measures}}\n\n<br><hr>\n\n",
        "solution_pairs": [
            [
                {
                    "language": "Swift",
                    "solution": "    // Utility for easy creation of Double from any Numeric\nextension Double {\n\tinit(withNum v: any Numeric) {\n\t\tswitch v {\n\t\tcase let ii as any BinaryInteger: self.init(ii)\n\t\tcase let ff as any BinaryFloatingPoint: self.init(ff)\n\t\tdefault: self.init()\n\t\t}\n\t}\n}\n    // Extension for numeric collections\nextension Collection where Element: Numeric {\n\tvar arithmeticMean: Double {\n\t\tself.reduce(0.0, {$0 + Double(withNum: $1)})/Double(self.count)\n\t}\n\tvar geometricMean: Double {\n\t\tpow(self.reduce(1.0, {$0 * Double(withNum: $1)}), 1.0/Double(self.count))\n\t}\n\tvar harmonicMean: Double {\n\t\tDouble(self.count) / self.reduce(0.0, {$0 + 1.0/Double(withNum:$1)})\n\t}\n}\n//Usage:\nvar c: [Int] = (1...10).map {$0}\n\nprint(c.arithmeticMean)\nprint(c.geometricMean)\nprint(c.harmonicMean)\n\n// output:\n// 5.5\n// 4.528728688116765\n// 3.414171521474055\n"
                },
                {
                    "language": "Oz",
                    "solution": "declare\n  %% helpers\n  fun {Sum Xs} {FoldL Xs Number.'+' 0.0} end\n  fun {Product Xs} {FoldL Xs Number.'*' 1.0} end\n  fun {Len Xs} {Int.toFloat {Length Xs}} end\n\n  fun {AMean Xs}\n     {Sum Xs}\n     /\n     {Len Xs}\n  end\n\n  fun {GMean Xs}\n     {Pow\n      {Product Xs}\n      1.0/{Len Xs}}\n  end\n\n  fun {HMean Xs}\n     {Len Xs}\n     /\n     {Sum {Map Xs fun {$ X} 1.0 / X end}}\n  end\n\n  Numbers = {Map {List.number 1 10 1} Int.toFloat}\n\n  [A G H] = [{AMean Numbers} {GMean Numbers} {HMean Numbers}]\nin\n  {Show [A G H]}\n  A >= G = true\n  G >= H = true\n"
                }
            ],
            [
                {
                    "language": "Modula-2",
                    "solution": "MODULE PythagoreanMeans;\nFROM FormatString IMPORT FormatString;\nFROM LongMath IMPORT power;\nFROM LongStr IMPORT RealToStr;\nFROM Terminal IMPORT WriteString,WriteLn,ReadChar;\n\nPROCEDURE ArithmeticMean(numbers : ARRAY OF LONGREAL) : LONGREAL;\nVAR\n    i,cnt : CARDINAL;\n    mean : LONGREAL;\nBEGIN\n    mean := 0.0;\n    cnt := 0;\n    FOR i:=0 TO HIGH(numbers) DO\n        mean := mean + numbers[i];\n        INC(cnt);\n    END;\n    RETURN mean / LFLOAT(cnt)\nEND ArithmeticMean;\n\nPROCEDURE GeometricMean(numbers : ARRAY OF LONGREAL) : LONGREAL;\nVAR\n    i,cnt : CARDINAL;\n    mean : LONGREAL;\nBEGIN\n    mean := 1.0;\n    cnt := 0;\n    FOR i:=0 TO HIGH(numbers) DO\n        mean := mean * numbers[i];\n        INC(cnt);\n    END;\n    RETURN power(mean, 1.0 / LFLOAT(cnt))\nEND GeometricMean;\n\nPROCEDURE HarmonicMean(numbers : ARRAY OF LONGREAL) : LONGREAL;\nVAR\n    i,cnt : CARDINAL;\n    mean : LONGREAL;\nBEGIN\n    mean := 0.0;\n    cnt := 0;\n    FOR i:=0 TO HIGH(numbers) DO\n        mean := mean + ( 1.0 / numbers[i]);\n        INC(cnt);\n    END;\n    RETURN LFLOAT(cnt) / mean\nEND HarmonicMean;\n\n\nCONST Size = 10;\nTYPE DA = ARRAY[1..Size] OF LONGREAL;\n\nVAR\n    buf : ARRAY[0..63] OF CHAR;\n    array : DA;\n    arithmetic,geometric,harmonic : LONGREAL;\nBEGIN\n    array := DA{1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0};\n\n    arithmetic := ArithmeticMean(array);\n    geometric := GeometricMean(array);\n    harmonic := HarmonicMean(array);\n\n    WriteString(\"A = \");\n    RealToStr(arithmetic, buf);\n    WriteString(buf);\n    WriteString(\" G = \");\n    RealToStr(geometric, buf);\n    WriteString(buf);\n    WriteString(\" H = \");\n    RealToStr(harmonic, buf);\n    WriteString(buf);\n    WriteLn;\n\n    FormatString(\"A >= G is %b, G >= H is %b\\n\", buf, arithmetic >= geometric, geometric >= harmonic);\n    WriteString(buf);\n\n    ReadChar\nEND PythagoreanMeans.\n"
                },
                {
                    "language": "PL-I",
                    "solution": "declare n fixed binary,\n        (Average, Geometric, Harmonic) float;\ndeclare A(10) float static initial (1,2,3,4,5,6,7,8,9,10);\n\nn = hbound(A,1);\n\n/* compute the average */\nAverage = sum(A)/n;\n\n/* Compute the geometric mean: */\nGeometric = prod(A)**(1/n);\n\n/* Compute the Harmonic mean: */\nHarmonic = n / sum(1/A);\n\nput skip data (Average);\nput skip data (Geometric);\nput skip data (Harmonic);\n\nif Average < Geometric then put skip list ('Error');\nif Geometric < Harmonic then put skip list ('Error');\n"
                }
            ],
            [
                {
                    "language": "Processing",
                    "solution": "void setup() {\n  float[] numbers = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n  println(\"Arithmetic mean: \" + arithmeticMean(numbers));\n  println(\"Geometric mean: \" + geometricMean(numbers));\n  println(\"Harmonic mean: \" + harmonicMean(numbers));\n}\n\nfloat arithmeticMean(float[] nums) {\n  float mean = 0;\n  for (float n : nums) {\n    mean += n;\n  }\n  mean = mean / nums.length;\n  return mean;\n}\n\nfloat geometricMean(float[] nums) {\n  float mean = 1;\n  for (float n : nums) {\n    mean *= n;\n  }\n  mean = pow(mean, 1.0 / nums.length);\n  return mean;\n}\n\nfloat harmonicMean(float[] nums) {\n  float mean = 0;\n  for (float n : nums) {\n    mean += 1 / n;\n  }\n  mean = nums.length / mean;\n  return mean;\n}\n"
                },
                {
                    "language": "Go",
                    "solution": "package main\n\nimport (\n    \"fmt\"\n    \"math\"\n)\n\nfunc main() {\n    sum, sumr, prod := 0., 0., 1.\n    for n := 1.; n <= 10; n++ {\n        sum += n\n        sumr += 1 / n\n        prod *= n\n    }\n    a, g, h := sum/10, math.Pow(prod, .1), 10/sumr\n    fmt.Println(\"A:\", a, \"G:\", g, \"H:\", h)\n    fmt.Println(\"A >= G >= H:\", a >= g && g >= h)\n}\n"
                }
            ],
            [
                {
                    "language": "Euler",
                    "solution": ">function A(x) := mean(x)\n>function G(x) := exp(mean(log(x)))\n>function H(x) := 1/mean(1/x)\n>x=1:10; A(x), G(x), H(x)\n 5.5\n 4.52872868812\n 3.41417152147\n"
                },
                {
                    "language": "JavaScript",
                    "solution": "{\n  \"values\": {\n    \"Arithmetic\": 5.5,\n    \"Geometric\": 4.528728688116765,\n    \"Harmonic\": 3.414171521474055\n  },\n  \"test\": \"is A >= G >= H ? yes\"\n}\n"
                }
            ],
            [
                {
                    "language": "Futhark",
                    "solution": "fun arithmetic_mean(as: [n]f64): f64 =\n  reduce (+) 0.0 (map (/f64(n)) as)\n\nfun geometric_mean(as: [n]f64): f64 =\n  reduce (*) 1.0 (map (**(1.0/f64(n))) as)\n\nfun harmonic_mean(as: [n]f64): f64 =\n  f64(n) / reduce (+) 0.0 (map (1.0/) as)\n\nfun main(as: [n]f64): (f64,f64,f64) =\n  (arithmetic_mean as,\n   geometric_mean as,\n   harmonic_mean as)\n"
                },
                {
                    "language": "Python",
                    "solution": "from operator import mul\nfrom functools import reduce\n\n\ndef amean(num):\n    return sum(num) / len(num)\n\n\ndef gmean(num):\n    return reduce(mul, num, 1)**(1 / len(num))\n\n\ndef hmean(num):\n    return len(num) / sum(1 / n for n in num)\n\n\nnumbers = range(1, 11)  # 1..10\na, g, h = amean(numbers), gmean(numbers), hmean(numbers)\nprint(a, g, h)\nassert a >= g >= h\n"
                }
            ]
        ]
    },
    {
        "task_name": "Averages-Root-mean-square",
        "task_description": ";Task\n\nCompute the &nbsp; [[wp:Root mean square|Root mean square]] &nbsp; of the numbers 1..10.\n\n\nThe &nbsp; ''root mean square'' &nbsp; is also known by its initials RMS (or rms), and as the '''quadratic mean'''.\n\nThe RMS is calculated as the mean of the squares of the numbers, square-rooted:\n\n\n::: <big><math>x_{\\mathrm{rms}} = \\sqrt {{{x_1}^2 + {x_2}^2 + \\cdots + {x_n}^2} \\over n}. </math></big>\n\n\n;See also\n\n{{Related tasks/Statistical measures}}\n\n<br><hr>\n\n",
        "solution_pairs": [
            [
                {
                    "language": "Fortran",
                    "solution": "print *,sqrt( sum(x**2)/size(x) )\n"
                },
                {
                    "language": "VBA",
                    "solution": "Function rms(iLow As Integer, iHigh As Integer)\n    Dim i As Integer\n    If iLow > iHigh Then\n        i = iLow\n        iLow = iHigh\n        iHigh = i\n    End If\n    For i = iLow To iHigh\n        rms = rms + i ^ 2\n    Next i\n    rms = Sqr(rms / (iHigh - iLow + 1))\nEnd Function\n\nSub foo()\n    Debug.Print rms(1, 10)\nEnd Sub\n"
                }
            ],
            [
                {
                    "language": "PostScript",
                    "solution": "/findrms{\n/x exch def\n/sum 0 def\n/i 0 def\nx length 0 eq{}\n{\nx length{\n/sum x i get 2 exp sum add def\n/i i 1 add def\n}repeat\n/sum sum x length div sqrt def\n}ifelse\nsum ==\n}def\n\n[1 2 3 4 5 6 7 8 9 10] findrms\n"
                },
                {
                    "language": "SNOBOL4",
                    "solution": "        define('rms(a)i,ssq') :(rms_end)\nrms     i = i + 1; ssq = ssq + (a<i> * a<i>) :s(rms)\n        rms = sqrt(1.0 * ssq / prototype(a)) :(return)\nrms_end\n\n*       # Fill array, test and display\n        str = '1 2 3 4 5 6 7 8 9 10'; a = array(10)\nloop    i = i + 1; str len(p) span('0123456789') . a<i> @p :s(loop)\n        output = str ' -> ' rms(a)\nend\n"
                }
            ],
            [
                {
                    "language": "Futhark",
                    "solution": "import \"futlib/math\"\n\nfun main(as: [n]f64): f64 =\n  f64.sqrt ((reduce (+) 0.0 (map (**2.0) as)) / f64(n))\n"
                },
                {
                    "language": "AppleScript",
                    "solution": "on rootMeanSquare(listOfNumbers)\n    script o\n        property lst : listOfNumbers\n    end script\n    set r to 0.0\n    repeat with n in o's lst\n        set r to r + (n ^ 2)\n    end repeat\n\n    return (r / (count o's lst)) ^ 0.5\nend rootMeanSquare\n\nrootMeanSquare({1, 2, 3, 4, 5, 6, 7, 8, 9, 10})\n"
                }
            ],
            [
                {
                    "language": "Excel",
                    "solution": "=SQRT(SUMSQ($A1:$A10)/COUNT($A1:$A10))\n"
                },
                {
                    "language": "OoRexx",
                    "solution": "call testAverage .array~of(10, 9, 8, 7, 6, 5, 4, 3, 2, 1)\ncall testAverage .array~of(10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0, 0, 0, 0, .11)\ncall testAverage .array~of(30, 10, 20, 30, 40, 50, -100, 4.7, -11e2)\n\n::routine testAverage\n  use arg list\n  say \"list =\" list~toString(\"l\", \", \")\n  say \"root mean square =\" rootmeansquare(list)\n  say\n\n::routine rootmeansquare\n  use arg numbers\n  -- return zero for an empty list\n  if numbers~isempty then return 0\n\n  sum = 0\n  do number over numbers\n      sum += number * number\n  end\n  return rxcalcsqrt(sum/numbers~items)\n\n::requires rxmath LIBRARY\n"
                }
            ],
            [
                {
                    "language": "BQN",
                    "solution": "6.2048368229954285\n"
                },
                {
                    "language": "Lasso",
                    "solution": "define rms(a::staticarray)::decimal => {\n\treturn math_sqrt((with n in #a sum #n*#n) / decimal(#a->size))\n}\nrms(generateSeries(1,10)->asStaticArray)\n"
                }
            ]
        ]
    },
    {
        "task_name": "Averages-Simple-moving-average",
        "task_description": "Computing the [[wp:Moving_average#Simple_moving_average|simple moving average]] of a series of numbers.\n\n;Task\n\nCreate a [[wp:Stateful|stateful]] function/class/instance that takes a period and returns a routine that takes a number as argument and returns a simple moving average of its arguments so far.\n\n{{task heading|Description}}\n\nA simple moving average is a method for computing an average of a stream of numbers by only averaging the last &nbsp; P &nbsp; numbers from the stream, &nbsp; where &nbsp; P &nbsp; is known as the period. \n\nIt can be implemented by calling an initialing routine with &nbsp; P &nbsp; as its argument, &nbsp; I(P), &nbsp; which should then return a routine that when called with individual, successive members of a stream of numbers, computes the mean of (up to), the last &nbsp; P &nbsp; of them, lets call this &nbsp; SMA().\n\nThe word &nbsp; ''stateful'' &nbsp; in the task description refers to the need for &nbsp; SMA() &nbsp; to remember certain information between calls to it:\n* &nbsp; The period, &nbsp; P\n* &nbsp; An ordered container of at least the last &nbsp; P &nbsp; numbers from each of its individual calls.\n\n<br>\n''Stateful'' &nbsp;  also means that successive calls to &nbsp; I(), &nbsp; the initializer, &nbsp; should return separate routines that do &nbsp; ''not'' &nbsp; share saved state so they could be used on two independent streams of data.\n\nPseudo-code for an implementation of &nbsp; SMA &nbsp; is:\n<pre>\nfunction SMA(number: N):\n    stateful integer: P\n    stateful list:    stream\n    number:           average\n\n    stream.append_last(N)\n    if stream.length() > P:\n        # Only average the last P elements of the stream\n        stream.delete_first()\n    if stream.length() == 0:\n        average = 0\n    else:    \n        average = sum( stream.values() ) / stream.length()\n    return average\n</pre>\n\n{{task heading|See also}}\n\n{{Related tasks/Statistical measures}}\n\n<hr>\n\n",
        "solution_pairs": [
            [
                {
                    "language": "Oforth",
                    "solution": ": test\n| sma3 sma5 l |\n   3 createSMA -> sma3\n   5 createSMA -> sma5\n   [ 1, 2, 3, 4, 5, 5, 4, 3, 2, 1 ] ->l\n   \"SMA3\" .cr l apply( #[ sma3 perform . ] ) printcr\n   \"SMA5\" .cr l apply( #[ sma5 perform . ] ) ;\n"
                },
                {
                    "language": "AWK",
                    "solution": "#!/usr/bin/awk -f\n# Moving average over the first column of a data file\nBEGIN {\n    P = 5;\n}\n\n{\n    x = $1;\t\n    i = NR % P;\n    MA += (x - Z[i]) / P;\n    Z[i] = x;\n    print MA;\t\n}\n"
                }
            ],
            [
                {
                    "language": "Ada",
                    "solution": "generic\n   Max_Elements : Positive;\n   type Number is digits <>;\npackage Moving is\n   procedure Add_Number (N : Number);\n   function Moving_Average (N : Number) return Number;\n   function Get_Average return Number;\nend Moving;\n"
                },
                {
                    "language": "BBC-BASIC",
                    "solution": "      MAXPERIOD = 10\n      FOR n = 1 TO 5\n        PRINT \"Number = \";n TAB(12) \" SMA3 = \";FNsma(n,3) TAB(30) \" SMA5 = \";FNsma(n,5)\n      NEXT\n      FOR n = 5 TO 1 STEP -1\n        PRINT \"Number = \";n TAB(12) \" SMA3 = \";FNsma(n,3) TAB(30) \" SMA5 = \";FNsma(n,5)\n      NEXT\n      END\n\n      DEF FNsma(number, period%)\n      PRIVATE nums(), accum(), index%(), window%()\n      DIM nums(MAXPERIOD,MAXPERIOD), accum(MAXPERIOD)\n      DIM index%(MAXPERIOD), window%(MAXPERIOD)\n      accum(period%) += number - nums(period%,index%(period%))\n      nums(period%,index%(period%)) = number\n      index%(period%) = (index%(period%) + 1) MOD period%\n      IF window%(period%)<period% window%(period%) += 1\n      = accum(period%) / window%(period%)\n"
                }
            ],
            [
                {
                    "language": "Smalltalk",
                    "solution": "|sma3 sma5|\n\nsma3 := MovingAverage newWithPeriod: 3.\nsma5 := MovingAverage newWithPeriod: 5.\n\n#( 1 2 3 4 5 5 4 3 2 1 ) do: [ :v |\n  ('Next number %1, SMA_3 = %2, SMA_5 = %3' % {\n         v . (sma3 add: v) asFloat . (sma5 add: v) asFloat\n    }) displayNl\n]\n"
                },
                {
                    "language": "D",
                    "solution": "import std.stdio, std.traits, std.algorithm;\n\nstruct SMA(T, int period) {\n    T[period] data = 0;\n    T sum = 0;\n    int index, nFilled;\n\n    auto opCall(in T v) pure nothrow @safe @nogc {\n        sum += -data[index] + v;\n        data[index] = v;\n        index = (index + 1) % period;\n        nFilled = min(period, nFilled + 1);\n        return CommonType!(T, float)(sum) / nFilled;\n    }\n}\n\nvoid main() {\n    SMA!(int, 3) s3;\n    SMA!(double, 5) s5;\n\n    foreach (immutable e; [1, 2, 3, 4, 5, 5, 4, 3, 2, 1])\n        writefln(\"Added %d, sma(3) = %f, sma(5) = %f\", e, s3(e), s5(e));\n}\n"
                }
            ],
            [
                {
                    "language": "Dyalect",
                    "solution": "func avg(xs) {\n    var acc = 0.0\n    var c = 0\n    for x in xs {\n        c += 1\n        acc += x\n    }\n    acc / c\n}\n\nfunc sma(p) {\n    var s = []\n    x => {\n        if s.Length() >= p {\n            s.RemoveAt(0)\n        }\n        s.Insert(s.Length(), x)\n        avg(s)\n    };\n}\n\nvar nums = Iterator.Concat(1.0..5.0, 5.0^-1.0..1.0)\nvar sma3 = sma(3)\nvar sma5 = sma(5)\n\nfor n in nums {\n    print(\"\\(n)\\t(sma3) \\(sma3(n))\\t(sma5) \\(sma5(n))\")\n}\n"
                },
                {
                    "language": "C",
                    "solution": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n\ntypedef struct sma_obj {\n  double sma;\n  double sum;\n  int period;\n  double *values;\n  int lv;\n} sma_obj_t;\n\ntypedef union sma_result {\n  sma_obj_t *handle;\n  double sma;\n  double *values;\n} sma_result_t;\n\nenum Action { SMA_NEW, SMA_FREE, SMA_VALUES, SMA_ADD, SMA_MEAN };\nsma_result_t sma(enum Action action, ...)\n{\n  va_list vl;\n  sma_result_t r;\n  sma_obj_t *o;\n  double v;\n\n  va_start(vl, action);\n  switch(action) {\n  case SMA_NEW: // args: int period\n    r.handle = malloc(sizeof(sma_obj_t));\n    r.handle->sma = 0.0;\n    r.handle->period = va_arg(vl, int);\n    r.handle->values = malloc(r.handle->period * sizeof(double));\n    r.handle->lv = 0;\n    r.handle->sum = 0.0;\n    break;\n  case SMA_FREE: // args: sma_obj_t *handle\n    r.handle = va_arg(vl, sma_obj_t *);\n    free(r.handle->values);\n    free(r.handle);\n    r.handle = NULL;\n    break;\n  case SMA_VALUES: // args: sma_obj_t *handle\n    o = va_arg(vl, sma_obj_t *);\n    r.values = o->values;\n    break;\n  case SMA_MEAN: // args: sma_obj_t *handle\n    o = va_arg(vl, sma_obj_t *);\n    r.sma = o->sma;\n    break;\n  case SMA_ADD: // args: sma_obj_t *handle, double value\n    o = va_arg(vl, sma_obj_t *);\n    v = va_arg(vl, double);\n    if ( o->lv < o->period ) {\n      o->values[o->lv++] = v;\n      o->sum += v;\n      o->sma = o->sum / o->lv;\n    } else {\n      o->sum -= o->values[ o->lv % o->period];\n      o->sum += v;\n      o->sma = o->sum / o->period;\n      o->values[ o->lv % o->period ] = v; o->lv++;\n    }\n    r.sma = o->sma;\n    break;\n  }\n  va_end(vl);\n  return r;\n}\n"
                }
            ],
            [
                {
                    "language": "VBScript",
                    "solution": "data = \"1,2,3,4,5,5,4,3,2,1\"\ntoken = Split(data,\",\")\nstream = \"\"\nWScript.StdOut.WriteLine \"Number\" & vbTab & \"SMA3\" & vbTab & \"SMA5\"\nFor j = LBound(token) To UBound(token)\n\tIf Len(stream) = 0 Then\n\t\tstream = token(j)\n\tElse\n\t\tstream = stream & \",\" & token(j)\n\tEnd If\n\tWScript.StdOut.WriteLine token(j) & vbTab & Round(SMA(stream,3),2) & vbTab & Round(SMA(stream,5),2)\nNext\n\nFunction SMA(s,p)\n\tIf Len(s) = 0 Then\n\t\tSMA = 0\n\t\tExit Function\n\tEnd If\n\td = Split(s,\",\")\n\tsum = 0\n\tIf UBound(d) + 1 >= p Then\n\t\tc = 0\n\t\tFor i = UBound(d) To LBound(d) Step -1\n\t\t\tsum = sum + Int(d(i))\n\t\t\tc = c + 1\n\t\t\tIf c = p Then\n\t\t\t\tExit For\n\t\t\tEnd If\n\t\tNext\n\t\tSMA = sum / p\n\tElse\n\t\tFor i = UBound(d) To LBound(d) Step -1\n\t\t\tsum = sum + Int(d(i))\n\t\tNext\n\t\tSMA = sum / (UBound(d) + 1)\n\tEnd If\nEnd Function\n"
                },
                {
                    "language": "Liberty-BASIC",
                    "solution": "    dim v$( 100)                                                            '   Each array term stores a particular SMA of period p in p*10 bytes\n\n    nomainwin\n\n    WindowWidth  =1080\n    WindowHeight = 780\n\n    graphicbox #w.gb1,   20,   20, 1000,  700\n\n    open \"Running averages to smooth data\" for window as #w\n\n    #w \"trapclose quit\"\n\n    #w.gb1 \"down\"\n\n    old.x         =  0\n    old.y.orig    =500  '   black\n    old.y.3.SMA   =350  '     red\n    old.y.20.SMA  =300  '   green\n\n    for i =0 to 999 step 1\n        scan\n        v       =1.1 +sin( i /1000 *2 *3.14159265) + 0.2 *rnd( 1)               '   sin wave with added random noise\n        x       =i /6.28318 *1000\n        y.orig  =500 -v /2.5 *500\n\n        #w.gb1 \"color black ; down ; line \"; i-1; \" \"; old.y.orig;  \" \"; i; \" \"; y.orig;         \" ; up\"\n\n        y.3.SMA =500 -SMA( 1, v,  3) /2.5 *500                                  '   SMA given ID of 1 is to do 3-term  running average\n        #w.gb1 \"color red   ; down ; line \"; i-1; \" \"; old.y.3.SMA +50;  \" \"; i; \" \"; y.3.SMA  +50;  \" ; up\"\n\n        y.20.SMA =500 -SMA( 2, v, 20) /2.5 *500                                 '   SMA given ID of 2 is to do 20-term running average\n        #w.gb1 \"color green ; down ; line \"; i-1; \" \"; old.y.20.SMA +100; \" \"; i; \" \"; y.20.SMA +100; \" ; up\"\n\n        'print \"Supplied with \"; v; \", so SMAs are now \"; using( \"###.###\", SMA( 1, v, 3)); \" over 3 terms or \"; using( \"###.###\", SMA( 2, v, 5)) ; \" over 5 terms.\"  '   ID, latest data, period\n\n        old.y.orig    =y.orig\n        old.y.3.SMA   =y.3.SMA\n        old.y.20.SMA  =y.20.SMA\n    next i\n\n    wait\n\nsub quit j$\n    close #w\n    end\nend sub\n\n\n\nfunction SMA( ID, Number, Period)\n    v$( ID) =right$( \"          \" +str$( Number), 10) +v$( ID)              '   add new number at left, lose last number on right\n    v$( ID) =left$( v$( ID), Period *10)\n    'print \"{\"; v$( ID); \"}\",\n\n    k      =0   '   number of terms read\n    total  =0   '   sum of terms read\n\n    do\n        p$     =mid$( v$( ID), 1 +k *10, 10)\n        if p$ =\"\" then exit do\n        vv     =val( p$)\n        total  =total +vv\n        k      =k +1\n    loop until p$ =\"\"\n\n    if k <Period then SMA =total / k else  SMA =total /Period\nend function\n"
                }
            ]
        ]
    },
    {
        "task_name": "AVL-tree",
        "task_description": "<br>\nIn computer science, an '''AVL tree''' is a self-balancing binary search tree. In an AVL tree, the heights of the two child subtrees of any node differ by at most one; at no time do they differ by more than one because rebalancing is done ensure this is the case. Lookup, insertion, and deletion all take O(log ''n'') time in both the average and worst cases, where n is the number of nodes in the tree prior to the operation. Insertions and deletions may require the tree to be rebalanced by one or more tree rotations. Note the tree of nodes comprise a set, so duplicate node keys are not allowed.\n\nAVL trees are often compared with [[Red_black_trees|red-black trees]] because they support the same set of operations and because red-black trees also take O(log ''n'') time for the basic operations.  Because AVL trees are more rigidly balanced, they are faster than red-black trees for lookup-intensive applications. Similar to red-black trees, AVL trees are height-balanced, but in general not weight-balanced nor \u00ce\u00bc-balanced; that is, sibling nodes can have hugely differing numbers of descendants.\n\n\n;Task:\nImplement an AVL tree in the language of choice, and provide at least basic operations.\n<br><br>\n;Related task\n[[Red_black_tree_sort]]\n<br><br>\n",
        "solution_pairs": [
            [
                {
                    "language": "Raku",
                    "solution": "class AVL-Tree {\n    has $.root is rw = 0;\n\n    class Node {\n        has $.key    is rw = '';\n        has $.parent is rw = 0;\n        has $.data   is rw = 0;\n        has $.left   is rw = 0;\n        has $.right  is rw = 0;\n        has Int $.balance is rw = 0;\n        has Int $.height  is rw = 0;\n    }\n\n    #=====================================================\n    # public methods\n    #=====================================================\n\n    #| returns a node object or 0 if not found\n    method find($key) {\n        return 0 if !$.root;\n        self!find: $key, $.root;\n    }\n\n    #| returns a list of tree keys\n    method keys() {\n        return () if !$.root;\n        my @list;\n        self!keys: $.root, @list;\n        @list;\n    }\n\n    #| returns a list of tree nodes\n    method nodes() {\n        return () if !$.root;\n        my @list;\n        self!nodes: $.root, @list;\n        @list;\n    }\n\n    #| insert a node key, optionally add data (the `parent` arg is for\n    #| internal use only)\n    method insert($key, :$data = 0, :$parent = 0,) {\n        return $.root = Node.new: :$key, :$parent, :$data if !$.root;\n        my $n = $.root;\n        while True {\n            return False if $n.key eq $key;\n            my $parent = $n;\n            my $goLeft = $n.key > $key;\n            $n = $goLeft ?? $n.left !! $n.right;\n            if !$n {\n                if $goLeft {\n                    $parent.left = Node.new: :$key, :$parent, :$data;\n                }\n                else {\n                    $parent.right = Node.new: :$key, :$parent, :$data;\n                }\n                self!rebalance: $parent;\n                last\n            }\n        }\n        True\n    }\n\n    #| delete one or more nodes by key\n    method delete(*@del-key) {\n        return if !$.root;\n        for @del-key -> $del-key {\n            my $child = $.root;\n            while $child {\n                my $node = $child;\n                $child = $del-key >= $node.key ?? $node.right !! $node.left;\n                if $del-key eq $node.key {\n                    self!delete: $node;\n                    next;\n                }\n            }\n        }\n    }\n\n    #| show a list of all nodes by key\n    method show-keys {\n        self!show-keys: $.root;\n        say()\n    }\n\n    #| show a list of all nodes' balances (not normally needed)\n    method show-balances {\n        self!show-balances: $.root;\n        say()\n    }\n\n    #=====================================================\n    # private methods\n    #=====================================================\n\n    method !delete($node) {\n        if !$node.left && !$node.right {\n            if !$node.parent {\n                $.root = 0;\n            }\n            else {\n                my $parent = $node.parent;\n                if $parent.left === $node {\n                    $parent.left = 0;\n                }\n                else {\n                    $parent.right = 0;\n                }\n                self!rebalance: $parent;\n            }\n            return\n        }\n\n        if $node.left {\n            my $child = $node.left;\n            while $child.right {\n                $child = $child.right;\n            }\n            $node.key = $child.key;\n            self!delete: $child;\n        }\n        else {\n            my $child = $node.right;\n            while $child.left {\n                $child = $child.left;\n            }\n            $node.key = $child.key;\n            self!delete: $child;\n        }\n    }\n\n    method !rebalance($n is copy) {\n        self!set-balance: $n;\n\n        if $n.balance == -2 {\n            if self!height($n.left.left) >= self!height($n.left.right) {\n                $n = self!rotate-right: $n;\n            }\n            else {\n                $n = self!rotate-left'right: $n;\n            }\n        }\n        elsif $n.balance == 2 {\n            if self!height($n.right.right) >= self!height($n.right.left) {\n                $n = self!rotate-left: $n;\n            }\n            else {\n                $n = self!rotate-right'left: $n;\n            }\n        }\n\n        if $n.parent {\n            self!rebalance: $n.parent;\n        }\n        else {\n            $.root = $n;\n        }\n    }\n\n    method !rotate-left($a) {\n\n        my $b     = $a.right;\n        $b.parent = $a.parent;\n\n        $a.right = $b.left;\n\n        if $a.right {\n            $a.right.parent = $a;\n        }\n\n        $b.left   = $a;\n        $a.parent = $b;\n\n        if $b.parent {\n            if $b.parent.right === $a {\n                $b.parent.right = $b;\n            }\n            else {\n                $b.parent.left = $b;\n            }\n        }\n\n        self!set-balance: $a, $b;\n        $b;\n    }\n\n    method !rotate-right($a) {\n\n        my $b = $a.left;\n        $b.parent = $a.parent;\n\n        $a.left = $b.right;\n\n        if $a.left {\n            $a.left.parent = $a;\n        }\n\n        $b.right  = $a;\n        $a.parent = $b;\n\n        if $b.parent {\n            if $b.parent.right === $a {\n                $b.parent.right = $b;\n            }\n            else {\n                $b.parent.left = $b;\n            }\n        }\n\n        self!set-balance: $a, $b;\n\n        $b;\n    }\n\n    method !rotate-left'right($n) {\n        $n.left = self!rotate-left: $n.left;\n        self!rotate-right: $n;\n    }\n\n    method !rotate-right'left($n) {\n        $n.right = self!rotate-right: $n.right;\n        self!rotate-left: $n;\n    }\n\n    method !height($n) {\n        $n ?? $n.height !! -1;\n    }\n\n    method !set-balance(*@n) {\n        for @n -> $n {\n            self!reheight: $n;\n            $n.balance = self!height($n.right) - self!height($n.left);\n        }\n    }\n\n    method !show-balances($n) {\n        if $n {\n            self!show-balances: $n.left;\n            printf \"%s \", $n.balance;\n            self!show-balances: $n.right;\n        }\n    }\n\n    method !reheight($node) {\n        if $node {\n            $node.height = 1 + max self!height($node.left), self!height($node.right);\n        }\n    }\n\n    method !show-keys($n) {\n        if $n {\n            self!show-keys: $n.left;\n            printf \"%s \", $n.key;\n            self!show-keys: $n.right;\n        }\n    }\n\n    method !nodes($n, @list) {\n        if $n {\n            self!nodes: $n.left, @list;\n            @list.push: $n if $n;\n            self!nodes: $n.right, @list;\n        }\n    }\n\n    method !keys($n, @list) {\n        if $n {\n            self!keys: $n.left, @list;\n            @list.push: $n.key if $n;\n            self!keys: $n.right, @list;\n        }\n    }\n\n    method !find($key, $n) {\n        if $n {\n            self!find: $key, $n.left;\n            return $n if $n.key eq $key;\n            self!find: $key, $n.right;\n        }\n    }\n}\n"
                },
                {
                    "language": "Logtalk",
                    "solution": ":- object(avltree,\n\timplements(dictionaryp),\n\textends(term)).\n\n% ... lots of elision ...\n\n:- end_object.\n"
                }
            ],
            [
                {
                    "language": "Go",
                    "solution": "package main\n\nimport (\n    \"encoding/json\"\n    \"fmt\"\n    \"log\"\n\n    \"avl\"\n)\n\ntype intKey int\n\n// satisfy avl.Key\nfunc (k intKey) Less(k2 avl.Key) bool { return k < k2.(intKey) }\nfunc (k intKey) Eq(k2 avl.Key) bool   { return k == k2.(intKey) }\n\n// use json for cheap tree visualization\nfunc dump(tree *avl.Node) {\n    b, err := json.MarshalIndent(tree, \"\", \"   \")\n    if err != nil {\n        log.Fatal(err)\n    }\n    fmt.Println(string(b))\n}\n\nfunc main() {\n    var tree *avl.Node\n    fmt.Println(\"Empty tree:\")\n    dump(tree)\n\n    fmt.Println(\"\\nInsert test:\")\n    avl.Insert(&tree, intKey(3))\n    avl.Insert(&tree, intKey(1))\n    avl.Insert(&tree, intKey(4))\n    avl.Insert(&tree, intKey(1))\n    avl.Insert(&tree, intKey(5))\n    dump(tree)\n\n    fmt.Println(\"\\nRemove test:\")\n    avl.Remove(&tree, intKey(3))\n    avl.Remove(&tree, intKey(1))\n    dump(tree)\n}\n"
                },
                {
                    "language": "Tcl",
                    "solution": "package require TclOO\n\nnamespace eval AVL {\n    # Class for the overall tree; manages real public API\n    oo::class create Tree {\n\tvariable root nil class\n\tconstructor {{nodeClass AVL::Node}} {\n\t    set class [oo::class create Node [list superclass $nodeClass]]\n\n\t    # Create a nil instance to act as a leaf sentinel\n\t    set nil [my NewNode \"\"]\n\t    set root [$nil ref]\n\n\t    # Make nil be special\n\t    oo::objdefine $nil {\n\t\tmethod height {} {return 0}\n\t\tmethod key {} {error \"no key possible\"}\n\t\tmethod value {} {error \"no value possible\"}\n\t\tmethod destroy {} {\n\t\t    # Do nothing (doesn't prohibit destruction entirely)\n\t\t}\n\t\tmethod print {indent increment} {\n\t\t    # Do nothing\n\t\t}\n\t    }\n\t}\n\n\t# How to actually manufacture a new node\n\tmethod NewNode {key} {\n\t    if {![info exists nil]} {set nil \"\"}\n\t    $class new $key $nil [list [namespace current]::my NewNode]\n\t}\n\n\t# Create a new node in the tree and return it\n\tmethod insert {key} {\n\t    set node [my NewNode $key]\n\t    if {$root eq $nil} {\n\t\tset root $node\n\t    } else {\n\t\t$root insert $node\n\t    }\n\t    return $node\n\t}\n\n\t# Find the node for a particular key\n\tmethod lookup {key} {\n\t    for {set node $root} {$node ne $nil} {} {\n\t\tif {[$node key] == $key} {\n\t\t    return $node\n\t\t} elseif {[$node key] > $key} {\n\t\t    set node [$node left]\n\t\t} else {\n\t\t    set node [$node right]\n\t\t}\n\t    }\n\t    error \"no such node\"\n\t}\n\n\t# Print a tree out, one node per line\n\tmethod print {{indent 0} {increment 1}} {\n\t    $root print $indent $increment\n\t    return\n\t}\n    }\n\n    # Class of an individual node; may be subclassed\n    oo::class create Node {\n\tvariable key value left right 0 refcount newNode\n\tconstructor {n nil instanceFactory} {\n\t    set newNode $instanceFactory\n\t    set 0 [expr {$nil eq \"\" ? [self] : $nil}]\n\t    set key $n\n\t    set value {}\n\t    set left [set right $0]\n\t    set refcount 0\n\t}\n\tmethod ref {} {\n\t    incr refcount\n\t    return [self]\n\t}\n\tmethod destroy {} {\n\t    if {[incr refcount -1] < 1} next\n\t}\n\tmethod New {key value} {\n\t    set n [{*}$newNode $key]\n\t    $n setValue $value\n\t    return $n\n\t}\n\n\t# Getters\n\tmethod key {} {return $key}\n\tmethod value {} {return $value}\n\tmethod left {} {return $left}\n\tmethod right {args} {return $right}\n\n\t# Setters\n\tmethod setValue {newValue} {\n\t    set value $newValue\n\t}\n\tmethod setLeft {node} {\n\t    # Non-trivial because of reference management\n\t    $node ref\n\t    $left destroy\n\t    set left $node\n\t    return\n\t}\n\tmethod setRight {node} {\n\t    # Non-trivial because of reference management\n\t    $node ref\n\t    $right destroy\n\t    set right $node\n\t    return\n\t}\n\n\t# Print a node and its descendents\n\tmethod print {indent increment} {\n\t    puts [format \"%s%s => %s\" [string repeat \" \" $indent] $key $value]\n\t    incr indent $increment\n\t    $left print $indent $increment\n\t    $right print $indent $increment\n\t}\n\n\tmethod height {} {\n\t    return [expr {max([$left height], [$right height]) + 1}]\n\t}\n\tmethod balanceFactor {} {\n\t    expr {[$left height] - [$right height]}\n\t}\n\n\tmethod insert {node} {\n\t    # Simple insertion\n\t    if {$key > [$node key]} {\n\t\tif {$left eq $0} {\n\t\t    my setLeft $node\n\t\t} else {\n\t\t    $left insert $node\n\t\t}\n\t    } else {\n\t\tif {$right eq $0} {\n\t\t    my setRight $node\n\t\t} else {\n\t\t    $right insert $node\n\t\t}\n\t    }\n\n\t    # Rebalance this node\n\t    if {[my balanceFactor] > 1} {\n\t\tif {[$left balanceFactor] < 0} {\n\t\t    $left rotateLeft\n\t\t}\n\t\tmy rotateRight\n\t    } elseif {[my balanceFactor] < -1} {\n\t\tif {[$right balanceFactor] > 0} {\n\t\t    $right rotateRight\n\t\t}\n\t\tmy rotateLeft\n\t    }\n\t}\n\n\t# AVL Rotations\n\tmethod rotateLeft {} {\n\t    set new [my New $key $value]\n\t    set key [$right key]\n\t    set value [$right value]\n\t    $new setLeft $left\n\t    $new setRight [$right left]\n\t    my setLeft $new\n\t    my setRight [$right right]\n\t}\n\n\tmethod rotateRight {} {\n\t    set new [my New $key $value]\n\t    set key [$left key]\n\t    set value [$left value]\n\t    $new setLeft [$left right]\n\t    $new setRight $right\n\t    my setLeft [$left left]\n\t    my setRight $new\n\t}\n    }\n}\n"
                }
            ],
            [
                {
                    "language": "Logtalk",
                    "solution": ":- object(avltree,\n\timplements(dictionaryp),\n\textends(term)).\n\n% ... lots of elision ...\n\n:- end_object.\n"
                },
                {
                    "language": "Component-Pascal",
                    "solution": "MODULE RosettaAVLTrees;\n\n\t(* An implementation of persistent AVL Trees *)\n\n\tTYPE\n\t\tOrder = ABSTRACT RECORD END;\n\t\tTree* = POINTER TO Node;\n\t\tNode* = ABSTRACT RECORD (Order)\n\t\t\tleft, right: Tree;\n\t\t\theight: INTEGER\n\t\tEND; (* Contains the left and right child nodes and the height of the node *)\n\n\t\tOut* = ABSTRACT RECORD END; (* Used for output by the `Draw` procedure *)\n\n\t\tVoid = RECORD (Order) END; (* Used by the `Ordered` procedure *)\n\n\t(* The following abstract procedures must be implemented by a user of `Node` *)\n\t(* They must be implemented correctly for the AVL tree to work *)\n\n\t(* Compares one node with another and returns a boolean value based on which is less *)\n\tPROCEDURE (IN n: Order) Less- (IN m: Node): BOOLEAN, NEW, ABSTRACT;\n\t(* Compares one node with another and returns a boolean value based on which is more *)\n\tPROCEDURE (IN n: Order) More- (IN m: Node): BOOLEAN, NEW, ABSTRACT;\n\t(* Creates a new root node *)\n\tPROCEDURE (IN n: Node) Alloc- (): Tree, NEW, ABSTRACT;\n\n\t(* Returns TRUE if n is in the tree t, FALSE otherwise *)\n\tPROCEDURE (IN n: Node) Lookup* (t: Tree): BOOLEAN, NEW;\n\tBEGIN\n\t\tIF t = NIL THEN RETURN FALSE END;\n\t\tIF n.Less(t) THEN RETURN n.Lookup(t.left) END;\n\t\tIF n.More(t) THEN RETURN n.Lookup(t.right) END;\n\t\tRETURN TRUE\n\tEND Lookup;\n\n\t(* Returns the height of the AVL tree t *)\n\tPROCEDURE Height (t: Tree): INTEGER;\n\tBEGIN\n\t\tIF t = NIL THEN RETURN 0 END;\n\t\tRETURN t.height\n\tEND Height;\n\n\t(* Creates and returns a new Node with the given children *)\n\tPROCEDURE (IN n: Node) New (left, right: Tree): Tree, NEW;\n\t\tVAR t: Tree;\n\tBEGIN\n\t\tt := n.Alloc(); (* Create a new root node *)\n\t\tt.left := left; t.right := right; (* set the children *)\n\t\t(* set the height of the node based on its children *)\n\t\tt.height := MAX(Height(left), Height(right)) + 1;\n\t\tRETURN t\n\tEND New;\n\n\t(* Returns the difference in height between the left and right children of a node *)\n\tPROCEDURE Slope (l, r: Tree): INTEGER;\n\tBEGIN RETURN Height(l) - Height(r) END Slope;\n\n\t(* Returns an AVL tree if it is right-heavy *)\n\tPROCEDURE (IN n: Node) BalL (l, r: Tree): Tree, NEW;\n\tBEGIN\n\t\tIF Slope(l, r) =  - 2 THEN\n\t\t\tIF Slope(r.left, r.right) = 1 THEN\n\t\t\t\tRETURN r.left.New(n.New(l, r.left.left),\n\t\t\t\t\t\t\t\t\t\t\t\t\tr.New(r.left.right, r.right))\n\t\t\tEND;\n\t\t\tRETURN r.New(n.New(l, r.left), r.right)\n\t\tEND;\n\t\tRETURN n.New(l, r)\n\tEND BalL;\n\n\t(* Returns an AVL tree if it is left-heavy *)\n\tPROCEDURE (IN n: Node) BalR (l, r: Tree): Tree, NEW;\n\tBEGIN\n\t\tIF Slope(l, r) = 2 THEN\n\t\t\tIF Slope(l.left, l.right) = - 1 THEN\n\t\t\t\tRETURN l.right.New(l.New(l.left, l.right.left),\n\t\t\t\t\t\t\t\t\t\t\t\t\t n.New(l.right.right, r))\n\t\t\tEND;\n\t\t\tRETURN l.New(l.left, n.New(l.right, r))\n\t\tEND;\n\t\tRETURN n.New(l, r)\n\tEND BalR;\n\n\t(* Returns the AVL tree t with the node n *)\n\tPROCEDURE (IN n: Node) Insert* (t: Tree): Tree, NEW;\n\tBEGIN\n\t\tIF t = NIL THEN RETURN n.New(NIL, NIL) END;\n\t\tIF n.Less(t) THEN RETURN t.BalR(n.Insert(t.left), t.right) END;\n\t\tIF n.More(t) THEN RETURN t.BalL(t.left, n.Insert(t.right)) END;\n\t\tRETURN t\n\tEND Insert;\n\n\t(* Returns the leftmost node of the non-empty tree t *)\n\tPROCEDURE (t: Tree) Head (): Tree, NEW;\n\tBEGIN\n\t\tIF t.left = NIL THEN RETURN t END;\n\t\tRETURN t.left.Head()\n\tEND Head;\n\n\t(* Returns the rightmost node of the non-empty tree t *)\n\tPROCEDURE (t: Tree) Last (): Tree, NEW;\n\tBEGIN\n\t\tIF t.right = NIL THEN RETURN t END;\n\t\tRETURN t.right.Last()\n\tEND Last;\n\n\t(* Returns the AVL tree t without the leftmost node *)\n\tPROCEDURE (IN t: Node) Tail* (): Tree, NEW;\n\tBEGIN\n\t\tIF t.left = NIL THEN RETURN t.right END;\n\t\tRETURN t.BalL(t.left.Tail(), t.right)\n\tEND Tail;\n\n\t(* Returns the AVL tree t without the rightmost node *)\n\tPROCEDURE (IN t: Node) Init* (): Tree, NEW;\n\tBEGIN\n\t\tIF t.right = NIL THEN RETURN t.left END;\n\t\tRETURN t.BalR(t.left, t.right.Init())\n\tEND Init;\n\n\t(* Returns the AVL tree t without node n *)\n\tPROCEDURE (IN n: Node) Delete* (t: Tree): Tree, NEW;\n\tBEGIN\n\t\tIF t = NIL THEN RETURN NIL END;\n\t\tIF n.Less(t) THEN RETURN t.BalL(n.Delete(t.left), t.right) END;\n\t\tIF n.More(t) THEN RETURN t.BalR(t.left, n.Delete(t.right)) END;\n\t\tIF Slope(t.left, t.right) = 1 THEN\n\t\t\tRETURN t.left.Last().BalL(t.left.Init(), t.right)\n\t\tEND;\n\t\tIF t.right = NIL THEN RETURN t.left END;\n\t\tRETURN t.right.Head().BalR(t.left, t.right.Tail())\n\tEND Delete;\n\n\t(* The following procedures are used for debugging *)\n\n\tPROCEDURE (IN n: Void) Less- (IN m: Node): BOOLEAN;\n\tBEGIN RETURN TRUE END Less;\n\n\tPROCEDURE (IN n: Void) More- (IN m: Node): BOOLEAN;\n\tBEGIN RETURN TRUE END More;\n\n\t(* Returns TRUE if the AVL tree t is ordered, FALSE otherwise *)\n\tPROCEDURE Ordered* (t: Tree): BOOLEAN;\n\t\tVAR void: Void;\n\n\t\tPROCEDURE Bounded (IN lo, hi: Order; t: Tree): BOOLEAN;\n\t\tBEGIN\n\t\t\tIF t = NIL THEN RETURN TRUE END;\n\t\t\tRETURN lo.Less(t) & hi.More(t) &\n\t\t\t\t\t\t Bounded(lo, t, t.left) & Bounded(t, hi, t.right)\n\t\tEND Bounded;\n\n\tBEGIN RETURN Bounded(void, void, t) END Ordered;\n\n\t(* The following abstract procedures must be implemented by a user of `Out` *)\n\n\t(* Writes a string *)\n\tPROCEDURE (IN o: Out) Str- (s: ARRAY OF CHAR), NEW, ABSTRACT;\n\t(* Writes an integer *)\n\tPROCEDURE (IN o: Out) Int- (i: INTEGER), NEW, ABSTRACT;\n\t(* Writes a  new-line *)\n\tPROCEDURE (IN o: Out) Ln-, NEW, ABSTRACT;\n\t(* Writes a  node *)\n\tPROCEDURE (IN o: Out) Node- (IN n: Node), NEW, ABSTRACT;\n\n\t(* Writes a tree (rotated) *)\n\tPROCEDURE (IN o: Out) Draw* (t: Tree), NEW;\n\n\t\tPROCEDURE Bars (bars, bar: ARRAY OF CHAR);\n\t\tBEGIN\n\t\t\tIF LEN(bars + bar) # 0 THEN o.Str(bars + \"+--\") END\n\t\tEND Bars;\n\n\t\tPROCEDURE Do (lBar, rBar, bars: ARRAY OF CHAR; t: Tree);\n\t\tBEGIN\n\t\t\tIF t = NIL THEN Bars(bars, lBar); o.Str(\"|\"); o.Ln\n\t\t\tELSIF (t.left = NIL) & (t.right = NIL) THEN\n\t\t\t\tBars(bars, lBar); o.Node(t); o.Ln\n\t\t\tELSE\n\t\t\t\tDo(\"|  \", \"   \", bars + rBar, t.right);\n\t\t\t\to.Str(bars + rBar + \"|\"); o.Ln;\n\t\t\t\tBars(bars, lBar); o.Node(t);\n\t\t\t\tIF Slope(t.left, t.right) # 0 THEN\n\t\t\t\t\to.Str(\" [\"); o.Int(Slope(t.left, t.right)); o.Str(\"]\")\n\t\t\t\tEND;\n\t\t\t\to.Ln;\n\t\t\t\to.Str(bars + lBar + \"|\"); o.Ln;\n\t\t\t\tDo(\"   \", \"|  \", bars + lBar, t.left)\n\t\t\tEND\n\t\tEND Do;\n\n\tBEGIN\n\t\tDo(\"\", \"\", \"\", t)\n\tEND Draw;\n\nEND RosettaAVLTrees.\n"
                }
            ],
            [
                {
                    "language": "Ada",
                    "solution": "with Ada.Text_IO, Ada.Finalization, Ada.Unchecked_Deallocation;\n\nprocedure Main is\n\n   generic\n      type Key_Type is private;\n      with function \"<\"(a, b : Key_Type) return Boolean is <>;\n      with function \"=\"(a, b : Key_Type) return Boolean is <>;\n      with function \"<=\"(a, b : Key_Type) return Boolean is <>;\n   package AVL_Tree is\n      type Tree is tagged limited private;\n      function insert(self : in out Tree; key : Key_Type) return Boolean;\n      procedure delete(self : in out Tree; key : Key_Type);\n      procedure print_balance(self : in out Tree);\n\n   private\n      type Height_Amt is range -1 .. Integer'Last;\n\n      -- Since only one key is inserted before each rebalance, the balance of\n      -- all trees/subtrees will stay in range -2 .. 2\n      type Balance_Amt is range -2 .. 2;\n\n      type Node;\n      type Node_Ptr is access Node;\n      type Node is new Ada.Finalization.Limited_Controlled with record\n         left, right, parent : Node_Ptr := null;\n         key : Key_Type;\n         balance : Balance_Amt := 0;\n      end record;\n      overriding procedure Finalize(self : in out Node);\n      subtype Node_Parent is Ada.Finalization.Limited_Controlled;\n\n      type Tree is new Ada.Finalization.Limited_Controlled with record\n         root : Node_Ptr := null;\n      end record;\n      overriding procedure Finalize(self : in out Tree);\n\n   end AVL_Tree;\n\n   package body AVL_Tree is\n\n      procedure Free_Node is new Ada.Unchecked_Deallocation(Node, Node_Ptr);\n\n      overriding procedure Finalize(self : in out Node) is\n      begin\n         Free_Node(self.left);\n         Free_Node(self.right);\n      end Finalize;\n\n      overriding procedure Finalize(self : in out Tree) is\n      begin\n         Free_Node(self.root);\n      end Finalize;\n\n\n      function height(n : Node_Ptr) return Height_Amt is\n      begin\n         if n = null then\n            return -1;\n         else\n            return 1 + Height_Amt'Max(height(n.left), height(n.right));\n         end if;\n      end height;\n\n      procedure set_balance(n : not null Node_Ptr) is\n      begin\n         n.balance := Balance_Amt(height(n.right) - height(n.left));\n      end set_balance;\n\n      procedure update_parent(parent : Node_Ptr; new_child : Node_Ptr; old_child : Node_Ptr) is\n      begin\n         if parent /= null then\n            if parent.right = old_child then\n               parent.right := new_child;\n            else\n               parent.left := new_child;\n            end if;\n         end if;\n      end update_parent;\n\n      function rotate_left(a : not null Node_Ptr) return Node_Ptr is\n         b : Node_Ptr := a.right;\n      begin\n         b.parent := a.parent;\n         a.right := b.left;\n         if a.right /= null then\n            a.right.parent := a;\n         end if;\n         b.left := a;\n         a.parent := b;\n         update_parent(parent => b.parent, new_child => b, old_child => a);\n\n         set_balance(a);\n         set_balance(b);\n         return b;\n      end rotate_left;\n\n      function rotate_right(a : not null Node_Ptr) return Node_Ptr is\n         b : Node_Ptr := a.left;\n      begin\n         b.parent := a.parent;\n         a.left := b.right;\n         if a.left /= null then\n            a.left.parent := a;\n         end if;\n         b.right := a;\n         a.parent := b;\n         update_parent(parent => b.parent, new_child => b, old_child => a);\n\n         set_balance(a);\n         set_balance(b);\n         return b;\n      end rotate_right;\n\n      function rotate_left_right(n : not null Node_Ptr) return Node_Ptr is\n      begin\n         n.left := rotate_left(n.left);\n         return rotate_right(n);\n      end rotate_left_right;\n\n      function rotate_right_left(n : not null Node_Ptr) return Node_Ptr is\n      begin\n         n.right := rotate_right(n.right);\n         return rotate_left(n);\n      end rotate_right_left;\n\n      procedure rebalance(self : in out Tree; n : not null Node_Ptr) is\n         new_n : Node_Ptr := n;\n      begin\n         set_balance(new_n);\n         if new_n.balance = -2 then\n            if height(new_n.left.left) >= height(new_n.left.right) then\n               new_n := rotate_right(new_n);\n            else\n               new_n := rotate_left_right(new_n);\n            end if;\n         elsif new_n.balance = 2 then\n            if height(new_n.right.right) >= height(new_n.right.left) then\n               new_n := rotate_left(new_n);\n            else\n               new_n := rotate_right_left(new_n);\n            end if;\n         end if;\n\n         if new_n.parent /= null then\n            rebalance(self, new_n.parent);\n         else\n            self.root := new_n;\n         end if;\n      end rebalance;\n\n      function new_node(key : Key_Type) return Node_Ptr is\n        (new Node'(Node_Parent with key => key, others => <>));\n\n      function insert(self : in out Tree; key : Key_Type) return Boolean is\n         curr, parent : Node_Ptr;\n         go_left : Boolean;\n      begin\n         if self.root = null then\n            self.root := new_node(key);\n            return True;\n         end if;\n\n         curr := self.root;\n         while curr.key /= key loop\n            parent := curr;\n            go_left := key < curr.key;\n            curr := (if go_left then curr.left else curr.right);\n            if curr = null then\n               if go_left then\n                  parent.left := new_node(key);\n                  parent.left.parent := parent;\n               else\n                  parent.right := new_node(key);\n                  parent.right.parent := parent;\n               end if;\n               rebalance(self, parent);\n               return True;\n            end if;\n         end loop;\n         return False;\n      end insert;\n\n      procedure delete(self : in out Tree; key : Key_Type) is\n         successor, parent, child : Node_Ptr := self.root;\n         to_delete : Node_Ptr := null;\n      begin\n         if self.root = null then\n            return;\n         end if;\n\n         while child /= null loop\n            parent := successor;\n            successor := child;\n            child := (if successor.key <= key then successor.right else successor.left);\n            if successor.key = key then\n               to_delete := successor;\n            end if;\n         end loop;\n\n         if to_delete = null then\n            return;\n         end if;\n         to_delete.key := successor.key;\n         child := (if successor.left = null then successor.right else successor.left);\n         if self.root.key = key then\n            self.root := child;\n         else\n            update_parent(parent => parent, new_child => child, old_child => successor);\n            rebalance(self, parent);\n         end if;\n         Free_Node(successor);\n      end delete;\n\n      procedure print_balance(n : Node_Ptr) is\n      begin\n         if n /= null then\n            print_balance(n.left);\n            Ada.Text_IO.Put(n.balance'Image);\n            print_balance(n.right);\n         end if;\n      end print_balance;\n\n      procedure print_balance(self : in out Tree) is\n      begin\n         print_balance(self.root);\n      end print_balance;\n   end AVL_Tree;\n\n   package Int_AVL_Tree is new AVL_Tree(Integer);\n\n   tree : Int_AVL_Tree.Tree;\n   success : Boolean;\nbegin\n   for i in 1 .. 10 loop\n      success := tree.insert(i);\n   end loop;\n   Ada.Text_IO.Put(\"Printing balance: \");\n   tree.print_balance;\n   Ada.Text_IO.New_Line;\nend Main;\n"
                },
                {
                    "language": "AArch64-Assembly",
                    "solution": "/* ARM assembly AARCH64 Raspberry PI 3B */\n/*  program avltree64.s   */\n\n/*******************************************/\n/* Constantes file                         */\n/*******************************************/\n/* for this file see task include a file in language AArch64 assembly*/\n.include \"../includeConstantesARM64.inc\"\n\n.equ NBVAL,    12\n\n/*******************************************/\n/* Structures                               */\n/********************************************/\n/* structure tree     */\n    .struct  0\ntree_root:                             // root pointer (or node right)\n    .struct  tree_root + 8\ntree_size:                             // number of element of tree\n    .struct  tree_size + 8\ntree_suite:\n    .struct  tree_suite + 24           // for alignement to node\ntree_fin:\n/* structure node tree */\n    .struct  0\nnode_right:                            // right pointer\n    .struct  node_right + 8\nnode_left:                             // left pointer\n    .struct  node_left + 8\nnode_value:                            // element value\n    .struct  node_value + 8\nnode_height:                          // element value\n    .struct  node_height + 8\nnode_parent:                          // element value\n    .struct  node_parent + 8\nnode_fin:\n\n/*******************************************/\n/* Initialized data                        */\n/*******************************************/\n.data\nszMessPreOrder:       .asciz \"PreOrder :\\n\"\nszCarriageReturn:     .asciz \"\\n\"\n/* datas error display */\nszMessErreur:         .asciz \"Error detected.\\n\"\nszMessKeyDbl:         .asciz \"Key exists in tree.\\n\"\nszMessInsInv:         .asciz \"Insertion in inverse order.\\n\"\n/* datas message display */\nszMessResult:         .asciz \"Ele: @ G: @ D: @ val @ h @ \\npere @\\n\"\n\n/*******************************************/\n/* UnInitialized data                      */\n/*******************************************/\n.bss\nsZoneConv:            .skip 24\nstTree:               .skip tree_fin    // place to structure tree\nstTree1:              .skip tree_fin    // place to structure tree\n/*******************************************/\n/*  code section                           */\n/*******************************************/\n.text\n.global main\nmain:\n    mov x20,#1                           // node tree value\n1:                                      // loop insertion in order\n    ldr x0,qAdrstTree                   // structure tree address\n    mov x1,x20\n    bl insertElement                    // add element value x1\n    cmp x0,-1\n    beq 99f\n    add x20,x20,1                           // increment value\n    cmp x20,NBVAL                       // end ?\n    ble 1b                              // no -> loop\n\n    ldr x0,qAdrstTree                   // structure tree address\n    mov x1,11                           // verif key dobble\n    bl insertElement                    // add element value x1\n    cmp x0,-1\n    bne 2f\n    ldr x0,qAdrszMessErreur\n    bl affichageMess\n2:\n    ldr x0,qAdrszMessPreOrder           // load verification\n    bl affichageMess\n    ldr x3,qAdrstTree                   // tree root address (begin structure)\n    ldr x0,[x3,tree_root]\n    ldr x1,qAdrdisplayElement           // function to execute\n    bl preOrder\n\n\n    ldr x0,qAdrszMessInsInv\n    bl affichageMess\n    mov x20,NBVAL                       // node tree value\n3:                                      // loop insertion inverse order\n    ldr x0,qAdrstTree1                  // structure tree address\n    mov x1,x20\n    bl insertElement                    // add element value x1\n    cmp x0,-1\n    beq 99f\n    sub x20,x20,1                           // increment value\n    cmp x20,0                           // end ?\n    bgt 3b                              // no -> loop\n\n    ldr x0,qAdrszMessPreOrder           // load verification\n    bl affichageMess\n    ldr x3,qAdrstTree1                  // tree root address (begin structure)\n    ldr x0,[x3,tree_root]\n    ldr x1,qAdrdisplayElement           // function to execute\n    bl preOrder\n\n                                        // search value\n    ldr x0,qAdrstTree1                  // tree root address (begin structure)\n    mov x1,11                          // value to search\n    bl searchTree\n    cmp x0,-1\n    beq 100f\n    mov x2,x0\n    ldr x0,qAdrszMessKeyDbl             // key exists\n    bl affichageMess\n                                        // suppresssion previous value\n    mov x0,x2\n    ldr x1,qAdrstTree1\n    bl supprimer\n\n    ldr x0,qAdrszMessPreOrder           // verification\n    bl affichageMess\n    ldr x3,qAdrstTree1                  // tree root address (begin structure)\n    ldr x0,[x3,tree_root]\n    ldr x1,qAdrdisplayElement           // function to execute\n    bl preOrder\n\n    b 100f\n99:                                     // display error\n    ldr x0,qAdrszMessErreur\n    bl affichageMess\n100:                                    // standard end of the program\n    mov x8, #EXIT                       // request to exit program\n    svc 0                               // perform system call\nqAdrszMessPreOrder:        .quad szMessPreOrder\nqAdrszMessErreur:          .quad szMessErreur\nqAdrszCarriageReturn:      .quad szCarriageReturn\nqAdrstTree:                .quad stTree\nqAdrstTree1:               .quad stTree1\nqAdrdisplayElement:        .quad displayElement\nqAdrszMessInsInv:          .quad szMessInsInv\n/******************************************************************/\n/*     insert element in the tree                                 */\n/******************************************************************/\n/* x0 contains the address of the tree structure */\n/* x1 contains the value of element              */\n/* x0 returns address of element or - 1 if error */\ninsertElement:                        // INFO: insertElement\n    stp x1,lr,[sp,-16]!               // save  registers\n    mov x6,x0                         // save head\n    mov x0,#node_fin                  // reservation place one element\n    bl allocHeap\n    cmp x0,#-1                        // allocation error\n    beq 100f\n    mov x5,x0\n    str x1,[x5,#node_value]           // store value in address heap\n    mov x3,#0\n    str x3,[x5,#node_left]            // init left pointer with zero\n    str x3,[x5,#node_right]           // init right pointer with zero\n    str x3,[x5,#node_height]          // init balance with zero\n    ldr x2,[x6,#tree_size]            // load tree size\n    cmp x2,#0                         // 0 element ?\n    bne 1f\n    str x5,[x6,#tree_root]            // yes -> store in root\n    b 4f\n1:                                    // else search free address in tree\n    ldr x3,[x6,#tree_root]            // start with address root\n2:                                    // begin loop to insertion\n    ldr x4,[x3,#node_value]           // load key\n    cmp x1,x4\n    beq 6f                            // key equal\n    blt 3f                            // key <\n                                      // key >  insertion right\n    ldr x8,[x3,#node_right]           // node empty ?\n    cmp x8,#0\n    csel x3,x8,x3,ne                  // current = right node if not\n    //movne x3,x8                       // no -> next node\n    bne 2b                            // and loop\n    str x5,[x3,#node_right]           // store node address in right pointer\n    b 4f\n3:                                    // left\n    ldr x8,[x3,#node_left]            // left pointer empty ?\n    cmp x8,#0\n    csel x3,x8,x3,ne                  // current = left node if not\n    //movne x3,x8                       //\n    bne 2b                            // no -> loop\n    str x5,[x3,#node_left]            // store node address in left pointer\n4:\n    str x3,[x5,#node_parent]          // store parent\n    mov x4,#1\n    str x4,[x5,#node_height]          // store height = 1\n    mov x0,x5                         // begin node to requilbrate\n    mov x1,x6                         // head address\n    bl equilibrer\n\n5:\n    add x2,x2,#1                        // increment tree size\n    str x2,[x6,#tree_size]\n    mov x0,#0\n    b 100f\n6:                                   // key equal ?\n    ldr x0,qAdrszMessKeyDbl\n    bl affichageMess\n    mov x0,#-1\n    b 100f\n100:\n    ldp x1,lr,[sp],16              // restaur  2 registers\n    ret                            // return to address lr x30\nqAdrszMessKeyDbl:           .quad szMessKeyDbl\n/******************************************************************/\n/*     equilibrer after insertion                                    */\n/******************************************************************/\n/* x0 contains the address of the node       */\n/* x1 contains the address of head */\nequilibrer:                       // INFO: equilibrer\n    stp x1,lr,[sp,-16]!           // save  registers\n    stp x2,x3,[sp,-16]!           // save  registers\n    stp x4,x5,[sp,-16]!           // save  registers\n    stp x6,x7,[sp,-16]!           // save  registers\n    mov x3,#0                     // balance factor\n1:                                // begin loop\n    ldr x5,[x0,#node_parent]      // load father\n    cmp x5,#0                     // end ?\n    beq 8f\n    cmp x3,#2                     // right tree too long\n    beq 8f\n    cmp x3,#-2                    // left tree too long\n    beq 8f\n    mov x6,x0                     // s = current\n    ldr x0,[x6,#node_parent]      // current = father\n    ldr x7,[x0,#node_left]\n    mov x4,#0\n    cmp x7,#0\n    beq 2f\n    ldr x4,[x7,#node_height]     // height left tree\n2:\n    ldr x7,[x0,#node_right]\n    mov x2,#0\n    cmp x7,#0\n    beq 3f\n    ldr x2,[x7,#node_height]     // height right tree\n3:\n    cmp x4,x2\n    ble 4f\n    add x4,x4,#1\n    str x4,[x0,#node_height]\n    b 5f\n4:\n    add x2,x2,#1\n    str x2,[x0,#node_height]\n5:\n    ldr x7,[x0,#node_right]\n    mov x4,0\n    cmp x7,#0\n    beq 6f\n    ldr x4,[x7,#node_height]\n6:\n    ldr x7,[x0,#node_left]\n    mov x2,0\n    cmp x7,#0\n    beq 7f\n    ldr x2,[x7,#node_height]\n7:\n    sub x3,x4,x2                    // compute balance factor\n    b 1b\n8:\n    cmp x3,#2\n    beq 9f\n    cmp x3,#-2\n    beq 9f\n    b 100f\n9:\n    mov x3,x1\n    mov x4,x0\n    mov x1,x6\n    bl equiUnSommet\n                                      // change head address ?\n    ldr x2,[x3,#tree_root]\n    cmp x2,x4\n    bne 100f\n    str x6,[x3,#tree_root]\n100:\n    ldp x6,x7,[sp],16              // restaur  2 registers\n    ldp x4,x5,[sp],16              // restaur  2 registers\n    ldp x2,x3,[sp],16              // restaur  2 registers\n    ldp x1,lr,[sp],16              // restaur  2 registers\n    ret                            // return to address lr x30\n/******************************************************************/\n/*     equilibre 1 sommet                                     */\n/******************************************************************/\n/* x0 contains the address of the node       */\n/* x1 contains the address of the node    */\nequiUnSommet:                             // INFO: equiUnSommet\n    stp x1,lr,[sp,-16]!           // save  registers\n    stp x2,x3,[sp,-16]!           // save  registers\n    stp x4,x5,[sp,-16]!           // save  registers\n    stp x6,x7,[sp,-16]!           // save  registers\n    mov x5,x0                             // save p\n    mov x6,x1    // s\n    ldr x2,[x5,#node_left]\n    cmp x2,x6\n    bne 6f\n    ldr x7,[x5,#node_right]\n    mov x4,#0\n    cmp x7,#0\n    beq 1f\n    ldr x4,[x7,#node_height]\n1:\n    ldr x7,[x5,#node_left]\n    mov x2,0\n    cmp x7,#0\n    beq 2f\n    ldr x2,[x7,#node_height]\n2:\n    sub x3,x4,x2\n    cmp x3,#-2\n    bne 100f\n    ldr x7,[x6,#node_right]\n    mov x4,0\n    cmp x7,#0\n    beq 3f\n    ldr x4,[x7,#node_height]\n3:\n    ldr x7,[x6,#node_left]\n    mov x2,0\n    cmp x7,#0\n    beq 4f\n    ldr x2,[x7,#node_height]\n4:\n    sub x3,x4,x2\n    cmp x3,#1\n    bge 5f\n    mov x0,x5\n    bl rotRight\n    b 100f\n5:\n    mov x0,x6\n    bl rotLeft\n    mov x0,x5\n    bl rotRight\n    b 100f\n\n6:\n    ldr x7,[x5,#node_right]\n    mov x4,0\n    cmp x7,#0\n    beq 7f\n    ldr x4,[x7,#node_height]\n7:\n    ldr x7,[x5,#node_left]\n    mov x2,0\n    cmp x7,#0\n    beq 8f\n    ldr x2,[x7,#node_height]\n8:\n    sub x3,x4,x2\n    cmp x3,2\n    bne 100f\n    ldr x7,[x6,#node_right]\n    mov x4,0\n    cmp x7,#0\n    beq 9f\n    ldr x4,[x7,#node_height]\n9:\n    ldr x7,[x6,#node_left]\n    mov x2,0\n    cmp x7,#0\n    beq 10f\n    ldr x2,[x7,#node_height]\n10:\n    sub x3,x4,x2\n    cmp x3,#-1\n    ble 11f\n    mov x0,x5\n    bl rotLeft\n    b 100f\n11:\n    mov x0,x6\n    bl rotRight\n    mov x0,x5\n    bl rotLeft\n\n100:\n    ldp x6,x7,[sp],16              // restaur  2 registers\n    ldp x4,x5,[sp],16              // restaur  2 registers\n    ldp x2,x3,[sp],16              // restaur  2 registers\n    ldp x1,lr,[sp],16              // restaur  2 registers\n    ret                            // return to address lr x30\n/******************************************************************/\n/*     right rotation                                     */\n/******************************************************************/\n/* x0 contains the address of the node       */\nrotRight:                           // INFO: rotRight\n    stp x1,lr,[sp,-16]!           // save  registers\n    stp x2,x3,[sp,-16]!           // save  registers\n    stp x4,x5,[sp,-16]!           // save  registers\n    //   x2                  x2\n    //      x0                   x1\n    //   x1                         x0\n    //      x3                    x3\n    ldr x1,[x0,#node_left]          // load left children\n    ldr x2,[x0,#node_parent]        // load father\n    cmp x2,#0                       // no father ???\n    beq 2f\n    ldr x3,[x2,#node_left]          // load left node father\n    cmp x3,x0                       // equal current node ?\n    bne 1f\n    str x1,[x2,#node_left]        // yes store left children\n    b 2f\n1:\n    str x1,[x2,#node_right]       // no store right\n2:\n    str x2,[x1,#node_parent]        // change parent\n    str x1,[x0,#node_parent]\n    ldr x3,[x1,#node_right]\n    str x3,[x0,#node_left]\n    cmp x3,#0\n    beq 3f\n    str x0,[x3,#node_parent]      // change parent node left\n3:\n    str x0,[x1,#node_right]\n\n    ldr x3,[x0,#node_left]          // compute newbalance factor\n    mov x4,0\n    cmp x3,#0\n    beq 4f\n    ldr x4,[x3,#node_height]\n4:\n    ldr x3,[x0,#node_right]\n    mov x5,0\n    cmp x3,#0\n    beq 5f\n    ldr x5,[x3,#node_height]\n5:\n    cmp x4,x5\n    ble 6f\n    add x4,x4,#1\n    str x4,[x0,#node_height]\n    b 7f\n6:\n    add x5,x5,#1\n    str x5,[x0,#node_height]\n7:\n//\n    ldr x3,[x1,#node_left]         // compute new balance factor\n    mov x4,0\n    cmp x3,#0\n    beq 8f\n    ldr x4,[x3,#node_height]\n8:\n    ldr x3,[x1,#node_right]\n    mov x5,0\n    cmp x3,#0\n    beq 9f\n    ldr x5,[x3,#node_height]\n9:\n    cmp x4,x5\n    ble 10f\n    add x4,x4,#1\n    str x4,[x1,#node_height]\n    b 100f\n10:\n    add x5,x5,#1\n    str x5,[x1,#node_height]\n100:\n    ldp x4,x5,[sp],16              // restaur  2 registers\n    ldp x2,x3,[sp],16              // restaur  2 registers\n    ldp x1,lr,[sp],16              // restaur  2 registers\n    ret                            // return to address lr x30\n/******************************************************************/\n/*     left rotation                                     */\n/******************************************************************/\n/* x0 contains the address of the node  sommet     */\nrotLeft:                             // INFO: rotLeft\n    stp x1,lr,[sp,-16]!              // save  registers\n    stp x2,x3,[sp,-16]!              // save  registers\n    stp x4,x5,[sp,-16]!              // save  registers\n    //   x2                  x2\n    //      x0                   x1\n    //          x1            x0\n    //        x3                 x3\n    ldr x1,[x0,#node_right]          // load right children\n    ldr x2,[x0,#node_parent]         // load father (racine)\n    cmp x2,#0                        // no father ???\n    beq 2f\n    ldr x3,[x2,#node_left]           // load left node father\n    cmp x3,x0                        // equal current node ?\n    bne 1f\n    str x1,[x2,#node_left]         // yes store left children\n    b 2f\n1:\n    str x1,[x2,#node_right]        // no store to right\n2:\n    str x2,[x1,#node_parent]         // change parent of right children\n    str x1,[x0,#node_parent]         // change parent of sommet\n    ldr x3,[x1,#node_left]           // left children\n    str x3,[x0,#node_right]          // left children pivot exists ?\n    cmp x3,#0\n    beq 3f\n    str x0,[x3,#node_parent]       // yes store in\n3:\n    str x0,[x1,#node_left]\n//\n    ldr x3,[x0,#node_left]           // compute new height for old summit\n    mov x4,0\n    cmp x3,#0\n    beq 4f\n    ldr x4,[x3,#node_height]       // left height\n4:\n    ldr x3,[x0,#node_right]\n    mov x5,0\n    cmp x3,#0\n    beq 5f\n    ldr x5,[x3,#node_height]       // right height\n5:\n    cmp x4,x5\n    ble 6f\n    add x4,x4,#1\n    str x4,[x0,#node_height]       // if right > left\n    b 7f\n6:\n    add x5,x5,#1\n    str x5,[x0,#node_height]       // if left > right\n7:\n//\n    ldr x3,[x1,#node_left]           // compute new height for new\n    mov x4,0\n    cmp x3,#0\n    beq 8f\n    ldr x4,[x3,#node_height]\n8:\n    ldr x3,[x1,#node_right]\n    mov x5,0\n    cmp x3,#0\n    beq 9f\n    ldr x5,[x3,#node_height]\n9:\n    cmp x4,x5\n    ble 10f\n    add x4,x4,#1\n    str x4,[x1,#node_height]\n    b 100f\n10:\n    add x5,x5,#1\n    str x5,[x1,#node_height]\n100:\n    ldp x4,x5,[sp],16              // restaur  2 registers\n    ldp x2,x3,[sp],16              // restaur  2 registers\n    ldp x1,lr,[sp],16              // restaur  2 registers\n    ret                            // return to address lr x30\n/******************************************************************/\n/*     search value in tree                                       */\n/******************************************************************/\n/* x0 contains the address of structure of tree */\n/* x1 contains the value to search  */\nsearchTree:                           // INFO: searchTree\n    stp x2,lr,[sp,-16]!              // save  registers\n    stp x3,x4,[sp,-16]!              // save  registers\n    ldr x2,[x0,#tree_root]\n\n1:                                    // begin loop\n    ldr x4,[x2,#node_value]           // load key\n    cmp x1,x4\n    beq 3f                            // key equal\n    blt 2f                            // key <\n                                      // key >  insertion right\n    ldr x3,[x2,#node_right]           // node empty ?\n    cmp x3,#0\n    csel x2,x3,x2,ne\n    //movne x2,x3                       // no -> next node\n    bne 1b                            // and loop\n    mov x0,#-1                        // not find\n    b 100f\n2:                                    // left\n    ldr x3,[x2,#node_left]            // left pointer empty ?\n    cmp x3,#0\n    csel x2,x3,x2,ne\n    bne 1b                            // no -> loop\n    mov x0,#-1                        // not find\n    b 100f\n3:\n    mov x0,x2                         // return node address\n100:\n    ldp x3,x4,[sp],16              // restaur  2 registers\n    ldp x2,lr,[sp],16              // restaur  2 registers\n    ret                            // return to address lr x30\n/******************************************************************/\n/*     suppression node                                           */\n/******************************************************************/\n/* x0 contains the address of the node */\n/* x1 contains structure tree address  */\nsupprimer:                       // INFO: supprimer\n    stp x1,lr,[sp,-16]!           // save  registers\n    stp x2,x3,[sp,-16]!           // save  registers\n    stp x4,x5,[sp,-16]!           // save  registers\n    stp x6,x7,[sp,-16]!           // save  registers\n    ldr x1,[x0,#node_left]\n    cmp x1,#0\n    bne 5f\n    ldr x1,[x0,#node_right]\n    cmp x1,#0\n    bne 5f\n                                 // is a leaf\n    mov x4,#0\n    ldr x3,[x0,#node_parent]     // father\n    cmp x3,#0\n    bne 11f\n    str x4,[x1,#tree_root]\n    b 100f\n11:\n    ldr x1,[x3,#node_left]\n    cmp x1,x0\n    bne 2f\n    str x4,[x3,#node_left]       // suppression left children\n    ldr x5,[x3,#node_right]\n    mov x6,#0\n    cmp x5,#0\n    beq 12f\n    ldr x6,[x5,#node_height]\n12:\n    add x6,x6,#1\n    str x6,[x3,#node_height]\n    b 3f\n2:                                // suppression right children\n    str x4,[x3,#node_right]\n    ldr x5,[x3,#node_left]\n    mov x6,#0\n    cmp x5,#0\n    beq 21f\n    ldr x6,[x5,#node_height]\n21:\n    add x6,x6,#1\n    str x6,[x3,#node_height]\n3:                                // new balance\n    mov x0,x3\n    bl equilibrerSupp\n    b 100f\n5:                                // is not \u00c3\u00a0 leaf\n    ldr x7,[x0,#node_right]\n    cmp x7,#0\n    beq 7f\n    mov x2,x0\n    mov x0,x7\n6:\n    ldr x6,[x0,#node_left]  // search the litle element\n    cmp x6,#0\n    beq 9f\n    mov x0,x6\n    b 6b\n7:\n    ldr x7,[x0,#node_left]\n    cmp x7,#0\n    beq 9f\n    mov x2,x0\n    mov x0,x7\n8:\n    ldr x6,[x0,#node_right]        // search the great element\n    cmp x6,#0\n    beq 9f\n    mov x0,x6\n    b 8b\n9:\n    ldr x5,[x0,#node_value]         // copy value\n    str x5,[x2,#node_value]\n    bl supprimer                    // suppression node x0\n100:\n    ldp x6,x7,[sp],16              // restaur  2 registers\n    ldp x4,x5,[sp],16              // restaur  2 registers\n    ldp x2,x3,[sp],16              // restaur  2 registers\n    ldp x1,lr,[sp],16              // restaur  2 registers\n    ret                            // return to address lr x30\n\n/******************************************************************/\n/*     equilibrer after suppression                                   */\n/******************************************************************/\n/* x0 contains the address of the node       */\n/* x1 contains the address of head */\nequilibrerSupp:                   // INFO: equilibrerSupp\n    stp x1,lr,[sp,-16]!           // save  registers\n    stp x2,x3,[sp,-16]!           // save  registers\n    stp x4,x5,[sp,-16]!           // save  registers\n    stp x6,x7,[sp,-16]!           // save  registers\n    mov x3,#1                     // balance factor\n    ldr x2,[x1,#tree_root]\n1:\n    ldr x5,[x0,#node_parent]      // load father\n    cmp x5,#0                     // no father\n    beq 100f\n    cmp x3,#0                     // balance equilibred\n    beq 100f\n    mov x6,x0                     // save entry node\n    ldr x0,[x6,#node_parent]      // current = father\n    ldr x7,[x0,#node_left]\n    mov x4,#0\n    cmp x7,#0\n    b 11f\n    ldr x4,[x7,#node_height]    // height left tree\n11:\n    ldr x7,[x0,#node_right]\n    mov x5,#0\n    cmp x7,#0\n    beq 12f\n    ldr x5,[x7,#node_height]    // height right tree\n12:\n    cmp x4,x5\n    ble 13f\n    add x4,x4,1\n    str x4,[x0,#node_height]\n    b 14f\n13:\n    add x5,x5,1\n    str x5,[x0,#node_height]\n14:\n    ldr x7,[x0,#node_right]\n    mov x4,#0\n    cmp x7,#0\n    beq 15f\n    ldr x4,[x7,#node_height]\n15:\n    ldr x7,[x0,#node_left]\n    mov x5,0\n    cmp x7,#0\n    beq 16f\n    ldr x5,[x7,#node_height]\n16:\n    sub x3,x4,x5                   // compute balance factor\n    mov x2,x1\n    mov x7,x0                      // save current\n    mov x1,x6\n    bl equiUnSommet\n                                   // change head address ?\n    cmp x2,x7\n    bne 17f\n    str x6,[x3,#tree_root]\n17:\n    mov x0,x7                      // restaur current\n    b 1b\n\n100:\n    ldp x6,x7,[sp],16              // restaur  2 registers\n    ldp x4,x5,[sp],16              // restaur  2 registers\n    ldp x2,x3,[sp],16              // restaur  2 registers\n    ldp x1,lr,[sp],16              // restaur  2 registers\n    ret                            // return to address lr x30\n/******************************************************************/\n/*     preOrder                                  */\n/******************************************************************/\n/* x0 contains the address of the node */\n/* x1 function address                 */\npreOrder:                                 // INFO: preOrder\n    stp x2,lr,[sp,-16]!           // save  registers\n    cmp x0,#0\n    beq 100f\n    mov x2,x0\n    blr x1                                // call function\n    ldr x0,[x2,#node_left]\n    bl preOrder\n    ldr x0,[x2,#node_right]\n    bl preOrder\n100:\n    ldp x2,lr,[sp],16              // restaur  2 registers\n    ret                            // return to address lr x30\n\n/******************************************************************/\n/*     display node                                               */\n/******************************************************************/\n/* x0 contains node  address          */\ndisplayElement:                   // INFO: displayElement\n    stp x1,lr,[sp,-16]!           // save  registers\n    stp x2,x3,[sp,-16]!           // save  registers\n    stp x4,x5,[sp,-16]!           // save  registers\n    mov x2,x0\n    ldr x1,qAdrsZoneConv\n    bl conversion16\n    //strb wzr,[x1,x0]\n    ldr x0,qAdrszMessResult\n    ldr x1,qAdrsZoneConv\n    bl strInsertAtCharInc\n    mov x3,x0\n    ldr x0,[x2,#node_left]\n    ldr x1,qAdrsZoneConv\n    bl conversion16\n    //strb wzr,[x1,x0]\n    mov x0,x3\n    ldr x1,qAdrsZoneConv\n    bl strInsertAtCharInc\n    mov x3,x0\n    ldr x0,[x2,#node_right]\n    ldr x1,qAdrsZoneConv\n    bl conversion16\n    //strb wzr,[x1,x0]\n    mov x0,x3\n    ldr x1,qAdrsZoneConv\n    bl strInsertAtCharInc\n    mov x3,x0\n    ldr x0,[x2,#node_value]\n    ldr x1,qAdrsZoneConv\n    bl conversion10\n    //strb wzr,[x1,x0]\n    mov x0,x3\n    ldr x1,qAdrsZoneConv\n    bl strInsertAtCharInc\n    mov x3,x0\n    ldr x0,[x2,#node_height]\n    ldr x1,qAdrsZoneConv\n    bl conversion10\n    //strb wzr,[x1,x0]\n    mov x0,x3\n    ldr x1,qAdrsZoneConv\n    bl strInsertAtCharInc\n    mov x3,x0\n    ldr x0,[x2,#node_parent]\n    ldr x1,qAdrsZoneConv\n    bl conversion16\n    //strb wzr,[x1,x0]\n    mov x0,x3\n    ldr x1,qAdrsZoneConv\n    bl strInsertAtCharInc\n    bl affichageMess\n100:\n    ldp x4,x5,[sp],16              // restaur  2 registers\n    ldp x2,x3,[sp],16              // restaur  2 registers\n    ldp x1,lr,[sp],16              // restaur  2 registers\n    ret                            // return to address lr x30\nqAdrszMessResult:          .quad szMessResult\nqAdrsZoneConv:             .quad sZoneConv\n\n/******************************************************************/\n/*     memory allocation on the heap                                  */\n/******************************************************************/\n/* x0 contains the size to allocate */\n/* x0 returns address of memory heap or - 1 if error */\n/* CAUTION : The size of the allowance must be a multiple of 4  */\nallocHeap:\n    stp x1,lr,[sp,-16]!            // save  registers\n    stp x2,x8,[sp,-16]!            // save  registers\n    // allocation\n    mov x1,x0                      // save size\n    mov x0,0                       // read address start heap\n    mov x8,BRK                     // call system 'brk'\n    svc 0\n    mov x2,x0                      // save address heap for return\n    add x0,x0,x1                   // reservation place for size\n    mov x8,BRK                     // call system 'brk'\n    svc 0\n    cmp x0,-1                      // allocation error\n    beq 100f\n    mov x0,x2                      // return address memory heap\n100:\n    ldp x2,x8,[sp],16              // restaur  2 registers\n    ldp x1,lr,[sp],16              // restaur  2 registers\n    ret                            // return to address lr x30\n/********************************************************/\n/*        File Include fonctions                        */\n/********************************************************/\n/* for this file see task include a file in language AArch64 assembly */\n.include \"../includeARM64.inc\"\n"
                }
            ],
            [
                {
                    "language": "Wren",
                    "solution": "class Node {\n    construct new(key, parent) {\n        _key = key\n        _parent = parent\n        _balance = 0\n        _left = null\n        _right = null\n    }\n\n    key     { _key     }\n    parent  { _parent  }\n    balance { _balance }\n    left    { _left    }\n    right   { _right   }\n\n    key=(k)     { _key = k     }\n    parent=(p)  { _parent = p  }\n    balance=(v) { _balance = v }\n    left=(n)    { _left = n    }\n    right= (n)  { _right = n   }\n}\n\nclass AvlTree {\n    construct new() {\n        _root = null\n    }\n\n    insert(key) {\n        if (!_root) {\n            _root = Node.new(key, null)\n        } else {\n            var n = _root\n            while (true) {\n                if (n.key == key) return false\n                var parent = n\n                var goLeft = n.key > key\n                n = goLeft ? n.left : n.right\n                if (!n) {\n                    if (goLeft) {\n                        parent.left  = Node.new(key, parent)\n                    } else {\n                        parent.right = Node.new(key, parent)\n                    }\n                    rebalance(parent)\n                    break\n                }\n            }\n       }\n       return true\n    }\n\n    delete(delKey) {\n        if (!_root) return\n        var n       = _root\n        var parent  = _root\n        var delNode = null\n        var child   = _root\n        while (child) {\n            parent = n\n            n = child\n            child = (delKey >= n.key) ? n.right : n.left\n            if (delKey == n.key) delNode = n\n        }\n        if (delNode) {\n            delNode.key = n.key\n            child = n.left ? n.left : n.right\n            if (_root.key == delKey) {\n                _root = child\n                if (_root) _root.parent = null\n            } else {\n                if (parent.left == n) {\n                    parent.left = child\n                } else {\n                    parent.right = child\n                }\n                if (child) child.parent = parent\n                rebalance(parent)\n            }\n        }\n    }\n\n    rebalance(n) {\n        setBalance([n])\n        var nn = n\n        if (nn.balance == -2) {\n            if (height(nn.left.left) >= height(nn.left.right)) {\n                nn = rotateRight(nn)\n            } else {\n                nn = rotateLeftThenRight(nn)\n            }\n        } else if (nn.balance == 2) {\n            if (height(nn.right.right) >= height(nn.right.left)) {\n                nn = rotateLeft(nn)\n            } else {\n                nn = rotateRightThenLeft(nn)\n            }\n        }\n        if (nn.parent) rebalance(nn.parent) else _root = nn\n    }\n\n    rotateLeft(a) {\n        var b = a.right\n        b.parent = a.parent\n        a.right = b.left\n        if (a.right) a.right.parent = a\n        b.left = a\n        a.parent = b\n        if (b.parent) {\n            if (b.parent.right == a) {\n                b.parent.right = b\n            } else {\n                b.parent.left = b\n            }\n        }\n        setBalance([a, b])\n        return b\n    }\n\n    rotateRight(a) {\n        var b = a.left\n        b.parent = a.parent\n        a.left = b.right\n        if (a.left) a.left.parent = a\n        b.right = a\n        a.parent = b\n        if (b.parent) {\n            if (b.parent.right == a) {\n                b.parent.right = b\n            } else {\n                b.parent.left = b\n            }\n        }\n        setBalance([a, b])\n        return b\n    }\n\n    rotateLeftThenRight(n) {\n        n.left = rotateLeft(n.left)\n        return rotateRight(n)\n    }\n\n    rotateRightThenLeft(n) {\n        n.right = rotateRight(n.right)\n        return rotateLeft(n)\n    }\n\n    height(n) {\n        if (!n) return -1\n        return 1 + height(n.left).max(height(n.right))\n    }\n\n    setBalance(nodes) {\n        for (n in nodes) n.balance = height(n.right) - height(n.left)\n    }\n\n    printKey() {\n        printKey(_root)\n        System.print()\n    }\n\n    printKey(n) {\n        if (n) {\n            printKey(n.left)\n            System.write(\"%(n.key) \")\n            printKey(n.right)\n        }\n    }\n\n    printBalance() {\n        printBalance(_root)\n        System.print()\n    }\n\n    printBalance(n) {\n        if (n) {\n            printBalance(n.left)\n            System.write(\"%(n.balance) \")\n            printBalance(n.right)\n        }\n    }\n}\n\nvar tree = AvlTree.new()\nSystem.print(\"Inserting values 1 to 10\")\nfor (i in 1..10) tree.insert(i)\nSystem.write(\"Printing key     : \")\ntree.printKey()\nSystem.write(\"Printing balance : \")\ntree.printBalance()\n"
                },
                {
                    "language": "Objeck",
                    "solution": "class AVLNode {\n  @key : Int;\n  @balance : Int;\n  @height : Int;\n  @left : AVLNode;\n  @right : AVLNode;\n  @above : AVLNode;\n\n  New(key : Int, above : AVLNode) {\n    @key := key;\n    @above := above;\n  }\n\n  method : public : GetKey() ~ Int {\n    return @key;\n  }\n\n  method : public : GetLeft() ~ AVLNode {\n    return @left;\n  }\n\n  method : public : GetRight() ~ AVLNode {\n    return @right;\n  }\n\n  method : public : GetAbove() ~ AVLNode {\n    return @above;\n  }\n\n  method : public : GetBalance() ~ Int {\n    return @balance;\n  }\n\n  method : public : GetHeight() ~ Int {\n    return @height;\n  }\n\n  method : public : SetBalance(balance : Int) ~ Nil {\n    @balance := balance;\n  }\n\n  method : public : SetHeight(height : Int) ~ Nil {\n    @height := height;\n  }\n\n  method : public : SetAbove(above : AVLNode) ~ Nil {\n    @above := above;\n  }\n\n  method : public : SetLeft(left : AVLNode) ~ Nil {\n    @left := left;\n  }\n\n  method : public : SetRight(right : AVLNode) ~ Nil {\n    @right := right;\n  }\n\n  method : public : SetKey(key : Int) ~ Nil {\n    @key := key;\n  }\n}\n\nclass AVLTree {\n  @root : AVLNode;\n\n  New() {}\n\n  method : public : Insert(key : Int) ~ Bool {\n    if(@root = Nil) {\n      @root := AVLNode->New( key, Nil);\n      return true;\n    };\n\n    n := @root;\n    while(true) {\n      if(n->GetKey() = key) {\n        return false;\n      };\n\n      parent := n;\n      goLeft := n->GetKey() > key;\n      n := goLeft ? n->GetLeft() : n->GetRight();\n\n      if(n = Nil) {\n        if(goLeft) {\n          parent->SetLeft(AVLNode->New( key, parent));\n        } else {\n          parent->SetRight(AVLNode->New( key, parent));\n        };\n        Rebalance(parent);\n        break;\n      };\n    };\n\n    return true;\n  }\n\n  method : Delete(node : AVLNode) ~ Nil {\n    if (node->GetLeft() = Nil & node->GetRight() = Nil) {\n      if (node ->GetAbove() = Nil) {\n        @root := Nil;\n      } else {\n        parent := node ->GetAbove();\n        if (parent->GetLeft() = node) {\n          parent->SetLeft(Nil);\n        } else {\n          parent->SetRight(Nil);\n        };\n        Rebalance(parent);\n      };\n      return;\n    };\n\n    if (node->GetLeft() <> Nil) {\n      child := node->GetLeft();\n      while (child->GetRight() <> Nil) {\n        child := child->GetRight();\n      };\n      node->SetKey(child->GetKey());\n      Delete(child);\n    } else {\n      child := node->GetRight();\n      while (child->GetLeft() <> Nil) {\n        child := child->GetLeft();\n      };\n      node->SetKey(child->GetKey());\n      Delete(child);\n    };\n  }\n\n  method : public : Delete(delKey : Int) ~ Nil {\n    if (@root = Nil) {\n      return;\n    };\n\n    child := @root;\n    while (child <> Nil) {\n      node := child;\n      child := delKey >= node->GetKey() ? node->GetRight() : node->GetLeft();\n      if (delKey = node->GetKey()) {\n        Delete(node);\n        return;\n      };\n    };\n  }\n\n  method : Rebalance(n : AVLNode) ~ Nil {\n    SetBalance(n);\n\n    if (n->GetBalance() = -2) {\n      if (Height(n->GetLeft()->GetLeft()) >= Height(n->GetLeft()->GetRight())) {\n        n := RotateRight(n);\n      }\n      else {\n        n := RotateLeftThenRight(n);\n      };\n\n    } else if (n->GetBalance() = 2) {\n      if(Height(n->GetRight()->GetRight()) >= Height(n->GetRight()->GetLeft())) {\n        n := RotateLeft(n);\n      }\n      else {\n        n := RotateRightThenLeft(n);\n      };\n    };\n\n    if(n->GetAbove() <> Nil) {\n      Rebalance(n->GetAbove());\n    } else {\n      @root := n;\n    };\n  }\n\n  method : RotateLeft(a : AVLNode) ~ AVLNode {\n    b := a->GetRight();\n    b->SetAbove(a->GetAbove());\n\n    a->SetRight(b->GetLeft());\n\n    if(a->GetRight() <> Nil) {\n      a->GetRight()->SetAbove(a);\n    };\n\n    b->SetLeft(a);\n    a->SetAbove(b);\n\n    if (b->GetAbove() <> Nil) {\n      if (b->GetAbove()->GetRight() = a) {\n        b->GetAbove()->SetRight(b);\n      } else {\n        b->GetAbove()->SetLeft(b);\n      };\n    };\n\n    SetBalance(a);\n    SetBalance(b);\n\n    return b;\n  }\n\n  method : RotateRight(a : AVLNode) ~ AVLNode {\n    b := a->GetLeft();\n    b->SetAbove(a->GetAbove());\n\n    a->SetLeft(b->GetRight());\n\n    if (a->GetLeft() <> Nil) {\n      a->GetLeft()->SetAbove(a);\n    };\n\n    b->SetRight(a);\n    a->SetAbove(b);\n\n    if (b->GetAbove() <> Nil) {\n      if (b->GetAbove()->GetRight() = a) {\n        b->GetAbove()->SetRight(b);\n      } else {\n        b->GetAbove()->SetLeft(b);\n      };\n    };\n\n    SetBalance(a);\n    SetBalance(b);\n\n    return b;\n  }\n\n  method : RotateLeftThenRight(n : AVLNode) ~ AVLNode {\n    n->SetLeft(RotateLeft(n->GetLeft()));\n    return RotateRight(n);\n  }\n\n  method : RotateRightThenLeft(n : AVLNode) ~ AVLNode {\n    n->SetRight(RotateRight(n->GetRight()));\n    return RotateLeft(n);\n  }\n\n  method : SetBalance(n : AVLNode) ~ Nil {\n    Reheight(n);\n    n->SetBalance(Height(n->GetRight()) - Height(n->GetLeft()));\n  }\n\n  method : Reheight(node : AVLNode) ~ Nil {\n    if(node <> Nil) {\n      node->SetHeight(1 + Int->Max(Height(node->GetLeft()), Height(node->GetRight())));\n    };\n  }\n\n  method : Height(n : AVLNode) ~ Int {\n    if(n = Nil) {\n      return -1;\n    };\n\n    return n->GetHeight();\n  }\n\n  method : public : PrintBalance() ~ Nil {\n    PrintBalance(@root);\n  }\n\n  method : PrintBalance(n : AVLNode) ~ Nil {\n    if (n <> Nil) {\n      PrintBalance(n->GetLeft());\n      balance := n->GetBalance();\n      \"{$balance} \"->Print();\n      PrintBalance(n->GetRight());\n    };\n  }\n}\n\nclass Test {\n  function : Main(args : String[]) ~ Nil {\n    tree := AVLTree->New();\n\n    \"Inserting values 1 to 10\"->PrintLine();\n    for(i := 1; i < 10; i+=1;) {\n      tree->Insert(i);\n    };\n\n    \"Printing balance: \"->Print();\n    tree->PrintBalance();\n  }\n}\n"
                }
            ]
        ]
    },
    {
        "task_name": "B-zier-curves-Intersections",
        "task_description": "You are given two planar quadratic [[wp:B\u00e9zier_curve|B\u00e9zier curves]], having control points <math>(-1,0), (0,10), (1,0)</math> and <math>(2,1), (-8,2), (2,3)</math>, respectively. They are parabolas intersecting at four points, as shown in the following diagram:\n\n\n::[[File:Figure-1 for bezier intersection.png|none|alt=Two intersecting parabolas and their control points.]]\n\n\nThe task is to write a program that finds all four intersection points and prints their <math>(x,y)</math> coordinates. You may use any algorithm you know of or can think of, including any of those that others have used.\n\n===See also===\n* [[Bitmap/B\u00e9zier_curves/Quadratic|Bitmap/B\u00e9zier curves/Quadratic]]\n* [[Steffensen's_method|Steffensen's method]]\n\n",
        "solution_pairs": [
            [
                {
                    "language": "Raku",
                    "solution": "# 20231025 Raku programming solution\n\nclass Point { has ($.x, $.y) is rw is default(0) }\n\nclass QuadSpline { has ($.c0, $.c1, $.c2) is rw is default(0) }\n\nclass QuadCurve { has QuadSpline ($.x, $.y) is rw }\n\nclass Workset { has QuadCurve ($.p, $.q) }\n\nsub subdivideQuadSpline($q, $t) {\n   my $s = 1.0 - $t;\n   my ($c0,$c1,$c2) = do given $q { .c0, .c1, .c2 };\n   my $u_c1 = $s*$c0 + $t*$c1;\n   my $v_c1 = $s*$c1 + $t*$c2;\n   my $u_c2 = $s*$u_c1 + $t*$v_c1;\n   return ($c0, $u_c1, $u_c2), ($u_c2, $v_c1, $c2)\n}\n\nsub subdivideQuadCurve($q, $t, $u is rw, $v is rw) {\n   with (subdivideQuadSpline($q.x,$t),subdivideQuadSpline($q.y,$t))\u00c2\u00bb.List.flat {\n      $u=QuadCurve.new(x => QuadSpline.new(c0 => .[0],c1 => .[1],c2 => .[2]),\n                       y => QuadSpline.new(c0 => .[6],c1 => .[7],c2 => .[8]));\n      $v=QuadCurve.new(x => QuadSpline.new(c0 => .[3],c1 => .[4],c2 => .[5]),\n                       y => QuadSpline.new(c0 => .[9],c1 => .[10],c2 => .[11]))\n   }\n}\n\nsub seemsToBeDuplicate(@intersects, $xy, $spacing) {\n   my $seemsToBeDup = False;\n   for @intersects {\n      $seemsToBeDup = abs(.x - $xy.x) < $spacing && abs(.y - $xy.y) < $spacing;\n      last if $seemsToBeDup;\n   }\n   return $seemsToBeDup;\n}\n\nsub rectsOverlap($xa0, $ya0, $xa1, $ya1, $xb0, $yb0, $xb1, $yb1) {\n   return $xb0 <= $xa1 && $xa0 <= $xb1 && $yb0 <= $ya1 && $ya0 <= $yb1\n}\n\nsub testIntersect($p,$q,$tol,$exclude is rw,$accept is rw,$intersect is rw) {\n   my $pxmin = min($p.x.c0, $p.x.c1, $p.x.c2);\n   my $pymin = min($p.y.c0, $p.y.c1, $p.y.c2);\n   my $pxmax = max($p.x.c0, $p.x.c1, $p.x.c2);\n   my $pymax = max($p.y.c0, $p.y.c1, $p.y.c2);\n   my $qxmin = min($q.x.c0, $q.x.c1, $q.x.c2);\n   my $qymin = min($q.y.c0, $q.y.c1, $q.y.c2);\n   my $qxmax = max($q.x.c0, $q.x.c1, $q.x.c2);\n   my $qymax = max($q.y.c0, $q.y.c1, $q.y.c2);\n   ($exclude, $accept) = True, False;\n\n   if rectsOverlap($pxmin,$pymin,$pxmax,$pymax,$qxmin,$qymin,$qxmax,$qymax) {\n      $exclude = False;\n      my ($xmin,$xmax) = max($pxmin, $qxmin), min($pxmax, $pxmax);\n      if ($xmax < $xmin) { die \"Assertion failure: $xmax < $xmin\\n\" }\n      my ($ymin,$ymax) = max($pymin, $qymin), min($pymax, $qymax);\n      if ($ymax < $ymin) { die \"Assertion failure: $ymax < $ymin\\n\" }\n      if $xmax - $xmin <= $tol and $ymax - $ymin <= $tol {\n         $accept = True;\n         given $intersect { (.x, .y) = 0.5 X* $xmin+$xmax, $ymin+$ymax }\n      }\n   }\n}\n\nsub find-intersects($p, $q, $tol, $spacing) {\n   my Point @intersects;\n   my @workload = Workset.new(p => $p, q => $q);\n\n   while my $work = @workload.pop {\n      my ($intersect,$exclude,$accept) = Point.new, False, False;\n      testIntersect($work.p, $work.q, $tol, $exclude, $accept, $intersect);\n      if $accept {\n         unless seemsToBeDuplicate(@intersects, $intersect, $spacing) {\n            @intersects.push: $intersect;\n         }\n      } elsif not $exclude {\n         my QuadCurve ($p0, $p1, $q0, $q1);\n         subdivideQuadCurve($work.p, 0.5, $p0, $p1);\n         subdivideQuadCurve($work.q, 0.5, $q0, $q1);\n         for $p0, $p1 X $q0, $q1 {\n            @workload.push: Workset.new(p => .[0], q => .[1])\n         }\n      }\n   }\n   return @intersects;\n}\n\nmy $p = QuadCurve.new( x => QuadSpline.new(c0 => -1.0,c1 =>  0.0,c2 => 1.0),\n                       y => QuadSpline.new(c0 =>  0.0,c1 => 10.0,c2 => 0.0));\nmy $q = QuadCurve.new( x => QuadSpline.new(c0 =>  2.0,c1 => -8.0,c2 => 2.0),\n                       y => QuadSpline.new(c0 =>  1.0,c1 =>  2.0,c2 => 3.0));\nmy $spacing = ( my $tol = 0.0000001 ) * 10;\n.say for find-intersects($p, $q, $tol, $spacing);\n"
                },
                {
                    "language": "Go",
                    "solution": "/* The control points of a planar quadratic B\u00c3\u00a9zier curve form a\n   triangle--called the \"control polygon\"--that completely contains\n   the curve. Furthermore, the rectangle formed by the minimum and\n   maximum x and y values of the control polygon completely contain\n   the polygon, and therefore also the curve.\n\n   Thus a simple method for narrowing down where intersections might\n   be is: subdivide both curves until you find \"small enough\" regions\n   where these rectangles overlap.\n*/\n\npackage main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"math\"\n)\n\ntype point struct {\n    x, y float64\n}\n\ntype quadSpline struct { // Non-parametric spline.\n    c0, c1, c2 float64\n}\n\ntype quadCurve struct { // Planar parametric spline.\n    x, y quadSpline\n}\n\n// Subdivision by de Casteljau's algorithm.\nfunc subdivideQuadSpline(q quadSpline, t float64, u, v *quadSpline) {\n    s := 1.0 - t\n    c0 := q.c0\n    c1 := q.c1\n    c2 := q.c2\n    u.c0 = c0\n    v.c2 = c2\n    u.c1 = s*c0 + t*c1\n    v.c1 = s*c1 + t*c2\n    u.c2 = s*u.c1 + t*v.c1\n    v.c0 = u.c2\n}\n\nfunc subdivideQuadCurve(q quadCurve, t float64, u, v *quadCurve) {\n    subdivideQuadSpline(q.x, t, &u.x, &v.x)\n    subdivideQuadSpline(q.y, t, &u.y, &v.y)\n}\n\n// It is assumed that xa0 <= xa1, ya0 <= ya1, xb0 <= xb1, and yb0 <= yb1.\nfunc rectsOverlap(xa0, ya0, xa1, ya1, xb0, yb0, xb1, yb1 float64) bool {\n    return (xb0 <= xa1 && xa0 <= xb1 && yb0 <= ya1 && ya0 <= yb1)\n}\n\nfunc max3(x, y, z float64) float64 { return math.Max(math.Max(x, y), z) }\nfunc min3(x, y, z float64) float64 { return math.Min(math.Min(x, y), z) }\n\n// This accepts the point as an intersection if the boxes are small enough.\nfunc testIntersect(p, q quadCurve, tol float64, exclude, accept *bool, intersect *point) {\n    pxmin := min3(p.x.c0, p.x.c1, p.x.c2)\n    pymin := min3(p.y.c0, p.y.c1, p.y.c2)\n    pxmax := max3(p.x.c0, p.x.c1, p.x.c2)\n    pymax := max3(p.y.c0, p.y.c1, p.y.c2)\n\n    qxmin := min3(q.x.c0, q.x.c1, q.x.c2)\n    qymin := min3(q.y.c0, q.y.c1, q.y.c2)\n    qxmax := max3(q.x.c0, q.x.c1, q.x.c2)\n    qymax := max3(q.y.c0, q.y.c1, q.y.c2)\n\n    *exclude = true\n    *accept = false\n    if rectsOverlap(pxmin, pymin, pxmax, pymax, qxmin, qymin, qxmax, qymax) {\n        *exclude = false\n        xmin := math.Max(pxmin, qxmin)\n        xmax := math.Min(pxmax, pxmax)\n        if xmax < xmin {\n            log.Fatalf(\"Assertion failure: %f < %f\\n\", xmax, xmin)\n        }\n        if xmax-xmin <= tol {\n            ymin := math.Max(pymin, qymin)\n            ymax := math.Min(pymax, qymax)\n            if ymax < ymin {\n                log.Fatalf(\"Assertion failure: %f < %f\\n\", ymax, ymin)\n            }\n            if ymax-ymin <= tol {\n                *accept = true\n                intersect.x = 0.5*xmin + 0.5*xmax\n                intersect.y = 0.5*ymin + 0.5*ymax\n            }\n        }\n    }\n}\n\nfunc seemsToBeDuplicate(intersects []point, xy point, spacing float64) bool {\n    seemsToBeDup := false\n    i := 0\n    for !seemsToBeDup && i != len(intersects) {\n        pt := intersects[i]\n        seemsToBeDup = math.Abs(pt.x-xy.x) < spacing && math.Abs(pt.y-xy.y) < spacing\n        i++\n    }\n    return seemsToBeDup\n}\n\nfunc findIntersects(p, q quadCurve, tol, spacing float64) []point {\n    var intersects []point\n    type workset struct {\n        p, q quadCurve\n    }\n    workload := []workset{workset{p, q}}\n\n    // Quit looking after having emptied the workload.\n    for len(workload) > 0 {\n        l := len(workload)\n        work := workload[l-1]\n        workload = workload[0 : l-1]\n        var exclude, accept bool\n        intersect := point{0, 0}\n        testIntersect(work.p, work.q, tol, &exclude, &accept, &intersect)\n        if accept {\n            // To avoid detecting the same intersection twice, require some\n            // space between intersections.\n            if !seemsToBeDuplicate(intersects, intersect, spacing) {\n                intersects = append(intersects, intersect)\n            }\n        } else if !exclude {\n            var p0, p1, q0, q1 quadCurve\n            subdivideQuadCurve(work.p, 0.5, &p0, &p1)\n            subdivideQuadCurve(work.q, 0.5, &q0, &q1)\n            workload = append(workload, workset{p0, q0})\n            workload = append(workload, workset{p0, q1})\n            workload = append(workload, workset{p1, q0})\n            workload = append(workload, workset{p1, q1})\n        }\n    }\n    return intersects\n}\n\nfunc main() {\n    var p, q quadCurve\n    p.x = quadSpline{-1.0, 0.0, 1.0}\n    p.y = quadSpline{0.0, 10.0, 0.0}\n    q.x = quadSpline{2.0, -8.0, 2.0}\n    q.y = quadSpline{1.0, 2.0, 3.0}\n    tol := 0.0000001\n    spacing := tol * 10\n    intersects := findIntersects(p, q, tol, spacing)\n    for _, intersect := range intersects {\n        fmt.Printf(\"(% f, %f)\\n\", intersect.x, intersect.y)\n    }\n}\n"
                }
            ],
            [
                {
                    "language": "Phix",
                    "solution": "-- -*- mode: indented-text; tab-width: 2; -*-\n\nenum X, Y\nenum C0, C1, C2\nenum CURV, T0, T1, ENDPT0, ENDPT1\n\nfunction normlength (atom a_x, a_y)\n  -- A \"length\" according to our chosen norm (which happens to be the\n  -- max norm). Here (a_x,a_y) is a vector used as measuring rod.\n  return max (abs (a_x), abs (a_y))\nend function\n\nfunction compare_normlengths (atom a_x, a_y, b_x, b_y)\n  -- Here is a general implementation for comparison of two\n  -- \"normlength\". For the euclidean norm, you might wish to skip\n  -- taking square roots.\n  atom len_a = normlength (a_x, a_y),\n       len_b = normlength (b_x, b_y),\n       cmpval = 0\n  if len_a < len_b then\n    cmpval = -1\n  elsif len_a > len_b then\n    cmpval = 1\n  end if\n  return cmpval\nend function\n\nfunction controls_to_spower (sequence controls)\n  -- Convert from control points (that is, Bernstein basis) to the\n  -- symmetric power basis.\n  sequence pt0 = controls[1],\n           pt1 = controls[2],\n           pt2 = controls[3]\n  return {{pt0[X], (2 * pt1[X]) - pt0[X] - pt2[X], pt2[X]},\n          {pt0[Y], (2 * pt1[Y]) - pt0[Y] - pt2[Y], pt2[Y]}}\nend function\n\nfunction spower_eval (sequence spow, atom t)\n  -- Evaluate an s-power spline at t.\n  return (spow[C0] + (spow[C1] * t)) * (1 - t) + (spow[C2] * t)\nend function\n\nfunction curve_eval (sequence curv, atom t)\n  -- Evaluate a curve at t.\n  return {spower_eval (curv[X], t),\n          spower_eval (curv[Y], t)}\nend function\n\nfunction spower_center_coef (sequence spow, atom t0, t1)\n  -- Return the center coefficient for the [t0,t1] portion of an\n  -- s-power spline. (The endpoint coefficients can be found with\n  -- spower_eval.) }\n  return spow[C1] * ((t1 - t0 - t0) * t1 + (t0 * t0))\nend function\n\nfunction spower_critical_pt (sequence spow)\n  -- Return t in (0,1) where p is at a critical point, else return -1.\n  atom crit_pt = -1\n  if spow[C1] != 0 then   -- If c1 is zero, then the spline is linear.\n    if spow[C1] = spow[C2] then\n      crit_pt = 0.5             -- The spline is \"pulse-like\".\n    else\n      -- The critical point is the root of the derivative.\n      atom t = (0.5 * (spow[C2] + spow[C1] - spow[C0])) / spow[C1]\n      if (0 < t) and (t < 1) then\n        crit_pt = t\n      end if\n    end if\n  end if\n  return crit_pt\nend function\n\nfunction bisect_portion (sequence port)\n  -- Bisect a portion and pre-compute the new shared endpoint.\n  atom t_mid = 0.5 * (port[T0] + port[T1])\n  sequence pt_mid = curve_eval (port[CURV], t_mid)\n  return {{port[CURV], port[T0], t_mid, port[ENDPT0], pt_mid},\n          {port[CURV], t_mid, port[T1], pt_mid, port[ENDPT1]}}\nend function\n\nfunction rectangles_overlap (sequence a0, a1, b0, b1)\n  -- Do the rectangles with corners at (a0,a1) and (b0,b1) overlap at\n  -- all?\n  return ((min (a0[X], a1[X]) <= max (b0[X], b1[X]))\n          and (min (b0[X], b1[X]) <= max (a0[X], a1[X]))\n          and (min (a0[Y], a1[Y]) <= max (b0[Y], b1[Y]))\n          and (min (b0[Y], b1[Y]) <= max (a0[Y], a1[Y])))\nend function\n\nfunction segment_parameters (sequence a0, a1, b0, b1)\n  -- Return the respective [0,1] parameters of line segments (a0,a1)\n  -- and (b0,b1), for their intersection point. If there are not two\n  -- such parameters, return -1 for both values.\n  atom axdiff = a1[X] - a0[X],\n       aydiff = a1[Y] - a0[Y],\n       bxdiff = b1[X] - b0[X],\n       bydiff = b1[Y] - b0[Y],\n       denom = (axdiff * bydiff) - (aydiff * bxdiff),\n       anumer = ((bxdiff * a0[Y]) - (bydiff * a0[X])\n                  + (b0[X] * b1[Y]) - (b1[X] * b0[Y])),\n       ta = anumer / denom,\n       tb = -1\n  if (ta < 0.0) or (1.0 < ta) then\n    ta = -1\n  else\n    atom bnumer = -((axdiff * b0[Y]) - (aydiff * b0[X])\n                      + (a0[X] * a1[Y]) - (a1[X] * a0[Y]))\n    tb = bnumer / denom\n    if (tb < 0.0) or (1.0 < tb) then\n      ta = -1\n      tb = -1\n    end if\n  end if\n  return {ta, tb}\nend function\n\nfunction flat_enough (sequence port, atom tol)\n  -- Is a curve portion flat enough to be treated as a line segment\n  -- between its endpoints?\n\n  -- The degree-2 s-power polynomials are 1-t, t(1-t), t. We want to\n  -- remove the terms in t(1-t). The maximum of t(1-t) is 1/4, reached\n  -- at t=1/2. That accounts for the 1/4=0.25 in the following.\n\n  atom xcentercoef = spower_center_coef (port[CURV][X], port[T0],\n                                         port[T1]),\n       ycentercoef = spower_center_coef (port[CURV][Y], port[T0],\n                                         port[T1]),\n       xlen = port[ENDPT1][X] - port[ENDPT0][X],\n       ylen = port[ENDPT1][Y] - port[ENDPT0][Y]\n  return (compare_normlengths (0.25 * xcentercoef,\n                               0.25 * ycentercoef,\n                               tol * xlen, tol * ylen) <= 0)\nend function\n\nfunction find_portion_intersections (sequence pportion, qportion,\n                                     atom tol)\n  -- Find intersections between portions of two curves. Return pairs\n  -- of t-parameters. There may be duplicates and (due to truncation\n  -- error) near-intersections.\n  sequence intersections = {}\n  if rectangles_overlap (pportion[ENDPT0], pportion[ENDPT1],\n                         qportion[ENDPT0], qportion[ENDPT1]) then\n    if flat_enough (pportion, tol) then\n      if flat_enough (qportion, tol) then\n        atom tp, tq\n        {tp, tq} = segment_parameters (pportion[ENDPT0],\n                                       pportion[ENDPT1],\n                                       qportion[ENDPT0],\n                                       qportion[ENDPT1])\n        if 0 <= tp then\n          tp = (1 - tp) * pportion[T0] + tp * pportion[T1]\n          tq = (1 - tq) * qportion[T0] + tq * qportion[T1]\n          intersections &= {{tp, tq}}\n        end if\n      else\n        sequence qport1, qport2\n        {qport1, qport2} = bisect_portion (qportion)\n        intersections &=\n            find_portion_intersections (pportion, qport1, tol)\n        intersections &=\n            find_portion_intersections (pportion, qport2, tol)\n      end if\n    else\n      if flat_enough (qportion, tol) then\n        sequence pport1, pport2\n        {pport1, pport2} = bisect_portion (pportion)\n        intersections &=\n            find_portion_intersections (pport1, qportion, tol)\n        intersections &=\n            find_portion_intersections (pport2, qportion, tol)\n      else\n        sequence pport1, pport2\n        sequence qport1, qport2\n        {pport1, pport2} = bisect_portion (pportion)\n        {qport1, qport2} = bisect_portion (qportion)\n        intersections &=\n            find_portion_intersections (pport1, qport1, tol)\n        intersections &=\n            find_portion_intersections (pport1, qport2, tol)\n        intersections &=\n            find_portion_intersections (pport2, qport1, tol)\n        intersections &=\n            find_portion_intersections (pport2, qport2, tol)\n      end if\n    end if\n  end if\n  return intersections\nend function\n\nfunction find_intersections (sequence p, q, atom tol)\n  -- Find intersections in [0,1]. Return pairs of t-parameters.\n  -- There may be duplicates and (due to truncation error)\n  -- near-intersections.\n\n  -- Break the curves at critical points, so one can assume the\n  -- portion between two endpoints is monotonic along both axes.\n\n  sequence tp = {0, 1}\n  atom tpx = spower_critical_pt (p[X]),\n       tpy = spower_critical_pt (p[Y])\n  if 0 < tpx then\n    tp &= {tpx}\n  end if\n  if 0 < tpy and tpy != tpx then\n    tp &= {tpy}\n  end if\n  tp = sort (tp)\n  sequence tq = {0, 1}\n\n  sequence pvals = {}\n  for t in tp do\n    pvals &= {curve_eval (p, t)}\n  end for\n\n  atom tqx = spower_critical_pt (q[X]),\n       tqy = spower_critical_pt (q[Y])\n  if 0 < tqx then\n    tq &= {tqx}\n  end if\n  if 0 < tqy and tqy != tqx then\n    tq &= {tqy}\n  end if\n  tq = sort (tq)\n\n  sequence qvals = {}\n  for t in tq do\n    qvals &= {curve_eval (q, t)}\n  end for\n\n  -- Find intersections in the cartesian product of the monotonic\n  -- portions of the two curves.\n  sequence intersections = {}\n  for i = 1 to length (tp) - 1 do\n    for j = 1 to length (tq) - 1 do\n      sequence pportion = {p, tp[i], tp[i + 1],\n                           pvals[i], pvals[i + 1]},\n               qportion = {q, tq[j], tq[j + 1],\n                           qvals[j], qvals[j + 1]}\n      intersections &=\n        find_portion_intersections (pportion, qportion, tol)\n    end for\n  end for\n\n  return intersections\nend function\n\nsequence pcontrols = {{-1, 0}, {0, 10}, {1, 0}},\n         qcontrols = {{2, 1}, {-8, 2}, {2, 3}},\n         p = controls_to_spower (pcontrols),\n         q = controls_to_spower (qcontrols)\n\natom flatness_tolerance = 0.0001\n\n--\n-- With this algorithm and its extension to higher degrees:\n--\n-- I suspect (albeit VERY, VERY, VERY weakly) merely removing exact\n-- duplicates from the returned pairs of t-parameters will suffice to\n-- eliminate repeated detections, because (aside from intersections\n-- with multiplicities) these SHOULD occur only at endpoints, which\n-- adjacent portions share, and where the t-parameters are exact zeros\n-- and ones.\n--\n-- In any case, comparing t-parameters is certainly an alternative to\n-- comparing point distances, especially if you want to let\n-- intersections have multiplicity (as can easily happen with\n-- cubics). Scheme's SRFI-1 has \"delete-duplicates\", which lets one\n-- specify an equivalence predicate other than the default \"equal?\"--\n-- the predicate can be defined as a closure to test closeness to\n-- within some tolerance. That is how the code below SHOULD be\n-- written.\n--\n-- But I do not know how to do the same thing so simply in Phix, and\n-- thus will merely say \"unique\" here and let others update the code\n-- if they wish. :)\n--\nsequence t_pairs =\n  unique (find_intersections (p, q, flatness_tolerance))\n\nprintf (1, \"\\n\")\nprintf (1, \"          convex up                \")\nprintf (1, \"                    convex left\\n\")\nfor tt in t_pairs do\n  atom tp, tq\n  {tp, tq} = tt\n  sequence ppoint = curve_eval (p, tp),\n           qpoint = curve_eval (q, tq)\n  printf\n    (1, \" %11.8f   (%11.8f, %11.8f)     %11.8f   (%11.8f, %11.8f)\\n\",\n     {tp, ppoint[X], ppoint[Y], tq, qpoint[X], qpoint[Y]})\nend for\nprintf (1, \"\\n\")\n"
                },
                {
                    "language": "Python",
                    "solution": "#!/bin/env python3\n#\n#               *  *  *\n#\n# This is the algorithm that was introduced with the Icon example, and\n# perhaps is new (at least in its details). It works by putting both\n# curves into the symmetric power basis, then first breaking them at\n# their critical points, then doing an adaptive flattening process\n# until the problem is reduced to the intersection of two\n# lines. Possible lines of inquiry are pruned by looking for overlap\n# of the rectangles formed by the endpoints of curve portions.\n#\n# Unlike Icon, Python does not have goal-directed evaluation\n# (GDE). What Python DOES have are \"iterables\" and\n# \"comprehensions\". Where you see \"yield\" and comprehensions in the\n# Python you will likely see \"suspend\" and \"every\" in the Icon.\n#\n# To put it another way: In Python, there are objects that \"can be\n# iterated over\". In Icon, there are objects that \"can produce values\n# more than once\". In either case, the objects are equivalent to a set\n# (albeit an ordered set), and really what THIS algorithm deals with\n# is (unordered) sets.\n#\n# Another thing about Icon to be aware of, when comparing this\n# algorithm's implementations, is that Icon does not have boolean\n# expressions. It has \"succeed\" and \"fail\". An Icon expression either\n# \"succeeds\" and has a value or it \"fails\" and has no value. An \"if\"\n# construct tests whether an expression succeeded, not what the\n# expression's value is. (Booleans are easily \"faked\", of course, if\n# you want them. The language variant Object Icon explicitly\n# introduces &yes and &no as boolean values.)\n#\n#               *  *  *\n#\n# References on the symmetric power basis:\n#\n#    J. S\u00e1nchez-Reyes, \u2018The symmetric analogue of the polynomial power\n#        basis\u2019, ACM Transactions on Graphics, vol 16 no 3, July 1997,\n#        page 319.\n#\n#    J. S\u00e1nchez-Reyes, \u2018Applications of the polynomial s-power basis\n#        in geometry processing\u2019, ACM Transactions on Graphics, vol 19\n#        no 1, January 2000, page 35.\n#\n\ndef length(ax, ay):\n    '''Length according to some norm, where (ax,ay) is a \"measuring\n    stick\" vector. Here I use the max norm.'''\n    assert isinstance(ax, float)\n    assert isinstance(ay, float)\n    return max(abs(ax), abs(ay))\n\ndef compare_lengths(ax, ay, bx, by):\n    '''Having a compare_lengths function lets one compare lengths in\n    the euclidean metric by comparing the squares of the lengths, and\n    thus avoiding the square root. The following, however, is a\n    general implementation.'''\n    assert isinstance(ax, float)\n    assert isinstance(ay, float)\n    assert isinstance(bx, float)\n    assert isinstance(by, float)\n    len_a = length(ax, ay)\n    len_b = length(bx, by)\n    if len_a < len_b:\n        cmpval = -1\n    elif len_a > len_b:\n        cmpval = 1\n    else:\n        cmpval = 0\n    return cmpval\n\ndef rectangles_overlap(a0, a1, b0, b1):\n    '''Do the rectangles with corners at (a0,a1) and (b0,b1) overlap\n    at all?'''\n    assert isinstance(a0, Point)\n    assert isinstance(a1, Point)\n    assert isinstance(b0, Point)\n    assert isinstance(b1, Point)\n    return ((min(a0.x, a1.x) <= max(b0.x, b1.x))\n            and (min(b0.x, b1.x) <= max(a0.x, a1.x))\n            and (min(a0.y, a1.y) <= max(b0.y, b1.y))\n            and (min(b0.y, b1.y) <= max(a0.y, a1.y)))\n\ndef segment_parameters(a0, a1, b0, b1):\n    '''Do the line segments (a0,a1) and (b0,b1) intersect?  If so,\n    return a tuple of their t-parameter values for the point of\n    intersection, treating them as parametric splines of degree\n    1. Otherwise return None.'''\n    assert isinstance(a0, Point)\n    assert isinstance(a1, Point)\n    assert isinstance(b0, Point)\n    assert isinstance(b1, Point)\n\n    retval = None\n\n    axdiff = a1.x - a0.x\n    aydiff = a1.y - a0.y\n    bxdiff = b1.x - b0.x\n    bydiff = b1.y - b0.y\n\n    denom = (axdiff * bydiff) - (aydiff * bxdiff)\n\n    anumer = ((bxdiff * a0.y) - (bydiff * a0.x)\n              + (b0.x * b1.y) - (b1.x * b0.y))\n    ta = anumer / denom\n    if 0.0 <= ta and ta <= 1.0:\n        bnumer = -((axdiff * b0.y) - (aydiff * b0.x)\n                   + (a0.x * a1.y) - (a1.x * a0.y))\n        tb = bnumer / denom\n        if 0.0 <= tb and tb <= 1.0:\n            retval = (ta, tb)\n\n    return retval\n\nclass Point:\n    def __init__(self, x, y):\n        assert isinstance(x, float)\n        assert isinstance(y, float)\n        self.x = x\n        self.y = y\n\nclass SPower:\n    '''Non-parametric spline in s-power basis.'''\n\n    def __init__(self, c0, c1, c2):\n        assert isinstance(c0, float)\n        assert isinstance(c1, float)\n        assert isinstance(c2, float)\n        self.c0 = c0\n        self.c1 = c1\n        self.c2 = c2\n\n    def val(self, t):\n        '''Evaluate at t.'''\n        assert isinstance(t, float)\n        return (self.c0 + (self.c1 * t)) * (1.0 - t) + (self.c2 * t)\n\n    def center_coef(self, t0, t1):\n        '''Return the center coefficient for the [t0,t1] portion. (The\n        other coefficients can be found with the val method.)'''\n        assert isinstance(t0, float)\n        assert isinstance(t1, float)\n        return self.c1 * ((t1 - t0 - t0) * t1 + (t0 * t0))\n\n    def critical_points(self):\n        '''Return a set of independent variable values for the\n        critical points that lie in (0,1).'''\n        critpoints = set()\n        if self.c1 != 0:    # If c1 is zero then the spline is linear.\n            if self.c0 == self.c2:\n                critpoints = {0.5} # The spline is \"pulse-like\".\n            else:\n                # The root of the derivative is the critical point.\n                t = (0.5 * (self.c2 + self.c1 - self.c0)) / self.c1\n                if 0.0 < t and t < 1.0:\n                    critpoints = {t}\n        return critpoints\n\nclass Curve:\n    '''Parametric spline in s-power basis.'''\n\n    def __init__(self, x, y):\n        assert isinstance(x, SPower)\n        assert isinstance(y, SPower)\n        self.x = x\n        self.y = y\n\n    @staticmethod\n    def from_controls(ctl0, ctl1, ctl2):\n        assert isinstance(ctl0, Point)\n        assert isinstance(ctl1, Point)\n        assert isinstance(ctl2, Point)\n        c0x = ctl0.x\n        c0y = ctl0.y\n        c1x = (2.0 * ctl1.x) - ctl0.x - ctl2.x\n        c1y = (2.0 * ctl1.y) - ctl0.y - ctl2.y\n        c2x = ctl2.x\n        c2y = ctl2.y\n        return Curve(SPower(c0x, c1x, c2x),\n                     SPower(c0y, c1y, c2y))\n\n    def val(self, t):\n        '''Evaluate at t.'''\n        assert isinstance(t, float)\n        return Point(self.x.val(t), self.y.val(t))\n\n    def critical_points(self):\n        '''Return a set of t-parameter values for the critical points\n        that lie in (0,1).'''\n        return (self.x.critical_points() | self.y.critical_points())\n\nclass Portion:\n    '''Portion of a parametric spline in [t0,t1].'''\n\n    default_num_pieces = 2\n\n    def __init__(self, curve, t0, t1, endpt0, endpt1):\n        assert isinstance(curve, Curve)\n        assert isinstance(t0, float)\n        assert isinstance(t1, float)\n        assert isinstance(endpt0, Point)\n        assert isinstance(endpt1, Point)\n        self.curve = curve\n        self.t0 = t0\n        self.t1 = t1\n        self.endpt0 = endpt0\n        self.endpt1 = endpt1\n\n    def flat_enough(self, tol):\n        '''Is the Portion close enough to linear to be treated as a\n        line segment?'''\n\n        # The degree-2 s-power polynomials are 1-t, t(1-t), t. We want\n        # to remove the terms in t(1-t). The maximum of t(1-t) is 1/4,\n        # reached at t=1/2. That accounts for the 1/4=0.25 in the\n        # following.\n\n        xcentercoef = self.curve.x.center_coef(self.t0, self.t1)\n        ycentercoef = self.curve.y.center_coef(self.t0, self.t1)\n        xlen = self.endpt1.x - self.endpt0.x\n        ylen = self.endpt1.y - self.endpt0.y\n        return compare_lengths(0.25 * xcentercoef,\n                               0.25 * ycentercoef,\n                               tol * xlen, tol * ylen) <= 0\n\n    def split(self, num_pieces = default_num_pieces):\n        '''Generate num_pieces sections of the Portion.'''\n        assert isinstance(num_pieces, int)\n        assert 2 <= num_pieces\n        k = 1.0 / num_pieces\n        ts = [(1.0 - (k * i)) * self.t0 + (k * i) * self.t1\n              for i in range(1, num_pieces)]\n        vals = [self.curve.val(t) for t in ts]\n        ts = [self.t0] + ts + [self.t1]\n        vals = [self.endpt0] + vals + [self.endpt1]\n        for i in range(len(ts) - 1):\n            yield Portion(self.curve, ts[i], ts[i + 1],\n                          vals[i], vals[i + 1])\n\ndef find_intersections(p, q, tol):\n    '''Generate t-parameter pairs detected as corresponding to\n    intersection points of p and q. There may be duplicate\n    detections. It is assumed those will be weeded out by later\n    processing. The tol parameter specifies the \"flatness tolerance\"\n    and is a relative tolerance.'''\n    assert isinstance(p, Curve)\n    assert isinstance(q, Curve)\n\n    # The initial workload is the cartesian product of the monotonic\n    # portions of p and q, respectively.\n    tp = [0.0] + sorted(p.critical_points()) + [1.0]\n    tq = [0.0] + sorted(q.critical_points()) + [1.0]\n    workload = {(Portion(p, tp[i], tp[i + 1],\n                         p.val(tp[i]), p.val(tp[i + 1])),\n                 Portion(q, tq[j], tq[j + 1],\n                         q.val(tq[j]), q.val(tq[j + 1])))\n                for i in range(len(tp) - 1)\n                for j in range(len(tq) - 1)}\n\n    while len(workload) != 0:\n        (pportion, qportion) = workload.pop()\n        if rectangles_overlap(pportion.endpt0, pportion.endpt1,\n                              qportion.endpt0, qportion.endpt1):\n            if pportion.flat_enough(tol):\n                if qportion.flat_enough(tol):\n                    params = segment_parameters(pportion.endpt0,\n                                                pportion.endpt1,\n                                                qportion.endpt0,\n                                                qportion.endpt1)\n                    if params is not None:\n                        (tp, tq) = params\n                        tp = (1 - tp) * pportion.t0 + tp * pportion.t1\n                        tq = (1 - tq) * qportion.t0 + tq * qportion.t1\n                        yield (tp, tq)\n                else:\n                    workload |= {(pportion, qport)\n                                 for qport in qportion.split()}\n            else:\n                if qportion.flat_enough(tol):\n                    workload |= {(pport, qportion)\n                                 for pport in pportion.split()}\n                else:\n                    workload |= {(pport, qport)\n                                 for pport in pportion.split()\n                                 for qport in qportion.split()}\n\nif __name__ == '__main__':\n    flatness_tolerance = 0.0001\n    minimum_spacing = 0.000001\n\n    p = Curve.from_controls(Point(-1.0, 0.0),\n                            Point(0.0, 10.0),\n                            Point(1.0, 0.0))\n    q = Curve.from_controls(Point(2.0, 1.0),\n                            Point(-8.0, 2.0),\n                            Point( 2.0, 3.0))\n\n    intersections = dict()\n    for (tp, tq) in find_intersections(p, q, flatness_tolerance):\n        pval = p.val(tp)\n        qval = q.val(tq)\n        if all([(minimum_spacing <=\n                 length(pval.x - intersections[t][1].x,\n                        pval.y - intersections[t][1].y))\n                and (minimum_spacing <=\n                     length(qval.x - intersections[t][3].x,\n                            qval.y - intersections[t][3].y))\n                for t in intersections]):\n            intersections[tp] = (tp, pval, tq, qval)\n\n    print()\n    print('          convex up                ',\n          '                   convex left');\n    for k in sorted(intersections):\n        (tp, pointp, tq, pointq) = intersections[k]\n        print((\" %11.8f   (%11.8f, %11.8f)     \" +\n               \"%11.8f   (%11.8f, %11.8f)\")\n              %(tp, pointp.x, pointp.y, tq, pointq.x, pointq.y))\n    print()\n"
                }
            ],
            [
                {
                    "language": "Maxima",
                    "solution": "/*\n\nThe method of implicitization:\n\n1. Find an implicit equation for one of the curves, in x and y.\n2. Plug the parametric equations of the other curve into the implicit\n   equation.\n3. Find the roots of the resulting polynomial equation in t.\n4. Plug those roots into the parametric equations of step (2).\n\n*/\n\n/* The Bernstein basis of degree 2. See\n   https://en.wikipedia.org/w/index.php?title=Bernstein_polynomial&oldid=1144565695\n   */\nb02(t) := 1 - 2*t +   t**2$\nb12(t) :=     2*t - 2*t**2$\nb22(t) :=             t**2$\n\n/* The convex-up parabola, with its control points as coefficients of\n   the Bernstein basis. */\nxu(t) := -b02(t) + b22(t)$\nyu(t) := 10*b12(t)$\n\n/* The convex-left parabola, with its control points as coefficients\n   of the Bernstein basis. */\nxl(t) := 2*b02(t) - 8*b12(t) + 2*b22(t)$\nyl(t) := b02(t) + 2*b12(t) + 3*b22(t)$\n\n/* One can implicitize the convex-up B\u00c3\u00a9zier curve by computing the\n   resultant of x - xu and y - yu.\n\n   The method is mentioned at\n   https://en.wikipedia.org/w/index.php?title=Gr%C3%B6bner_basis&oldid=1152603392#Implicitization_of_a_rational_curve\n   although they are describing a more general method that I do not\n   know how to do.\n\n   Here I combine forming the resultant with plugging in xl(t) and\n   yl(t).  */\nquartic_poly: resultant (xl(t) - xu(tau), yl(t) - yu(tau), tau)$\n\n/* Find all the roots of the quartic equation that lie in [0,1]. */\nroots: ev (realroots (quartic_poly = 0), float)$\nroots: sublist(roots, lambda([item], 0 <= rhs(t) and rhs(t) <= 1))$\n\n/* Plug them into xl(t) and yl(t). */\nfor i: 1 thru length(roots) do\nblock (\n  display(expand(xl(roots[i]))),\n  display(expand(yl(roots[i])))\n  )$\n\n/* As an afterword, I would like to mention some drawbacks of\n   implicitization.\n\n     * It cannot find self-intersections. This is a major problem for\n       curves of degree 3 or greater.\n\n     * It gives you the t-parameter values for only one of the two\n       curves. If you just need t-parameter values for both curves\n       (such as to break them up at intersection points), then you\n       could perform implicitization both ways. But, if you need to\n       know which t corresponds to which, you need more than just\n       implicitization. (A method for finding t from given (x,y), for\n       instance.)\n\n     * It requires first constructing a polynomial of degree 4, 9, 16,\n       etc., and then finding its roots in [0,1]. There are serious\n       difficulties associated with both of those tasks. */\n"
                },
                {
                    "language": "Wren",
                    "solution": "/* The control points of a planar quadratic B\u00c3\u00a9zier curve form a\n   triangle--called the \"control polygon\"--that completely contains\n   the curve. Furthermore, the rectangle formed by the minimum and\n   maximum x and y values of the control polygon completely contain\n   the polygon, and therefore also the curve.\n\n   Thus a simple method for narrowing down where intersections might\n   be is: subdivide both curves until you find \"small enough\" regions\n   where these rectangles overlap.\n*/\n\nimport \"./dynamic\" for Struct\nimport \"./trait\" for ByRef\nimport \"./math\" for Math, Nums\nimport \"./assert\" for Assert\nimport \"./seq\" for Stack\nimport \"./fmt\" for Fmt\n\n// Note that these are all mutable as we need to pass by reference.\nvar Point      = Struct.create(\"Point\", [\"x\", \"y\"])\nvar QuadSpline = Struct.create(\"QuadSpline\", [\"c0\", \"c1\", \"c2\"]) // non-parametric\nvar QuadCurve  = Struct.create(\"QuadCurve\", [\"x\", \"y\"]) // planar parametric\nvar Workset    = Struct.create(\"Workset\", [\"p\", \"q\"])\n\n// Subdivision by de Casteljau's algorithm\nvar subdivideQuadSpline = Fn.new { |q, t, u, v|\n    var s = 1 - t\n    var c0 = q.c0\n    var c1 = q.c1\n    var c2 = q.c2\n    u.c0 = c0\n    v.c2 = c2\n    u.c1 = s * c0 + t * c1\n    v.c1 = s * c1 + t * c2\n    u.c2 = s * u.c1 + t * v.c1\n    v.c0 = u.c2\n}\n\nvar subdivideQuadCurve = Fn.new { |q, t, u, v|\n    subdivideQuadSpline.call(q.x, t, u.x, v.x)\n    subdivideQuadSpline.call(q.y, t, u.y, v.y)\n}\n\n// It is assumed that xa0 <= xa1, ya0 <= ya1, xb0 <= xb1, and yb0 <= yb1.\nvar rectsOverlap = Fn.new { |xa0, ya0, xa1, ya1, xb0, yb0, xb1, yb1|\n    return (xb0 <= xa1 && xa0 <= xb1 && yb0 <= ya1 && ya0 <= yb1)\n}\n\n// This accepts the point as an intersection if the boxes are small enough.\nvar testIntersect = Fn.new { |p, q, tol, exclude, accept, intersect|\n    var pxmin = Nums.min([p.x.c0, p.x.c1, p.x.c2])\n    var pymin = Nums.min([p.y.c0, p.y.c1, p.y.c2])\n    var pxmax = Nums.max([p.x.c0, p.x.c1, p.x.c2])\n    var pymax = Nums.max([p.y.c0, p.y.c1, p.y.c2])\n\n    var qxmin = Nums.min([q.x.c0, q.x.c1, q.x.c2])\n    var qymin = Nums.min([q.y.c0, q.y.c1, q.y.c2])\n    var qxmax = Nums.max([q.x.c0, q.x.c1, q.x.c2])\n    var qymax = Nums.max([q.y.c0, q.y.c1, q.y.c2])\n\n    exclude.value = true\n    accept.value = false\n    if (rectsOverlap.call(pxmin, pymin, pxmax, pymax, qxmin, qymin, qxmax, qymax)) {\n        exclude.value = false\n        var xmin = Math.max(pxmin, qxmin)\n        var xmax = Math.min(pxmax, qxmax)\n        Assert.ok(xmax >= xmin)\n        if (xmax - xmin <= tol) {\n            var ymin = Math.max(pymin, qymin)\n            var ymax = Math.min(pymax, qymax)\n            Assert.ok(ymax >= ymin)\n            if (ymax - ymin <= tol) {\n                accept.value = true\n                intersect.x = 0.5 * xmin + 0.5 * xmax\n                intersect.y = 0.5 * ymin + 0.5 * ymax\n            }\n        }\n    }\n}\n\nvar seemsToBeDuplicate = Fn.new { |intersects, xy, spacing|\n    var seemsToBeDup = false\n    var i = 0\n    while (!seemsToBeDup && i != intersects.count) {\n        var pt = intersects[i]\n        seemsToBeDup = (pt.x - xy.x).abs < spacing && (pt.y - xy.y).abs < spacing\n        i = i + 1\n    }\n    return seemsToBeDup\n}\n\nvar findIntersects = Fn.new { |p, q, tol, spacing|\n    var intersects = []\n    var workload = Stack.new()\n    workload.push(Workset.new(p, q))\n\n    // Quit looking after having emptied the workload.\n    while (!workload.isEmpty) {\n        var work = workload.peek()\n        workload.pop()\n        var exclude = ByRef.new(false)\n        var accept  = ByRef.new(false)\n        var intersect = Point.new(0, 0)\n        testIntersect.call(work.p, work.q, tol, exclude, accept, intersect)\n        if (accept.value) {\n            // To avoid detecting the same intersection twice, require some\n            // space between intersections.\n            if (!seemsToBeDuplicate.call(intersects, intersect, spacing)) {\n                intersects.add(intersect)\n            }\n        } else if (!exclude.value) {\n            var p0 = QuadCurve.new(QuadSpline.new(0, 0, 0), QuadSpline.new(0, 0, 0))\n            var p1 = QuadCurve.new(QuadSpline.new(0, 0, 0), QuadSpline.new(0, 0, 0))\n            var q0 = QuadCurve.new(QuadSpline.new(0, 0, 0), QuadSpline.new(0, 0, 0))\n            var q1 = QuadCurve.new(QuadSpline.new(0, 0, 0), QuadSpline.new(0, 0, 0))\n            subdivideQuadCurve.call(work.p, 0.5, p0, p1)\n            subdivideQuadCurve.call(work.q, 0.5, q0, q1)\n            workload.push(Workset.new(p0, q0))\n            workload.push(Workset.new(p0, q1))\n            workload.push(Workset.new(p1, q0))\n            workload.push(Workset.new(p1, q1))\n        }\n    }\n    return intersects\n}\n\nvar p = QuadCurve.new(QuadSpline.new(-1,  0, 1), QuadSpline.new(0, 10, 0))\nvar q = QuadCurve.new(QuadSpline.new( 2, -8, 2), QuadSpline.new(1,  2, 3))\nvar tol = 0.0000001\nvar spacing = 10 * tol\nvar intersects = findIntersects.call(p, q, tol, spacing)\nfor (intersect in intersects) Fmt.print(\"($ f, $f)\", intersect.x, intersect.y)\n"
                }
            ],
            [
                {
                    "language": "Wren",
                    "solution": "/* The control points of a planar quadratic B\u00c3\u00a9zier curve form a\n   triangle--called the \"control polygon\"--that completely contains\n   the curve. Furthermore, the rectangle formed by the minimum and\n   maximum x and y values of the control polygon completely contain\n   the polygon, and therefore also the curve.\n\n   Thus a simple method for narrowing down where intersections might\n   be is: subdivide both curves until you find \"small enough\" regions\n   where these rectangles overlap.\n*/\n\nimport \"./dynamic\" for Struct\nimport \"./trait\" for ByRef\nimport \"./math\" for Math, Nums\nimport \"./assert\" for Assert\nimport \"./seq\" for Stack\nimport \"./fmt\" for Fmt\n\n// Note that these are all mutable as we need to pass by reference.\nvar Point      = Struct.create(\"Point\", [\"x\", \"y\"])\nvar QuadSpline = Struct.create(\"QuadSpline\", [\"c0\", \"c1\", \"c2\"]) // non-parametric\nvar QuadCurve  = Struct.create(\"QuadCurve\", [\"x\", \"y\"]) // planar parametric\nvar Workset    = Struct.create(\"Workset\", [\"p\", \"q\"])\n\n// Subdivision by de Casteljau's algorithm\nvar subdivideQuadSpline = Fn.new { |q, t, u, v|\n    var s = 1 - t\n    var c0 = q.c0\n    var c1 = q.c1\n    var c2 = q.c2\n    u.c0 = c0\n    v.c2 = c2\n    u.c1 = s * c0 + t * c1\n    v.c1 = s * c1 + t * c2\n    u.c2 = s * u.c1 + t * v.c1\n    v.c0 = u.c2\n}\n\nvar subdivideQuadCurve = Fn.new { |q, t, u, v|\n    subdivideQuadSpline.call(q.x, t, u.x, v.x)\n    subdivideQuadSpline.call(q.y, t, u.y, v.y)\n}\n\n// It is assumed that xa0 <= xa1, ya0 <= ya1, xb0 <= xb1, and yb0 <= yb1.\nvar rectsOverlap = Fn.new { |xa0, ya0, xa1, ya1, xb0, yb0, xb1, yb1|\n    return (xb0 <= xa1 && xa0 <= xb1 && yb0 <= ya1 && ya0 <= yb1)\n}\n\n// This accepts the point as an intersection if the boxes are small enough.\nvar testIntersect = Fn.new { |p, q, tol, exclude, accept, intersect|\n    var pxmin = Nums.min([p.x.c0, p.x.c1, p.x.c2])\n    var pymin = Nums.min([p.y.c0, p.y.c1, p.y.c2])\n    var pxmax = Nums.max([p.x.c0, p.x.c1, p.x.c2])\n    var pymax = Nums.max([p.y.c0, p.y.c1, p.y.c2])\n\n    var qxmin = Nums.min([q.x.c0, q.x.c1, q.x.c2])\n    var qymin = Nums.min([q.y.c0, q.y.c1, q.y.c2])\n    var qxmax = Nums.max([q.x.c0, q.x.c1, q.x.c2])\n    var qymax = Nums.max([q.y.c0, q.y.c1, q.y.c2])\n\n    exclude.value = true\n    accept.value = false\n    if (rectsOverlap.call(pxmin, pymin, pxmax, pymax, qxmin, qymin, qxmax, qymax)) {\n        exclude.value = false\n        var xmin = Math.max(pxmin, qxmin)\n        var xmax = Math.min(pxmax, qxmax)\n        Assert.ok(xmax >= xmin)\n        if (xmax - xmin <= tol) {\n            var ymin = Math.max(pymin, qymin)\n            var ymax = Math.min(pymax, qymax)\n            Assert.ok(ymax >= ymin)\n            if (ymax - ymin <= tol) {\n                accept.value = true\n                intersect.x = 0.5 * xmin + 0.5 * xmax\n                intersect.y = 0.5 * ymin + 0.5 * ymax\n            }\n        }\n    }\n}\n\nvar seemsToBeDuplicate = Fn.new { |intersects, xy, spacing|\n    var seemsToBeDup = false\n    var i = 0\n    while (!seemsToBeDup && i != intersects.count) {\n        var pt = intersects[i]\n        seemsToBeDup = (pt.x - xy.x).abs < spacing && (pt.y - xy.y).abs < spacing\n        i = i + 1\n    }\n    return seemsToBeDup\n}\n\nvar findIntersects = Fn.new { |p, q, tol, spacing|\n    var intersects = []\n    var workload = Stack.new()\n    workload.push(Workset.new(p, q))\n\n    // Quit looking after having emptied the workload.\n    while (!workload.isEmpty) {\n        var work = workload.peek()\n        workload.pop()\n        var exclude = ByRef.new(false)\n        var accept  = ByRef.new(false)\n        var intersect = Point.new(0, 0)\n        testIntersect.call(work.p, work.q, tol, exclude, accept, intersect)\n        if (accept.value) {\n            // To avoid detecting the same intersection twice, require some\n            // space between intersections.\n            if (!seemsToBeDuplicate.call(intersects, intersect, spacing)) {\n                intersects.add(intersect)\n            }\n        } else if (!exclude.value) {\n            var p0 = QuadCurve.new(QuadSpline.new(0, 0, 0), QuadSpline.new(0, 0, 0))\n            var p1 = QuadCurve.new(QuadSpline.new(0, 0, 0), QuadSpline.new(0, 0, 0))\n            var q0 = QuadCurve.new(QuadSpline.new(0, 0, 0), QuadSpline.new(0, 0, 0))\n            var q1 = QuadCurve.new(QuadSpline.new(0, 0, 0), QuadSpline.new(0, 0, 0))\n            subdivideQuadCurve.call(work.p, 0.5, p0, p1)\n            subdivideQuadCurve.call(work.q, 0.5, q0, q1)\n            workload.push(Workset.new(p0, q0))\n            workload.push(Workset.new(p0, q1))\n            workload.push(Workset.new(p1, q0))\n            workload.push(Workset.new(p1, q1))\n        }\n    }\n    return intersects\n}\n\nvar p = QuadCurve.new(QuadSpline.new(-1,  0, 1), QuadSpline.new(0, 10, 0))\nvar q = QuadCurve.new(QuadSpline.new( 2, -8, 2), QuadSpline.new(1,  2, 3))\nvar tol = 0.0000001\nvar spacing = 10 * tol\nvar intersects = findIntersects.call(p, q, tol, spacing)\nfor (intersect in intersects) Fmt.print(\"($ f, $f)\", intersect.x, intersect.y)\n"
                },
                {
                    "language": "Phix",
                    "solution": "(phixonline)-->\n <span style=\"color: #008080;\">enum</span> <span style=\"color: #000000;\">X</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">Y</span>\n <span style=\"color: #008080;\">type</span> <span style=\"color: #000000;\">quadratic_spline</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #004080;\">sequence</span> <span style=\"color: #000080;font-style:italic;\">/*c*/</span><span style=\"color: #0000FF;\">)</span>\n <span style=\"color: #000080;font-style:italic;\">--  return apply(c,sq_atom)={1,1,1} -- oops, requires 1.0.3...</span>\n     <span style=\"color: #008080;\">return</span> <span style=\"color: #004600;\">true</span> <span style=\"color: #000080;font-style:italic;\">-- this will do instead for 1.0.2 and earlier</span>\n <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">type</span>\n\n <span style=\"color: #008080;\">type</span> <span style=\"color: #000000;\">quadratic_curve</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #004080;\">sequence</span> <span style=\"color: #000080;font-style:italic;\">/*c*/</span><span style=\"color: #0000FF;\">)</span>\n <span style=\"color: #000080;font-style:italic;\">--  return apply(c,sq_atom)=<nowiki>{{</nowiki>1,1,1},{1,1,1<nowiki>}}</nowiki>   -- ditto</span>\n     <span style=\"color: #008080;\">return</span> <span style=\"color: #004600;\">true</span>\n <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">type</span>\n\n <span style=\"color: #008080;\">function</span> <span style=\"color: #000000;\">subdivide_quadratic_spline</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">quadratic_spline</span> <span style=\"color: #000000;\">q</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #004080;\">atom</span> <span style=\"color: #000000;\">t</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #000080;font-style:italic;\">// Subdivision by de Casteljau's algorithm.</span>\n     <span style=\"color: #004080;\">atom</span> <span style=\"color: #0000FF;\">{</span><span style=\"color: #000000;\">c1</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">c2</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">c3</span><span style=\"color: #0000FF;\">}</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #000000;\">q</span><span style=\"color: #0000FF;\">,</span>\n          <span style=\"color: #000000;\">s</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #000000;\">1</span> <span style=\"color: #0000FF;\">-</span> <span style=\"color: #000000;\">t</span><span style=\"color: #0000FF;\">,</span>\n         <span style=\"color: #000000;\">u1</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">s</span> <span style=\"color: #0000FF;\">*</span> <span style=\"color: #000000;\">c1</span><span style=\"color: #0000FF;\">)</span> <span style=\"color: #0000FF;\">+</span> <span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">t</span> <span style=\"color: #0000FF;\">*</span> <span style=\"color: #000000;\">c2</span><span style=\"color: #0000FF;\">),</span>\n         <span style=\"color: #000000;\">v1</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">s</span> <span style=\"color: #0000FF;\">*</span> <span style=\"color: #000000;\">c2</span><span style=\"color: #0000FF;\">)</span> <span style=\"color: #0000FF;\">+</span> <span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">t</span> <span style=\"color: #0000FF;\">*</span> <span style=\"color: #000000;\">c3</span><span style=\"color: #0000FF;\">),</span>\n          <span style=\"color: #000000;\">m</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">s</span> <span style=\"color: #0000FF;\">*</span> <span style=\"color: #000000;\">u1</span><span style=\"color: #0000FF;\">)</span> <span style=\"color: #0000FF;\">+</span> <span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">t</span> <span style=\"color: #0000FF;\">*</span> <span style=\"color: #000000;\">v1</span><span style=\"color: #0000FF;\">)</span>\n   <span style=\"color: #008080;\">return</span> <span style=\"color: #0000FF;\">{{</span><span style=\"color: #000000;\">c1</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">u1</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">m</span><span style=\"color: #0000FF;\">},{</span><span style=\"color: #000000;\">m</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">v1</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">c3</span><span style=\"color: #0000FF;\">}}</span>\n <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">function</span>\n\n <span style=\"color: #008080;\">function</span> <span style=\"color: #000000;\">subdivide_quadratic_curve</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">quadratic_curve</span> <span style=\"color: #000000;\">q</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #004080;\">atom</span> <span style=\"color: #000000;\">t</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #004080;\">sequence</span> <span style=\"color: #0000FF;\">{</span><span style=\"color: #000000;\">px</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">qx</span><span style=\"color: #0000FF;\">}</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #000000;\">subdivide_quadratic_spline</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">q</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">X</span><span style=\"color: #0000FF;\">],</span> <span style=\"color: #000000;\">t</span><span style=\"color: #0000FF;\">),</span>\n              <span style=\"color: #0000FF;\">{</span><span style=\"color: #000000;\">py</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">qy</span><span style=\"color: #0000FF;\">}</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #000000;\">subdivide_quadratic_spline</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">q</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">Y</span><span style=\"color: #0000FF;\">],</span> <span style=\"color: #000000;\">t</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #008080;\">return</span> <span style=\"color: #0000FF;\">{{</span><span style=\"color: #000000;\">px</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">py</span><span style=\"color: #0000FF;\">},{</span><span style=\"color: #000000;\">qx</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">qy</span><span style=\"color: #0000FF;\">}}</span>\n <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">function</span>\n\n <span style=\"color: #008080;\">function</span> <span style=\"color: #000000;\">rectangles_overlap</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #004080;\">atom</span> <span style=\"color: #000000;\">xa1</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #000000;\">ya1</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #000000;\">xa2</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #000000;\">ya2</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #000000;\">xb1</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #000000;\">yb1</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #000000;\">xb2</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #000000;\">yb2</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #7060A8;\">assert</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">xa1</span><span style=\"color: #0000FF;\"><=</span><span style=\"color: #000000;\">xa2</span> <span style=\"color: #008080;\">and</span> <span style=\"color: #000000;\">ya1</span><span style=\"color: #0000FF;\"><=</span><span style=\"color: #000000;\">ya2</span> <span style=\"color: #008080;\">and</span> <span style=\"color: #000000;\">xb1</span><span style=\"color: #0000FF;\"><=</span><span style=\"color: #000000;\">xb2</span> <span style=\"color: #008080;\">and</span> <span style=\"color: #000000;\">yb1</span><span style=\"color: #0000FF;\"><=</span><span style=\"color: #000000;\">yb2</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #008080;\">return</span> <span style=\"color: #000000;\">xb1</span> <span style=\"color: #0000FF;\"><=</span> <span style=\"color: #000000;\">xa2</span> <span style=\"color: #008080;\">and</span> <span style=\"color: #000000;\">xa1</span> <span style=\"color: #0000FF;\"><=</span> <span style=\"color: #000000;\">xb2</span> <span style=\"color: #008080;\">and</span> <span style=\"color: #000000;\">yb1</span> <span style=\"color: #0000FF;\"><=</span> <span style=\"color: #000000;\">ya2</span> <span style=\"color: #008080;\">and</span> <span style=\"color: #000000;\">ya1</span> <span style=\"color: #0000FF;\"><=</span> <span style=\"color: #000000;\">yb2</span>\n <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">function</span>\n\n <span style=\"color: #008080;\">function</span> <span style=\"color: #000000;\">test_intersection</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">quadratic_curve</span> <span style=\"color: #000000;\">p</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #000000;\">q</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #004080;\">atom</span> <span style=\"color: #000000;\">tolerance</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #004080;\">atom</span> <span style=\"color: #000000;\">pxmin</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">min</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">p</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">X</span><span style=\"color: #0000FF;\">]),</span>  <span style=\"color: #000000;\">pymin</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">min</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">p</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">Y</span><span style=\"color: #0000FF;\">]),</span>\n          <span style=\"color: #000000;\">pxmax</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">max</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">p</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">X</span><span style=\"color: #0000FF;\">]),</span>  <span style=\"color: #000000;\">pymax</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">max</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">p</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">Y</span><span style=\"color: #0000FF;\">]),</span>\n          <span style=\"color: #000000;\">qxmin</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">min</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">q</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">X</span><span style=\"color: #0000FF;\">]),</span>  <span style=\"color: #000000;\">qymin</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">min</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">q</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">Y</span><span style=\"color: #0000FF;\">]),</span>\n          <span style=\"color: #000000;\">qxmax</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">max</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">q</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">X</span><span style=\"color: #0000FF;\">]),</span>  <span style=\"color: #000000;\">qymax</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">max</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">q</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">Y</span><span style=\"color: #0000FF;\">])</span>\n     <span style=\"color: #008080;\">if</span> <span style=\"color: #000000;\">rectangles_overlap</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">pxmin</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #000000;\">pymin</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #000000;\">pxmax</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #000000;\">pymax</span><span style=\"color: #0000FF;\">,</span>\n                           <span style=\"color: #000000;\">qxmin</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #000000;\">qymin</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #000000;\">qxmax</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #000000;\">qymax</span><span style=\"color: #0000FF;\">)</span> <span style=\"color: #008080;\">then</span>\n         <span style=\"color: #004080;\">atom</span> <span style=\"color: #000000;\">xmin</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">max</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">pxmin</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">qxmin</span><span style=\"color: #0000FF;\">),</span> <span style=\"color: #000000;\">xmax</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">min</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">pxmax</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">qxmax</span><span style=\"color: #0000FF;\">),</span>\n              <span style=\"color: #000000;\">ymin</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">max</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">pymin</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">qymin</span><span style=\"color: #0000FF;\">),</span> <span style=\"color: #000000;\">ymax</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">min</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">pymax</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">qymax</span><span style=\"color: #0000FF;\">)</span>\n         <span style=\"color: #7060A8;\">assert</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">xmax</span> <span style=\"color: #0000FF;\">>=</span> <span style=\"color: #000000;\">xmin</span> <span style=\"color: #008080;\">and</span> <span style=\"color: #000000;\">ymax</span> <span style=\"color: #0000FF;\">>=</span> <span style=\"color: #000000;\">ymin</span><span style=\"color: #0000FF;\">)</span>\n         <span style=\"color: #008080;\">if</span> <span style=\"color: #000000;\">xmax</span><span style=\"color: #0000FF;\">-</span><span style=\"color: #000000;\">xmin</span> <span style=\"color: #0000FF;\"><=</span> <span style=\"color: #000000;\">tolerance</span>\n         <span style=\"color: #008080;\">and</span> <span style=\"color: #000000;\">ymax</span><span style=\"color: #0000FF;\">-</span><span style=\"color: #000000;\">ymin</span> <span style=\"color: #0000FF;\"><=</span> <span style=\"color: #000000;\">tolerance</span> <span style=\"color: #008080;\">then</span>\n             <span style=\"color: #000080;font-style:italic;\">-- we found a suitable intersection!</span>\n             <span style=\"color: #008080;\">return</span> <span style=\"color: #0000FF;\">{(</span><span style=\"color: #000000;\">xmin</span><span style=\"color: #0000FF;\">+</span><span style=\"color: #000000;\">xmax</span><span style=\"color: #0000FF;\">)/</span><span style=\"color: #000000;\">2</span><span style=\"color: #0000FF;\">,(</span><span style=\"color: #000000;\">ymin</span><span style=\"color: #0000FF;\">+</span><span style=\"color: #000000;\">ymax</span><span style=\"color: #0000FF;\">)/</span><span style=\"color: #000000;\">2</span><span style=\"color: #0000FF;\">}</span>\n         <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">if</span>\n         <span style=\"color: #008080;\">return</span> <span style=\"color: #004600;\">true</span> <span style=\"color: #000080;font-style:italic;\">-- accept/further subdivide</span>\n     <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">if</span>\n     <span style=\"color: #008080;\">return</span> <span style=\"color: #004600;\">false</span> <span style=\"color: #000080;font-style:italic;\">-- exclude</span>\n <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">function</span>\n\n <span style=\"color: #008080;\">function</span> <span style=\"color: #000000;\">seems_to_be_a_duplicate</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #004080;\">sequence</span> <span style=\"color: #000000;\">intersections</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #000000;\">xy</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #004080;\">atom</span> <span style=\"color: #000000;\">spacing</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #008080;\">for</span> <span style=\"color: #000000;\">pt</span> <span style=\"color: #008080;\">in</span> <span style=\"color: #000000;\">intersections</span> <span style=\"color: #008080;\">do</span>\n         <span style=\"color: #008080;\">if</span> <span style=\"color: #7060A8;\">abs</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">pt</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">X</span><span style=\"color: #0000FF;\">]-</span><span style=\"color: #000000;\">xy</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">X</span><span style=\"color: #0000FF;\">])<</span><span style=\"color: #000000;\">spacing</span>\n         <span style=\"color: #008080;\">and</span> <span style=\"color: #7060A8;\">abs</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">pt</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">Y</span><span style=\"color: #0000FF;\">]-</span><span style=\"color: #000000;\">xy</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">Y</span><span style=\"color: #0000FF;\">])<</span><span style=\"color: #000000;\">spacing</span> <span style=\"color: #008080;\">then</span>\n             <span style=\"color: #008080;\">return</span> <span style=\"color: #004600;\">true</span>\n         <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">if</span>\n     <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">for</span>\n     <span style=\"color: #008080;\">return</span> <span style=\"color: #004600;\">false</span>\n <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">function</span>\n\n <span style=\"color: #008080;\">function</span> <span style=\"color: #000000;\">find_intersections</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">quadratic_curve</span> <span style=\"color: #000000;\">p</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #000000;\">q</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #004080;\">atom</span> <span style=\"color: #000000;\">tolerance</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #004080;\">sequence</span> <span style=\"color: #000000;\">insects</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #0000FF;\">{},</span> <span style=\"color: #000000;\">todo</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #0000FF;\">{{</span><span style=\"color: #000000;\">p</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">q</span><span style=\"color: #0000FF;\">}}</span>\n     <span style=\"color: #008080;\">while</span> <span style=\"color: #7060A8;\">length</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">todo</span><span style=\"color: #0000FF;\">)</span> <span style=\"color: #008080;\">do</span>\n         <span style=\"color: #0000FF;\">{{</span><span style=\"color: #000000;\">p</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">q</span><span style=\"color: #0000FF;\">},</span><span style=\"color: #000000;\">todo</span><span style=\"color: #0000FF;\">}</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #0000FF;\">{</span><span style=\"color: #000000;\">todo</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">],</span><span style=\"color: #000000;\">todo</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">2</span><span style=\"color: #0000FF;\">..$]}</span>\n         <span style=\"color: #004080;\">object</span> <span style=\"color: #000000;\">insect</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #000000;\">test_intersection</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">p</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #000000;\">q</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #000000;\">tolerance</span><span style=\"color: #0000FF;\">)</span>\n         <span style=\"color: #008080;\">if</span> <span style=\"color: #004080;\">sequence</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">insect</span><span style=\"color: #0000FF;\">)</span> <span style=\"color: #008080;\">then</span>\n             <span style=\"color: #008080;\">if</span> <span style=\"color: #008080;\">not</span> <span style=\"color: #000000;\">seems_to_be_a_duplicate</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">insects</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">insect</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">tolerance</span><span style=\"color: #0000FF;\">*</span><span style=\"color: #000000;\">10</span><span style=\"color: #0000FF;\">)</span> <span style=\"color: #008080;\">then</span>\n                 <span style=\"color: #000000;\">insects</span> <span style=\"color: #0000FF;\">&=</span> <span style=\"color: #0000FF;\">{</span><span style=\"color: #000000;\">insect</span><span style=\"color: #0000FF;\">}</span>\n             <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">if</span>\n         <span style=\"color: #008080;\">elsif</span> <span style=\"color: #000000;\">insect</span> <span style=\"color: #008080;\">then</span>\n             <span style=\"color: #004080;\">sequence</span> <span style=\"color: #0000FF;\">{</span><span style=\"color: #000000;\">p1</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">p2</span><span style=\"color: #0000FF;\">}</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #000000;\">subdivide_quadratic_curve</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">p</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">0.5</span><span style=\"color: #0000FF;\">),</span>\n                      <span style=\"color: #0000FF;\">{</span><span style=\"color: #000000;\">q1</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">q2</span><span style=\"color: #0000FF;\">}</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #000000;\">subdivide_quadratic_curve</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">q</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">0.5</span><span style=\"color: #0000FF;\">)</span>\n             <span style=\"color: #000000;\">todo</span> <span style=\"color: #0000FF;\">&=</span> <span style=\"color: #0000FF;\">{{</span><span style=\"color: #000000;\">p1</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">q1</span><span style=\"color: #0000FF;\">},{</span><span style=\"color: #000000;\">p1</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">q2</span><span style=\"color: #0000FF;\">},{</span><span style=\"color: #000000;\">p2</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">q1</span><span style=\"color: #0000FF;\">},{</span><span style=\"color: #000000;\">p2</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">q2</span><span style=\"color: #0000FF;\">}}</span>\n         <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">if</span>\n     <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">while</span>\n     <span style=\"color: #000000;\">insects</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">sort_columns</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">insects</span><span style=\"color: #0000FF;\">,{-</span><span style=\"color: #000000;\">Y</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">X</span><span style=\"color: #0000FF;\">})</span>\n     <span style=\"color: #008080;\">return</span> <span style=\"color: #000000;\">insects</span>\n <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">function</span>\n\n <span style=\"color: #000000;\">quadratic_curve</span> <span style=\"color: #000000;\">p</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #0000FF;\">{{-</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">0</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">},{</span><span style=\"color: #000000;\">0</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">10</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">0</span><span style=\"color: #0000FF;\">}},</span>\n                 <span style=\"color: #000000;\">q</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #0000FF;\">{{</span><span style=\"color: #000000;\">2</span><span style=\"color: #0000FF;\">,-</span><span style=\"color: #000000;\">8</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">2</span><span style=\"color: #0000FF;\">},{</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">2</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">3</span><span style=\"color: #0000FF;\">}}</span>\n <span style=\"color: #004080;\">sequence</span> <span style=\"color: #000000;\">intersections</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #000000;\">find_intersections</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">p</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #000000;\">q</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #000000;\">0.000001</span><span style=\"color: #0000FF;\">)</span>\n <span style=\"color: #7060A8;\">printf</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #008000;\">\"Intersections from top to bottom:\\n\"</span><span style=\"color: #0000FF;\">)</span>\n <span style=\"color: #7060A8;\">pp</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">intersections</span><span style=\"color: #0000FF;\">,{</span><span style=\"color: #004600;\">pp_Nest</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #004600;\">pp_FltFmt</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #008000;\">\"%9.6f\"</span><span style=\"color: #0000FF;\">})</span>\n<!--\n"
                }
            ],
            [
                {
                    "language": "Modula-2",
                    "solution": "(* This program does not do any subdivision, but instead takes\n   advantage of monotonicity.\n\n   It is possible for points accidentally to be counted twice, for\n   instance if they lie right on an interval boundary. We will avoid\n   that by the crude (but likely satisfactory) mechanism of requiring\n   a minimum max norm between intersections. *)\n\nMODULE bezierIntersectionsInModula2;\n\n(* ISO Modula-2 libraries. *)\nFROM Storage IMPORT ALLOCATE, DEALLOCATE;\nFROM SYSTEM IMPORT TSIZE;\nIMPORT SLongIO;\nIMPORT STextIO;\n\n(* GNU Modula-2 gm2-libs *)\nFROM Assertion IMPORT Assert;\n\n(* Schumaker's and Volk's algorithm for evaluating a B\u00c3\u00a9zier spline in\n   Bernstein basis. This is faster than de Casteljau, though not quite\n   as numerical stable. *)\nPROCEDURE SchumakerVolk (c0, c1, c2, t : LONGREAL) : LONGREAL;\n  VAR s, u, v : LONGREAL;\nBEGIN\n  s := 1.0 - t;\n  IF t <= 0.5 THEN\n    (* Horner form in the variable u = t/s, taking into account the\n       binomial coefficients = 1,2,1. *)\n    u := t / s;\n    v := c0 + (u * (c1 + c1 + (u * c2)));\n    (* Multiply by s raised to the degree of the spline. *)\n    v := v * s * s;\n  ELSE\n    (* Horner form in the variable u = s/t, taking into account the\n       binomial coefficients = 1,2,1. *)\n    u := s / t;\n    v := c2 + (u * (c1 + c1 + (u * c0)));\n    (* Multiply by t raised to the degree of the spline. *)\n    v := v * t * t;\n  END;\n  RETURN v;\nEND SchumakerVolk;\n\nPROCEDURE FindExtremePoint (c0, c1, c2 : LONGREAL;\n                            VAR LiesInside01 : BOOLEAN;\n                            VAR ExtremePoint : LONGREAL);\n  VAR numer, denom : LONGREAL;\nBEGIN\n  (* If the spline has c0=c2 but not c0=c1=c2, then treat it as having\n     an extreme point at 0.5. *)\n  IF (c0 = c2) AND (c0 <> c1) THEN\n    LiesInside01 := TRUE;\n    ExtremePoint := 0.5\n  ELSE\n    (* Find the root of the derivative of the spline. *)\n    LiesInside01 := FALSE;\n    numer := c0 - c1;\n    denom := c2 - c1 - c1 + c0;\n    IF (denom <> 0.0) AND (numer * denom >= 0.0)\n       AND (numer <= denom) THEN\n      LiesInside01 := TRUE;\n      ExtremePoint := numer / denom\n    END\n  END\nEND FindExtremePoint;\n\nTYPE StartIntervCount = [2 .. 4];\n     StartIntervArray = ARRAY [1 .. 4] OF LONGREAL;\n\nPROCEDURE PossiblyInsertExtremePoint\n            (c0, c1, c2 : LONGREAL;\n             VAR numStartInterv : StartIntervCount;\n             VAR startInterv : StartIntervArray);\n  VAR liesInside01 : BOOLEAN;\n      extremePt : LONGREAL;\nBEGIN\n  FindExtremePoint (c0, c1, c2, liesInside01, extremePt);\n  IF liesInside01 AND (0.0 < extremePt) AND (extremePt < 1.0) THEN\n    IF numStartInterv = 2 THEN\n      startInterv[3] := 1.0;\n      startInterv[2] := extremePt;\n      numStartInterv := 3\n    ELSIF extremePt < startInterv[2] THEN\n      startInterv[4] := 1.0;\n      startInterv[3] := startInterv[2];\n      startInterv[2] := extremePt;\n      numStartInterv := 4\n    ELSIF extremePt > startInterv[2] THEN\n      startInterv[4] := 1.0;\n      startInterv[3] := extremePt;\n      numStartInterv := 4\n    END\n  END\nEND PossiblyInsertExtremePoint;\n\nPROCEDURE minimum2 (x, y : LONGREAL) : LONGREAL;\n  VAR w : LONGREAL;\nBEGIN\n  IF x <= y THEN\n    w := x\n  ELSE\n    w := y\n  END;\n  RETURN w;\nEND minimum2;\n\nPROCEDURE maximum2 (x, y : LONGREAL) : LONGREAL;\n  VAR w : LONGREAL;\nBEGIN\n  IF x >= y THEN\n    w := x\n  ELSE\n    w := y\n  END;\n  RETURN w;\nEND maximum2;\n\nPROCEDURE RectanglesOverlap (xa0, ya0, xa1, ya1 : LONGREAL;\n                             xb0, yb0, xb1, yb1 : LONGREAL) : BOOLEAN;\nBEGIN\n  (* It is assumed that xa0<=xa1, ya0<=ya1, xb0<=xb1, and yb0<=yb1. *)\n  RETURN ((xb0 <= xa1) AND (xa0 <= xb1)\n          AND (yb0 <= ya1) AND (ya0 <= yb1))\nEND RectanglesOverlap;\n\nPROCEDURE TestIntersection (xp0, xp1 : LONGREAL;\n                            yp0, yp1 : LONGREAL;\n                            xq0, xq1 : LONGREAL;\n                            yq0, yq1 : LONGREAL;\n                            tol : LONGREAL;\n                            VAR exclude, accept : BOOLEAN;\n                            VAR x, y : LONGREAL);\n  VAR xpmin, ypmin, xpmax, ypmax : LONGREAL;\n      xqmin, yqmin, xqmax, yqmax : LONGREAL;\n      xmin, xmax, ymin, ymax : LONGREAL;\nBEGIN\n  xpmin := minimum2 (xp0, xp1);\n  ypmin := minimum2 (yp0, yp1);\n  xpmax := maximum2 (xp0, xp1);\n  ypmax := maximum2 (yp0, yp1);\n\n  xqmin := minimum2 (xq0, xq1);\n  yqmin := minimum2 (yq0, yq1);\n  xqmax := maximum2 (xq0, xq1);\n  yqmax := maximum2 (yq0, yq1);\n\n  exclude := TRUE;\n  accept := FALSE;\n  IF RectanglesOverlap (xpmin, ypmin, xpmax, ypmax,\n                        xqmin, yqmin, xqmax, yqmax) THEN\n    exclude := FALSE;\n    xmin := maximum2 (xpmin, xqmin);\n    xmax := minimum2 (xpmax, xqmax);\n    Assert (xmax >= xmin);\n    IF xmax - xmin <= tol THEN\n      ymin := maximum2 (ypmin, yqmin);\n      ymax := minimum2 (ypmax, yqmax);\n      Assert (ymax >= ymin);\n      IF ymax - ymin <= tol THEN\n        accept := TRUE;\n        x := (0.5 * xmin) + (0.5 * xmax);\n        y := (0.5 * ymin) + (0.5 * ymax);\n      END;\n    END;\n  END;\nEND TestIntersection;\n\nTYPE WorkPile = POINTER TO WorkTask;\n     WorkTask =\n     RECORD\n       tp0, tp1 : LONGREAL;\n       tq0, tq1 : LONGREAL;\n       next : WorkPile\n     END;\n\nPROCEDURE WorkIsDone (workload : WorkPile) : BOOLEAN;\nBEGIN\n  RETURN workload = NIL\nEND WorkIsDone;\n\nPROCEDURE DeferWork (VAR workload : WorkPile;\n                     tp0, tp1 : LONGREAL;\n                     tq0, tq1 : LONGREAL);\n  VAR work : WorkPile;\nBEGIN\n  ALLOCATE (work, TSIZE (WorkTask));\n  work^.tp0 := tp0;\n  work^.tp1 := tp1;\n  work^.tq0 := tq0;\n  work^.tq1 := tq1;\n  work^.next := workload;\n  workload := work\nEND DeferWork;\n\nPROCEDURE DoSomeWork (VAR workload : WorkPile;\n                      VAR tp0, tp1 : LONGREAL;\n                      VAR tq0, tq1 : LONGREAL);\n  VAR work : WorkPile;\nBEGIN\n  Assert (NOT WorkIsDone (workload));\n  work := workload;\n  tp0 := work^.tp0;\n  tp1 := work^.tp1;\n  tq0 := work^.tq0;\n  tq1 := work^.tq1;\n  workload := work^.next;\n  DEALLOCATE (work, TSIZE (WorkTask));\nEND DoSomeWork;\n\nCONST px0 = -1.0;  px1 =  0.0;  px2 =  1.0;\n      py0 =  0.0;  py1 = 10.0;  py2 =  0.0;\n      qx0 =  2.0;  qx1 = -8.0;  qx2 =  2.0;\n      qy0 =  1.0;  qy1 =  2.0;  qy2 =  3.0;\n      tol = 0.0000001;\n      spacing = 100.0 * tol;\n\nTYPE IntersectionCount = [0 .. 4];\n     IntersectionRange = [1 .. 4];\n\nVAR pxHasExtremePt, pyHasExtremePt : BOOLEAN;\n    qxHasExtremePt, qyHasExtremePt : BOOLEAN;\n    pxExtremePt, pyExtremePt : LONGREAL;\n    qxExtremePt, qyExtremePt : LONGREAL;\n    pNumStartInterv, qNumStartInterv : StartIntervCount;\n    pStartInterv, qStartInterv : StartIntervArray;\n    workload : WorkPile;\n    i, j : StartIntervCount;\n    numIntersections, k : IntersectionCount;\n    intersectionsX : ARRAY IntersectionRange OF LONGREAL;\n    intersectionsY : ARRAY IntersectionRange OF LONGREAL;\n    tp0, tp1, tq0, tq1 : LONGREAL;\n    xp0, xp1, xq0, xq1 : LONGREAL;\n    yp0, yp1, yq0, yq1 : LONGREAL;\n    exclude, accept : BOOLEAN;\n    x, y : LONGREAL;\n    tpMiddle, tqMiddle : LONGREAL;\n\nPROCEDURE MaybeAddIntersection (x, y : LONGREAL;\n                                spacing : LONGREAL);\n  VAR i : IntersectionRange;\n  VAR TooClose : BOOLEAN;\nBEGIN\n  IF numIntersections = 0 THEN\n    intersectionsX[1] := x;\n    intersectionsY[1] := y;\n    numIntersections := 1;\n  ELSE\n    TooClose := FALSE;\n    FOR i := 1 TO numIntersections DO\n        IF (ABS (x - intersectionsX[i]) < spacing)\n           AND (ABS (y - intersectionsY[i]) < spacing) THEN\n          TooClose := TRUE\n        END\n    END;\n    IF NOT TooClose THEN\n      numIntersections := numIntersections + 1;\n      intersectionsX[numIntersections] := x;\n      intersectionsY[numIntersections] := y\n    END\n  END\nEND MaybeAddIntersection;\n\nBEGIN\n  (* Find monotonic sections of the curves, and use those as the\n     starting jobs. *)\n  pNumStartInterv := 2;\n  pStartInterv[1] := 0.0;  pStartInterv[2] := 1.0;\n  PossiblyInsertExtremePoint (px0, px1, px2,\n                              pNumStartInterv, pStartInterv);\n  PossiblyInsertExtremePoint (py0, py1, py2,\n                              pNumStartInterv, pStartInterv);\n  qNumStartInterv := 2;\n  qStartInterv[1] := 0.0;  qStartInterv[2] := 1.0;\n  PossiblyInsertExtremePoint (qx0, qx1, qx2,\n                              qNumStartInterv, qStartInterv);\n  PossiblyInsertExtremePoint (qy0, qy1, qy2,\n                              qNumStartInterv, qStartInterv);\n  workload := NIL;\n  FOR i := 2 TO pNumStartInterv DO\n    FOR j := 2 TO qNumStartInterv DO\n      DeferWork (workload, pStartInterv[i - 1], pStartInterv[i],\n                 qStartInterv[j - 1], qStartInterv[j])\n    END;\n  END;\n\n  (* Go through the workload, deferring work as necessary. *)\n  numIntersections := 0;\n  WHILE NOT WorkIsDone (workload) DO\n    (* The following code recomputes values of the splines\n       sometimes. You may wish to store such values in the work pile,\n       to avoid recomputing them. *)\n    DoSomeWork (workload, tp0, tp1, tq0, tq1);\n    xp0 := SchumakerVolk (px0, px1, px2, tp0);\n    yp0 := SchumakerVolk (py0, py1, py2, tp0);\n    xp1 := SchumakerVolk (px0, px1, px2, tp1);\n    yp1 := SchumakerVolk (py0, py1, py2, tp1);\n    xq0 := SchumakerVolk (qx0, qx1, qx2, tq0);\n    yq0 := SchumakerVolk (qy0, qy1, qy2, tq0);\n    xq1 := SchumakerVolk (qx0, qx1, qx2, tq1);\n    yq1 := SchumakerVolk (qy0, qy1, qy2, tq1);\n    TestIntersection (xp0, xp1, yp0, yp1,\n                      xq0, xq1, yq0, yq1, tol,\n                      exclude, accept, x, y);\n    IF accept THEN\n      MaybeAddIntersection (x, y, spacing)\n    ELSIF NOT exclude THEN\n      tpMiddle := (0.5 * tp0) + (0.5 * tp1);\n      tqMiddle := (0.5 * tq0) + (0.5 * tq1);\n      DeferWork (workload, tp0, tpMiddle, tq0, tqMiddle);\n      DeferWork (workload, tp0, tpMiddle, tqMiddle, tq1);\n      DeferWork (workload, tpMiddle, tp1, tq0, tqMiddle);\n      DeferWork (workload, tpMiddle, tp1, tqMiddle, tq1);\n    END\n  END;\n\n  IF numIntersections = 0 THEN\n    STextIO.WriteString (\"no intersections\");\n    STextIO.WriteLn;\n  ELSE\n    FOR k := 1 TO numIntersections DO\n      STextIO.WriteString (\"(\");\n      SLongIO.WriteReal (intersectionsX[k], 10);\n      STextIO.WriteString (\", \");\n      SLongIO.WriteReal (intersectionsY[k], 10);\n      STextIO.WriteString (\")\");\n      STextIO.WriteLn;\n    END\n  END\nEND bezierIntersectionsInModula2.\n"
                },
                {
                    "language": "Java",
                    "solution": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Stack;\n\npublic final class BezierCurveIntersection {\n\n\tpublic static void main(String[] aArgs) {\n\t\tQuadCurve vertical = new QuadCurve( new QuadSpline(-1.0, 0.0, 1.0), new QuadSpline(0.0, 10.0, 0.0) );\n\t\t// QuadCurve vertical represents the Bezier curve having control points (-1, 0), (0, 10) and (1, 0)\n\t\tQuadCurve horizontal = new QuadCurve( new QuadSpline(2.0, -8.0, 2.0), new QuadSpline(1.0, 2.0, 3.0) );\n\t\t// QuadCurve horizontal represents the Bezier curve having control points (2, 1), (-8, 2) and (2, 3) \t\t\n\n\t\tSystem.out.println(\"The points of intersection are:\");\n\t\tList<Point> intersects = findIntersects(vertical, horizontal);\n\t\tfor ( Point intersect : intersects ) {\n\t\t\tSystem.out.println(String.format(\"%s%9.6f%s%9.6f%s\", \"( \", intersect.aX, \", \", intersect.aY, \" )\"));\n\t\t}\n\t}\n\t\n\tprivate static List<Point> findIntersects(QuadCurve aP, QuadCurve aQ) {\n\t\tList<Point> result = new ArrayList<Point>();\n\t\tStack<QuadCurve> stack = new Stack<QuadCurve>();\n\t\tstack.push(aP);\n\t\tstack.push(aQ);\n\t\t\n\t\twhile ( ! stack.isEmpty() ) {\n\t\t\tQuadCurve pp = stack.pop();\n\t\t    QuadCurve qq = stack.pop();\n\t\t    List<Object> objects = testIntersection(pp, qq);\n\t\t    final boolean accepted = (boolean) objects.get(0);\n\t\t    final boolean excluded = (boolean) objects.get(1);\n\t\t    Point intersect = (Point) objects.get(2);\n\t\t\n\t\t    if ( accepted ) {\n\t\t    \tif ( ! seemsToBeDuplicate(result, intersect) ) {\n\t\t    \t\tresult.add(intersect);\n\t\t    \t}\n\t\t    } else if ( ! excluded ) {\n\t\t    \tQuadCurve p0 = new QuadCurve();\n\t\t    \tQuadCurve q0 = new QuadCurve();\n\t\t    \tQuadCurve p1 = new QuadCurve();\n\t\t    \tQuadCurve q1 = new QuadCurve();\n\t\t    \tsubdivideQuadCurve(pp, 0.5, p0, p1);\n\t\t    \tsubdivideQuadCurve(qq, 0.5, q0, q1);\n\t\t    \tstack.addAll(List.of( p0, q0, p0, q1, p1, q0, p1, q1 ));\n\t\t    }\n\t\t}\n\t\treturn result;\n\t}\n\t\n\tprivate static boolean seemsToBeDuplicate(List<Point> aIntersects, Point aPoint) {\n\t\tfor ( Point intersect : aIntersects ) {\n\t\t\tif ( Math.abs(intersect.aX - aPoint.aX) < SPACING && Math.abs(intersect.aY - aPoint.aY) < SPACING ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tprivate static List<Object> testIntersection(QuadCurve aP, QuadCurve aQ) {\n\t    final double pxMin = Math.min(Math.min(aP.x.c0, aP.x.c1), aP.x.c2);\n\t    final double pyMin = Math.min(Math.min(aP.y.c0, aP.y.c1), aP.y.c2);\n\t    final double pxMax = Math.max(Math.max(aP.x.c0, aP.x.c1), aP.x.c2);\n\t    final double pyMax = Math.max(Math.max(aP.y.c0, aP.y.c1), aP.y.c2);\n\n\t    final double qxMin = Math.min(Math.min(aQ.x.c0, aQ.x.c1), aQ.x.c2);\n\t    final double qyMin = Math.min(Math.min(aQ.y.c0, aQ.y.c1), aQ.y.c2);\n\t    final double qxMax = Math.max(Math.max(aQ.x.c0, aQ.x.c1), aQ.x.c2);\n\t    final double qyMax = Math.max(Math.max(aQ.y.c0, aQ.y.c1), aQ.y.c2);\n\t\n\t    boolean accepted = false;\n\t    boolean excluded = true;\n\t    Point intersect = new Point(0.0, 0.0);\n\t\n\t    if ( rectanglesOverlap(pxMin, pyMin, pxMax, pyMax, qxMin, qyMin, qxMax, qyMax) ) {\n\t\t    excluded = false;\n\t\t    final double xMin = Math.max(pxMin, qxMin);\n\t\t    final double xMax = Math.min(pxMax, pxMax);\n\t\t    if ( xMax - xMin <= TOLERANCE ) {\n\t\t    \tfinal double yMin = Math.max(pyMin, qyMin);\n\t\t    \tfinal double yMax = Math.min(pyMax, qyMax);\n\t\t    \tif ( yMax - yMin <= TOLERANCE ) {\n\t\t    \t\taccepted = true;\n\t\t    \t\tintersect = new Point(0.5 * ( xMin + xMax), 0.5 * ( yMin +  yMax));\n\t\t    \t}\n\t\t    }\n\t    }\n\t    return List.of( accepted, excluded, intersect );\n\t}\n\t\n\tprivate static boolean rectanglesOverlap(double aXa0, double aYa0, double aXa1, double aYa1,\n\t\t\t\t\t\t\t\t\t\t     double aXb0, double aYb0, double aXb1, double aYb1) {\n\t\treturn aXb0 <= aXa1 && aXa0 <= aXb1 && aYb0 <= aYa1 && aYa0 <= aYb1;\n\t}\n\t\n\tprivate static void subdivideQuadCurve(QuadCurve aQ, double aT, QuadCurve aU, QuadCurve aV) {\n\t\tsubdivideQuadSpline(aQ.x, aT, aU.x, aV.x);\n\t\tsubdivideQuadSpline(aQ.y, aT, aU.y, aV.y);\n\t}\n\t\n\t// de Casteljau's algorithm\n\tprivate static void subdivideQuadSpline(QuadSpline aQ, double aT, QuadSpline aU, QuadSpline aV) {\n\t\tfinal double s = 1.0 - aT;\n\t\taU.c0 = aQ.c0;\n\t\taV.c2 = aQ.c2;\n\t\taU.c1 = s * aQ.c0 + aT * aQ.c1;\n\t\taV.c1 = s * aQ.c1 + aT * aQ.c2;\n\t\taU.c2 = s * aU.c1 + aT * aV.c1;\n\t\taV.c0 = aU.c2;\n\t}\n\t\n\tprivate static record Point(double aX, double aY) {}\n\t\n\tprivate static class QuadSpline {\n\t\t\n\t\tpublic QuadSpline(double aC0, double aC1, double aC2) {\n\t\t\tc0 = aC0; c1 = aC1; c2 = aC2;\n\t\t}\n\t\t\n\t\tpublic QuadSpline() {\n\t\t\tthis(0.0, 0.0, 0.0);\n\t\t}\n\t\t\n\t\tprivate double c0, c1, c2;\t\n\t\t\n\t}\t\n\t\n\tprivate static class QuadCurve {\n\t\t\n\t\tpublic QuadCurve(QuadSpline aX, QuadSpline aY) {\n\t\t\tx = aX; y = aY;\n\t\t}\n\t\t\n\t\tpublic QuadCurve() {\n\t\t\tthis( new QuadSpline(), new QuadSpline() );\n\t\t}\n\t\t\n\t\tprivate QuadSpline x, y;\n\t\t\n\t}\n\t\n\tprivate static final double TOLERANCE = 0.000_000_1;\n\tprivate static final double SPACING = 10 * TOLERANCE;\n\n}\n"
                }
            ]
        ]
    },
    {
        "task_name": "Babbage-problem",
        "task_description": "[[wp:Charles_Babbage|Charles Babbage]], looking ahead to the sorts of problems his Analytical Engine would be able to solve, gave this example:\n{{quote\n | What is the smallest positive integer whose square ends in the digits 269,696?\n | Babbage, letter to Lord Bowden, 1837; see Hollingdale and Tootill, <i>Electronic Computers</i>, second edition, 1970, p. 125.\n}}\nHe thought the answer might be 99,736, whose square is 9,947,269,696; but he couldn't be certain.\n\n\n;Task\n\nThe task is to find out if Babbage had the right answer \u00e2\u20ac\u201d and to do so, as far as your language allows it, in code that Babbage himself would have been able to read and understand. \nAs Babbage evidently solved the task with pencil and paper, a similar efficient solution is preferred.\n\nFor these purposes, Charles Babbage may be taken to be an intelligent person, familiar with mathematics and with the idea of a computer; he has written the first drafts of simple computer programmes in tabular form. [[https://collection.sciencemuseum.org.uk/documents/aa110000020 Babbage Archive Series L]].\n\n\n;Motivation\n\nThe aim of the task is to write a program that is sufficiently clear and well-documented for such a person to be able to read it and be confident that it does indeed solve the specified problem.\n<br><br>\n\n",
        "solution_pairs": [
            [
                {
                    "language": "Maxima",
                    "solution": "/* Function that returns a list of digits given a nonnegative integer */\ndecompose(num) := block([digits, remainder],\n  digits: [],\n  while num > 0 do\n   (remainder: mod(num, 10),\n    digits: cons(remainder, digits),\n    num: floor(num/10)),\n  digits\n)$\n\n/* Test case */\nblock(babbage_param:269696,i:isqrt(babbage_param)+1,cache_babbage:decompose(babbage_param),\n    while rest(decompose(i^2),(length(decompose(i^2))-6))#cache_babbage do i:i+2,\n    i);\n"
                },
                {
                    "language": "Simula",
                    "solution": "BEGIN\n    INTEGER PROBE, SQUARE;\n    BOOLEAN DONE;\n\n    WHILE NOT DONE DO BEGIN\n        PROBE := PROBE + 1;\n        SQUARE := PROBE * PROBE;\n        IF MOD(SQUARE, 1000000) = 269696 THEN BEGIN\n\n            OUTTEXT(\"THE SMALLEST NUMBER: \");\n            OUTINT(PROBE,0);\n            OUTIMAGE;\n\n            OUTTEXT(\"THE SQUARE : \");\n            OUTINT(SQUARE,0);\n            OUTIMAGE;\n\n            DONE := TRUE;\n        END;\n    END;\n\nEND\n"
                }
            ],
            [
                {
                    "language": "Erlang",
                    "solution": "-module(solution1).\n-export([main/0]).\nbabbage(N,E) when N*N rem 1000000 == 269696 ->\n\tio:fwrite(\"~p\",[N]);\nbabbage(N,E) ->\n\tcase E of\n\t4 -> babbage(N+2,6);\n\t6 -> babbage(N+8,4)\nend.\nmain()->\n\tbabbage(4,4).\n"
                },
                {
                    "language": "UTFool",
                    "solution": "\u00b7\u00b7\u00b7\nhttp://rosettacode.org/wiki/Babbage_problem\n\u00b7\u00b7\u00b7\n\u25a0 BabbageProblem\n  \u00a7 static\n    \u25b6 main\n    \u2022 args\u2982 String[]\n      for each number from \u221a269696 up to \u221aInteger.MAX_VALUE\n          if (\"\u2e28number \u00d7 number\u2e29\").endsWith \"269696\"\n             System.exit number\n"
                }
            ],
            [
                {
                    "language": "QBasic",
                    "solution": "number = 524\nDO\n    NUMBER = number + 2\nLOOP UNTIL ((number ^ 2) MOD 1000000) = 269696\nPRINT \"The smallest number whose square ends in 269696 is: \"; number\nPRINT \"It's square is \"; number ^ 2\nEND\n"
                },
                {
                    "language": "EasyLang",
                    "solution": "while n * n mod 1000000 <> 269696\n  n += 1\n.\nprint n\n"
                }
            ],
            [
                {
                    "language": "M2000-Interpreter",
                    "solution": "Def Long  k=1000000, T=269696, n\nn=Sqrt(269696)\nFor n=n to k {\n      If n^2 mod k = T Then Exit\n}\nReport format$(\"The smallest number whose square ends in {0} is {1}, Its square is {2}\", T, n, n**2)\n"
                },
                {
                    "language": "C",
                    "solution": "// This code is the implementation of Babbage Problem\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\nint main() {\n\tint current = 0, \t//the current number\n\t    square;\t\t//the square of the current number\n\n\t//the strategy of take the rest of division by 1e06 is\n\t//to take the a number how 6 last digits are 269696\n\twhile (((square=current*current) % 1000000 != 269696) && (square<INT_MAX)) {\n\t\tcurrent++;\n\t}\n\n        //output\n\tif (square>+INT_MAX)\n\t    printf(\"Condition not satisfied before INT_MAX reached.\");\n\telse\t\t\n\t    printf (\"The smallest number whose square ends in 269696 is %d\\n\", current);\n\t\n        //the end\n\treturn 0 ;\n}\n"
                }
            ],
            [
                {
                    "language": "True-BASIC",
                    "solution": "LET number = 2\nDO\n   LET number = number + 2\nLOOP UNTIL REMAINDER((number ^ 2), 1000000) = 269696\nPRINT \"The smallest number whose square ends in 269696 is: \"; number\nPRINT \"It's square is \"; number ^ 2\nEND\n"
                },
                {
                    "language": "V-(Vlang)",
                    "solution": "const (\n    target  = 269696\n    modulus = 1000000\n)\nfn main() {\n\tfor n := 1; ; n++ { // Repeat with n=1, n=2, n=3, ...\n\t\tsquare := n * n\n\t\tending := square % modulus\n\t\tif ending == target {\n\t\t\tprintln(\"The smallest number whose square ends with $target is $n\")\n\t\t\treturn\n\t\t}\n\t}\n}\n"
                }
            ]
        ]
    },
    {
        "task_name": "Babylonian-spiral",
        "task_description": "f\nThe '''Babylonian spiral''' is a sequence of points in the plane that are created so as to\ncontinuously minimally increase in vector length and minimally bend in vector direction,\nwhile always moving from point to point on strictly integral coordinates. Of the two criteria\nof length and angle, the length has priority.\n\n; Examples\n\nP(1) and P(2) are defined to be at (x = 0, y = 0) and (x = 0, y = 1). The first vector is\nfrom P(1) to P(2). It is vertical and of length 1. Note that the square of that length is 1.\n\nNext in sequence is the vector from P(2) to P(3). This should be the smallest distance to a\npoint with integral (x, y) which is longer than the last vector (that is, 1). It should also bend clockwise\nmore than zero radians, but otherwise to the least degree.\n\nThe point chosen for P(3) that fits criteria is (x = 1, y = 2). Note the length of the vector\nfrom P(2) to P(3) is \u00e2\u02c6\u01612, which squared is 2. The lengths of the vectors thus determined can be given by a sorted\nlist of possible sums of two integer squares, including 0 as a square.\n\n; Task\n\nFind and show the first 40 (x, y) coordinates of the Babylonian spiral.\n\n; Stretch task\n\nShow in your program how to calculate and plot the first 10000 points in the sequence. Your result\nshould look similar to the graph shown at the OEIS: [[File:From_oies_A@97346_A297347_plot2a.png]]\n\n; See also\n\n;* [[oeis:A256111|OEIS:A256111 - squared distance to the origin of the n-th vertex on a Babylonian Spiral.]]\n;* [[oeis:A297346|OEIS:A297346 - List of successive x-coordinates in the Babylonian Spiral.]]\n;* [[oeis:A297347|OEIS:A297347 - List of successive y-coordinates in the Babylonian Spiral.]]\n\n\n\n",
        "solution_pairs": [
            [
                {
                    "language": "Jq",
                    "solution": "Points(10000) | join(\" \")\n"
                },
                {
                    "language": "Python",
                    "solution": "from itertools import islice, count\nimport matplotlib.pyplot as plt\nimport heapq\n\ndef twosquares():\n    q, n = [], 1\n\n    while True:\n        while not q or n*n <= q[0][0]:\n            heapq.heappush(q, (n*n, n, 0))\n            n += 1\n\n        s, xy = q[0][0], []\n\n        while q and q[0][0] == s: # pop all vectors with same length\n            s, a, b = heapq.heappop(q)\n            xy.append((a, b))\n            if a > b:\n                heapq.heappush(q, (a*a + (b+1)*(b+1), a, b + 1))\n\n        yield tuple(xy)\n\ndef gen_dirs():\n    d = (0, 1)\n    for v in twosquares():\n        # include symmetric vectors\n        v += tuple((b, a) for a, b in v if a != b)\n        v += tuple((a, -b) for a, b in v if b)\n        v += tuple((-a, b) for a, b in v if a)\n\n        # filter using dot and cross product\n        d = max((a*d[0] + b*d[1], a, b) for a, b in v if a*d[1] - b*d[0] >= 0)[1:]\n        yield d\n\ndef positions():\n    p = (0, 0)\n    for d in gen_dirs():\n        yield p\n        p = (p[0] + d[0], p[1] + d[1])\n\nprint(list(islice(positions(), 40)))\n\nplt.plot(*zip(*list(islice(positions(), 100000))), lw=0.4)\nplt.gca().set_aspect(1)\nplt.show()\n"
                }
            ],
            [
                {
                    "language": "Raku",
                    "solution": "my @next = { :x(1), :y(1), :2hyp },;\n\nsub next-interval (Int $int) {\n     @next.append: (0..$int).map: { %( :x($int), :y($_), :hyp($int\u00b2 + .\u00b2) ) };\n     @next = |@next.sort: *.<hyp>;\n}\n\nmy @spiral = [\\\u00bb+\u00ab] lazy gather {\n    my $interval = 1;\n    take [0,0];\n    take my @tail = 0,1;\n    loop {\n        my \\\u0398 = atan2 |@tail[1,0];\n        my @this = @next.shift;\n        @this.push: @next.shift while @next and @next[0]<hyp> == @this[0]<hyp>;\n        my @candidates = @this.map: {\n            my (\\i, \\j) = .<x y>;\n            next-interval(++$interval) if $interval == i;\n            |((i,j),(-i,j),(i,-j),(-i,-j),(j,i),(-j,i),(j,-i),(-j,-i))\n        }\n        take @tail = |@candidates.min: { ( \u0398 - atan2 |.[1,0] ) % \u03c4 };\n    }\n}\n\n# The task\nsay \"The first $_ Babylonian spiral points are:\\n\",\n@spiral[^$_].map({ sprintf '(%3d,%4d)', |$_ }).batch(10).join: \"\\n\" given 40;\n\n# Stretch\nuse SVG;\n\n'babylonean-spiral-raku.svg'.IO.spurt: SVG.serialize(\n    svg => [\n        :width<100%>, :height<100%>,\n        :rect[:width<100%>, :height<100%>, :style<fill:white;>],\n        :polyline[ :points(flat @spiral[^10000]),\n          :style(\"stroke:red; stroke-width:6; fill:white;\"),\n          :transform(\"scale (.05, -.05) translate (1000,-10000)\")\n        ],\n    ],\n);\n"
                },
                {
                    "language": "Julia",
                    "solution": "using DataStructures\nusing Plots\n\nstruct SquareSums end\n\nfunction Base.iterate(ss::SquareSums, state = (1, PriorityQueue{Tuple{Int, Int, Int}, Int}()))\n    i, sums = state\n    while isempty(sums) || i^2 <= peek(sums)[2]\n        enqueue!(sums, (i^2, i, 0) => i^2)\n        i += 1\n    end\n    nextsum, xy = peek(sums)[2], Tuple{Int, Int}[]\n    while !isempty(sums) && peek(sums)[2] == nextsum # pop all vectors with same length\n        nextsum, a, b = dequeue!(sums)\n        push!(xy, (a, b))\n        if a > b\n            hsq = a^2 + (b + 1)^2\n            enqueue!(sums, (hsq, a, b + 1) => hsq)\n        end\n    end\n    return xy, (i, sums)\nend\n\nfunction babylonian_spiral(N)\n    dx, dy, points = 0, 1, [(0, 0)]\n    for xys in SquareSums()\n        for i in 1:length(xys)\n            a, b = xys[i]\n            a != b && push!(xys, (b, a))\n            a != 0 && push!(xys, (-a, b), (b, -a))\n            b != 0 && push!(xys, (a, -b), (-b, a))\n            a * b != 0 && push!(xys, (-a, -b), (-b, -a))\n        end\n        filter!(p -> p[1] * dy - p[2] * dx >= 0, xys)\n        _, idx = findmax(p -> p[1] * dx + p[2] * dy, xys)\n        dx, dy = xys[idx]\n        push!(points, (points[end][1] + dx, points[end][2] + dy))\n        length(points) >= N && break\n    end\n    return @view points[begin:N]\nend\n\nprintln(\"The first 40 Babylonian spiral points are:\")\nfor (i, p) in enumerate(babylonian_spiral(40))\n    print(rpad(p, 10), i % 10 == 0 ? \"\\n\" : \"\")\nend\n\nPlots.plot(babylonian_spiral(10_000))\n"
                }
            ],
            [
                {
                    "language": "Jq",
                    "solution": "\"The first 40 Babylonian spiral points are:\",\n ([Points(40)] | _nwise(10) | map(tostring) | join(\" \") )\n"
                },
                {
                    "language": "Raku",
                    "solution": "my @next = { :x(1), :y(1), :2hyp },;\n\nsub next-interval (Int $int) {\n     @next.append: (0..$int).map: { %( :x($int), :y($_), :hyp($int\u00b2 + .\u00b2) ) };\n     @next = |@next.sort: *.<hyp>;\n}\n\nmy @spiral = [\\\u00bb+\u00ab] lazy gather {\n    my $interval = 1;\n    take [0,0];\n    take my @tail = 0,1;\n    loop {\n        my \\\u0398 = atan2 |@tail[1,0];\n        my @this = @next.shift;\n        @this.push: @next.shift while @next and @next[0]<hyp> == @this[0]<hyp>;\n        my @candidates = @this.map: {\n            my (\\i, \\j) = .<x y>;\n            next-interval(++$interval) if $interval == i;\n            |((i,j),(-i,j),(i,-j),(-i,-j),(j,i),(-j,i),(j,-i),(-j,-i))\n        }\n        take @tail = |@candidates.min: { ( \u0398 - atan2 |.[1,0] ) % \u03c4 };\n    }\n}\n\n# The task\nsay \"The first $_ Babylonian spiral points are:\\n\",\n@spiral[^$_].map({ sprintf '(%3d,%4d)', |$_ }).batch(10).join: \"\\n\" given 40;\n\n# Stretch\nuse SVG;\n\n'babylonean-spiral-raku.svg'.IO.spurt: SVG.serialize(\n    svg => [\n        :width<100%>, :height<100%>,\n        :rect[:width<100%>, :height<100%>, :style<fill:white;>],\n        :polyline[ :points(flat @spiral[^10000]),\n          :style(\"stroke:red; stroke-width:6; fill:white;\"),\n          :transform(\"scale (.05, -.05) translate (1000,-10000)\")\n        ],\n    ],\n);\n"
                }
            ],
            [
                {
                    "language": "Python",
                    "solution": "\"\"\" Rosetta Code task rosettacode.org/wiki/Babylonian_spiral \"\"\"\n\nfrom itertools import accumulate\nfrom math import isqrt, atan2, tau\nfrom matplotlib.pyplot import axis, plot, show\n\n\nsquare_cache = []\n\ndef babylonian_spiral(nsteps):\n    \"\"\"\n    Get the points for each step along a Babylonia spiral of `nsteps` steps.\n    Origin is at (0, 0) with first step one unit in the positive direction along\n    the vertical (y) axis. The other points are selected to have integer x and y\n    coordinates, progressively concatenating the next longest vector with integer\n    x and y coordinates on the grid. The direction change of the  new vector is\n    chosen to be nonzero and clockwise in a direction that minimizes the change\n    in direction from the previous vector.\n\n    See also: oeis.org/A256111, oeis.org/A297346, oeis.org/A297347\n    \"\"\"\n    if len(square_cache) <= nsteps:\n        square_cache.extend([x * x for x in range(len(square_cache), nsteps)])\n    xydeltas = [(0, 0), (0, 1)]\n    \u03b4squared = 1\n    for _ in range(nsteps - 2):\n        x, y = xydeltas[-1]\n        \u03b8 = atan2(y, x)\n        candidates = []\n        while not candidates:\n            \u03b4squared += 1\n            for i, a in enumerate(square_cache):\n                if a > \u03b4squared // 2:\n                    break\n                for j in range(isqrt(\u03b4squared) + 1, 0, -1):\n                    b = square_cache[j]\n                    if a + b < \u03b4squared:\n                        break\n                    if a + b == \u03b4squared:\n                        candidates.extend([(i, j), (-i, j), (i, -j), (-i, -j), (j, i), (-j, i),\n                           (j, -i), (-j, -i)])\n\n        p = min(candidates, key=lambda d: (\u03b8 - atan2(d[1], d[0])) % tau)\n        xydeltas.append(p)\n\n    return list(accumulate(xydeltas, lambda a, b: (a[0] + b[0], a[1] + b[1])))\n\n\npoints10000 = babylonian_spiral(10000)\nprint(\"The first 40 Babylonian spiral points are:\")\nfor i, p in enumerate(points10000[:40]):\n     print(str(p).ljust(10), end = '\\n' if (i + 1) % 10 == 0 else '')\n\n# stretch portion of task\nplot(*zip(*points10000), color=\"navy\", linewidth=0.2)\naxis('scaled')\nshow()\n"
                },
                {
                    "language": "MATLAB",
                    "solution": "% Rosetta Code task rosettacode.org/wiki/Babylonian_spiral\n\nclear all;close all;clc;\n% Example usage\nfprintf(\"The first 40 Babylonian spiral points are:\\n\");\nspiral_points = babylonianspiral(40);\nfor i = 1:size(spiral_points, 1)\n    fprintf('(%d, %d) ', spiral_points(i, 1), spiral_points(i, 2));\n    if mod(i, 10) == 0\n        fprintf('\\n');\n    end\nend\n\n% For plotting the spiral (requires MATLAB plotting functions)\nspiral_points = babylonianspiral(10000);\nplot(spiral_points(:, 1), spiral_points(:, 2), 'LineWidth', 1);\n\n\nfunction points = babylonianspiral(nsteps)\n% Get the points for a Babylonian spiral of `nsteps` steps. Origin is at (0, 0)\n% with first step one unit in the positive direction along the vertical (y) axis.\n% See also: oeis.org/A256111, oeis.org/A297346, oeis.org/A297347\n\n    persistent squarecache;\n    if isempty(squarecache)\n        squarecache = [];\n    end\n\n    if length(squarecache) <= nsteps\n        squarecache = [squarecache, arrayfun(@(x) x^2, length(squarecache):nsteps)];\n    end\n\n    xydeltas = [0, 0; 0, 1];\n    deltaSq = 1;\n    for i = 1:nsteps-2\n        x = xydeltas(end, 1);\n        y = xydeltas(end, 2);\n        theta = atan2(y, x);\n        candidates = [];\n        while isempty(candidates)\n            deltaSq = deltaSq + 1;\n            for k = 1:length(squarecache)\n                a = squarecache(k);\n                if a > deltaSq / 2\n                    break;\n                end\n                for j = floor(sqrt(deltaSq)):-1:1\n                    b = squarecache(j+1);\n                    if a + b < deltaSq\n                        break;\n                    end\n                    if a + b == deltaSq\n                        i = k - 1;\n                        candidates = [candidates; i, j; -i, j; i, -j; -i, -j; ...\n                                                     j, i; -j, i; j, -i; -j, -i];\n                    end\n                end\n            end\n        end\n        [~, idx] = min(arrayfun(@(n) mod(theta - atan2(candidates(n, 2), candidates(n, 1)), 2*pi), 1:size(candidates, 1)));\n        xydeltas = [xydeltas; candidates(idx, :)];\n    end\n\n    points = cumsum(xydeltas);\nend\n"
                }
            ],
            [
                {
                    "language": "Raku",
                    "solution": "sub babylonianSpiral (\\nsteps) {\n    my @squareCache = (0..nsteps).hyper.map: *\u00b2;\n    my @dxys = [0, 0], [0, 1];\n    my $dsq  = 1;\n\n    for ^(nsteps-2) {\n        my \\\u0398 = atan2 |@dxys[*-1][1,0];\n        my @candidates;\n\n        until @candidates.elems {\n            $dsq++;\n            for @squareCache.kv -> \\i, \\a {\n                last if a > $dsq/2;\n                for reverse 0 .. $dsq.sqrt.ceiling -> \\j {\n                    last if $dsq > (a + my \\b = @squareCache[j]);\n                    next if $dsq != a + b;\n                    @candidates.append: [i, j], [-i, j], [i, -j], [-i, -j],\n                                        [j, i], [-j, i], [j, -i], [-j, -i]\n                }\n            }\n        }\n        @dxys.push: @candidates.min: { ( \u0398 - atan2 |.[1,0] ) % \u03c4 };\n    }\n\n    [\\\u00bb+\u00ab] @dxys\n}\n\n# The task\nsay \"The first $_ Babylonian spiral points are:\\n\",\n(babylonianSpiral($_).map: { sprintf '(%3d,%4d)', @$_ }).batch(10).join(\"\\n\") given 40;\n\n# Stretch\nuse SVG;\n\n'babylonean-spiral-raku.svg'.IO.spurt: SVG.serialize(\n    svg => [\n        :width<100%>, :height<100%>,\n        :rect[:width<100%>, :height<100%>, :style<fill:white;>],\n        :polyline[ :points(flat babylonianSpiral(10000)),\n          :style(\"stroke:red; stroke-width:6; fill:white;\"),\n          :transform(\"scale (.05, -.05) translate (1000,-10000)\")\n        ],\n    ],\n);\n"
                },
                {
                    "language": "Nim",
                    "solution": "import std/[math, strformat, strutils]\n\ntype Vector = tuple[x, y: int]\n\nfunc `+`(a, b: Vector): Vector =\n  ## Return the sum of two vectors.\n  (a.x + b.x, a.y + b.y)\n\nfunc isqrt(n: int): int =\n  ## Return the integer square root of \"n\".\n  int(sqrt(n.toFloat))\n\n\nproc babylonianSpiral(nsteps: int): seq[Vector] =\n  ## Get the points for each step along a Babylonia spiral of `nsteps` steps.\n  ## Origin is at (0, 0) with first step one unit in the positive direction along\n  ## the vertical (y) axis. The other points are selected to have integer x and y\n  ## coordinates, progressively concatenating the next longest vector with integer\n  ## x and y coordinates on the grid. The direction change of the  new vector is\n  ## chosen to be nonzero and clockwise in a direction that minimizes the change\n  ## in direction from the previous vector.\n\n  var xyDeltas: seq[Vector] = @[(0, 0), (0, 1)]\n  var \u03b4squared = 1\n  for _ in 0..nsteps - 3:\n    let (x, y) = xyDeltas[^1]\n    let \u03b8 = arctan2(y.toFloat, x.toFloat)\n    var candidates: seq[Vector]\n    while candidates.len == 0:\n      inc \u03b4squared, 1\n      for i in 0..<nsteps:\n        let a = i * i\n        if a > \u03b4squared div 2:\n          break\n        for j in countdown(isqrt(\u03b4squared) + 1, 1):\n          let b = j * j\n          if a + b < \u03b4squared:\n            break\n          if a + b == \u03b4squared:\n            candidates.add [(i, j), (-i, j), (i, -j), (-i, -j), (j, i), (-j, i), (j, -i), (-j, -i)]\n      var p: Vector\n      var minVal = TAU\n      for candidate in candidates:\n        let val = floorMod(\u03b8 - arctan2(candidate.y.toFloat, candidate.x.toFloat), TAU)\n        if val < minVal:\n          minVal = val\n          p = candidate\n      xyDeltas.add p\n\n  result = cumsummed(xyDeltas)\n\nlet points10000 = babylonianSpiral(10_000)\n\n\n### Task ###\necho \"The first 40 Babylonian spiral points are:\"\nfor i, p in points10000[0..39]:\n  stdout.write alignLeft(&\"({p.x}, {p.y})\", 10)\n  stdout.write if (i + 1) mod 10 == 0: \"\\n\" else: \"\"\n\n\n### Stretch task ###\n\nimport gnuplot\n\nvar x, y: seq[float]\nfor p in points10000:\n  x.add p.x.toFloat\n  y.add p.y.toFloat\n\nwithGnuPlot:\n  cmd \"set size ratio -1\"\n  plot(x, y, \"Babylonian spiral\", \"with lines lc black lw 1\")\n  png(\"babylonian_spiral.png\")\n"
                }
            ]
        ]
    },
    {
        "task_name": "Balanced-brackets",
        "task_description": "'''Task''': \n* Generate a string with &nbsp; '''N''' &nbsp; opening brackets &nbsp; <big>'''['''</big> &nbsp; and with &nbsp; '''N''' &nbsp; closing brackets &nbsp; <big>''']'''</big>, &nbsp; in some arbitrary order. \n* Determine whether the generated string is ''balanced''; that is, whether it consists entirely of pairs of opening/closing brackets (in that order), none of which mis-nest.\n\n\n\n;Examples:\n    (empty)      OK\n    []           OK   \n    [][]         OK   \n    [[][]]       OK \n    ][         NOT OK\n    ][][       NOT OK\n    []][[]     NOT OK\n<br><br>\n\n",
        "solution_pairs": [
            [
                {
                    "language": "Red",
                    "solution": "; Functional code\nbalanced-brackets: [#\"[\" any balanced-brackets #\"]\"]\nrule: [any balanced-brackets end]\nbalanced?: func [str][parse str rule]\n\n; Tests\ntests: [\n\tgood: [\"\" \"[]\" \"[][]\" \"[[]]\" \"[[][]]\" \"[[[[[]]][][[]]]]\"]\n\tbad:  [\"[\" \"]\" \"][\" \"[[]\" \"[]]\" \"[]][[]\" \"[[[[[[]]]]]]]\"]\n]\n\nforeach str tests/good [\n\tif not balanced? str [print [mold str \"failed!\"]]\n]\nforeach str tests/bad [\n\tif balanced? str [print [mold str \"failed!\"]]\n]\n\nrepeat i 10 [\n\tstr: random copy/part \"[][][][][][][][][][]\" i * 2\n\tprint [mold str \"is\" either balanced? str [\"balanced\"][\"unbalanced\"]]\n]\n"
                },
                {
                    "language": "FutureBasic",
                    "solution": "include \"NSLog.incl\"\n\nlocal fn BracketBalance( strWithBracket as CFStringRef ) as CFStringRef\n  NSInteger   i, bracketTracker = 0\n  CFStringRef result\n\n  CFCharacterSetRef bracketSet      = fn CharacterSetWithCharactersInString( @\"[]\" )\n  CFCharacterSetRef bracketsOnlySet = fn CharacterSetInvertedSet( bracketSet )\n  CFArrayRef         trimmedSArray  = fn StringComponentsSeparatedByCharactersInSet( strWithBracket, bracketsOnlySet )\n  CFStringRef        trimmedStr     = fn ArrayComponentsJoinedByString( trimmedSArray, @\"\" )\n\n  NSUInteger strLen = len( trimmedStr )\n\n  // Empty string, no brackets\n  if ( strLen == 0  ) then result = @\"No brackets\" : exit fn\n  // String with odd number of brackets is unbalanced\n  if ( strLen mod 2 ) then result = @\"Unbalanced\"  : exit fn\n\n  for i = 0 to strLen - 1\n    CFStringRef bracket = fn StringWithFormat( @\"%C\", fn StringCharacterAtIndex( trimmedStr, i ) )\n    if fn StringisEqual( bracket, @\"[\" ) then bracketTracker++\n    if fn StringisEqual( bracket, @\"]\" ) then bracketTracker--\n    if bracketTracker < 0 then result = @\"Unbalanced\" : break\n  next\n  if bracketTracker == 0 then result = @\"Balanced\"\nend fn = result\n\nNSLog( @\"%12s: %@\", fn StringUTF8String( fn BracketBalance( @\"\"     ) ), @\"\"     )\nNSLog( @\"%12s: %@\", fn StringUTF8String( fn BracketBalance( @\"[\"    ) ), @\"[\"    )\nNSLog( @\"%12s: %@\", fn StringUTF8String( fn BracketBalance( @\"]\"    ) ), @\"]\"    )\nNSLog( @\"%12s: %@\", fn StringUTF8String( fn BracketBalance( @\"[]\"   ) ), @\"[]\"   )\nNSLog( @\"%12s: %@\", fn StringUTF8String( fn BracketBalance( @\"[[]\"  ) ), @\"[[]\"  )\nNSLog( @\"%12s: %@\", fn StringUTF8String( fn BracketBalance( @\"[]]\"  ) ), @\"[]]\"  )\nNSLog( @\"%12s: %@\", fn StringUTF8String( fn BracketBalance( @\"[][]\" ) ), @\"[][]\" )\nNSLog( @\"%12s: %@\", fn StringUTF8String( fn BracketBalance( @\"][\"   ) ), @\"][\"   )\nNSLog( @\"%12s: %@\", fn StringUTF8String( fn BracketBalance( @\"][][\" ) ), @\"][][\" )\nNSLog( @\"%12s: %@\", fn StringUTF8String( fn BracketBalance( @\"[[]][][][[][]]\"       ) ), @\"[[]][][][[][]]\"         )\nNSLog( @\"%12s: %@\", fn StringUTF8String( fn BracketBalance( @\"][[]][][][]]][[\"      ) ), @\"][[]][][][]]][[\"        )\nNSLog( @\"%12s: %@\", fn StringUTF8String( fn BracketBalance( @\"[[[abc]][[d]]]]]\"     ) ), @\"[[[abc]][[def]]]]]\"     )\nNSLog( @\"%12s: %@\", fn StringUTF8String( fn BracketBalance( @\"[[[abc]]][[[[[d]]]]]\" ) ), @\"[[[abc]]][[[[[def]]]]]\" )\nNSLog( @\"%12s: %@\", fn StringUTF8String( fn BracketBalance( @\"[][abc]]][[[[[d]]]]]\" ) ), @\"[][abc]]][[[[[def]]]]]\" )\nNSLog( @\"%12s: %@\", fn StringUTF8String( fn BracketBalance( @\"The quick brown fox\"  ) ), @\"The quick brown fox\"    )\n\nHandleEvents\n"
                }
            ],
            [
                {
                    "language": "Quackery",
                    "solution": "  [ char [ over of\n    swap\n    char ] swap of\n    join shuffle ]      is bracket$ ( n --> $ )\n\n  [ 0 swap witheach\n      [ char [ =\n        iff 1 else -1 +\n        dup 0 < if\n          conclude ]\n    0 = ]               is balanced ( $ --> b )\n\n\n  10 times\n    [ 20 i 2 * - times sp\n      i bracket$ dup echo$\n      say \" is \"\n      balanced not if\n        [ say \"un\" ]\n      say \"balanced.\"\n      cr ]\n"
                },
                {
                    "language": "PowerShell",
                    "solution": "#  Test\n$Strings = @( \"\" )\n$Strings += 1..5 | ForEach { ( [char[]](\"[]\" * $_) | Get-Random -Count ( $_ * 2 ) ) -join \"\" }\n\nForEach ( $String in $Strings )\n    {\n    $String.PadRight( 12, \" \" ) + (Get-BalanceStatus $String)\n    }\n"
                }
            ],
            [
                {
                    "language": "TXR",
                    "solution": "@(define paren)@(maybe)[@(coll)@(paren)@(until)]@(end)]@(end)@(end)\n@(do (defvar r (make-random-state nil))\n\n     (defun generate-1 (count)\n       (let ((bkt (repeat \"[]\" count)))\n         (cat-str (shuffle bkt))))\n\n     (defun generate-list (num count)\n       [[generate tf (op generate-1 count)] 0..num]))\n@(next :list @(generate-list 22 6))\n@(output)\nINPUT           MATCHED         REST\n@(end)\n@  (collect)\n@    (all)\n@parens\n@    (and)\n@{matched (paren)}@mismatched\n@    (end)\n@  (output)\n@{parens 15} @{matched 15} @{mismatched 15}\n@  (end)\n@(end)\n"
                },
                {
                    "language": "VBScript",
                    "solution": "For n = 1 To 10\n\tsequence = Generate_Sequence(n)\n\tWScript.Echo sequence & \" is \" & Check_Balance(sequence) & \".\"\nNext\n\nFunction Generate_Sequence(n)\n\tFor i = 1 To n\n\t\tj = Round(Rnd())\n\t\tIf j = 0 Then\n\t\t\tGenerate_Sequence = Generate_Sequence & \"[\"\n\t\tElse\n\t\t\tGenerate_Sequence = Generate_Sequence & \"]\"\n\t\tEnd If\n\tNext\nEnd Function\n\nFunction Check_Balance(s)\n\tSet Stack = CreateObject(\"System.Collections.Stack\")\n\tFor i = 1 To Len(s)\n\t\tchar = Mid(s,i,1)\n\t\tIf i = 1 Or char = \"[\" Then\n\t\t\tStack.Push(char)\n\t\tElseIf Stack.Count <> 0 Then\n\t\t\tIf char = \"]\" And Stack.Peek = \"[\" Then\n\t\t\t\tStack.Pop\n\t\t\tEnd If\n\t\tElse\n\t\t\tStack.Push(char)\n\t\tEnd If\n\tNext\n\tIf Stack.Count > 0 Then\n\t\tCheck_Balance = \"Not Balanced\"\n\tElse\n\t\tCheck_Balance = \"Balanced\"\n\tEnd If\nEnd Function\n"
                }
            ],
            [
                {
                    "language": "Factor",
                    "solution": "USING: combinators formatting kernel math random sequences strings ;\nIN: rosetta-code.balanced-brackets\n\n: balanced? ( str -- ? )\n    0 swap [\n        {\n            { CHAR: [ [ 1 + t ] }\n            { CHAR: ] [ 1 - dup 0 >= ] }\n            [ drop t ]\n        } case\n    ] all? swap zero? and ;\n\n: bracket-pairs ( n -- str )\n    [ \"[]\" ] replicate \"\" concat-as ;\n\n: balanced-brackets-main ( -- )\n    5 bracket-pairs randomize dup balanced? \"\" \"not \" ?\n    \"String \\\"%s\\\" is %sbalanced.\\n\" printf ;\n\nMAIN: balanced-brackets-main\n"
                },
                {
                    "language": "OxygenBasic",
                    "solution": "function CheckBrackets(string s) as bool\n'=======================================\n  sys co, le=len s\n  byte b at strptr s\n  indexbase 0\n  for i=0 to <le\n    select b(i)\n    case \"[\" : co++\n    case \"]\" : co--\n    end select\n    if co<0 then return 0\n  next\n  if co=0 then return 1\nend function\n\n\n'TEST\n'====\n\nprint CheckBrackets \"\"    '1\nprint CheckBrackets \"[\"   '0\nprint CheckBrackets \"]\"   '0\nprint CheckBrackets \"[]\"  '1\nprint CheckBrackets \"[[]\" '0\nprint CheckBrackets \"[]]\" '0\nprint CheckBrackets \"[][]\"'1\nprint CheckBrackets \"][\"  '0\n"
                }
            ],
            [
                {
                    "language": "ABAP",
                    "solution": "CLASS lcl_balanced_brackets DEFINITION.\n  PUBLIC SECTION.\n    CLASS-METHODS:\n      class_constructor,\n\n      are_brackets_balanced\n        IMPORTING\n          seq                            TYPE string\n        RETURNING\n          VALUE(r_are_brackets_balanced) TYPE abap_bool,\n\n      get_random_brackets_seq\n        IMPORTING\n          n                    TYPE i\n        RETURNING\n          VALUE(r_bracket_seq) TYPE string.\n\n  PRIVATE SECTION.\n    CLASS-DATA: random_int TYPE REF TO cl_abap_random_int.\n\n    CLASS-METHODS:\n      _split_string\n        IMPORTING\n          i_text         TYPE string\n        RETURNING\n          VALUE(r_chars) TYPE stringtab,\n\n      _rand_bool\n        RETURNING\n          VALUE(r_bool) TYPE i.\nENDCLASS.\n\nCLASS lcl_balanced_brackets IMPLEMENTATION.\n  METHOD class_constructor.\n    random_int = cl_abap_random_int=>create( seed = CONV #( sy-uzeit )\n                                             min  = 0\n                                             max  = 1 ).\n  ENDMETHOD.\n\n  METHOD are_brackets_balanced.\n    DATA: open_bracket_count TYPE i.\n\n    DATA(chars) = _split_string( seq ).\n\n    r_are_brackets_balanced = abap_false.\n\n    LOOP AT chars ASSIGNING FIELD-SYMBOL(<c>).\n      IF <c> = ']' AND open_bracket_count = 0.\n        RETURN.\n      ENDIF.\n\n      IF <c> = ']'.\n        open_bracket_count = open_bracket_count - 1.\n      ENDIF.\n\n      IF <c> = '['.\n        open_bracket_count = open_bracket_count + 1.\n      ENDIF.\n    ENDLOOP.\n\n    IF open_bracket_count > 0.\n      RETURN.\n    ENDIF.\n\n    r_are_brackets_balanced = abap_true.\n  ENDMETHOD.\n\n  METHOD get_random_brackets_seq.\n    DATA(itab) = VALUE stringtab( FOR i = 1 THEN i + 1 WHILE i <= n\n                                     ( COND #( WHEN _rand_bool( ) = 0 THEN '['\n                                               ELSE ']' ) ) ).\n    r_bracket_seq = concat_lines_of( itab ).\n  ENDMETHOD.\n\n  METHOD _rand_bool.\n    r_bool = random_int->get_next( ).\n  ENDMETHOD.\n\n  METHOD _split_string.\n    DATA: off TYPE i VALUE 0.\n\n    DO strlen( i_text ) TIMES.\n      INSERT i_text+off(1) INTO TABLE r_chars.\n      off = off + 1.\n    ENDDO.\n  ENDMETHOD.\nENDCLASS.\n\nSTART-OF-SELECTION.\n  DO 10 TIMES.\n    DATA(seq) = lcl_balanced_brackets=>get_random_brackets_seq( 10 ).\n    cl_demo_output=>write( |{ seq } => { COND string( WHEN lcl_balanced_brackets=>are_brackets_balanced( seq ) = abap_true THEN 'OK'\n                                                      ELSE 'NOT OK' ) }| ).\n  ENDDO.\n  cl_demo_output=>display( ).\n"
                },
                {
                    "language": "Nu",
                    "solution": "def gen_brackets [n: int] { 1..$in | each {[\"[\" \"]\"]} | flatten | shuffle | str join }\n\ndef check_brackets [] {\n\tsplit chars | reduce --fold 0 {|x, d|\n\t\tif ($d < 0) {-1} else {\n\t\t\t$d + (if ($x == \"[\") {1} else {-1})\n\t\t}\n\t} | $in > -1\n}\n\n\n1..10 | each {gen_brackets $in | {brackets: $in, valid: ($in | check_brackets)}} | print\n"
                }
            ]
        ]
    },
    {
        "task_name": "Balanced-ternary",
        "task_description": "[[wp:Balanced ternary|Balanced ternary]] is a way of representing numbers.  Unlike the prevailing binary representation, a balanced ternary integer is in base 3, and each digit can have the values 1, 0, or \u22121.  \n\n\n;Examples:\nDecimal 11 = 3<sup>2</sup> + 3<sup>1</sup> \u2212 3<sup>0</sup>, thus it can be written as \"++\u2212\"\n\nDecimal  6 = 3<sup>2</sup> \u2212 3<sup>1</sup> + 0 \u00d7 3<sup>0</sup>, thus it can be written as \"+\u22120\"\n\n\n;Task:\nImplement balanced ternary representation of integers with the following:\n# Support arbitrarily large integers, both positive and negative;\n# Provide ways to convert to and from text strings, using digits '+', '-' and '0' (unless you are already using strings to represent balanced ternary; but see requirement 5).\n# Provide ways to convert to and from native integer type (unless, improbably, your platform's native integer type ''is'' balanced ternary).  If your native integers can't support arbitrary length, overflows during conversion must be indicated.\n# Provide ways to perform addition, negation and multiplication directly on balanced ternary integers; do ''not'' convert to native integers first.\n# Make your implementation efficient, with a reasonable definition of \"efficient\" (and with a reasonable definition of \"reasonable\").\n\n\n'''Test case''' With balanced ternaries ''a'' from string \"+-0++0+\", ''b'' from native integer -436, ''c'' \"+-++-\":\n* write out ''a'', ''b'' and ''c'' in decimal notation;\n* calculate ''a'' \u00d7 (''b'' \u2212 ''c''), write out the result in both ternary and decimal notations.\n\n\n'''Note:''' The pages [[generalised floating point addition]] and [[generalised floating point multiplication]] have code implementing [[wp:arbitrary precision|arbitrary precision]] [[wp:floating point|floating point]] balanced ternary.\n<br><br>\n\n",
        "solution_pairs": [
            [
                {
                    "language": "Common-Lisp",
                    "solution": ";;; balanced ternary\n;;; represented as a list of 0, 1 or -1s, with least significant digit first\n\n;;; convert ternary to integer\n(defun bt-integer (b)\n  (reduce (lambda (x y) (+ x (* 3 y))) b :from-end t :initial-value 0))\n\n;;; convert integer to ternary\n(defun integer-bt (n)\n  (if (zerop n) nil\n    (case (mod n 3)\n      (0 (cons  0 (integer-bt (/ n 3))))\n      (1 (cons  1 (integer-bt (floor n 3))))\n      (2 (cons -1 (integer-bt (floor (1+ n) 3)))))))\n\n;;; convert string to ternary\n(defun string-bt (s)\n  (loop with o = nil for c across s do\n\t  (setf o (cons (case c (#\\+ 1) (#\\- -1) (#\\0 0)) o))\n\t  finally (return o)))\n\n;;; convert ternary to string\n(defun bt-string (bt)\n  (if (not bt) \"0\"\n    (let* ((l (length bt))\n\t   (s (make-array l :element-type 'character)))\n      (mapc (lambda (b)\n\t      (setf (aref s (decf l))\n\t\t    (case b (-1 #\\-) (0 #\\0) (1 #\\+))))\n\t    bt)\n      s)))\n\n;;; arithmetics\n(defun bt-neg (a) (map 'list #'- a))\n(defun bt-sub (a b) (bt-add a (bt-neg b)))\n\n(let ((tbl #((0 -1) (1 -1) (-1 0) (0 0) (1 0) (-1 1) (0 1))))\n  (defun bt-add-digits (a b c)\n    (values-list (aref tbl (+ 3 a b c)))))\n\n(defun bt-add (a b &optional (c 0))\n  (if (not (and a b))\n    (if (zerop c) (or a b)\n      (bt-add (list c) (or a b)))\n    (multiple-value-bind (d c)\n      (bt-add-digits (if a (car a) 0) (if b (car b) 0) c)\n      (let ((res (bt-add (cdr a) (cdr b) c)))\n\t;; trim leading zeros\n\t(if (or res (not (zerop d)))\n\t  (cons d res))))))\n\n(defun bt-mul (a b)\n  (if (not (and a b))\n    nil\n    (bt-add (case (car a)\n\t        (-1 (bt-neg b))\n\t\t( 0 nil)\n\t\t( 1 b))\n\t    (cons 0 (bt-mul (cdr a) b)))))\n\n;;; division with quotient/remainder, for completeness\n(defun bt-truncate (a b)\n  (let ((n (- (length a) (length b)))\n\t(d (car (last b))))\n    (if (minusp n)\n      (values nil a)\n      (labels ((recur (a b x)\n\t (multiple-value-bind (quo rem)\n\t   (if (plusp x) (recur a (cons 0 b) (1- x))\n\t     (values nil a))\n\n\t   (loop with g = (car (last rem))\n\t\t with quo = (cons 0 quo)\n\t\t while (= (length rem) (length b)) do\n\t\t (cond ((= g d) (setf rem (bt-sub rem b)\n\t\t\t\t      quo (bt-add '(1) quo)))\n\t\t       ((= g (- d)) (setf rem (bt-add rem b)\n\t\t\t\t\t  quo (bt-add '(-1) quo))))\n\t\t (setf x (car (last rem)))\n\t\t finally (return (values quo rem))))))\n\n\t(recur a b n)))))\n\n;;; test case\n(let* ((a (string-bt \"+-0++0+\"))\n       (b (integer-bt -436))\n       (c (string-bt \"+-++-\"))\n       (d (bt-mul a (bt-sub b c))))\n  (format t \"a~5d~8t~a~%b~5d~8t~a~%c~5d~8t~a~%a \u00d7 (b \u2212 c) = ~d ~a~%\"\n\t  (bt-integer a) (bt-string a)\n\t  (bt-integer b) (bt-string b)\n\t  (bt-integer c) (bt-string c)\n\t  (bt-integer d) (bt-string d)))\n"
                },
                {
                    "language": "Glagol",
                    "solution": "PROGRAM Setun+;\nUSES\n  Parameter IS \"...\\Departments\\Exchange\\\"\n  Text IS \"...\\Departments\\Numbers\\\"\n  Output IS \"...\\Departments\\Exchange\\\";\n\nVAR\n  AF: RANGE 10 IS SIGN;\n  mfpos: INT;\n  number: INT;\n  memory ACCESS TO STRUCT\n    cell: RANGE 20 IS INT;\n    size: UZKEL;\n    negative: BOOL\n  END;\n\nPROC Create.Memory;\nBEGIN\n  CREATE(memory);\n  memory.size := 0;\n  memory.negative := FALSE\nEND Create.Memory;\n\nPROC Add.Memory(that: INT)\nBEGIN\n  memory.cells[memory.size] := that;\n  ZOOM(memory.size)\nEND Add.Memory;\n\nPROC Invert.Memory;\nVAR\n  zchsl: INT;\n  account: INT;\nBEGIN\n  FOR cq := 0 TO memory.size DIVIDE 2 - 1 DO\n    zchsl := memory.cells[cq];\n    memory.cells[cq] := memory.cells[memory.size-size-1];\n    memory.cells[memory.size-MF-1] := zchsl\n  END\nEND Invert.Memory;\n\nPROC Withdraw.Memory;\nVAR\n  account: INT;\nBEGIN\n  FOR cq := 0 TO memory.size-1 DO\n    IF memory.cells[cq] < 0 THEN\n      Output.Append(\"-\")\n    ANDIF memory.cells[cq] > 0 THEN\n      Output.Append(\"+\")\n    ELSE Output.Append(\"0\") END\n  END\nEND Withdraw.Memory;\n\nPROC Remove.Memory;\nBEGIN\n  memory := Empty\nEND Remove.Memory;\n\nPROC Translate(number: INT)\nVAR\n  about: INT;\n  s: BOOL;\n  PROC B.Memory(that: INT)\n  BEGIN\n    IF memory.negative THEN\n      IF that < 0 THEN Add.Memory(1)\n      ANDIF that > 0 THEN Add.Memory(1)\n      ELSE Add.Memory(0) END\n    ELSE\n      Add.Memory(that)\n    END\n  END B.Memory;\nBEGIN\n  IF number < 0 THEN memory.negative := TRUE END;\n  number := UNIT(number)\n  s := FALSE;\n  WHILE number > 0 DO\n    about := number BALANCE 3;\n    number := number DIVIDE 3;\n    IF s THEN\n      IF about = 2 THEN B.Memory(0) ANDIF about = 1 THEN B.Memory(1) ELSE B.Memory(1) s := FALSE END\n    ELSE\n      IF about = 2 THEN B.Memory(-1) s := TRUE ELSE B.Memory(a) END\n    END\n  END;\n  IF s THEN B.Memory(1) END;\n  Invert.Memory;\n  Withdraw.Memory(TRUE)\nEND Translate;\n\nPROC InNumber(): INT;\nVAR\n  MF, MN: INT;\n  result: INT;\nBEGIN\n  result := 0\n  pl := 1;\n  FOR cq := 0 TO memory.size-1 DO\n    ZOOM(result, memory.Cells[memory.size-cq-1] * mn);\n    pl := pl * 3\n  END;\n  RETURN result;\nEND InNumber;\n\nBEGIN\n  Parameter.Text(1, AF); mfpos := 0;\n  number := Text.Whole(AF, mfpos);\n  Create.Memory;\n  Translate(number);\n  Output.ChTarget(\" = %d.\", InNumber(), 0, 0, 0);\n  Remove.Memory\nEND Setun.\n"
                }
            ],
            [
                {
                    "language": "Erlang",
                    "solution": "234> ternary:test().\nA = +-0++0+ -> 523\nB = -++-0-- -> -436\nC = +-++- -> 65\nA x (B - C) = 0----0+--0++0 -> -262023\nok\n"
                },
                {
                    "language": "Factor",
                    "solution": "USING: kernel combinators locals formatting lint literals\n       sequences assocs strings arrays\n       math math.functions math.order ;\nIN: rosetta-code.bt\nCONSTANT: addlookup {\n  { 0 CHAR: 0 }\n  { 1 CHAR: + }\n  { -1 CHAR: - }\n}\n\n<PRIVATE\n\n: bt-add-digits ( a b c -- d e )\n  + + 3 +\n  { { 0 -1 } { 1 -1 } { -1 0 } { 0 0 } { 1 0 } { -1 1 } { 0 1 } }\n  nth first2\n;\n\nPRIVATE>\n\n! Conversion\n: bt>integer ( seq -- x ) 0 [ swap 3 * + ] reduce ;\n: integer>bt ( x -- x ) [ dup zero? not ] [\n    dup 3 rem {\n      { 0 [ 3 / 0 ] }\n      { 1 [ 3 / round 1 ] }\n      { 2 [ 1 + 3 / round -1 ] }\n    } case\n  ] produce nip reverse\n;\n: bt>string ( seq -- str ) [ addlookup at ] map >string ;\n: string>bt ( str -- seq ) [ addlookup value-at ] { } map-as ;\n\n! Arithmetic\n: bt-neg ( a -- -a ) [ neg ] map ;\n:: bt-add ( u v -- w )\n  u v max-length :> maxl\n  u v [ maxl 0 pad-head reverse ] bi@ :> ( u v )\n  0 :> carry!\n  u v { } [ carry bt-add-digits carry! prefix ] 2reduce\n  carry prefix [ zero? ] trim-head\n;\n: bt-sub ( u v -- w ) bt-neg bt-add ;\n:: bt-mul ( u v -- w ) u { } [\n    {\n      { -1 [ v bt-neg ] }\n      { 0  [ { } ] }\n      { 1  [ v ] }\n    } case bt-add 0 suffix\n  ] reduce\n  1 head*\n;\n\n[let\n  \"+-0++0+\" string>bt :> a\n  -436 integer>bt     :> b\n  \"+-++-\" string>bt   :> c\n  b c bt-sub a bt-mul :> d\n  \"a\" a bt>integer a bt>string \"%s: %d, %s\\n\" printf\n  \"b\" b bt>integer b bt>string \"%s: %d, %s\\n\" printf\n  \"c\" c bt>integer c bt>string \"%s: %d, %s\\n\" printf\n  \"a*(b-c)\" d bt>integer d bt>string \"%s: %d, %s\\n\" printf\n]\n"
                }
            ],
            [
                {
                    "language": "Bruijn",
                    "solution": ":import std/Combinator .\n:import std/Logic .\n:import std/Pair .\n\n# negative trit indicating coefficient of (-1)\nt\u207b [[[2]]]\n\n# positive trit indicating coefficient of (+1)\nt\u207a [[[1]]]\n\n# zero trit indicating coefficient of 0\nt\u2070 [[[0]]]\n\n# shifts a negative trit into a balanced ternary number\n\u2191\u207b\u2023 [[[[[2 (4 3 2 1 0)]]]]]\n\n# shifts a positive trit into a balanced ternary number\n\u2191\u207a\u2023 [[[[[1 (4 3 2 1 0)]]]]]\n\n# shifts a zero trit into a balanced ternary number\n\u2191\u2070\u2023 [[[[[0 (4 3 2 1 0)]]]]]\n\n# shifts a specified trit into a balanced ternary number\n\u2026\u2191\u2026 [[[[[[5 2 1 0 (4 3 2 1 0)]]]]]]\n\n# negates a balanced ternary number\n-\u2023 [[[[[4 3 1 2 0]]]]]\n\n# increments a balanced ternary number (can introduce leading 0s)\n++\u2023 [~(0 z a\u207b a\u207a a\u2070)]\n\tz (+0) : (+1)\n\ta\u207b &[[\u2191\u207b1 : \u2191\u20701]]\n\ta\u207a &[[\u2191\u207a1 : \u2191\u207b0]]\n\ta\u2070 &[[\u2191\u20701 : \u2191\u207a1]]\n\n# decrements a balanced ternary number (can introduce leading 0s)\n--\u2023 [~(0 z a\u207b a\u207a a\u2070)]\n\tz (+0) : (-1)\n\ta\u207b &[[\u2191\u207b1 : \u2191\u207a0]]\n\ta\u207a &[[\u2191\u207a1 : \u2191\u20701]]\n\ta\u2070 &[[\u2191\u20701 : \u2191\u207b1]]\n\n# converts the normal balanced ternary representation into abstract form\n\u2192^\u2023 [0 z a\u207b a\u207a a\u2070]\n\tz (+0)\n\ta\u207b [[[[[2 4]]]]]\n\ta\u207a [[[[[1 4]]]]]\n\ta\u2070 [[[[[0 4]]]]]\n\n# converts the abstracted balanced ternary representation back to normal\n\u2192_\u2023 y [[0 z a\u207b a\u207a a\u2070]]\n\tz (+0)\n\ta\u207b [\u2191\u207b(2 0)]\n\ta\u207a [\u2191\u207a(2 0)]\n\ta\u2070 [\u2191\u2070(2 0)]\n\n# adds two balanced ternary numbers (can introduce leading 0s)\n\u2026+\u2026 [[[c (0 z a\u207b a\u207a a\u2070)] 1 \u2192^0]]\n\tb\u207b [1 \u2191\u207a(3 0 t\u207b) \u2191\u2070(3 0 t\u2070) \u2191\u207b(3 0 t\u2070)]\n\tb\u2070 [1 \u2191 (3 0 t\u2070)]\n\tb\u207a [1 \u2191\u2070(3 0 t\u2070) \u2191\u207b(3 0 t\u207a) \u2191\u207a(3 0 t\u2070)]\n\ta\u207b [[[1 (b\u207b 1) b\u207b' b\u2070 b\u207b]]]\n\t\tb\u207b' [1 \u2191\u2070(3 0 t\u207b) \u2191\u207b(3 0 t\u2070) \u2191\u207a(3 0 t\u207b)]\n\ta\u207a [[[1 (b\u207a 1) b\u2070 b\u207a' b\u207a]]]\n\t\tb\u207a' [1 \u2191\u207a(3 0 t\u2070) \u2191\u2070(3 0 t\u207a) \u2191\u207b(3 0 t\u207a)]\n\ta\u2070 [[[1 (b\u2070 1) b\u207b b\u207a b\u2070]]]\n\tz [[0 --(\u2192_1) ++(\u2192_1) \u2192_1]]\n\tc [[1 0 t\u2070]]\n\n# subtracts two balanced ternary numbers (can introduce leading 0s)\n\u2026-\u2026 [[1 + -0]]\n\n# multiplicates two balanced ternary numbers (can introduce leading 0s)\n\u2026\u22c5\u2026 [[1 z a\u207b a\u207a a\u2070]]\n\tz (+0)\n\ta\u207b [\u2191\u20700 - 1]\n\ta\u207a [\u2191\u20700 + 1]\n\ta\u2070 [\u2191\u20700]\n\n# true if balanced ternary number is zero\n=?\u2023 [0 true [false] [false] i]\n\n# true if two balanced ternary numbers are equal\n# \u2192 ignores leading 0s!\n\u2026=?\u2026 [[[0 z a\u207b a\u207a a\u2070] 1 \u2192^0]]\n\tz [=?(\u2192_0)]\n\ta\u207b [[0 false [2 0] [false] [false]]]\n\ta\u207a [[0 false [false] [2 0] [false]]]\n\ta\u2070 [[0 (1 0) [false] [false] [2 0]]]\n\nmain [[0]]\n\n# --- tests/examples ---\n\n:test ((-42) + (-1) =? (-43)) (true)\n:test ((+1) + (+2) =? (+3)) (true)\n:test ((-42) - (-1) =? (-41)) (true)\n:test ((+1) - (+2) =? (-1)) (true)\n:test ((-1) \u22c5 (+42) =? (-42)) (true)\n:test ((+3) \u22c5 (+11) =? (+33)) (true)\n"
                },
                {
                    "language": "PicoLisp",
                    "solution": "(seed (in \"/dev/urandom\" (rd 8)))\n\n(setq *G '((0 -1) (1 -1) (-1 0) (0 0) (1 0) (-1 1) (0 1)))\n\n# For humans\n(de negh (L)\n   (mapcar\n      '((I)\n         (case I\n            (- '+)\n            (+ '-)\n            (T 0) ) )\n      L ) )\n\n(de trih (X)\n   (if (num? X)\n      (let (S (lt0 X)  X (abs X)  R NIL)\n         (if (=0 X)\n            (push 'R 0)\n            (until (=0 X)\n               (push 'R\n                  (case (% X 3)\n                     (0 0)\n                     (1 '+)\n                     (2 (inc 'X) '-) ) )\n               (setq X (/ X 3)) ) )\n         (if S (pack (negh R)) (pack R)) )\n      (let M 1\n         (sum\n            '((C)\n               (prog1\n                  (unless (= C \"0\") ((intern C) M))\n                  (setq M (* 3 M)) ) )\n            (flip (chop X)) ) ) ) )\n\n# For robots\n(de neg (L)\n   (mapcar\n      '((I)\n         (case I (-1 1) (1 -1) (T 0)) )\n      L ) )\n\n(de tri (X)\n   (if (num? X)\n      (let (S (lt0 X)  X (abs X)  R NIL)\n         (if (=0 X)\n            (push 'R 0)\n            (until (=0 X)\n               (push 'R\n                  (case (% X 3)\n                     (0 0)\n                     (1 1)\n                     (2 (inc 'X) (- 1)) ) )\n               (setq X (/ X 3)) ) )\n         (flip (if S (neg R) R)) )\n      (let M 1\n         (sum\n            '((C)\n               (prog1 (* C M) (setq M (* 3 M))) )\n            X ) ) ) )\n\n(de add (D1 D2)\n   (let\n      (L (max (length D1) (length D2))\n         D1 (need (- L) D1 0)\n         D2 (need (- L) D2 0)\n         C 0 )\n      (mapcon\n         '((L1 L2)\n            (let R\n               (get\n                  *G\n                  (+ 4 (+ (car L1) (car L2) C)) )\n               (ifn (cdr L1)\n                  R\n                  (setq C (cadr R))\n                  (cons (car R)) ) ) )\n         D1\n         D2 ) ) )\n\n(de mul (D1 D2)\n   (ifn (and D1 D2)\n      0\n      (add\n         (case (car D1)\n            (0 0)\n            (1 D2)\n            (-1 (neg D2)) )\n         (cons 0 (mul (cdr D1) D2) ) ) ) )\n\n(de sub (D1 D2)\n   (add D1 (neg D2)) )\n\n# Random testing\n(let (X 0  Y 0  C 2048)\n   (do C\n      (setq\n         X (rand (- C) C)\n         Y (rand (- C) C) )\n      (test X (trih (trih X)))\n      (test X (tri (tri X)))\n      (test\n         (+ X Y)\n         (tri (add (tri X) (tri Y))) )\n      (test\n         (- X Y)\n         (tri (sub (tri X) (tri Y))) )\n      (test\n         (* X Y)\n         (tri (mul (tri X) (tri Y))) ) ) )\n\n(println 'A (trih 523) (trih \"+-0++0+\"))\n(println 'B (trih -436) (trih \"-++-0--\"))\n(println 'C (trih 65) (trih \"+-++-\"))\n(let R\n   (tri\n      (mul\n         (tri (trih \"+-0++0+\"))\n         (sub (tri -436) (tri (trih \"+-++-\"))) ) )\n   (println 'R (trih R) R) )\n\n(bye)\n"
                }
            ],
            [
                {
                    "language": "Prolog",
                    "solution": ":- module('bt_mult.pl', [op(850, xfx, btmult),\n\t\t\t btmult/2,\n\t\t\t multiplication/3\n\t\t\t]).\n\n:- use_module('bt_add.pl').\n\n:- op(850, xfx, btmult).\nA is B btmult C :-\n\tmultiplication(B, C, A).\n\nneg(A, B) :-\n\tmaplist(opp, A, B).\n\nopp(48, 48).\nopp(45, 43).\nopp(43, 45).\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n% the multiplication (efficient)\n% multiplication(+BIn, +QIn, -AOut)\n% Aout is BIn * QIn\n% BIn, QIn, AOut are strings\nmultiplication(BIn, QIn, AOut) :-\n\tstring_to_list(BIn, B),\n\tstring_to_list(QIn, Q),\n\n\t% We work with positive numbers\n\t(   B = [45 | _] -> Pos0 = false, neg(B,BP) ; BP = B, Pos0 = true),\n\t(   Q = [45 | _] -> neg(Q, QP), select(Pos0, [true, false], [Pos1]); QP = Q, Pos1 = Pos0),\n\n\tmultiplication_(BP, QP, [48], A),\n\t(   Pos1 = false -> neg(A, A1); A1 = A),\n\tstring_to_list(AOut, A1).\n\n\nmultiplication_(_B, [], A, A).\n\nmultiplication_(B, [H | T], A, AF) :-\n\tmultiplication_1(B, H, B1),\n\tappend(A, [48], A1),\n\tbt_add1(B1, A1, A2),\n\tmultiplication_(B, T, A2, AF).\n\n% by 1 (digit '+' code 43)\nmultiplication_1(B, 43, B).\n\n% by 0 (digit '0' code 48)\nmultiplication_1(_, 48, [48]).\n\n% by -1 (digit '-' code 45)\nmultiplication_1(B, 45, B1) :- neg(B, B1).\n\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n% the division (efficient)\n% division(+AIn, +BIn, -QOut, -ROut)\n%\ndivision(AIn, BIn, QOut, ROut) :-\n\tstring_to_list(AIn, A),\n\tstring_to_list(BIn, B),\n\tlength(B, LB),\n\tlength(A, LA),\n\tLen is LA - LB,\n\t(   Len < 0 -> Q = [48], R = A\n\t;   neg(B, NegB), division_(A, B, NegB, LB, Len, [], Q, R)),\n\tstring_to_list(QOut, Q),\n\tstring_to_list(ROut, R).\n\n\ndivision_(A, B, NegB, LenB, LenA, QC, QF, R) :-\n\t% if the remainder R is negative (last number A), we must decrease the quotient Q, annd add B to R\n\t(   LenA = -1 -> (A = [45 | _]  -> positive(A, B, QC, QF, R) ;\tQF = QC, A = R)\n\t;   extract(LenA, _, A, AR, AF),\n\t    length(AR, LR),\n\n\t    (\tLR >= LenB -> ( AR = [43 | _] ->\n\t\t\t        bt_add1(AR, NegB, S), Q0 = [43],\n\t\t\t\t% special case : R has the same length than B\n\t\t\t\t% and his first digit is + (1)\n\t\t\t\t% we must do another one substraction\n\t\t\t\t(   (length(S, LenB), S = [43|_]) ->\n\t\t\t\t                       bt_add1(S, NegB, S1),\n\t\t\t\t                       bt_add1(QC, [43], QC1),\n\t\t\t\t                       Q00 = [45]\n\t\t\t\t;   S1 = S, QC1 = QC, Q00 = Q0)\n\n\n\t                        ; bt_add1(AR, B, S1), Q00 = [45], QC1 = QC),\n\t\t\t\tappend(QC1, Q00, Q1),\n\t\t                append(S1, AF, A1),\n\t\t\t\tstrip_nombre(A1, A2, []),\n\t\t\t\tLenA1 is LenA - 1,\n\t\t\t\tdivision_(A2, B, NegB, LenB, LenA1, Q1, QF, R)\n\n\t    ;   append(QC, [48], Q1), LenA1 is LenA - 1,\n\t        division_(A, B, NegB, LenB, LenA1, Q1, QF, R))).\n\n% extract(+Len, ?N1, +L, -Head, -Tail)\n% remove last N digits from the list L\n% put them in Tail.\nextract(Len, Len, [], [], []).\n\nextract(Len, N1, [H|T], AR1, AF1) :-\n\textract(Len, N, T, AR, AF),\n\tN1 is N-1,\n\t(   N > 0 -> AR = AR1, AF1 = [H | AF]; AR1 = [H | AR], AF1 = AF).\n\n\n\npositive(R, _, Q, Q, R) :- R = [43 | _].\n\npositive(S, B, Q, QF, R ) :-\n\tbt_add1(S, B, S1),\n\tbt_add1(Q, [45], Q1),\n\tpositive(S1, B, Q1, QF, R).\n\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n% \"euclidian\" division (inefficient)\n% euclide(?A, +BIn, ?Q, ?R)\n% A = B * Q + R\neuclide(A, B, Q, R) :-\n\tmult(A, B, Q, R).\n\n\nmult(AIn, BIn, QIn, RIn) :-\n\t(   nonvar(AIn) -> string_to_list(AIn, A); A = AIn),\n\t(   nonvar(BIn) -> string_to_list(BIn, B); B = BIn),\n\t(   nonvar(QIn) -> string_to_list(QIn, Q); Q = QIn),\n\t(   nonvar(RIn) -> string_to_list(RIn, R); R = RIn),\n\n\t% we use positive numbers\n\t(   B = [45 | _] -> Pos0 = false, neg(B,BP) ; BP = B, Pos0 = true),\n\t(   (nonvar(Q), Q = [45 | _]) -> neg(Q, QP), select(Pos0, [true, false], [Pos1])\n\t;   nonvar(Q) -> Q = QP , Pos1 = Pos0\n\t;   Pos1 = Pos0),\n\t(   (nonvar(A), A = [45 | _]) -> neg(A, AP)\n\t;   nonvar(A) -> AP = A\n\t;   true),\n\n\t% is R instancied ?\n\t( nonvar(R) -> R1 = R; true),\n\t% multiplication ? we add B to A and substract 1 (digit '-') to Q\n\t(   nonvar(Q) -> BC = BP, Ajout = [45],\n\t    (\tnonvar(R) ->  bt_add1(BC, R, AP) ; AP = BC)\n\t% division ? we substract B to A and add 1 (digit '+') to Q\n\t;    neg(BP, BC), Ajout = [43], QP = [48]),\n\n\t% do the real job\n\tmult_(BC, QP, AP, R1, Resultat, Ajout),\n\n\t(   var(QIn) -> (Pos1 = false -> neg(Resultat, QT); Resultat = QT), string_to_list(QIn, QT)\n\t;   true),\n\t(   var(AIn) -> (Pos1 = false -> neg(Resultat, AT); Resultat = AT), string_to_list(AIn, AT)\n\t;   true),\n\t(   var(RIn) -> string_to_list(RIn, R1); true).\n\n% @arg1 : divisor\n% @arg2 : quotient\n% @arg3 : dividend\n% @arg4 : remainder\n% @arg5 : Result :  receive either the dividend A\n%                           either the quotient Q\nmult_(B, Q, A, R, Resultat, Ajout) :-\n\tbt_add1(Q, Ajout, Q1),\n\tbt_add1(A, B, A1),\n\t(  Q1 = [48] -> Resultat = A % a multiplication\n\t;  ( A1 = [45 | _], Ajout = [43]) -> Resultat = Q, R = A  % a division\n\t;  mult_(B, Q1, A1, R, Resultat, Ajout)) .\n"
                },
                {
                    "language": "C-sharp",
                    "solution": "using System;\nusing System.Text;\nusing System.Collections.Generic;\n\npublic class BalancedTernary\n{\n\tpublic static void Main()\n\t{\n\t\tBalancedTernary a = new BalancedTernary(\"+-0++0+\");\n\t\tSystem.Console.WriteLine(\"a: \" + a + \" = \" + a.ToLong());\n\t\tBalancedTernary b = new BalancedTernary(-436);\n\t\tSystem.Console.WriteLine(\"b: \" + b + \" = \" + b.ToLong());\n\t\tBalancedTernary c = new BalancedTernary(\"+-++-\");\n\t\tSystem.Console.WriteLine(\"c: \" + c + \" = \" + c.ToLong());\n\t\tBalancedTernary d = a * (b - c);\n\t\tSystem.Console.WriteLine(\"a * (b - c): \" + d + \" = \" + d.ToLong());\n\t}\n\n\tprivate enum BalancedTernaryDigit\n\t{\n\t\tMINUS = -1,\n\t\tZERO = 0,\n\t\tPLUS = 1\n\t}\n\n\tprivate BalancedTernaryDigit[] value;\n\n\t// empty = 0\n\tpublic BalancedTernary()\n\t{\n\t\tthis.value = new BalancedTernaryDigit[0];\n\t}\n\n\t// create from String\n\tpublic BalancedTernary(String str)\n\t{\n\t\tthis.value = new BalancedTernaryDigit[str.Length];\n\t\tfor (int i = 0; i < str.Length; ++i)\n\t\t{\n\t\t\tswitch (str[i])\n\t\t\t{\n\t\t\t\tcase '-':\n\t\t\t\t\tthis.value[i] = BalancedTernaryDigit.MINUS;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '0':\n\t\t\t\t\tthis.value[i] = BalancedTernaryDigit.ZERO;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '+':\n\t\t\t\t\tthis.value[i] = BalancedTernaryDigit.PLUS;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new ArgumentException(\"Unknown Digit: \" + str[i]);\n\t\t\t}\n\t\t}\n\t\tArray.Reverse(this.value);\n\t}\n\n\t// convert long integer\n\tpublic BalancedTernary(long l)\n\t{\n\t\tList<BalancedTernaryDigit> value = new List<BalancedTernaryDigit>();\n\t\tint sign = Math.Sign(l);\n\t\tl = Math.Abs(l);\n\t\t\n\t\twhile (l != 0)\n\t\t{\n\t\t\tbyte rem = (byte)(l % 3);\n\t\t\tswitch (rem)\n\t\t\t{\n\t\t\t\tcase 0:\n\t\t\t\tcase 1:\n\t\t\t\t\tvalue.Add((BalancedTernaryDigit)rem);\n\t\t\t\t\tl /= 3;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tvalue.Add(BalancedTernaryDigit.MINUS);\n\t\t\t\t\tl = (l + 1) / 3;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tthis.value = value.ToArray();\n\t\tif (sign < 0)\n\t\t{\n\t\t\tthis.Invert();\n\t\t}\n\t}\n\n\t// copy constructor\n\tpublic BalancedTernary(BalancedTernary origin)\n\t{\n\t\tthis.value = new BalancedTernaryDigit[origin.value.Length];\n\t\tArray.Copy(origin.value, this.value, origin.value.Length);\n\t}\n\n\t// only for internal use\n\tprivate BalancedTernary(BalancedTernaryDigit[] value)\n\t{\n\t\tint end = value.Length - 1;\n\t\twhile (value[end] == BalancedTernaryDigit.ZERO)\n\t\t\t--end;\n\t\tthis.value = new BalancedTernaryDigit[end + 1];\n\t\tArray.Copy(value, this.value, end + 1);\n\t}\n\n\t// invert the values\n\tprivate void Invert()\n\t{\n\t\tfor (int i=0; i < this.value.Length; ++i)\n\t\t{\n\t\t\tthis.value[i] = (BalancedTernaryDigit)(-(int)this.value[i]);\n\t\t}\n\t}\n\n\t// convert to string\n\toverride public String ToString()\n\t{\n\t\tStringBuilder result = new StringBuilder();\n\t\tfor (int i = this.value.Length - 1; i >= 0; --i)\n\t\t{\n\t\t\tswitch (this.value[i])\n\t\t\t{\n\t\t\t\tcase BalancedTernaryDigit.MINUS:\n\t\t\t\t\tresult.Append('-');\n\t\t\t\t\tbreak;\n\t\t\t\tcase BalancedTernaryDigit.ZERO:\n\t\t\t\t\tresult.Append('0');\n\t\t\t\t\tbreak;\n\t\t\t\tcase BalancedTernaryDigit.PLUS:\n\t\t\t\t\tresult.Append('+');\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn result.ToString();\n\t}\n\n\t// convert to long\n\tpublic long ToLong()\n\t{\n\t\tlong result = 0;\n\t\tint digit;\n\t\tfor (int i = 0; i < this.value.Length; ++i)\n\t\t{\n\t\t\tresult += (long)this.value[i] * (long)Math.Pow(3.0, (double)i);\n\t\t}\n\t\treturn result;\n\t}\n\n\t// unary minus\n\tpublic static BalancedTernary operator -(BalancedTernary origin)\n\t{\n\t\tBalancedTernary result = new BalancedTernary(origin);\n\t\tresult.Invert();\n\t\treturn result;\n\t}\n\n\t// addition of digits\n\tprivate static BalancedTernaryDigit carry = BalancedTernaryDigit.ZERO;\n\tprivate static BalancedTernaryDigit Add(BalancedTernaryDigit a, BalancedTernaryDigit b)\n\t{\n\t\tif (a != b)\n\t\t{\n\t\t\tcarry = BalancedTernaryDigit.ZERO;\n\t\t\treturn (BalancedTernaryDigit)((int)a + (int)b);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcarry = a;\n\t\t\treturn (BalancedTernaryDigit)(-(int)b);\n\t\t}\n\t}\n\n\t// addition of balanced ternary numbers\n\tpublic static BalancedTernary operator +(BalancedTernary a, BalancedTernary b)\n\t{\n\t\tint maxLength = Math.Max(a.value.Length, b.value.Length);\n\t\tBalancedTernaryDigit[] resultValue = new BalancedTernaryDigit[maxLength + 1];\n\t\tfor (int i=0; i < maxLength; ++i)\n\t\t{\n\t\t\tif (i < a.value.Length)\n\t\t\t{\n\t\t\t\tresultValue[i] = Add(resultValue[i], a.value[i]);\n\t\t\t\tresultValue[i+1] = carry;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcarry = BalancedTernaryDigit.ZERO;\n\t\t\t}\n\t\t\t\n\t\t\tif (i < b.value.Length)\n\t\t\t{\n\t\t\t\tresultValue[i] = Add(resultValue[i], b.value[i]);\n\t\t\t\tresultValue[i+1] = Add(resultValue[i+1], carry);\n\t\t\t}\n\t\t}\n\t\treturn new BalancedTernary(resultValue);\n\t}\n\n\t// subtraction of balanced ternary numbers\n\tpublic static BalancedTernary operator -(BalancedTernary a, BalancedTernary b)\n\t{\n\t\treturn a + (-b);\n\t}\n\n\t// multiplication of balanced ternary numbers\n\tpublic static BalancedTernary operator *(BalancedTernary a, BalancedTernary b)\n\t{\n\t\tBalancedTernaryDigit[] longValue = a.value;\n\t\tBalancedTernaryDigit[] shortValue = b.value;\n\t\tBalancedTernary result = new BalancedTernary();\n\t\tif (a.value.Length < b.value.Length)\n\t\t{\n\t\t\tlongValue = b.value;\n\t\t\tshortValue = a.value;\n\t\t}\n\n\t\tfor (int i = 0; i < shortValue.Length; ++i)\n\t\t{\n\t\t\tif (shortValue[i] != BalancedTernaryDigit.ZERO)\n\t\t\t{\n\t\t\t\tBalancedTernaryDigit[] temp = new BalancedTernaryDigit[i + longValue.Length];\n\t\t\t\tfor (int j = 0; j < longValue.Length; ++j)\n\t\t\t\t{\n\t\t\t\t\ttemp[i+j] = (BalancedTernaryDigit)((int)shortValue[i] * (int)longValue[j]);\n\t\t\t\t}\n\t\t\t\tresult = result + new BalancedTernary(temp);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n}\n"
                }
            ],
            [
                {
                    "language": "D",
                    "solution": "import std.stdio, std.bigint, std.range, std.algorithm;\n\nstruct BalancedTernary {\n    // Represented as a list of 0, 1 or -1s,\n    // with least significant digit first.\n    enum Dig : byte { N=-1, Z=0, P=+1 } // Digit.\n    const Dig[] digits;\n\n    // This could also be a BalancedTernary template argument.\n    static immutable string dig2str = \"-0+\";\n\n    immutable static Dig[dchar] str2dig; // = ['+': Dig.P, ...];\n    nothrow static this() {\n        str2dig = ['+': Dig.P, '-':  Dig.N, '0': Dig.Z];\n    }\n\n    immutable pure nothrow static Dig[2][] table =\n        [[Dig.Z, Dig.N], [Dig.P, Dig.N], [Dig.N, Dig.Z],\n         [Dig.Z, Dig.Z], [Dig.P, Dig.Z], [Dig.N, Dig.P],\n         [Dig.Z, Dig.P]];\n\n    this(in string inp) const pure {\n        this.digits = inp.retro.map!(c => str2dig[c]).array;\n    }\n\n    this(in long inp) const pure nothrow {\n        this.digits = _bint2ternary(inp.BigInt);\n    }\n\n    this(in BigInt inp) const pure nothrow {\n        this.digits = _bint2ternary(inp);\n    }\n\n    this(in BalancedTernary inp) const pure nothrow {\n        // No need to dup, they are virtually immutable.\n        this.digits = inp.digits;\n    }\n\n    private this(in Dig[] inp) pure nothrow {\n        this.digits = inp;\n    }\n\n    static Dig[] _bint2ternary(in BigInt n) pure nothrow {\n        static py_div(T1, T2)(in T1 a, in T2 b) pure nothrow {\n            if (a < 0) {\n                return (b < 0) ?\n                       -a / -b :\n                       -(-a / b) - (-a % b != 0 ? 1 : 0);\n            } else {\n                return (b < 0) ?\n                       -(a / -b) - (a % -b != 0 ? 1 : 0) :\n                       a / b;\n            }\n        }\n\n        if (n == 0) return [];\n        // This final switch in D v.2.064 is fake, not enforced.\n        final switch (((n % 3) + 3) % 3) { // (n % 3) is the remainder.\n            case 0: return Dig.Z ~ _bint2ternary(py_div(n, 3));\n            case 1: return Dig.P ~ _bint2ternary(py_div(n, 3));\n            case 2: return Dig.N ~ _bint2ternary(py_div(n + 1, 3));\n        }\n    }\n\n    @property BigInt toBint() const pure nothrow {\n        return reduce!((y, x) => x + 3 * y)(0.BigInt, digits.retro);\n    }\n\n    string toString() const pure nothrow {\n        if (digits.empty) return \"0\";\n        return digits.retro.map!(d => dig2str[d + 1]).array;\n    }\n\n    static const(Dig)[] neg_(in Dig[] digs) pure nothrow {\n        return digs.map!(a => -a).array;\n    }\n\n    BalancedTernary opUnary(string op:\"-\")() const pure nothrow {\n        return BalancedTernary(neg_(this.digits));\n    }\n\n    static const(Dig)[] add_(in Dig[] a, in Dig[] b, in Dig c=Dig.Z)\n    pure nothrow {\n        const a_or_b = a.length ? a : b;\n        if (a.empty || b.empty) {\n            if (c == Dig.Z)\n                return a_or_b;\n            else\n                return BalancedTernary.add_([c], a_or_b);\n        } else {\n            // (const d, c) = table[...];\n            const dc = table[3 + (a.length ? a[0] : 0) +\n                             (b.length ? b[0] : 0) + c];\n            const res = add_(a[1 .. $], b[1 .. $], dc[1]);\n            // Trim leading zeros.\n            if (res.length || dc[0] != Dig.Z)\n                return [dc[0]] ~ res;\n            else\n                return res;\n        }\n    }\n\n    BalancedTernary opBinary(string op:\"+\")(in BalancedTernary b)\n    const pure nothrow {\n        return BalancedTernary(add_(this.digits, b.digits));\n    }\n\n    BalancedTernary opBinary(string op:\"-\")(in BalancedTernary b)\n    const pure nothrow {\n        return this + (-b);\n    }\n\n    static const(Dig)[] mul_(in Dig[] a, in Dig[] b) pure nothrow {\n        if (a.empty || b.empty) {\n            return [];\n        } else {\n            const y = Dig.Z ~ mul_(a[1 .. $], b);\n            final switch (a[0]) {\n                case Dig.N: return add_(neg_(b), y);\n                case Dig.Z: return add_([], y);\n                case Dig.P: return add_(b, y);\n            }\n        }\n    }\n\n    BalancedTernary opBinary(string op:\"*\")(in BalancedTernary b)\n    const pure nothrow {\n        return BalancedTernary(mul_(this.digits, b.digits));\n    }\n}\n\nvoid main() {\n    immutable a = BalancedTernary(\"+-0++0+\");\n    writeln(\"a: \", a.toBint, ' ', a);\n\n    immutable b = BalancedTernary(-436);\n    writeln(\"b: \", b.toBint, ' ', b);\n\n    immutable c = BalancedTernary(\"+-++-\");\n    writeln(\"c: \", c.toBint, ' ', c);\n\n    const /*immutable*/ r = a * (b - c);\n    writeln(\"a * (b - c): \", r.toBint, ' ', r);\n}\n"
                },
                {
                    "language": "FreeBASIC",
                    "solution": "#define MAX(a, b) iif((a) > (b), (a), (b))\nDim Shared As Integer pow, signo\nDim Shared As String t\nt = \"-0+\"\n\nFunction deci(cadena As String) As Integer\n    Dim As Integer i, deci1\n    Dim As String c1S\n    pow = 1\n    For i = Len(cadena) To 1 Step -1\n        c1S = Mid(cadena,i,1)\n        signo = Instr(t, c1S)-2\n        deci1 = deci1 + pow * signo\n        pow *= 3\n    Next i\n    Return deci1\nEnd Function\n\nFunction ternary(n As Integer) As String\n    Dim As String ternario\n    Dim As Integer i, k\n    While Abs(n) > 3^k/2\n        k += 1\n    Wend\n    k -= 1\n\n    pow = 3^k\n    For i = k To 0 Step -1\n        signo = (n>0) - (n<0)\n        signo *= (Abs(n) > pow/2)\n        ternario += Mid(t,signo+2,1)\n        n -= signo*pow\n        pow /= 3\n    Next\n    If ternario = \"\" Then ternario = \"0\"\n    Return ternario\nEnd Function\n\nFunction negate(cadena As String) As String\n    Dim As String negar = \"\"\n    For i As Integer = 1 To Len(cadena)\n        negar += Mid(t, 4-Instr(t, Mid(cadena,i,1)), 1)\n    Next i\n    Return negar\nEnd Function\n\nFunction pad(cadenaA As String, n As Integer) As String\n    Dim As String relleno = cadenaA\n    While Len(relleno) < n\n        relleno = \"0\" + relleno\n    Wend\n    Return relleno\nEnd Function\n\nFunction addTernary(cadenaA As String, cadenaB As String) As String\n    Dim As Integer l = max(Len(cadenaA), Len(cadenaB))\n    Dim As Integer i, x, y, z\n    cadenaA = pad(cadenaA, l)\n    cadenaB = pad(cadenaB, l)\n    Dim As String resultado = \"\"\n    Dim As Byte llevar = 0\n    For i = l To 1 Step -1\n        x = Instr(t, Mid(cadenaA,i,1))-2\n        y = Instr(t, Mid(cadenaB,i,1))-2\n        z = x + y + llevar\n\n        If Abs(z) < 2 Then\n            llevar = 0\n        Elseif z > 0 Then\n            llevar = 1: z -= 3\n        Elseif z < 0 Then\n            llevar = -1: z += 3\n        End If\n\n        resultado = Mid(t,z+2,1) + resultado\n    Next i\n    If llevar <> 0 Then resultado = Mid(t,llevar+2,1) + resultado\n\n    i = 0\n    While Mid(resultado,i+1,1) = \"0\"\n        i += 1\n    Wend\n    resultado = Mid(resultado,i+1)\n    If resultado = \"\" Then resultado = \"0\"\n    Return resultado\nEnd Function\n\nFunction subTernary(cadenaA As String, cadenaB As String) As String\n    Return addTernary(cadenaA, negate(cadenaB))\nEnd Function\n\nFunction multTernary(cadenaA As String, cadenaB As String) As String\n    Dim As String resultado = \"\"\n    Dim As String tS = \"\", cambio = \"\"\n    For i As Integer = Len(cadenaA) To 1 Step -1\n        Select Case Mid(cadenaA,i,1)\n        Case \"+\": tS = cadenaB\n        Case \"0\": tS = \"0\"\n        Case \"-\": tS = negate(cadenaB)\n        End Select\n\n        resultado = addTernary(resultado, tS + cambio)\n        cambio += \"0\"\n    Next i\n    Return resultado\nEnd Function\n\n\nDim As String cadenaA = \"+-0++0+\"\nDim As Integer a = deci(cadenaA)\nPrint \"      a:\", a, cadenaA\n\nDim As Integer b = -436\nDim As String cadenaB = ternary(b)\nPrint \"      b:\", b, cadenaB\n\nDim As String cadenaC = \"+-++-\"\nDim As Integer c = deci(cadenaC)\nPrint \"      c:\", c, cadenaC\n\n'calcular en ternario\nDim As String resS = multTernary(cadenaA, subTernary(cadenaB, cadenaC))\nPrint \"a*(b-c):\", deci(resS), resS\n\nPrint !\"\\nComprobamos:\"\nPrint \"a*(b-c): \", a * (b - c)\nSleep\n"
                }
            ]
        ]
    },
    {
        "task_name": "Barnsley-fern",
        "task_description": "A [[wp:Barnsley_fern|Barnsley fern]] is a fractal named after British mathematician Michael Barnsley and can be created using an iterated function system (IFS).\n\n\n;Task:\nCreate this fractal fern, using the following transformations:\n* \u01921 &nbsp; (chosen 1% of the time)\n         xn + 1 = 0\n         yn + 1 = 0.16 yn\n\n* \u01922 &nbsp; (chosen 85% of the time)\n         xn + 1 = 0.85 xn + 0.04 yn\n         yn + 1 = \u22120.04 xn + 0.85 yn + 1.6\n\n* \u01923 &nbsp; (chosen 7% of the time)\n         xn + 1 = 0.2 xn \u2212 0.26 yn\n         yn + 1 = 0.23 xn + 0.22 yn + 1.6\n\n* \u01924 &nbsp; (chosen 7% of the time)\n         xn + 1 = \u22120.15 xn + 0.28 yn\n         yn + 1 = 0.26 xn + 0.24 yn + 0.44.\n\nStarting position: x = 0, y = 0\n<br><br>\n\n",
        "solution_pairs": [
            [
                {
                    "language": "Quackery",
                    "solution": "  [ $ \"turtleduck.qky\" loadfile ] now!\n\n  [ ' [ 79 121 66 ] fill\n     [ 3 2 circle ] ]       is dot       (         -->         )\n\n  [ 1 fly\n    -1 4 turn\n    1 fly\n    1 4 turn ]              is toxy      (     n n -->         )\n\n  [ 100 1 v* /\n    dip [ 100 1 v* / ]\n    2dup toxy\n    dot\n    1 2 turn\n    toxy\n    1 2 turn ]              is plot      (     n n -->         )\n\n\n  [ 2swap 2drop 0 1\n    2swap 16 100 v* ]       is f1        ( n/d n/d --> n/d n/d )\n\n  [ 2over -4 100 v*\n    2over 85 100 v*\n    16 10 v+ v+\n    join dip\n      [ 4 100 v*\n        2swap 85 100 v*\n        v+ ]\n    do ]                    is f2        ( n/d n/d --> n/d n/d )\n\n  [ 2over 23 100 v*\n    2over 22 100 v*\n    16 10 v+ v+\n    join dip\n      [ -26 100 v*\n        2swap 20 100 v*\n        v+ ]\n    do ]                    is f3        ( n/d n/d --> n/d n/d )\n\n  [ 2over 26 100 v*\n    2over 24 100 v*\n    44 100 v+ v+\n    join dip\n      [ 28 100 v*\n        2swap -15 100 v*\n        v+ ]\n    do ]                    is f4        ( n/d n/d --> n/d n/d )\n\n  [ 100 random\n    [ dup 0 = iff\n        [ drop f1 ] done\n      dup 86 < iff\n        [ drop f2 ] done\n      93 < iff f3   done\n      f4 ]\n     2swap 1000000000 round\n     2swap 1000000000 round\n     2over 2over plot ]     is nextpoint ( n/d n/d --> n/d n/d )\n\n  turtle\n  ' [ 79 121 66 ] colour\n  -500 1 fly\n  0 1 0 1\n  0 frames\n  20000 times nextpoint\n  1 frames\n  4 times drop\n"
                },
                {
                    "language": "Applesoft-BASIC",
                    "solution": " 100  LET YY(1) = .16\n 110  XX(2) =    .85:XY(2) = .04\n 120  YX(2) =  - .04:YY(2) = .85\n 130  LET Y(2) = 1.6\n 140  XX(3) = .20:XY(3) =  - .26\n 150  YX(3) = .23:YY(3) =    .22\n 160  LET Y(3) = 1.6\n 170  XX(4) =  - .15:XY(4) = .28\n 180  YX(4) =    .26:YY(4) = .24\n 190  LET Y(4) = .44\n 200  HGR :I =  PEEK (49234)\n 210  HCOLOR= 1\n 220  LET X = 0:Y = 0\n 230  FOR I = 1 TO 100000\n 240      R =  INT ( RND (1) * 100)\n 250      F = (R < 7) + (R < 14) + 2\n 260      F = F - (R = 99)\n 270      X = XX(F) * X + XY(F) * Y\n 280      Y = YX(F) * X + YY(F) * Y\n 290      Y = Y + Y(F)\n 300      X% = 62 + X * 27.9\n 320      Y% = 192 - Y * 19.1\n 330      HPLOT X% * 2 + 1,Y%\n 340  NEXT\n"
                }
            ],
            [
                {
                    "language": "XPL0",
                    "solution": "int  N, R;\nreal NX, NY, X, Y;\n[SetVid($12);           \\set 640x480x4 VGA graphics (on PC or RPi)\nX:= 0.0;  Y:= 0.0;\nfor N:= 0 to 200_000 do\n        [R:= Ran(100);  \\0..99\n        case of\n        R < 1:  [NX:= 0.0;              NY:= 0.16*Y];\n        R < 8:  [NX:= 0.20*X - 0.26*Y;  NY:= 0.23*X + 0.22*Y + 1.60];\n        R < 15: [NX:=-0.15*X + 0.28*Y;  NY:= 0.26*X + 0.24*Y + 0.44]\n        other   [NX:= 0.85*X + 0.04*Y;  NY:=-0.04*X + 0.85*Y + 1.60];\n        X:= NX;  Y:= NY;\n        Point(320+fix(X*40.0), 440-fix(Y*40.0), 2\\green\\);\n        ]\n]\n"
                },
                {
                    "language": "JavaScript",
                    "solution": "<html>\n <head><script src=\"BarnsleyFern.js\"></script></head>\n <body onload=\"pBarnsleyFern('canvas', 100000)\">\n   <br /> <h3>Barnsley fern fractal</h3>\n   <canvas id=\"canvas\" width=\"540\" height=\"540\" style=\"border: 2px inset;\"></canvas>\n </body>\n</html>\n"
                }
            ],
            [
                {
                    "language": "J",
                    "solution": "require 'plot'\n\nf=: |: 0 \". 1 2 }. ];._2 noun define\nw    a     b     c    d     e  f     prob\nf1  0     0     0    0.16   0 0      0.01\nf2  0.85 -0.04  0.04 0.85   0 1.60   0.85\nf3  0.20  0.23 -0.26 0.22   0 1.60   0.07\nf4 -0.15  0.26  0.28 0.24   0 0.44   0.07\n)\n\nfm=: {&(|: 2 2 $ f)\nfa=: {&(|: 4 5 { f)\nprob=: (+/\\ 6 { f) I. ?@0:\n\nifs=: (fa@] + fm@] +/ .* [) prob\ngetPoints=: ifs^:(<200000)\nplotFern=: 'dot;frame 0;grids 0;tics 0;labels 0;aspect 2;color green' plot ;/@|:\n\n   plotFern getPoints 0 0\n"
                },
                {
                    "language": "Ada",
                    "solution": "with Ada.Numerics.Discrete_Random;\n\nwith SDL.Video.Windows.Makers;\nwith SDL.Video.Renderers.Makers;\nwith SDL.Events.Events;\n\nprocedure Barnsley_Fern is\n\n   Iterations : constant := 1_000_000;\n   Width      : constant := 500;\n   Height     : constant := 750;\n   Scale      : constant := 70.0;\n\n   type Percentage is range 1 .. 100;\n   package Random_Percentages is\n      new Ada.Numerics.Discrete_Random (Percentage);\n\n   Gen      : Random_Percentages.Generator;\n   Window   : SDL.Video.Windows.Window;\n   Renderer : SDL.Video.Renderers.Renderer;\n   Event    : SDL.Events.Events.Events;\n\n   procedure Draw_Barnsley_Fern is\n      use type SDL.C.int;\n      subtype F1_Range is Percentage range Percentage'First  .. Percentage'First;\n      subtype F2_Range is Percentage range F1_Range'Last + 1 .. F1_Range'Last + 85;\n      subtype F3_Range is Percentage range F2_Range'Last + 1 .. F2_Range'Last + 7;\n      subtype F4_Range is Percentage range F3_Range'Last + 1 .. F3_Range'Last + 7;\n\n      X0, Y0 : Float := 0.00;\n      X1, Y1 : Float;\n   begin\n      for I in 1 .. Iterations loop\n         case Random_Percentages.Random (Gen) is\n\n            when F1_Range =>\n               X1 := 0.00;\n               Y1 := 0.16 * Y0;\n\n            when F2_Range =>\n               X1 :=  0.85 * X0 + 0.04 * Y0;\n               Y1 := -0.04 * X0 + 0.85 * Y0 + 1.60;\n\n            when F3_Range =>\n               X1 := 0.20 * X0 - 0.26 * Y0;\n               Y1 := 0.23 * X0 + 0.22 * Y0 + 1.60;\n\n            when F4_Range =>\n               X1 := -0.15 * X0 + 0.28 * Y0;\n               Y1 :=  0.26 * X0 + 0.24 * Y0 + 0.44;\n\n         end case;\n         Renderer.Draw (Point => (X => Width / 2 + SDL.C.int (Scale * X1),\n                                  Y => Height    - SDL.C.int (Scale * Y1)));\n         X0 := X1; Y0 := Y1;\n\n      end loop;\n   end Draw_Barnsley_Fern;\n\n   procedure Wait is\n      use type SDL.Events.Event_Types;\n   begin\n      loop\n         while SDL.Events.Events.Poll (Event) loop\n            if Event.Common.Event_Type = SDL.Events.Quit then\n               return;\n            end if;\n         end loop;\n      end loop;\n   end Wait;\n\nbegin\n   if not SDL.Initialise (Flags => SDL.Enable_Screen) then\n      return;\n   end if;\n\n   SDL.Video.Windows.Makers.Create (Win      => Window,\n                                    Title    => \"Barnsley Fern\",\n                                    Position => SDL.Natural_Coordinates'(X => 10, Y => 10),\n                                    Size     => SDL.Positive_Sizes'(Width, Height),\n                                    Flags    => 0);\n   SDL.Video.Renderers.Makers.Create  (Renderer, Window.Get_Surface);\n   Renderer.Set_Draw_Colour ((0, 0, 0, 255));\n   Renderer.Fill (Rectangle => (0, 0, Width, Height));\n   Renderer.Set_Draw_Colour ((0, 220, 0, 255));\n\n   Random_Percentages.Reset (Gen);\n   Draw_Barnsley_Fern;\n   Window.Update_Surface;\n\n   Wait;\n   Window.Finalize;\n   SDL.Finalise;\nend Barnsley_Fern;\n"
                }
            ],
            [
                {
                    "language": "C",
                    "solution": "#include<graphics.h>\n#include<stdlib.h>\n#include<stdio.h>\n#include<time.h>\n\nvoid barnsleyFern(int windowWidth, unsigned long iter){\n\t\n\tdouble x0=0,y0=0,x1,y1;\n\tint diceThrow;\n\ttime_t t;\n\tsrand((unsigned)time(&t));\n\t\n\twhile(iter>0){\n\t\tdiceThrow = rand()%100;\n\t\t\n\t\tif(diceThrow==0){\n\t\t\tx1 = 0;\n\t\t\ty1 = 0.16*y0;\n\t\t}\n\t\t\n\t\telse if(diceThrow>=1 && diceThrow<=7){\n\t\t\tx1 = -0.15*x0 + 0.28*y0;\n\t\t\ty1 = 0.26*x0 + 0.24*y0 + 0.44;\n\t\t}\n\t\t\n\t\telse if(diceThrow>=8 && diceThrow<=15){\n\t\t\tx1 = 0.2*x0 - 0.26*y0;\n\t\t\ty1 = 0.23*x0 + 0.22*y0 + 1.6;\n\t\t}\n\t\t\n\t\telse{\n\t\t\tx1 = 0.85*x0 + 0.04*y0;\n\t\t\ty1 = -0.04*x0 + 0.85*y0 + 1.6;\n\t\t}\n\t\t\n\t\tputpixel(30*x1 + windowWidth/2.0,30*y1,GREEN);\n\t\t\n\t\tx0 = x1;\n\t\ty0 = y1;\n\t\t\n\t\titer--;\n\t}\n\n}\n\nint main()\n{\n\tunsigned long num;\n\t\n\tprintf(\"Enter number of iterations : \");\n\tscanf(\"%ld\",&num);\n\t\n\tinitwindow(500,500,\"Barnsley Fern\");\n\t\n\tbarnsleyFern(500,num);\n\t\n\tgetch();\n\t\n\tclosegraph();\n\t\n\treturn 0;\n}\n"
                },
                {
                    "language": "Phix",
                    "solution": "(phixonline)-->\n <span style=\"color: #000080;font-style:italic;\">--\n -- pwa\\phix\\BarnsleyFern.exw\n -- =========================\n --</span>\n <span style=\"color: #008080;\">with</span> <span style=\"color: #008080;\">javascript_semantics</span>\n <span style=\"color: #008080;\">include</span> <span style=\"color: #000000;\">pGUI</span><span style=\"color: #0000FF;\">.</span><span style=\"color: #000000;\">e</span>\n\n <span style=\"color: #004080;\">Ihandle</span> <span style=\"color: #000000;\">dlg</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #000000;\">canvas</span>\n <span style=\"color: #004080;\">cdCanvas</span> <span style=\"color: #000000;\">cddbuffer</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #000000;\">cdcanvas</span>\n\n <span style=\"color: #008080;\">function</span> <span style=\"color: #000000;\">redraw_cb</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #004080;\">Ihandle</span> <span style=\"color: #000080;font-style:italic;\">/*canvas*/</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #004080;\">integer</span> <span style=\"color: #000080;font-style:italic;\">/*posx*/</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #004080;\">integer</span> <span style=\"color: #000080;font-style:italic;\">/*posy*/</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #004080;\">atom</span> <span style=\"color: #000000;\">x</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #000000;\">0</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #000000;\">y</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #000000;\">0</span>\n     <span style=\"color: #004080;\">integer</span> <span style=\"color: #0000FF;\">{</span><span style=\"color: #000000;\">width</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #000000;\">height</span><span style=\"color: #0000FF;\">}</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">IupGetIntInt</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">canvas</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #008000;\">\"DRAWSIZE\"</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #7060A8;\">cdCanvasActivate</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">cddbuffer</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #008080;\">for</span> <span style=\"color: #000000;\">i</span><span style=\"color: #0000FF;\">=</span><span style=\"color: #000000;\">1</span> <span style=\"color: #008080;\">to</span> <span style=\"color: #000000;\">100000</span> <span style=\"color: #008080;\">do</span>\n         <span style=\"color: #004080;\">integer</span> <span style=\"color: #000000;\">r</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">rand</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">100</span><span style=\"color: #0000FF;\">)</span>\n <span style=\"color: #000080;font-style:italic;\">--      {x, y} = iff(r&lt;=1? {             0,        0.16*y     } :\n --               iff(r&lt;=8? { 0.20*x-0.26*y, 0.23*x+0.22*y+1.60} :\n --               iff(r&lt;=15?{-0.15*x+0.28*y, 0.26*x+0.24*y+0.44} :\n --                         { 0.85*x+0.04*y,-0.04*x+0.85*y+1.60})))</span>\n         <span style=\"color: #008080;\">if</span> <span style=\"color: #000000;\">r</span><span style=\"color: #0000FF;\"><=</span><span style=\"color: #000000;\">1</span> <span style=\"color: #008080;\">then</span>        <span style=\"color: #0000FF;\">{</span><span style=\"color: #000000;\">x</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #000000;\">y</span><span style=\"color: #0000FF;\">}</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #0000FF;\">{</span>             <span style=\"color: #000000;\">0</span><span style=\"color: #0000FF;\">,</span>        <span style=\"color: #000000;\">0.16</span><span style=\"color: #0000FF;\">*</span><span style=\"color: #000000;\">y</span>     <span style=\"color: #0000FF;\">}</span>\n         <span style=\"color: #008080;\">elsif</span> <span style=\"color: #000000;\">r</span><span style=\"color: #0000FF;\"><=</span><span style=\"color: #000000;\">8</span> <span style=\"color: #008080;\">then</span>     <span style=\"color: #0000FF;\">{</span><span style=\"color: #000000;\">x</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #000000;\">y</span><span style=\"color: #0000FF;\">}</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #0000FF;\">{</span> <span style=\"color: #000000;\">0.20</span><span style=\"color: #0000FF;\">*</span><span style=\"color: #000000;\">x</span><span style=\"color: #0000FF;\">-</span><span style=\"color: #000000;\">0.26</span><span style=\"color: #0000FF;\">*</span><span style=\"color: #000000;\">y</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #000000;\">0.23</span><span style=\"color: #0000FF;\">*</span><span style=\"color: #000000;\">x</span><span style=\"color: #0000FF;\">+</span><span style=\"color: #000000;\">0.22</span><span style=\"color: #0000FF;\">*</span><span style=\"color: #000000;\">y</span><span style=\"color: #0000FF;\">+</span><span style=\"color: #000000;\">1.60</span><span style=\"color: #0000FF;\">}</span>\n         <span style=\"color: #008080;\">elsif</span> <span style=\"color: #000000;\">r</span><span style=\"color: #0000FF;\"><=</span><span style=\"color: #000000;\">15</span> <span style=\"color: #008080;\">then</span>    <span style=\"color: #0000FF;\">{</span><span style=\"color: #000000;\">x</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #000000;\">y</span><span style=\"color: #0000FF;\">}</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #0000FF;\">{-</span><span style=\"color: #000000;\">0.15</span><span style=\"color: #0000FF;\">*</span><span style=\"color: #000000;\">x</span><span style=\"color: #0000FF;\">+</span><span style=\"color: #000000;\">0.28</span><span style=\"color: #0000FF;\">*</span><span style=\"color: #000000;\">y</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #000000;\">0.26</span><span style=\"color: #0000FF;\">*</span><span style=\"color: #000000;\">x</span><span style=\"color: #0000FF;\">+</span><span style=\"color: #000000;\">0.24</span><span style=\"color: #0000FF;\">*</span><span style=\"color: #000000;\">y</span><span style=\"color: #0000FF;\">+</span><span style=\"color: #000000;\">0.44</span><span style=\"color: #0000FF;\">}</span>\n         <span style=\"color: #008080;\">else</span>                <span style=\"color: #0000FF;\">{</span><span style=\"color: #000000;\">x</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #000000;\">y</span><span style=\"color: #0000FF;\">}</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #0000FF;\">{</span> <span style=\"color: #000000;\">0.85</span><span style=\"color: #0000FF;\">*</span><span style=\"color: #000000;\">x</span><span style=\"color: #0000FF;\">+</span><span style=\"color: #000000;\">0.04</span><span style=\"color: #0000FF;\">*</span><span style=\"color: #000000;\">y</span><span style=\"color: #0000FF;\">,-</span><span style=\"color: #000000;\">0.04</span><span style=\"color: #0000FF;\">*</span><span style=\"color: #000000;\">x</span><span style=\"color: #0000FF;\">+</span><span style=\"color: #000000;\">0.85</span><span style=\"color: #0000FF;\">*</span><span style=\"color: #000000;\">y</span><span style=\"color: #0000FF;\">+</span><span style=\"color: #000000;\">1.60</span><span style=\"color: #0000FF;\">}</span>\n         <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">if</span>\n         <span style=\"color: #7060A8;\">cdCanvasPixel</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">cddbuffer</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #000000;\">width</span><span style=\"color: #0000FF;\">/</span><span style=\"color: #000000;\">2</span><span style=\"color: #0000FF;\">+</span><span style=\"color: #000000;\">x</span><span style=\"color: #0000FF;\">*</span><span style=\"color: #000000;\">50</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #000000;\">y</span><span style=\"color: #0000FF;\">*</span><span style=\"color: #000000;\">50</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #004600;\">CD_DARK_GREEN</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">for</span>\n     <span style=\"color: #7060A8;\">cdCanvasFlush</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">cddbuffer</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #008080;\">return</span> <span style=\"color: #004600;\">IUP_DEFAULT</span>\n <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">function</span>\n\n <span style=\"color: #7060A8;\">IupOpen</span><span style=\"color: #0000FF;\">()</span>\n\n <span style=\"color: #000000;\">canvas</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">IupCanvas</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #7060A8;\">Icallback</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #008000;\">\"redraw_cb\"</span><span style=\"color: #0000FF;\">),</span><span style=\"color: #008000;\">\"RASTERSIZE=340x540\"</span><span style=\"color: #0000FF;\">)</span>\n <span style=\"color: #000000;\">dlg</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">IupDialog</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">canvas</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #008000;\">`TITLE=\"Barnsley Fern\"`</span><span style=\"color: #0000FF;\">)</span>\n\n <span style=\"color: #7060A8;\">IupMap</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">dlg</span><span style=\"color: #0000FF;\">)</span>\n <span style=\"color: #000000;\">cdcanvas</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">cdCreateCanvas</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #004600;\">CD_IUP</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #000000;\">canvas</span><span style=\"color: #0000FF;\">)</span>\n <span style=\"color: #000000;\">cddbuffer</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">cdCreateCanvas</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #004600;\">CD_DBUFFER</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #000000;\">cdcanvas</span><span style=\"color: #0000FF;\">)</span>\n <span style=\"color: #7060A8;\">IupSetAttribute</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">canvas</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #008000;\">\"RASTERSIZE\"</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #004600;\">NULL</span><span style=\"color: #0000FF;\">)</span> <span style=\"color: #000080;font-style:italic;\">-- release the minimum limitation</span>\n <span style=\"color: #7060A8;\">IupShow</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">dlg</span><span style=\"color: #0000FF;\">)</span>\n <span style=\"color: #008080;\">if</span> <span style=\"color: #7060A8;\">platform</span><span style=\"color: #0000FF;\">()!=</span><span style=\"color: #004600;\">JS</span> <span style=\"color: #008080;\">then</span>\n     <span style=\"color: #7060A8;\">IupMainLoop</span><span style=\"color: #0000FF;\">()</span>\n     <span style=\"color: #7060A8;\">IupClose</span><span style=\"color: #0000FF;\">()</span>\n <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">if</span>\n<!--\n"
                }
            ],
            [
                {
                    "language": "PureBasic",
                    "solution": "EnableExplicit\nDisableDebugger\n\nDataSection\n  R84:  : Data.d 0.85,0.04,-0.04,0.85,1.6\n  R91:  : Data.d 0.2,-0.26,0.23,0.22,1.6\n  R98:  : Data.d -0.15,0.28,0.26,0.24,0.44\n  R100: : Data.d 0.0,0.0,0.0,0.16,0.0\nEndDataSection\n\nProcedure Barnsley(height.i)\n  Define x.d, y.d, xn.d, yn.d, v1.d, v2.d, v3.d, v4.d, v5.d,\n         f.d=height/10.6,\n         offset.i=Int(height/4-height/40),\n         n.i, r.i\n  For n=1 To height*50\n    r=Random(99,0)\n    Select r\n      Case 0 To 84  : Restore R84\n      Case 85 To 91 : Restore R91\n      Case 92 To 98 : Restore R98\n      Default       : Restore R100\n    EndSelect\n    Read.d v1 : Read.d v2 : Read.d v3 : Read.d v4 : Read.d v5\n    xn=v1*x+v2*y : yn=v3*x+v4*y+v5\n    x=xn : y=yn\n    Plot(offset+x*f,height-y*f,RGB(0,255,0))\n  Next\nEndProcedure\n\nDefine w1.i=400,\n       h1.i=800\n\nIf OpenWindow(0,#PB_Ignore,#PB_Ignore,w1,h1,\"Barnsley fern\")\n  If CreateImage(0,w1,h1,24,0) And StartDrawing(ImageOutput(0))\n    Barnsley(h1)\n    StopDrawing()\n  EndIf\n  ImageGadget(0,0,0,0,0,ImageID(0))\n  Repeat : Until WaitWindowEvent(50)=#PB_Event_CloseWindow\nEndIf\nEnd\n"
                },
                {
                    "language": "Run-BASIC",
                    "solution": "'Barnsley Fern - Run BASIC\n  'http://rosettacode.org/wiki/Barnsley_fern#Run_BASIC\n  'copy code and run it at http://www.runbasic.com\n  '\n  ' -----------------------------------\n  ' Barnsley Fern\n  ' -----------------------------------maxpoints\t= 20000\ngraphic #g, 200, 200\n#g fill(\"blue\")\nFOR n\t= 1 TO maxpoints\np\t= RND(0)*100\nIF p <= 1 THEN\n\tnx\t= 0\n\tny\t= 0.16 * y\nelse if p <= 8 THEN\n\tnx\t= 0.2 * x - 0.26 * y\n\tny\t= 0.23 * x + 0.22 * y + 1.6\nelse if p <= 15 THEN\n\tnx\t= -0.15 * x + 0.28 * y\n\tny\t= 0.26 * x + 0.24 * y + 0.44\nelse\n\tnx\t= 0.85 * x +0.04 * y\n\tny\t= -0.04 * x +0.85 * y + 1.6\nend if\nx\t= nx\ny\t= ny\n#g \"color green ; set \"; x * 17 + 100; \" \"; y * 17\n\nNEXT n\nrender #g\n#g \"flush\"\n"
                }
            ]
        ]
    },
    {
        "task_name": "Base64-decode-data",
        "task_description": "See [[Base64 encode data]]. \n\nNow write a program that takes the output of the [[Base64 encode data]] task as input and regenerate the original file. \n\nWhen working on the VBA implementation I found several 'solutions' on the net, including one from the software maker himself, that showed output with incorrect padding. Obviously with incorrect padding in the output you can not decode correctly to the original file again.\n\n",
        "solution_pairs": [
            [
                {
                    "language": "PHP",
                    "solution": "$encoded = 'VG8gZXJyIGlzIGh1bWFuLCBidXQgdG8gcmVhbGx5IGZvdWwgdGhpbmdzIHVw' .\n           'IHlvdSBuZWVkIGEgY29tcHV0ZXIuCiAgICAtLSBQYXVsIFIuIEVocmxpY2g=';\necho\n    $encoded, PHP_EOL,\n    base64_decode($encoded), PHP_EOL;\n"
                },
                {
                    "language": "Rust",
                    "solution": "use std::str;\n\nconst INPUT: &str = \"VG8gZXJyIGlzIGh1bWFuLCBidXQgdG8gcmVhbGx5IGZvdWwgdGhpbmdzIHVwIHlvdSBuZWVkIGEgY29tcHV0ZXIuCiAgICAtLVBhdWwgUi5FaHJsaWNo\";\nconst UPPERCASE_OFFSET: i8 = -65;\nconst LOWERCASE_OFFSET: i8 = 26 - 97;\nconst NUM_OFFSET: i8 = 52 - 48;\n\nfn main() {\n    println!(\"Input: {}\", INPUT);\n\n    let result = INPUT.chars()\n        .filter(|&ch| ch != '=')                                //Filter '=' chars\n        .map(|ch| {                                             //Map char values using Base64 Characters Table\n            let ascii = ch as i8;\n            let convert = match ch {\n                '0' ... '9' => ascii + NUM_OFFSET,\n                'a' ... 'z' => ascii + LOWERCASE_OFFSET,\n                'A' ... 'Z' => ascii + UPPERCASE_OFFSET,\n                '+' => 62,\n                '/' => 63,\n                _ => panic!(\"Not a valid base64 encoded string\")\n            };\n            format!(\"{:#08b}\", convert)[2..].to_string()        //convert indices to binary format and remove the two first digits\n        })\n        .collect::<String>()                                    //concatenate the resulting binary values\n        .chars()\n        .collect::<Vec<char>>()\n        .chunks(8)                                              //split into 8 character chunks\n        .map(|chunk| {\n            let num_str = chunk.iter().collect::<String>();\n            usize::from_str_radix(&num_str, 2).unwrap() as u8   //convert the binary string into its u8 value\n        })\n        .collect::<Vec<_>>();\n\n    let result = str::from_utf8(&result).unwrap();              //convert into UTF-8 string\n\n    println!(\"Output: {}\", result);\n}\n"
                }
            ],
            [
                {
                    "language": "Action-",
                    "solution": "BYTE FUNC FindIndex(BYTE b)\n  IF b>='A AND b<='Z THEN\n    RETURN (b-'A)\n  ELSEIF b>='a AND b<='z THEN\n    RETURN (b-'a+26)\n  ELSEIF b>='0 AND b<='9 THEN\n    RETURN (b-'0+52)\n  ELSEIF b='+ THEN\n    RETURN (62)\n  ELSEIF b='/ THEN\n    RETURN (63)\n  FI\nRETURN (-1)\n\nPROC PrintChar(CHAR c)\n  IF c=10 THEN\n    PutE()\n  ELSE\n    Put(c)\n  FI\nRETURN\n\nPROC Decode(CHAR ARRAY s)\n  BYTE i,b1,b2,b3,b4,i1,i2,i3,i4\n  CHAR c\n\n  IF s(0) MOD 4#0 THEN\n    PrintE(\"Invalid length of string!!!\")\n    Break()\n  FI\n\n  i=1\n  WHILE i<=s(0)\n  DO\n    b1=s(i) i==+1\n    b2=s(i) i==+1\n    b3=s(i) i==+1\n    b4=s(i) i==+1\n\n    i1=FindIndex(b1)\n    i2=FindIndex(b2)\n\n    c=i1 LSH 2\n    c==%i2 RSH 4\n    PrintChar(c)\n\n    IF b3#'= THEN\n      i3=FindIndex(b3)\n      c=(i2&$0F) LSH 4\n      c==%i3 RSH 2\n      PrintChar(c)\n\n      IF b4#'= THEN\n        i4=FindIndex(b4)\n        c=(i3&$03) LSH 6\n        c==%i4\n        PrintChar(c)\n      FI\n    FI\n  OD\nRETURN\n\nPROC Test(CHAR ARRAY s)\n  PrintE(\"Encoded:\")\n  PrintE(s)\n  PutE()\n  PrintE(\"Decoded:\")\n  Decode(s)\n  PutE()\nRETURN\n\nPROC Main()\n  Test(\"VG8gZXJyIGlzIGh1bWFuLCBidXQgdG8gcmVhbGx5IGZvdWwgdGhpbmdzIHVwIHlvdSBuZWVkIGEgY29tcHV0ZXIuCiAgICAtLVBhdWwgUi5FaHJsaWNo\")\nRETURN\n"
                },
                {
                    "language": "Julia",
                    "solution": "using Base64\n\nio = IOBuffer()\n\niob64_decode = Base64DecodePipe(io)\n\nwrite(io, \"VG8gZXJyIGlzIGh1bWFuLCBidXQgdG8gcmVhbGx5IGZvdWwgdGhpbmdzIHVwIHlvdSBuZWVkIGEgY29tcHV0ZXIuCiAgICAtLVBhdWwgUi5FaHJsaWNo\")\n\nseekstart(io)\n\nprintln(String(read(iob64_decode)))\n"
                }
            ],
            [
                {
                    "language": "Kotlin",
                    "solution": "import java.util.Base64\n\nfun main() {\n    val data =\n        \"VG8gZXJyIGlzIGh1bWFuLCBidXQgdG8gcmVhbGx5IGZvdWwgdGhpbmdzIHVwIHlvdSBuZWVkIGEgY29tcHV0ZXIuCiAgICAtLSBQYXVsIFIuIEVocmxpY2g=\"\n    val decoder = Base64.getDecoder()\n    val decoded = decoder.decode(data)\n    val decodedStr = String(decoded, Charsets.UTF_8)\n    println(decodedStr)\n}\n"
                },
                {
                    "language": "Tcl",
                    "solution": "package require tcl 8.6\nset data VG8gZXJyIGlzIGh1bWFuLCBidXQgdG8gcmVhbGx5IGZvdWwgdGhpbmdzIHVwIHlvdSBuZWVkIGEgY29tcHV0ZXIuCiAgICAtLSBQYXVsIFIuIEVocmxpY2g=\n\nputs [binary decode base64 $data]\n"
                }
            ],
            [
                {
                    "language": "Haxe",
                    "solution": "class Main {\n  static function main() {\n    var data = \"VG8gZXJyIGlzIGh1bWFuLCBidXQgdG8gcmVhbGx5IGZvdWwgdGhpbmdzIHVw\" +\n               \"IHlvdSBuZWVkIGEgY29tcHV0ZXIuCiAgICAtLSBQYXVsIFIuIEVocmxpY2g=\";\n    Sys.println('$data\\n');\n    var decoded = haxe.crypto.Base64.decode(data);\n    Sys.println(decoded);\n  }\n}\n"
                },
                {
                    "language": "Raku",
                    "solution": "my $e64 = '\nVG8gZXJyIGlzIGh1bWFuLCBidXQgdG8gcmVhbGx5IGZvdWwgdGhpbmdzIHVwIHlvdSBuZWVkIGEgY2\n9tcHV0ZXIuCiAgICAtLSBQYXVsIFIuIEVocmxpY2g=\n';\n\nmy @base64map = flat 'A' .. 'Z', 'a' .. 'z', ^10, '+', '/';\nmy %base64 is default(0) = @base64map.pairs.invert;\n\nsub base64-decode-slow ($enc) {\n    my $buf = Buf.new;\n    for $enc.subst(/\\s/, '', :g).comb(4) -> $chunck {\n        $buf.append: |(sprintf \"%06d%06d%06d%06d\", |$chunck.comb.map:\n            {%base64{$_}.base(2)}).comb(8).map: {:2($_)};\n    }\n    $buf\n}\n\nsay 'Slow:';\nsay base64-decode-slow($e64).decode('utf8');\n\n\n# Of course, the above routine is slow and is only for demonstration purposes.\n# For real code you should use a module, which is MUCH faster and heavily tested.\nsay \"\\nFast:\";\nuse Base64::Native;\nsay base64-decode($e64).decode('utf8');\n"
                }
            ],
            [
                {
                    "language": "Python",
                    "solution": "import base64\ndata = 'VG8gZXJyIGlzIGh1bWFuLCBidXQgdG8gcmVhbGx5IGZvdWwgdGhpbmdzIHVwIHlvdSBuZWVkIGEgY29tcHV0ZXIuCiAgICAtLSBQYXVsIFIuIEVocmxpY2g='\nprint(base64.b64decode(data).decode('utf-8'))\n"
                },
                {
                    "language": "Phix",
                    "solution": "(phixonline)-->\n <span style=\"color: #008080;\">with</span> <span style=\"color: #008080;\">javascript_semantics</span>\n <span style=\"color: #008080;\">include</span> <span style=\"color: #000000;\">builtins</span><span style=\"color: #0000FF;\">\\</span><span style=\"color: #000000;\">base64</span><span style=\"color: #0000FF;\">.</span><span style=\"color: #000000;\">e</span>\n <span style=\"color: #004080;\">string</span> <span style=\"color: #000000;\">s</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #008000;\">\"Rosetta Code Base64 decode data task\"</span>\n <span style=\"color: #004080;\">string</span> <span style=\"color: #000000;\">e</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">encode_base64</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">s</span><span style=\"color: #0000FF;\">)</span>\n <span style=\"color: #0000FF;\">?</span><span style=\"color: #000000;\">e</span>\n <span style=\"color: #0000FF;\">?</span><span style=\"color: #7060A8;\">decode_base64</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">e</span><span style=\"color: #0000FF;\">)</span>\n<!--\n"
                }
            ]
        ]
    },
    {
        "task_name": "Bell-numbers",
        "task_description": "[[wp:Bell number|Bell or exponential numbers]] are enumerations of the number of different ways to partition a set that has exactly '''n''' elements. Each element of the sequence '''B<sub>n</sub>''' is the number of partitions of a set of size '''n''' where order of the elements and order of the partitions are non-significant. E.G.: '''{a b}''' is the same as '''{b a}''' and '''{a} {b}''' is the same as '''{b} {a}'''.\n\n\n;So:\n\n:'''B<sub>0</sub> = 1''' trivially. There is only one way to partition a set with zero elements. '''{ }'''\n\n:'''B<sub>1</sub> = 1''' There is only one way to partition a set with one element. '''{a}'''\n\n:'''B<sub>2</sub> = 2''' Two elements may be partitioned in two ways. '''{a} {b}, {a b}'''\n\n:'''B<sub>3</sub> = 5''' Three elements may be partitioned in five ways '''{a} {b} {c}, {a b} {c}, {a} {b c}, {a c} {b}, {a b c}'''\n\n: and so on.\n\n\nA simple way to find the Bell numbers is construct a '''[[wp:Bell_triangle|Bell triangle]]''', also known as an '''Aitken's array''' or '''Peirce triangle''', and read off the numbers in the first column of each row. There are other generating algorithms though, and you are free to choose the best / most appropriate for your case.\n\n\n;Task:\n\nWrite a routine (function, generator, whatever) to generate the Bell number sequence and call the routine to show here, on this page at least the '''first 15''' and (if your language supports big Integers) '''50th''' elements of the sequence. \n\nIf you ''do'' use the Bell triangle method to generate the numbers, also show the '''first ten rows''' of the Bell triangle.\n\n\n;See also:\n\n:* '''[[oeis:A000110|OEIS:A000110 Bell or exponential numbers]]'''\n:* '''[[oeis:A011971|OEIS:A011971 Aitken's array]]'''\n\n",
        "solution_pairs": [
            [
                {
                    "language": "Prolog",
                    "solution": "bell(N, Bell):-\n    bell(N, Bell, [], _).\n\nbell(0, [[1]|T], T, [1]):-!.\nbell(N, Bell, B, Row):-\n    N1 is N - 1,\n    bell(N1, Bell, [Row|B], Last),\n    next_row(Row, Last).\n\nnext_row([Last|Bell], Bell1):-\n    last(Bell1, Last),\n    next_row1(Last, Bell, Bell1).\n\nnext_row1(_, [], []):-!.\nnext_row1(X, [Y|Rest], [B|Bell]):-\n    Y is X + B,\n    next_row1(Y, Rest, Bell).\n\nprint_bell_numbers(_, 0):-!.\nprint_bell_numbers([[Number|_]|Bell], N):-\n    writef('%w\\n', [Number]),\n    N1 is N - 1,\n    print_bell_numbers(Bell, N1).\n\nprint_bell_rows(_, 0):-!.\nprint_bell_rows([Row|Rows], N):-\n    print_bell_row(Row),\n    N1 is N - 1,\n    print_bell_rows(Rows, N1).\n\nprint_bell_row([Number]):-\n    !,\n    writef('%w\\n', [Number]).\nprint_bell_row([Number|Numbers]):-\n    writef('%w ', [Number]),\n    print_bell_row(Numbers).\n\nmain:-\n    bell(49, Bell),\n    writef('First 15 Bell numbers:\\n'),\n    print_bell_numbers(Bell, 15),\n    last(Bell, [Number|_]),\n    writef('\\n50th Bell number: %w\\n', [Number]),\n    writef('\\nFirst 10 rows of Bell triangle:\\n'),\n    print_bell_rows(Bell, 10).\n"
                },
                {
                    "language": "APL",
                    "solution": "bell\u2190{\n    tr\u2190\u2191(\u22a2,(\u2282\u2283\u2218\u233d+0,+\\)\u2218\u2283\u2218\u233d)\u236314\u22a2,\u2282,1\n    \u2395\u2190'First 15 Bell numbers:'\n    \u2395\u2190tr[;1]\n    \u2395\u2190'First 10 rows of Bell''s triangle:'\n    \u2395\u2190tr[\u237310;\u237310]\n}\n"
                }
            ],
            [
                {
                    "language": "D",
                    "solution": "import std.array : uninitializedArray;\nimport std.bigint;\nimport std.stdio : writeln, writefln;\n\nauto bellTriangle(int n) {\n    auto tri = uninitializedArray!(BigInt[][])(n);\n    foreach (i; 0..n) {\n        tri[i] = uninitializedArray!(BigInt[])(i);\n        tri[i][] = BigInt(0);\n    }\n    tri[1][0] = 1;\n    foreach (i; 2..n) {\n        tri[i][0] = tri[i - 1][i - 2];\n        foreach (j; 1..i) {\n            tri[i][j] = tri[i][j - 1] + tri[i - 1][j - 1];\n        }\n    }\n    return tri;\n}\n\nvoid main() {\n    auto bt = bellTriangle(51);\n    writeln(\"First fifteen and fiftieth Bell numbers:\");\n    foreach (i; 1..16) {\n        writefln(\"%2d: %d\", i, bt[i][0]);\n    }\n    writeln(\"50: \", bt[50][0]);\n    writeln;\n    writeln(\"The first ten rows of Bell's triangle:\");\n    foreach (i; 1..11) {\n        writeln(bt[i]);\n    }\n}\n"
                },
                {
                    "language": "Chipmunk-Basic",
                    "solution": "100 cls\n110 dim a(13)\n120 for i = 0 to ubound(a) : a(i) = 0 : next i\n130 n = 0\n140 a(0) = 1\n150 displayrow()\n160 while n <= ubound(a)\n170  a(n) = a(0)\n180  j = n\n190  while j >= 1\n200   jm1 = j-1\n210   a(jm1) = a(jm1)+a(j)\n220   j = j-1\n230  wend\n240  n = n+1\n250  displayrow()\n260 wend\n270 end\n280 sub displayrow()\n290  print \"B(\";\n300  print right$(str$(n),2)\") = \" a(0)\n310 return\n"
                }
            ],
            [
                {
                    "language": "AutoHotkey",
                    "solution": ";-----------------------------------\nBell_triangle(maxRows){\n\trow := 1, col := 1, Arr := []\n\tArr[row, col] := 1\n\twhile (Arr.Count() < maxRows){\n\t\trow++\n\t\tmax := Arr[row-1].Count()\n\t\tLoop % max{\n\t\t\tif (col := A_Index) =1\n\t\t\t\tArr[row, col] := Arr[row-1, max]\n\t\t\tArr[row, col+1] := Arr[row, col] + Arr[row-1, col]\n\t\t}\n\t}\n\treturn Arr\n}\n;-----------------------------------\nShow_Bell_Number(Arr){\n\tfor i, obj in Arr{\n\t\tres .= obj.1 \"`n\"\n\t}\n\treturn Trim(res, \"`n\")\n}\n;-----------------------------------\nShow_Bell_triangle(Arr){\n\tfor i, obj in Arr{\n\t\tfor j, v in obj\n\t\t\tres .= v \", \"\n\t\tres := Trim(res, \", \") . \"`n\"\n\t}\n\treturn Trim(res, \"`n\")\n}\n;-----------------------------------\n"
                },
                {
                    "language": "Picat",
                    "solution": "main =>\n  B50=b(50),\n  println(B50[1..18]),\n  println(b50=B50.last),\n  nl.\n\nb(M) = R =>\n  A = new_array(M-1),\n  bind_vars(A,0),\n  A[1] := 1,\n  R = [1, 1],\n  foreach(N in 2..M-1)\n    A[N] := A[1],\n    foreach(K in N..-1..2)\n       A[K-1] := A[K-1] + A[K],\n    end,\n    R := R ++ [A[1]]\n  end.\n"
                }
            ],
            [
                {
                    "language": "F-Sharp",
                    "solution": "// Generate bell triangle. Nigel Galloway: July 6th., 2019\nlet bell=Seq.unfold(fun g->Some(g,List.scan(+) (List.last g) g))[1I]\n"
                },
                {
                    "language": "AutoHotkey",
                    "solution": "MsgBox % Show_Bell_Number(Bell_triangle(15))\nMsgBox % Show_Bell_triangle(Bell_triangle(10))\nreturn\n"
                }
            ],
            [
                {
                    "language": "Scala",
                    "solution": "import scala.collection.mutable.ListBuffer\n\nobject BellNumbers {\n  class BellTriangle {\n    val arr: ListBuffer[Int] = ListBuffer.empty[Int]\n\n    def this(n: Int) {\n      this()\n\n      val length = n * (n + 1) / 2\n      for (_ <- 0 until length) {\n        arr += 0\n      }\n\n      this (1, 0) = 1\n      for (i <- 2 to n) {\n        this (i, 0) = this (i - 1, i - 2)\n        for (j <- 1 until i) {\n          this (i, j) = this (i, j - 1) + this (i - 1, j - 1)\n        }\n      }\n    }\n\n    private def index(row: Int, col: Int): Int = {\n      require(row > 0, \"row must be greater than zero\")\n      require(col >= 0, \"col must not be negative\")\n      require(col < row, \"col must be less than row\")\n\n      row * (row - 1) / 2 + col\n    }\n\n    def apply(row: Int, col: Int): Int = {\n      val i = index(row, col)\n      arr(i)\n    }\n\n    def update(row: Int, col: Int, value: Int): Unit = {\n      val i = index(row, col)\n      arr(i) = value\n    }\n  }\n\n  def main(args: Array[String]): Unit = {\n    val rows = 15\n    val bt = new BellTriangle(rows)\n\n    println(\"First fifteen Bell numbers:\")\n    for (i <- 0 until rows) {\n      printf(\"%2d: %d\\n\", i + 1, bt(i + 1, 0))\n    }\n\n    for (i <- 1 to 10) {\n      print(bt(i, 0))\n      for (j <- 1 until i) {\n        print(s\", ${bt(i, j)}\")\n      }\n      println()\n    }\n  }\n}\n"
                },
                {
                    "language": "ALGOL-68",
                    "solution": "BEGIN # show some Bell numbers #\n    PROC show bell = ( INT n, LONG LONG INT bell number )VOID:\n         print( ( whole( n, -2 ), \": \", whole( bell number, 0 ), newline ) );\n    INT max bell = 50;\n    [ 0 : max bell - 2 ]LONG LONG INT a; FOR i TO UPB a DO a[ i ] := 0 OD;\n    a[ 0 ] := 1;\n    show bell( 1, a[ 0 ] );\n    FOR n FROM 0 TO UPB a DO\n        # replace a with the next line of the triangle #\n        a[ n ] := a[ 0 ];\n        FOR j FROM n BY -1 TO 1 DO\n            a[ j - 1 ] +:= a[ j ]\n        OD;\n        IF   n < 14       THEN\n            show bell( n + 2, a[ 0 ] )\n        ELIF n = UPB a THEN\n            print( ( \"...\", newline ) );\n            show bell( n + 2, a[ 0 ] )\n        FI\n    OD\nEND\n"
                }
            ]
        ]
    },
    {
        "task_name": "Benfords-law",
        "task_description": "<br>\n'''Benford's law''', also called the '''first-digit law''', refers to the frequency distribution of digits in many (but not all) real-life sources of data. \n\nIn this distribution, the number 1 occurs as the first digit about 30% of the time, while larger numbers occur in that position less frequently: 9 as the first digit less than 5% of the time. This distribution of first digits is the same as the widths of gridlines on a logarithmic scale. \n\nBenford's law also concerns the expected distribution for digits beyond the first, which approach a uniform distribution.\n\nThis result has been found to apply to a wide variety of data sets, including electricity bills, street addresses, stock prices, population numbers, death rates, lengths of rivers, physical and mathematical constants, and processes described by power laws (which are very common in nature). It tends to be most accurate when values are distributed across multiple orders of magnitude.\n\nA set of numbers is said to satisfy Benford's law if the leading digit <big><math>d</math>&nbsp;&nbsp;(<math>d \\in \\{1, \\ldots, 9\\}</math>)</big> occurs with probability\n\n:::: <big><math>P(d) = \\log_{10}(d+1)-\\log_{10}(d) = \\log_{10}\\left(1+\\frac{1}{d}\\right)</math></big>\n\nFor this task, write (a) routine(s) to calculate the distribution of first significant (non-zero) digits in a collection of numbers, then display the actual vs. expected distribution in the way most convenient for your language (table / graph / histogram / whatever).\n\nUse the first 1000 numbers from the Fibonacci sequence as your data set. No need to show how the Fibonacci numbers are obtained. \n\nYou can [[Fibonacci sequence|generate]] them or load them [http://www.fullbooks.com/The-first-1001-Fibonacci-Numbers.html from a file]; whichever is easiest. \n\nDisplay your actual vs expected distribution.\n\n\n''For extra credit:'' Show the distribution for one other set of numbers from a page on Wikipedia. State which Wikipedia page it can be obtained from and what the set enumerates. Again, no need to display the actual list of numbers or the code to load them.\n\n\n;<nowiki>See also:</nowiki>\n* [http://www.numberphile.com/videos/benfords_law.html numberphile.com].\n* A starting page on Wolfram Mathworld is {{Wolfram|Benfords|Law}}.\n<br><br>\n\n",
        "solution_pairs": [
            [
                {
                    "language": "Fortran",
                    "solution": "subroutine fibber(a,b,c,d)\n  ! compute most significant digits, Fibonacci like.\n  implicit none\n  integer (kind=8), intent(in) :: a,b\n  integer (kind=8), intent(out) :: c,d\n  d = a + b\n  if (15 .lt. log10(float(d))) then\n    c = b/10\n    d = d/10\n  else\n    c = b\n  endif\nend subroutine fibber\n\ninteger function leadingDigit(a)\n  implicit none\n  integer (kind=8), intent(in) :: a\n  integer (kind=8) :: b\n  b = a\n  do while (9 .lt. b)\n    b = b/10\n  end do\n  leadingDigit = transfer(b,leadingDigit)\nend function leadingDigit\n\nreal function benfordsLaw(a)\n  implicit none\n  integer, intent(in) :: a\n  benfordsLaw = log10(1.0 + 1.0 / a)\nend function benfordsLaw\n\nprogram benford\n\n  implicit none\n\n  interface\n\n    subroutine fibber(a,b,c,d)\n      implicit none\n      integer (kind=8), intent(in) :: a,b\n      integer (kind=8), intent(out) :: c,d\n    end subroutine fibber\n\n    integer function leadingDigit(a)\n      implicit none\n      integer (kind=8), intent(in) :: a\n    end function leadingDigit\n\n    real function benfordsLaw(a)\n      implicit none\n      integer, intent(in) :: a\n    end function benfordsLaw\n\n  end interface\n\n  integer (kind=8) :: a, b, c, d\n  integer :: i, count(10)\n  data count/10*0/\n  a = 1\n  b = 1\n  do i = 1, 1001\n    count(leadingDigit(a)) = count(leadingDigit(a)) + 1\n    call fibber(a,b,c,d)\n    a = c\n    b = d\n  end do\n  write(6,*) (benfordsLaw(i),i=1,9),'THE LAW'\n  write(6,*) (count(i)/1000.0 ,i=1,9),'LEADING FIBONACCI DIGIT'\nend program benford\n"
                },
                {
                    "language": "FutureBasic",
                    "solution": "Short t, i, j, k, m\nDouble a(9), z\nDouble phi, psi\nCFStringRef s\n\nprint @\"Benford:\"\nfor i = 1 to 9\n  a(i) =  log10( 1 + 1 / i )\n  print fn StringWithFormat( @\"%.3f  \", a(i) ),\nnext\n\n\n// Fibonacci according to DeMoivre and Binet\nfor t = 1 to 9 : a(t) = 0 : next // Clean array\nphi = ( 1 + sqr(5) ) / 2\npsi = ( 1 - sqr(5) ) / 2\nfor i = 1 to 1000\n  z = ( phi^i - psi^i ) / sqr( 5 )\n  s = fn StringWithFormat( @\"%e\", z) // Get first digit\n  t = fn StringIntegerValue( left( s, 1 ) )\n  a(t) = a(t) + 1\nnext\nprint @\"\\n\\nFibonacci:\"\nfor i = 1 to 9\n  print fn StringWithFormat( @\"%.3f  \", a(i) / 1000 ),\nnext\n\n\n// Multiplication tables\nfor t = 1 to 9 : a(t) = 0 : next // Clean array\nfor i = 1 to 10\n  for j = 1 to 10\n    for k = 1 to 10\n      for m = 1 to 10\n        z = i * j * k * m\n        s = fn StringWithFormat( @\"%e\", z )\n        t = fn StringIntegerValue( left( s, 1 ) )\n        a(t) = a(t) + 1\n      next\n    next\n  next\nnext\nprint @\"\\n\\nMultiplication:\"\nfor i = 1 to 9\n  print fn StringWithFormat( @\"%.3f  \", a(i) / 1e4 ),\nnext\n\n\n// Factorials according to DeMoivre and Stirling\nfor t = 1 to 9 : a(t) = 0 : next // Clean array\nfor i = 10 to 110\n  z = sqr(2 * pi * i ) * (i / exp(1) )^i\n  s = fn StringWithFormat( @\"%e\", z )\n  t = fn StringIntegerValue( left( s, 1 ) )\n  a(t) = a(t) + 1\nnext\nprint @\"\\n\\nFactorials:\"\nfor i = 1 to 9\n  print fn StringWithFormat( @\"%.2f   \", a(i) / 100 ),\nnext\n\n\nhandleevents\n}\n"
                }
            ],
            [
                {
                    "language": "D",
                    "solution": "import std.stdio, std.range, std.math, std.conv, std.bigint;\n\ndouble[2][9] benford(R)(R seq) if (isForwardRange!R && !isInfinite!R) {\n    typeof(return) freqs = 0;\n    uint seqLen = 0;\n    foreach (d; seq)\n        if (d != 0) {\n            freqs[d.text[0] - '1'][1]++;\n            seqLen++;\n        }\n\n    foreach (immutable i, ref p; freqs)\n        p = [log10(1.0 + 1.0 / (i + 1)), p[1] / seqLen];\n    return freqs;\n}\n\nvoid main() {\n    auto fibs = recurrence!q{a[n - 1] + a[n - 2]}(1.BigInt, 1.BigInt);\n\n    writefln(\"%9s %9s %9s\", \"Actual\", \"Expected\", \"Deviation\");\n    foreach (immutable i, immutable p; fibs.take(1000).benford)\n        writefln(\"%d: %5.2f%% | %5.2f%% | %5.4f%%\",\n                 i+1, p[1] * 100, p[0] * 100, abs(p[1] - p[0]) * 100);\n}\n"
                },
                {
                    "language": "Icon",
                    "solution": "global counts, total\n\nprocedure main()\n\n   counts := table(0)\n   total := 0.0\n   every benlaw(fib(1 to 1000))\n\n   every i := 1 to 9 do\n      write(i,\": \",right(100*counts[string(i)]/total,9),\" \",100*P(i))\n\nend\n\nprocedure benlaw(n)\n   if counts[n ? (tab(upto('123456789')),move(1))] +:= 1 then total +:= 1\nend\n\nprocedure P(d)\n   return log(1+1.0/d, 10)\nend\n\nprocedure fib(n)        # From Fibonacci Sequence task\n    return fibMat(n)[1]\nend\n\nprocedure fibMat(n)\n    if n <= 0 then return [0,0]\n    if n  = 1 then return [1,0]\n    fp := fibMat(n/2)\n    c := fp[1]*fp[1] + fp[2]*fp[2]\n    d := fp[1]*(fp[1]+2*fp[2])\n    if n%2 = 1 then return [c+d, d]\n    else return [d, c]\nend\n"
                }
            ],
            [
                {
                    "language": "Groovy",
                    "solution": "def tallyFirstDigits = { size, generator ->\n    def population = (0..<size).collect { generator(it) }\n    def firstDigits = [0]*10\n    population.each { number ->\n        firstDigits[(number as String)[0] as int] ++\n    }\n    firstDigits\n}\n"
                },
                {
                    "language": "BASIC256",
                    "solution": "n = 1000\ndim actual(n) fill 0\n\nfor nr = 1 to n\n\tnum$ = string(fibonacci(nr))\n\tj = int(left(num$,1))\n\tactual[j] += 1\nnext\n\nprint \"First 1000 Fibonacci numbers\"\nprint \"Digit  \", \"Actual freq  \", \"Expected freq\"\nfor i = 1 to 9\n\tfreq = frequency(i)*100\n\tprint \"  \"; ljust(i,4), rjust(actual[i]/10,5), rjust(freq,5)\nnext\nend\n\nfunction frequency(n)\n\treturn (log10(n+1) - log10(n))\nend function\n\nfunction fibonacci(f)\n\tf = int(f)\n\ta = 0 : b = 1 : c = 0 : n = 0\n\n\twhile n < f\n\t\ta = b\n\t\tb = c\n\t\tc = a + b\n\t\tn += 1\n\tend while\n\n\treturn c\nend function\n"
                }
            ],
            [
                {
                    "language": "Elixir",
                    "solution": "defmodule Benfords_law do\n  def distribution(n), do: :math.log10( 1 + (1 / n) )\n\n  def task(total \\\\ 1000) do\n    IO.puts \"Digit\tActual\tBenfords expected\"\n    fib(total)\n    |> Enum.group_by(fn i -> hd(to_char_list(i)) end)\n    |> Enum.map(fn {key,list} -> {key - ?0, length(list)} end)\n    |> Enum.sort\n    |> Enum.each(fn {x,len} -> IO.puts \"#{x}\t#{len / total}\t#{distribution(x)}\" end)\n  end\n\n  defp fib(n) do                        # suppresses zero\n    Stream.unfold({1,1}, fn {a,b} -> {a,{b,a+b}} end) |> Enum.take(n)\n  end\nend\n\nBenfords_law.task\n"
                },
                {
                    "language": "J",
                    "solution": "log10 =: 10&^.\nbenford =: log10@:(1+%)\nassert '0.30 0.18 0.12 0.10 0.08 0.07 0.06 0.05 0.05' -: 5j2 \": benford >: i. 9\n\n\nappend_next_fib =: , +/@:(_2&{.)\nassert 5 8 13 -: append_next_fib 5 8\n\nleading_digits =: {.@\":&>\nassert '581' -: leading_digits 5 8 13x\n\ncount =: #/.~ /: ~.\nassert 2 1 3 4 -: count 'XCXBAXACXC'  NB. 2 A's, 1 B, 3 C's, and some X's.\n\nnormalize =: % +/\nassert 1r3 2r3 -: normalize 1 2x\n\nFIB =: append_next_fib ^: (1000-#) 1 1\nLDF =: leading_digits FIB\n\n\nTALLY_BY_KEY =: count LDF\nassert 9 -: # TALLY_BY_KEY   NB. If all of [1-9] are present then we know what the digits are.\n\nmean =: +/ % #\ncenter=: - mean\nmp =: $:~ :(+/ .*)\nnum =: mp&:center\nden =: %:@:(*&:(+/@:(*:@:center)))\nr =: num % den   NB. r is the LibreOffice correl function\nassert '_0.982' -: 6j3 \": 1 2 3 r 6 5 3  NB. confirmed using LibreOffice correl function\n\n\nassert '0.9999' -: 6j4 \": (normalize TALLY_BY_KEY) r benford >: i.9\n\nassert '0.9999' -: 6j4 \": TALLY_BY_KEY r benford >: i.9  NB. Of course we don't need normalization\n"
                }
            ],
            [
                {
                    "language": "C++",
                    "solution": "//to cope with the big numbers , I used the Class Library for Numbers( CLN )\n//if used prepackaged you can compile writing \"g++ -std=c++11 -lcln yourprogram.cpp -o yourprogram\"\n#include <cln/integer.h>\n#include <cln/integer_io.h>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <iomanip>\n#include <sstream>\n#include <string>\n#include <cstdlib>\n#include <cmath>\n#include <map>\nusing namespace cln ;\n\nclass NextNum {\npublic :\n   NextNum ( cl_I & a , cl_I & b ) : first( a ) , second ( b ) { }\n   cl_I operator( )( ) {\n      cl_I result = first + second ;\n      first = second ;\n      second = result ;\n      return result ;\n   }\nprivate :\n   cl_I first ;\n   cl_I second ;\n} ;\n\nvoid findFrequencies( const std::vector<cl_I> & fibos , std::map<int , int> &numberfrequencies  ) {\n   for ( cl_I bignumber : fibos ) {\n      std::ostringstream os ;\n      fprintdecimal ( os , bignumber ) ;//from header file cln/integer_io.h\n      int firstdigit = std::atoi( os.str( ).substr( 0 , 1 ).c_str( )) ;\n      auto result = numberfrequencies.insert( std::make_pair( firstdigit , 1 ) ) ;\n      if ( ! result.second )\n\t numberfrequencies[ firstdigit ]++ ;\n   }\n}\n\nint main( ) {\n   std::vector<cl_I> fibonaccis( 1000 ) ;\n   fibonaccis[ 0 ] = 0 ;\n   fibonaccis[ 1 ] = 1 ;\n   cl_I a = 0 ;\n   cl_I b = 1 ;\n   //since a and b are passed as references to the generator's constructor\n   //they are constantly changed !\n   std::generate_n( fibonaccis.begin( ) + 2 , 998 , NextNum( a , b ) ) ;\n   std::cout << std::endl ;\n   std::map<int , int> frequencies ;\n   findFrequencies( fibonaccis , frequencies ) ;\n   std::cout << \"                found                    expected\\n\" ;\n   for ( int i = 1 ; i < 10 ; i++ ) {\n      double found = static_cast<double>( frequencies[ i ] ) / 1000 ;\n      double expected = std::log10( 1 + 1 / static_cast<double>( i )) ;\n      std::cout << i << \" :\" << std::setw( 16 ) << std::right << found * 100 << \" %\" ;\n      std::cout.precision( 3 ) ;\n      std::cout << std::setw( 26 ) << std::right << expected * 100 << \" %\\n\" ;\n   }\n   return 0 ;\n}\n"
                },
                {
                    "language": "8th",
                    "solution": ": n:log10e ` 1 10 ln / ` ;\n\nwith: n\n\n: n:log10  \\ n -- n\n    ln log10e * ;\n\n: benford  \\ x -- x\n    1 swap / 1+ log10 ;\n\n: fibs \\ xt n\n    swap >r\n    0.0 1.0 rot\n    ( dup r@ w:exec tuck + ) swap times\n    2drop rdrop ;\n\nvar counts\n\n: init\n    a:new ( 0 a:push ) 9 times counts ! ;\n\n: leading \\ n -- n\n    \"%g\" s:strfmt\n    0 s:@ '0 - nip ;\n\n: bump-digit \\ n --\n    1 swap\n    counts @ swap 1- ' + a:op! drop ;\n\n: count-fibs \\ --\n    ( leading bump-digit ) 1000 fibs ;\n\n: adjust \\ --\n    counts @  ( 0.001 * ) a:map  counts ! ;\n\n: spaces \\ n --\n    ' space swap times ;\n\n: .fw \\ s n --\n    >r s:len r> rot . swap - spaces ;\n\n: .header \\ --\n    \"Digit\" 8 .fw \"Expected\" 10 .fw \"Actual\" 10 .fw cr ;\n\n: .digit \\ n --\n    >s 8 .fw ;\n\n: .actual \\ n --\n    \"%.3f\" s:strfmt 10 .fw ;\n\n: .expected \\ n --\n    \"%.4f\" s:strfmt 10 .fw ;\n\n: report \\ --\n    .header\n    counts @\n    ( swap 1+ dup benford swap\n      .digit .expected .actual cr )\n    a:each drop ;\n\n: benford-test\n    init count-fibs adjust report ;\n\n;with\n\nbenford-test\nbye\n"
                }
            ]
        ]
    },
    {
        "task_name": "Bernoulli-numbers",
        "task_description": "[[wp:Bernoulli number|Bernoulli numbers]] are used in some series expansions of several functions &nbsp; (trigonometric, hyperbolic, gamma, etc.), &nbsp; and are extremely important in number theory and analysis. \n\nNote that there are two definitions of Bernoulli numbers; &nbsp; this task will be using the modern usage &nbsp; (as per &nbsp; ''The National Institute of Standards and Technology convention'').\n\nThe &nbsp; n<sup>th</sup> &nbsp; Bernoulli number is expressed as &nbsp; '''B'''<sub>n</sub>.\n<br>\n\n;Task\n\n:* &nbsp; show the Bernoulli numbers &nbsp; '''B'''<sub>0</sub> &nbsp; through &nbsp; '''B'''<sub>60</sub>.\n:* &nbsp; suppress the output of values which are equal to zero. &nbsp; (Other than &nbsp; '''B'''<sub>1</sub>&nbsp;, all &nbsp; ''odd'' &nbsp; Bernoulli numbers have a value of zero.)\n:* &nbsp; express the Bernoulli numbers as fractions &nbsp;(most are improper fractions).\n:* &nbsp; the fractions should be reduced.\n:* &nbsp; index each number in some way so that it can be discerned which Bernoulli number is being displayed.\n:* &nbsp; align the solidi &nbsp; (<big><b>/</b></big>) &nbsp; if used &nbsp;(extra credit).\n\n\n;An algorithm\nThe Akiyama\u2013Tanigawa algorithm for the \"second Bernoulli numbers\" as taken from [[wp:Bernoulli_number#Algorithmic_description|wikipedia]] is as follows:\n\n  '''for''' ''m'' '''from''' 0 '''by''' 1 '''to''' ''n'' '''do'''\n     ''A''[''m''] \u2190 1/(''m''+1)\n     '''for''' ''j'' '''from''' ''m'' '''by''' -1 '''to''' 1 '''do'''\n       ''A''[''j''-1] \u2190 ''j''\u00d7(''A''[''j''-1] - ''A''[''j''])\n   '''return''' ''A''[0] (which is ''B''<sub>''n''</sub>)\n\n;See also\n* Sequence [[oeis:A027641|A027641 Numerator of Bernoulli number B_n]] on The On-Line Encyclopedia of Integer Sequences.\n* Sequence [[oeis:A027642|A027642 Denominator of Bernoulli number B_n]] on The On-Line Encyclopedia of Integer Sequences.\n* Entry [http://mathworld.wolfram.com/BernoulliNumber.html Bernoulli number] on The Eric Weisstein's World of Mathematics (TM).\n* Luschny's [http://luschny.de/math/zeta/The-Bernoulli-Manifesto.html The Bernoulli Manifesto] for a discussion on &nbsp; <big> '''B<sub>1</sub> &nbsp; = &nbsp; -&frac12;''' &nbsp; versus &nbsp; '''+&frac12;'''. </big>\n<br><br>\n",
        "solution_pairs": [
            [
                {
                    "language": "Fermat",
                    "solution": "Func Bern(m) = Sigma<k=0,m>[Sigma<v=0,k>[(-1)^v*Bin(k,v)*(v+1)^m/(k+1)]].;\nfor i=0, 60 do b:=Bern(i); if b<>0 then !!(i,b) fi od;\n"
                },
                {
                    "language": "Jq",
                    "solution": "# Using the algorithm in the task description:\ndef bernoulli(n):\n  reduce range(0; n+1) as $m\n    ( [];\n      .[$m] = [\"1\", long_add($m|tostring; \"1\")]  # i.e. 1 / ($m+1)\n      | reduce ($m - range(0 ; $m)) as $j\n          (.;\n            .[$j-1] = multiply( [($j|tostring), \"1\"]; minus( .[$j-1] ; .[$j]) ) ))\n  | .[0] # (which is Bn)\n  ;\n"
                }
            ],
            [
                {
                    "language": "Jq",
                    "solution": "$ jq -n -r -f Bernoulli.jq\n0: [\"1\",\"1\"]\n1: [\"1\",\"2\"]\n2: [\"1\",\"6\"]\n4: [\"-1\",\"30\"]\n6: [\"1\",\"42\"]\n8: [\"-1\",\"30\"]\n10: [\"5\",\"66\"]\n12: [\"-691\",\"2730\"]\n14: [\"7\",\"6\"]\n16: [\"-3617\",\"510\"]\n18: [\"43867\",\"798\"]\n20: [\"-174611\",\"330\"]\n22: [\"854513\",\"138\"]\n24: [\"-236364091\",\"2730\"]\n26: [\"8553103\",\"6\"]\n28: [\"-23749461029\",\"870\"]\n30: [\"8615841276005\",\"14322\"]\n32: [\"-7709321041217\",\"510\"]\n34: [\"2577687858367\",\"6\"]\n36: [\"-26315271553053477373\",\"1919190\"]\n38: [\"2929993913841559\",\"6\"]\n40: [\"-261082718496449122051\",\"13530\"]\n42: [\"1520097643918070802691\",\"1806\"]\n44: [\"-27833269579301024235023\",\"690\"]\n46: [\"596451111593912163277961\",\"282\"]\n48: [\"-5609403368997817686249127547\",\"46410\"]\n50: [\"495057205241079648212477525\",\"66\"]\n52: [\"-801165718135489957347924991853\",\"1590\"]\n54: [\"29149963634884862421418123812691\",\"798\"]\n56: [\"-2479392929313226753685415739663229\",\"870\"]\n58: [\"84483613348880041862046775994036021\",\"354\"]\n60: [\"-1215233140483755572040304994079820246041491\",\"56786730\"]\n"
                },
                {
                    "language": "C++",
                    "solution": "/**\n * Configured with: --prefix=/Library/Developer/CommandLineTools/usr --with-gxx-include-dir=/usr/include/c++/4.2.1\n * Apple LLVM version 9.1.0 (clang-902.0.39.1)\n * Target: x86_64-apple-darwin17.5.0\n * Thread model: posix\n*/\n\n#include <boost/multiprecision/cpp_int.hpp>  // 1024bit precision\n#include <boost/rational.hpp>                // Rationals\n#include <iostream>                          // formatting with std::cout\n#include <vector>                            // Container\n\ntypedef boost::rational<boost::multiprecision::int1024_t> rational;  // reduce boilerplate\n\nrational bernoulli(size_t n) {\n    auto out = std::vector<rational>();\n\n    for (size_t m = 0; m <= n; m++) {\n        out.emplace_back(1, (m + 1));  // automatically constructs object\n        for (size_t j = m; j >= 1; j--) {\n            out[j - 1] = rational(j) * (out[j - 1] - out[j]);\n        }\n    }\n    return out[0];\n}\n\nint main() {\n    for (size_t n = 0; n <= 60; n += n >= 2 ? 2 : 1) {\n        auto b = bernoulli(n);\n        std::cout << \"B(\" << std::right << std::setw(2) << n << \") = \";\n        std::cout << std::right << std::setw(44) << b.numerator();\n        std::cout << \" / \" << b.denominator() << std::endl;\n    }\n\n    return 0;\n}\n"
                }
            ],
            [
                {
                    "language": "Go",
                    "solution": "package main\n\nimport (\n\t\"fmt\"\n\t\"math/big\"\n)\n\nfunc b(n int) *big.Rat {\n\tvar f big.Rat\n\ta := make([]big.Rat, n+1)\n\tfor m := range a {\n\t\ta[m].SetFrac64(1, int64(m+1))\n\t\tfor j := m; j >= 1; j-- {\n\t\t\td := &a[j-1]\n\t\t\td.Mul(f.SetInt64(int64(j)), d.Sub(d, &a[j]))\n\t\t}\n\t}\n\treturn f.Set(&a[0])\n}\n\nfunc main() {\n\tfor n := 0; n <= 60; n++ {\n\t\tif b := b(n); b.Num().BitLen() > 0 {\n\t\t\tfmt.Printf(\"B(%2d) =%45s/%s\\n\", n, b.Num(), b.Denom())\n\t\t}\n\t}\n}\n"
                },
                {
                    "language": "EchoLisp",
                    "solution": ";; Bernoulli numbers\n;; http://rosettacode.org/wiki/Bernoulli_numbers\n(define A (make-vector 100 0))\n\n(define (B n)\n(for ((m (1+ n))) ;; #1 creates a large integer\n\t(vector-set! A m (Rational #1 (+ #1 m)))\n\t(for ((j (in-range m 0 -1)))\n\t  (vector-set! A (1- j)\n\t  \t(mul (sub (vector-ref A (1- j)) (vector-ref A j)) j))))\n\t  (vector-ref A 0))\n\n    (for ((b (in-range 0 62 2))) (writeln b (B b)))  \u2192\n\n0                                                      1 / 1\n2                                                      1 / 6\n4                                                     -1 / 30\n6                                                      1 / 42\n8                                                     -1 / 30\n10                                                      5 / 66\n12                                                   -691 / 2730\n14                                                      7 / 6\n16                                                  -3617 / 510\n18                                                  43867 / 798\n20                                                -174611 / 330\n22                                                 854513 / 138\n24                                             -236364091 / 2730\n26                                                8553103 / 6\n28                                           -23749461029 / 870\n30                                          8615841276005 / 14322\n32                                         -7709321041217 / 510\n34                                          2577687858367 / 6\n36                                  -26315271553053477373 / 1919190\n38                                       2929993913841559 / 6\n40                                 -261082718496449122051 / 13530\n42                                 1520097643918070802691 / 1806\n44                               -27833269579301024235023 / 690\n46                               596451111593912163277961 / 282\n48                          -5609403368997817686249127547 / 46410\n50                            495057205241079648212477525 / 66\n52                        -801165718135489957347924991853 / 1590\n54                       29149963634884862421418123812691 / 798\n56                    -2479392929313226753685415739663229 / 870\n58                    84483613348880041862046775994036021 / 354\n60           -1215233140483755572040304994079820246041491 / 56786730\n\n(B 1) \u2192 1 / 2\n"
                }
            ],
            [
                {
                    "language": "Julia",
                    "solution": "function bernoulli(n)\n    A = Vector{Rational{BigInt}}(undef, n + 1)\n    for m = 0 : n\n        A[m + 1] = 1 // (m + 1)\n        for j = m : -1 : 1\n            A[j] = j * (A[j] - A[j + 1])\n        end\n    end\n    return A[1]\nend\n\nfunction display(n)\n    B = map(bernoulli, 0 : n)\n    pad = mapreduce(x -> ndigits(numerator(x)) + Int(x < 0), max, B)\n    argdigits = ndigits(n)\n    for i = 0 : n\n        if numerator(B[i + 1]) & 1 == 1\n            println(\n                \"B(\", lpad(i, argdigits), \") = \",\n                lpad(numerator(B[i + 1]), pad), \" / \", denominator(B[i + 1])\n            )\n        end\n    end\nend\n\ndisplay(60)\n\n# Alternative: Following the comment in the Perl section it is much more efficient\n# to compute the list of numbers instead of one number after the other.\n\nfunction BernoulliList(len)\n    A = Vector{Rational{BigInt}}(undef, len + 1)\n    B = similar(A)\n    for n in 0 : len\n        A[n + 1] = 1 // (n + 1)\n        for j = n : -1 : 1\n            A[j] = j * (A[j] - A[j + 1])\n        end\n        B[n + 1] =  A[1]\n    end\n    return B\nend\n\nfor (n, b) in enumerate(BernoulliList(60))\n    isodd(numerator(b)) && println(\"B($(n-1)) = $b\")\nend\n"
                },
                {
                    "language": "EchoLisp",
                    "solution": "(lib 'bigint) ;; lerge numbers\n(lib 'gloops) ;; classes\n\n(define-class Rational null ((a :initform #0) (b :initform #1)))\n(define-method tostring  (Rational) (lambda (r) (format \"%50d / %d\" r.a r.b)))\n(define-method normalize (Rational) (lambda (r) ;; divide a and b by gcd\n\t\t (let ((g (gcd r.a r.b)))\n\t\t (set! r.a (/ r.a g)) (set! r.b (/ r.b g))\n \t\t (when (< r.b 0) (set! r.a ( - r.a)) (set! r.b (- r.b))) ;; denominator > 0\n \t\tr)))\n\t\t\t\n(define-method initialize (Rational) (lambda (r) (normalize r)))\n(define-method add (Rational) (lambda (r n)  ;; + Rational any number\n\t\t\t(normalize (Rational (+ (* (+ #0 n) r.b) r.a) r.b))))\n(define-method add (Rational Rational) (lambda (r q) ;;; + Rational Rational\n\t\t\t(normalize (Rational (+ (* r.a q.b) (* r.b q.a)) (* r.b q.b)))))\n(define-method sub (Rational Rational) (lambda (r q)\n\t\t\t(normalize (Rational (- (* r.a q.b) (* r.b q.a)) (* r.b q.b)))))\n(define-method mul (Rational Rational) (lambda (r q)\n\t\t\t(normalize (Rational  (* r.a q.a)  (* r.b q.b)))))\n(define-method mul (Rational) (lambda (r n)\n\t\t\t(normalize (Rational  (* r.a (+ #0 n))  r.b ))))\n(define-method div (Rational Rational) (lambda (r q)\n\t\t\t(normalize (Rational  (* r.a q.b)  (* r.b q.a)))))\n"
                }
            ],
            [
                {
                    "language": "Java",
                    "solution": "import org.apache.commons.math3.fraction.BigFraction;\n\npublic class BernoulliNumbers {\n\n    public static void main(String[] args) {\n        for (int n = 0; n <= 60; n++) {\n            BigFraction b = bernouilli(n);\n            if (!b.equals(BigFraction.ZERO))\n                System.out.printf(\"B(%-2d) = %-1s%n\", n , b);\n        }\n    }\n\n    static BigFraction bernouilli(int n) {\n        BigFraction[] A = new BigFraction[n + 1];\n        for (int m = 0; m <= n; m++) {\n            A[m] = new BigFraction(1, (m + 1));\n            for (int j = m; j >= 1; j--)\n                A[j - 1] = (A[j - 1].subtract(A[j])).multiply(new BigFraction(j));\n        }\n        return A[0];\n    }\n}\n"
                },
                {
                    "language": "Raku",
                    "solution": "constant bernoulli = gather {\n    my @a;\n    for 0..* -> $m {\n        @a = FatRat.new(1, $m + 1),\n                -> $prev {\n                    my $j = @a.elems;\n                    $j * (@a.shift - $prev);\n                } ... { not @a.elems }\n        take $m => @a[*-1] if @a[*-1];\n    }\n}\n\nconstant @bpairs = bernoulli[^52];\n\nmy $width = max @bpairs.map: *.value.numerator.chars;\nmy $form = \"B(%d)\\t= \\%{$width}d/%d\\n\";\n\nprintf $form, .key, .value.nude for @bpairs;\n"
                }
            ]
        ]
    },
    {
        "task_name": "Best-shuffle",
        "task_description": ";Task:\nShuffle the characters of a string in such a way that as many of the character values are in a different position as possible. \n\nA shuffle that produces a randomized result among the best choices is to be preferred. A deterministic approach that produces the same sequence every time is acceptable as an alternative.\n\nDisplay the result as follows: \n\n original string, shuffled string, (score) \n\nThe score gives the number of positions whose character value did ''not'' change. \n\n\n;Example:\n tree, eetr, (0)\n\n\n;Test cases:\n abracadabra\n seesaw\n elk\n grrrrrr\n up\n a\n\n\n;Related tasks\n* &nbsp; [[Anagrams/Deranged anagrams]]\n* &nbsp; [[Permutations/Derangements]]\n\n\n{{Template:Strings}}\n<br><br>\n",
        "solution_pairs": [
            [
                {
                    "language": "Lua",
                    "solution": "math.randomseed(os.time())\n\nlocal function shuffle(t)\n  for i = #t, 2, -1 do\n    local j = math.random(i)\n    t[i], t[j] = t[j], t[i]\n  end\nend\n\nlocal function bestshuffle(s, r)\n  local order, shufl, count = {}, {}, 0\n  for ch in s:gmatch(\".\") do order[#order+1], shufl[#shufl+1] = ch, ch end\n  if r then shuffle(shufl) end\n  for i = 1, #shufl do\n    for j = 1, #shufl do\n      if i ~= j and shufl[i] ~= order[j] and shufl[j] ~= order[i] then\n        shufl[i], shufl[j] = shufl[j], shufl[i]\n      end\n    end\n  end\n  for i = 1, #shufl do\n    if shufl[i] == order[i] then\n      count = count + 1\n    end\n  end\n  return table.concat(shufl), count\nend\n\nlocal words = { \"abracadabra\", \"seesaw\", \"elk\", \"grrrrrr\", \"up\", \"a\" }\n\nlocal function test(r)\n  print(r and \"RANDOM:\" or \"DETERMINISTIC:\")\n  for _, word in ipairs(words) do\n    local shufl, count = bestshuffle(word, r)\n    print(string.format(\"%s, %s, (%d)\", word, shufl, count))\n  end\n  print()\nend\n\ntest(true)\ntest(false)\n"
                },
                {
                    "language": "Phix",
                    "solution": "(phixonline)-->\n <span style=\"color: #008080;\">with</span> <span style=\"color: #008080;\">javascript_semantics</span>\n <span style=\"color: #008080;\">constant</span> <span style=\"color: #000000;\">tests</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #0000FF;\">{</span><span style=\"color: #008000;\">\"abracadabra\"</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #008000;\">\"seesaw\"</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #008000;\">\"elk\"</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #008000;\">\"grrrrrr\"</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #008000;\">\"up\"</span><span style=\"color: #0000FF;\">,</span> <span style=\"color: #008000;\">\"a\"</span><span style=\"color: #0000FF;\">}</span>\n <span style=\"color: #008080;\">for</span> <span style=\"color: #000000;\">test</span><span style=\"color: #0000FF;\">=</span><span style=\"color: #000000;\">1</span> <span style=\"color: #008080;\">to</span> <span style=\"color: #7060A8;\">length</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">tests</span><span style=\"color: #0000FF;\">)</span> <span style=\"color: #008080;\">do</span>\n     <span style=\"color: #004080;\">string</span> <span style=\"color: #000000;\">s</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #000000;\">tests</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">test</span><span style=\"color: #0000FF;\">],</span>\n            <span style=\"color: #000000;\">t</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #7060A8;\">shuffle</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">s</span><span style=\"color: #0000FF;\">)</span>\n     <span style=\"color: #008080;\">for</span> <span style=\"color: #000000;\">i</span><span style=\"color: #0000FF;\">=</span><span style=\"color: #000000;\">1</span> <span style=\"color: #008080;\">to</span> <span style=\"color: #7060A8;\">length</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">t</span><span style=\"color: #0000FF;\">)</span> <span style=\"color: #008080;\">do</span>\n         <span style=\"color: #008080;\">for</span> <span style=\"color: #000000;\">j</span><span style=\"color: #0000FF;\">=</span><span style=\"color: #000000;\">1</span> <span style=\"color: #008080;\">to</span> <span style=\"color: #7060A8;\">length</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">t</span><span style=\"color: #0000FF;\">)</span> <span style=\"color: #008080;\">do</span>\n             <span style=\"color: #004080;\">integer</span> <span style=\"color: #0000FF;\">{</span><span style=\"color: #000000;\">ti</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">tj</span><span style=\"color: #0000FF;\">}</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #0000FF;\">{</span><span style=\"color: #000000;\">t</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">i</span><span style=\"color: #0000FF;\">],</span><span style=\"color: #000000;\">t</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">j</span><span style=\"color: #0000FF;\">]}</span>\n             <span style=\"color: #008080;\">if</span> <span style=\"color: #000000;\">i</span><span style=\"color: #0000FF;\">!=</span><span style=\"color: #000000;\">j</span> <span style=\"color: #008080;\">and</span> <span style=\"color: #000000;\">ti</span><span style=\"color: #0000FF;\">!=</span><span style=\"color: #000000;\">s</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">j</span><span style=\"color: #0000FF;\">]</span> <span style=\"color: #008080;\">and</span> <span style=\"color: #000000;\">tj</span><span style=\"color: #0000FF;\">!=</span><span style=\"color: #000000;\">s</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">i</span><span style=\"color: #0000FF;\">]</span> <span style=\"color: #008080;\">then</span>\n                 <span style=\"color: #000000;\">t</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">i</span><span style=\"color: #0000FF;\">]</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #000000;\">tj</span>\n                 <span style=\"color: #000000;\">t</span><span style=\"color: #0000FF;\">[</span><span style=\"color: #000000;\">j</span><span style=\"color: #0000FF;\">]</span> <span style=\"color: #0000FF;\">=</span> <span style=\"color: #000000;\">ti</span>\n                 <span style=\"color: #008080;\">exit</span>\n             <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">if</span>\n         <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">for</span>\n     <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">for</span>\n     <span style=\"color: #7060A8;\">printf</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">1</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #008000;\">\"%s -&gt; %s (%d)\\n\"</span><span style=\"color: #0000FF;\">,{</span><span style=\"color: #000000;\">s</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">t</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #7060A8;\">sum</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #7060A8;\">sq_eq</span><span style=\"color: #0000FF;\">(</span><span style=\"color: #000000;\">t</span><span style=\"color: #0000FF;\">,</span><span style=\"color: #000000;\">s</span><span style=\"color: #0000FF;\">))})</span>\n <span style=\"color: #008080;\">end</span> <span style=\"color: #008080;\">for</span>\n<!--\n"
                }
            ],
            [
                {
                    "language": "EasyLang",
                    "solution": "proc best_shuffle s$ . r$ diff .\n   l = len s$\n   for c$ in strchars s$\n      s[] &= strcode c$\n   .\n   len cnt[] 128\n   for i to l\n      cnt[s[i]] += 1\n      max = higher max cnt[s[i]]\n   .\n   for i to 128\n      while cnt[i] > 0\n         cnt[i] -= 1\n         buf[] &= i\n      .\n   .\n   r[] = s[]\n   for i to l\n      for j to l\n         if r[i] = buf[j]\n            r[i] = buf[(j + max) mod1 l] mod 128\n            if buf[j] <= 128\n               buf[j] += 128\n            .\n            break 1\n         .\n      .\n   .\n   diff = 0\n   r$ = \"\"\n   for i to l\n      diff += if r[i] = s[i]\n      r$ &= strchar r[i]\n   .\n.\nfor s$ in [ \"abracadabra\" \"seesaw\" \"elk\" \"grrrrrr\" \"up\" \"a\" ]\n   best_shuffle s$ r$ d\n   print s$ & \" \" & r$ & \" \" & d\n.\n"
                },
                {
                    "language": "PicoLisp",
                    "solution": "(de bestShuffle (Str)\n   (let Lst NIL\n      (for C (setq Str (chop Str))\n         (if (assoc C Lst)\n            (con @ (cons C (cdr @)))\n            (push 'Lst (cons C)) ) )\n      (setq Lst (apply conc (flip (by length sort Lst))))\n      (let Res\n         (mapcar\n            '((C)\n               (prog1 (or (find <> Lst (circ C)) C)\n                  (setq Lst (delete @ Lst)) ) )\n            Str )\n         (prinl Str \" \" Res \" (\" (cnt = Str Res) \")\") ) ) )\n"
                }
            ],
            [
                {
                    "language": "PowerShell",
                    "solution": "#  Calculate best possible shuffle score for a given string\n#  (Split out into separate function so we can use it separately in our output)\nfunction Get-BestScore ( [string]$String )\n    {\n    #  Convert to array of characters, group identical characters,\n    #  sort by frequecy, get size of first group\n    $MostRepeats = $String.ToCharArray() |\n                    Group |\n                    Sort Count -Descending |\n                    Select -First 1 -ExpandProperty Count\n\n    #  Return count of most repeated character minus all other characters (math simplified)\n    return [math]::Max( 0, 2 * $MostRepeats - $String.Length )\n    }\n\nfunction Get-BestShuffle ( [string]$String )\n    {\n    #  Convert to arrays of characters, one for comparison, one for manipulation\n    $S1 = $String.ToCharArray()\n    $S2 = $String.ToCharArray()\n\n    #  Calculate best possible score as our goal\n    $BestScore = Get-BestScore $String\n\n    #  Unshuffled string has score equal to number of characters\n    $Length = $String.Length\n    $Score = $Length\n\n    #  While still striving for perfection...\n    While ( $Score -gt $BestScore )\n        {\n        #  For each character\n        ForEach ( $i in 0..($Length-1) )\n            {\n            #  If the shuffled character still matches the original character...\n            If ( $S1[$i] -eq $S2[$i] )\n                {\n                #  Swap it with a random character\n                #  (Random character $j may be the same as or may even be\n                #   character $i. The minor impact on speed was traded for\n                #   a simple solution to guarantee randomness.)\n                $j = Get-Random -Maximum $Length\n                $S2[$i], $S2[$j] = $S2[$j], $S2[$i]\n                }\n            }\n        #  Count the number of indexes where the two arrays match\n        $Score = ( 0..($Length-1) ).Where({ $S1[$_] -eq $S2[$_] }).Count\n        }\n    #  Put it back into a string\n    $Shuffle = ( [string[]]$S2 -join '' )\n    return $Shuffle\n    }\n"
                },
                {
                    "language": "Go",
                    "solution": "package main\n\nimport (\n    \"fmt\"\n    \"math/rand\"\n    \"time\"\n)\n\nvar ts = []string{\"abracadabra\", \"seesaw\", \"elk\", \"grrrrrr\", \"up\", \"a\"}\n\nfunc main() {\n    rand.Seed(time.Now().UnixNano())\n    for _, s := range ts {\n        // create shuffled byte array of original string\n        t := make([]byte, len(s))\n        for i, r := range rand.Perm(len(s)) {\n            t[i] = s[r]\n        }\n        // algorithm of Icon solution\n        for i := range t {\n            for j := range t {\n                if i != j && t[i] != s[j] && t[j] != s[i] {\n                    t[i], t[j] = t[j], t[i]\n                    break\n                }\n            }\n        }\n        // count unchanged and output\n        var count int\n        for i, ic := range t {\n            if ic == s[i] {\n                count++\n            }\n        }\n        fmt.Printf(\"%s -> %s (%d)\\n\", s, string(t), count)\n    }\n}\n"
                }
            ],
            [
                {
                    "language": "Haskell",
                    "solution": "import Control.Monad.Random (getRandomR)\n"
                },
                {
                    "language": "Zkl",
                    "solution": "ss:=T(\"abracadabra\",\"immediately\",\"grrrrrr\",\"seesaw\",\"pop\",\"up\",\"a\",\"\");\nforeach s in (ss){\n   ns,cnt:=bestShuffle(s);\n   println(\"%s --> %s (%d)\".fmt(s,ns,cnt));\n}\n"
                }
            ],
            [
                {
                    "language": "Wren",
                    "solution": "import \"random\" for Random\n\nclass BestShuffle {\n    static shuffle_(ca) {\n        var rand = Random.new()\n        var i = ca.count - 1\n        while (i >= 1) {\n            var r = rand.int(i + 1)\n            var tmp = ca[i]\n            ca[i] = ca[r]\n            ca[r] = tmp\n            i = i - 1\n        }\n    }\n\n    static count_(ca, s1) {\n        var count = 0\n        for (i in 0...ca.count) if (s1[i] == ca[i]) count = count + 1\n        return count\n    }\n\n    static invoke(s1) {\n        var s2 = s1.toList\n        shuffle_(s2)\n        for (i in 0...s2.count) {\n            if (s2[i] == s1[i]) {\n                for (j in 0...s2.count) {\n                    if (s2[i] != s2[j] && s2[i] != s1[j] && s2[j] != s1[i]) {\n                        var tmp = s2[i]\n                        s2[i] = s2[j]\n                        s2[j] = tmp\n                        break\n                    }\n                }\n            }\n        }\n        return s1 + \", \" + s2.join() + \", (\" + \"%(count_(s2, s1))\" + \")\"\n    }\n}\n\nvar words = [\"tree\", \"abracadabra\", \"seesaw\", \"elk\", \"grrrrrr\", \"up\", \"a\"]\nwords.each { |w| System.print(BestShuffle.invoke(w)) }\n"
                },
                {
                    "language": "Free-Pascal-Lazarus",
                    "solution": "Program BestShuffle;\n\nConst\n  arr : array[1..6] Of string = ('abracadabra','seesaw','elk','grrrrrr','up','a');\n\nFunction Shuffle(inp: String): STRING;\n\nVar x,ReplacementDigit : longint;\n  ch : char;\nBegin\n  If length(inp) > 1 Then\n    Begin\n      Randomize;\n      For x := 1 To length(inp) Do\n        Begin\n          Repeat\n            ReplacementDigit := random(length(inp))+1;\n          Until (ReplacementDigit <> x);\n          ch := inp[x];\n          inp[x] := inp[ReplacementDigit];\n          inp[ReplacementDigit] := ch;\n        End;\n    End;\n  shuffle := inp;\nEnd;\n\n\nFunction score(OrgString,ShuString : String) : integer;\n\nVar i : integer;\nBegin\n  score := 0;\n  For i := 1 To length(OrgString) Do\n    If OrgString[i] = ShuString[i] Then inc(score);\nEnd;\n\nVar i : integer;\n  shuffled : string;\nBegin\n  For i := low(arr) To high(arr) Do\n    Begin\n      shuffled := shuffle(arr[i]);\n      writeln(arr[i],' , ',shuffled,' , (',score(arr[i],shuffled),')');\n    End;\nEnd.\n"
                }
            ]
        ]
    },
    {
        "task_name": "Bifid-cipher",
        "task_description": ";Description\nThe [[wp:Bifid_cipher|'''Bifid cipher''']] is a polygraphic substitution cipher which was invented by [[wp:F\u00e9lix_ Delastelle|F\u00e9lix Delastelle]] in around 1901. It uses a 5 x 5 [[wp:Polybius_square|Polybius square]] combined with transposition and fractionation to encrypt a message. Any 5 x 5 Polybius square can be used but, as it only has 25 cells and there are 26 letters of the (English) alphabet, one cell needs to represent two letters - I and J being a common choice.\n\n;Operation\nSuppose we want to encrypt the message \"ATTACKATDAWN\".\n\nWe use this archetypal Polybius square where I and J share the same position.\n<pre>\nx/y 1 2 3 4 5\n-------------\n1 | A B C D E\n2 | F G H I K\n3 | L M N O P\n4 | Q R S T U \n5 | V W X Y Z\n</pre>\nThe message is first converted to its x, y coordinates, but they are written vertically beneath.\n\n<pre>\nA T T A C K A T D A W N\n1 4 4 1 1 2 1 4 1 1 5 3\n1 4 4 1 3 5 1 4 4 1 2 3\n</pre>\n\nThey are then arranged in a row.\n\n<pre>\n1 4 4 1 1 2 1 4 1 1 5 3 1 4 4 1 3 5 1 4 4 1 2 3\n</pre>\n\nFinally, they are divided up into pairs which are used to look up the encrypted letters in the square.\n\n<pre>\n14 41 12 14 11 53 14 41 35 14 41 23\nD  Q  B  D  A  X  D  Q  P  D  Q  H\n</pre>\n\nThe encrypted message is therefore \"DQBDAXDQPDQH\".\n\nDecryption can be achieved by simply reversing these steps.\n\n;Task\nWrite routines in your language to encrypt and descrypt a message using the Bifid cipher.\n\nUse them to verify (including subsequent decryption):\n \n1. The above example.\n\n2. The example in the Wikipedia article using the message and Polybius square therein.\n\n3. The above example but using the Polybius square in the Wikipedia article to illustrate that it doesn't matter which square you use as long, of course, as the same one is used for both encryption and decryption.\n\nIn addition, encrypt and decrypt the message \"The invasion will start on the first of January\" using any Polybius square you like. Convert the message to upper case and ignore spaces.\n\n;Bonus\nSuggest a way in which the cipher could be modified so that ALL 26 letters can be uniquely encrypted.\n\n;Related task\n[[Playfair_cipher|Playfair cipher]]\n<br><br>\n\n",
        "solution_pairs": [
            [
                {
                    "language": "J",
                    "solution": "ref1=: ~.normalize alpha\nref2=: 'BGWKZQPNDSIOAXEFCLUMTHYVR'\nref3=: 'PLAYFIREXMBCDGHKNOQSTUVWZ'\n\n   ref1 bifid normalize 'attack at dawn'\nDQBDAXDQPDQH\n   ref1 difib ref1 bifid normalize 'attack at dawn'\nATTACKATDAWN\n   ref2 bifid normalize 'flee at once'\nUAEOLWRINS\n   ref2 difib ref2 bifid normalize 'flee at once'\nFLEEATONCE\n   ref2 bifid normalize 'attack at dawn'\nEYFENGIWDILA\n   ref2 difib ref2 bifid normalize 'attack at dawn'\nATTACKATDAWN\n   ref3 bifid normalize 'The invasion will start on the first of January'\nVRSYXSIYTMQVIRSKISLPVLDTCKRTCAIVTMATCEX\n   ref3 difib ref3 bifid normalize 'The invasion will start on the first of January'\nTHEINVASIONWILLSTARTONTHEFIRSTOFIANUARY\n   (_81{.123{.a.)bifid 'The invasion will start on the first of January'\nTgqhpqpqxzpxfqzoKqhxw/O3eWH53BYw`+Be8F1\n   (_81{.123{.a.)difib(_81{.123{.a.)bifid 'The invasion will start on the first of January'\nTheinvasionwillstartonthefirstofJanuary\n"
                },
                {
                    "language": "Jq",
                    "solution": "# Input: the message to be encrypted\ndef encrypt($polybius):\n  (ascii_upcase | gsub(\"J\"; \"I\") ) as $m\n  | {rows: [], cols : [] }\n  | reduce ($m|chars) as $c (.;\n      ($polybius|index($c)) as $ix\n      | if $ix\n        then .rows += [($ix/5)|floor + 1]\n        | .cols += [($ix%5) + 1]\n        else .\n        end )\n  | reduce (.rows + .cols | _nwise(2)) as $pair (\"\";\n      (($pair[0] - 1) * 5 + $pair[1] - 1) as $ix\n      | . + $polybius[$ix:$ix+1] ) ;\n\n# Input: the message to be decrypted\ndef decrypt($polybius):\n  reduce chars as $c ( {rows: [], cols : [] };\n       ($polybius|index($c)) as $ix\n       | .rows += [($ix/5)|floor + 1]\n       | .cols += [($ix%5) + 1] )\n  | ([.rows, .cols] | transpose | flatten) as $lines\n  | ($lines|length/2) as $count\n  | $lines[:$count] as $rows\n  | $lines[$count:] as $cols\n  | [$rows, $cols] as $d\n  | reduce range(0; $count) as $i (\"\";\n       (($rows[$i] - 1) * 5 + $cols[$i] - 1) as $ix\n       | . + $polybius[$ix:$ix+1] ) ;\n\ndef polys:\n  def p1: \"ABCDEFGHIKLMNOPQRSTUVWXYZ\";\n  def p2: \"BGWKZQPNDSIOAXEFCLUMTHYVR\";\n  def p3: \"PLAYFIREXMBCDGHKNOQSTUVWZ\";\n  [p1, p2, p2, p3];\n\ndef messages: [\n  \"ATTACKATDAWN\",\n  \"FLEEATONCE\",\n  \"ATTACKATDAWN\",\n  \"The invasion will start on the first of January\"\n  ];\n\ndef task:\n  range(0; messages|length) as $i\n  |  messages[$i]\n  | encrypt(polys[$i]) as $encrypted\n  | ($encrypted | decrypt(polys[$i] )) as $decrypted\n  | \"Message   : \\(.)\",\n    \"Encrypted : \\($encrypted)\",\n    \"Decrypted : \\($decrypted)\"\n    \"\" ;\n\ntask\n"
                }
            ],
            [
                {
                    "language": "AppleScript",
                    "solution": "\"Given example:\nATTACKATDAWN --> DQBDAXDQPDQH --> ATTACKATDAWN\nWikipedia example:\nFLEEATONCE --> UAEOLWRINS --> FLEEATONCE\nA 6 x 6 square allows all 36 letters & digits to be encoded:\nThe invasion will start on the 1st of January --> TTFAEWUAU9WTE3WP1S5KDF0B8M9AH7KHHVLAV --> THEINVASIONWILLSTARTONTHE1STOFJANUARY\"\n"
                },
                {
                    "language": "Python",
                    "solution": "\"\"\"Bifid cipher. Requires Python >=3.7.\"\"\"\nimport math\nimport pprint\nimport string\n\nfrom itertools import chain\nfrom itertools import zip_longest\n\nfrom typing import Dict\nfrom typing import Iterable\nfrom typing import Iterator\nfrom typing import Tuple\nfrom typing import TypeVar\n\n\nT = TypeVar(\"T\")\n\n\ndef group(it: Iterable[T], n: int) -> Iterator[Tuple[T, ...]]:\n    \"\"\"Return the input iterable split in to `n` equal chunks, padded with `None`.\"\"\"\n    return zip_longest(*[iter(it)] * n)\n\n\nSquare = Tuple[Tuple[str, ...], ...]\n\n\ndef polybius_square(alphabet: str) -> Square:\n    \"\"\"Return the given alphabet as a tuple of tuples, representing a Polybius square.\"\"\"\n    return tuple(group(alphabet, math.ceil(math.sqrt(len(alphabet)))))\n\n\ndef polybius_map(square: Square) -> Dict[str, Tuple[int, int]]:\n    \"\"\"Return a reverse lookup for the given Polybius square.\"\"\"\n    return {\n        square[i][j]: (i + 1, j + 1)\n        for i in range(len(square))\n        for j in range(len(square))\n    }\n\n\ndef encrypt(message: str, square: Square) -> str:\n    \"\"\"Encrypt a plaintext message using a bifid cipher with the given Polybius square.\"\"\"\n    _map = polybius_map(square)\n    return \"\".join(\n        square[x - 1][y - 1]\n        for x, y in group(\n            chain.from_iterable(zip(*(_map[c] for c in message if c in _map))),\n            2,\n        )\n    )\n\n\ndef decrypt(message: str, square: Square) -> str:\n    \"\"\"Decrypt a ciphertext message using a bifid cipher with the given Polybius square.\"\"\"\n    _map = polybius_map(square)\n    return \"\".join(\n        square[x - 1][y - 1]\n        for x, y in zip(\n            *group(\n                chain.from_iterable((_map[c] for c in message if c in _map)),\n                len(message),\n            )\n        )\n    )\n\n\ndef normalize(message: str) -> str:\n    \"\"\"Normalize a message for the typical Polybius square.\"\"\"\n    return message.upper().replace(\"J\", \"I\")\n\n\nTYPICAL_POLYBIUS_SQUARE = polybius_square(\n    alphabet=\"\".join(c for c in string.ascii_uppercase if c != \"J\")\n)\n\n\nEXAMPLE_POLYBIUS_SQUARE = polybius_square(\n    alphabet=\"BGWKZQPNDSIOAXEFCLUMTHYVR\",\n)\n\n\ndef main() -> None:\n    test_cases = [\n        (\"ATTACKATDAWN\", TYPICAL_POLYBIUS_SQUARE),  # 1\n        (\"FLEEATONCE\", EXAMPLE_POLYBIUS_SQUARE),  # 2\n        (\"FLEEATONCE\", TYPICAL_POLYBIUS_SQUARE),  # 3\n        (\n            normalize(\"The invasion will start on the first of January\"),\n            polybius_square(alphabet=\"PLAYFIREXMBCDGHKNOQSTUVWZ\"),\n        ),\n        (\n            \"The invasion will start on the first of January\".upper(),\n            polybius_square(alphabet=string.ascii_uppercase + string.digits),\n        ),\n    ]\n\n    for message, square in test_cases:\n        pprint.pprint(square)\n        print(\"Message  :\", message)\n        print(\"Encrypted:\", encrypt(message, square))\n        print(\"Decrypted:\", decrypt(encrypt(message, square), square))\n        print(\"\")\n\n\nif __name__ == \"__main__\":\n    main()\n"
                }
            ],
            [
                {
                    "language": "J",
                    "solution": "alpha=: a.{~65+i.26\nnormalize=: {{ rplc&'JI'(toupper y)([-.-.)alpha }}\nbifid=: {{ m{~_2 (t&#.)\\,|:(t,t=.%:#m)#:m i.y([-.-.)m }}\ndifib=: {{ m{~t#.|:(|.@$$,)(t,t=.%:#m)#:m i.y([-.-.)m }}\n"
                },
                {
                    "language": "Nim",
                    "solution": "import std/[sequtils, strutils, tables]\n\n# Description of a Bifid cipher.\ntype Bifid[N: static Positive] = object\n  grid: array[1..N, array[1..N, char]]\n  coords: Table[char, (int, int)]\n\nproc initBifid(N: static Positive; text: string): Bifid[N] =\n  # Initialize a Bifid cipher.\n  assert text.len == N * N\n  var row, col = 1\n  for c in text:\n    result.grid[row][col] = c\n    result.coords[c] = (row, col)\n    inc col\n    if col > N:\n      col = 1\n      inc row\n  if N == 5:\n    result.coords['J'] = result.coords['I']\n\nfunc encrypt(bifid: Bifid; text: string): string =\n  ## Encrypt \"text\" using the given cipher.\n  var row1, row2: seq[int]\n  for ch in text:\n    let coords = bifid.coords[ch]\n    row1.add coords[0]\n    row2.add coords[1]\n  let row = row1 & row2\n  for i in countup(0, row.high, 2):\n    result.add bifid.grid[row[i]][row[i+1]]\n\nfunc decrypt(bifid: Bifid; text: string): string =\n  ## Decrypt \"text\" using the given cipher.\n  var row: seq[int]\n  for ch in text:\n    let coords = bifid.coords[ch]\n    row.add [coords[0],  coords[1]]\n  let m = row.len shr 1\n  let row1 = row[0..<m]\n  let row2 = row[m..^1]\n  for i in 0..<m:\n    result.add bifid.grid[row1[i]][row2[i]]\n\nfunc `$`(bifid: Bifid): string =\n  ## Display the Polybius square of a Bifid cipher.\n  result = \"  \" & toSeq(1..bifid.N).join(\" \") & '\\n'\n  for row in 1..bifid.N:\n    result.add alignLeft($row, 2) & bifid.grid[row].join(\" \") & '\\n'\n\nproc runTest(bifid: Bifid; message: string) =\n  ## Run the test with given cipher and message.\n  echo \"Using Polybius square:\"\n  echo bifid\n  echo \"Message:   \", message\n  let encrypted = bifid.encrypt(message)\n  echo \"Encrypted: \", encrypted\n  let decrypted = bifid.decrypt(encrypted)\n  echo \"Decrypted: \", decrypted\n  echo(\"\\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\")\n\nconst\n  Message1 = \"ATTACKATDAWN\"\n  Message2 = \"FLEEATONCE\"\n  Message3 = \"The invasion will start on the first of January\".toUpperAscii.replace(\" \")\n\n# Using 5x5 Polybius squares.\nconst\n  Bifid1 = initBifid(5, \"ABCDEFGHIKLMNOPQRSTUVWXYZ\")\n  Bifid2 = initBifid(5, \"BGWKZQPNDSIOAXEFCLUMTHYVR\")\nfor (bifid, message) in [(Bifid1, Message1), (Bifid2, Message2),\n                         (Bifid2, Message1), (Bifid1, Message3)]:\n  runTest(bifid, message)\n\n# Using a 6x6 Polybius square with 26 letters and 10 digits.\nconst Bifid3 = initBifid(6, \"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\")\nrunTest(Bifid3, Message3)\n"
                }
            ],
            [
                {
                    "language": "Jq",
                    "solution": "# Input: the message to be encrypted\ndef encrypt($polybius):\n  (ascii_upcase | gsub(\"J\"; \"I\") ) as $m\n  | {rows: [], cols : [] }\n  | reduce ($m|chars) as $c (.;\n      ($polybius|index($c)) as $ix\n      | if $ix\n        then .rows += [($ix/5)|floor + 1]\n        | .cols += [($ix%5) + 1]\n        else .\n        end )\n  | reduce (.rows + .cols | _nwise(2)) as $pair (\"\";\n      (($pair[0] - 1) * 5 + $pair[1] - 1) as $ix\n      | . + $polybius[$ix:$ix+1] ) ;\n\n# Input: the message to be decrypted\ndef decrypt($polybius):\n  reduce chars as $c ( {rows: [], cols : [] };\n       ($polybius|index($c)) as $ix\n       | .rows += [($ix/5)|floor + 1]\n       | .cols += [($ix%5) + 1] )\n  | ([.rows, .cols] | transpose | flatten) as $lines\n  | ($lines|length/2) as $count\n  | $lines[:$count] as $rows\n  | $lines[$count:] as $cols\n  | [$rows, $cols] as $d\n  | reduce range(0; $count) as $i (\"\";\n       (($rows[$i] - 1) * 5 + $cols[$i] - 1) as $ix\n       | . + $polybius[$ix:$ix+1] ) ;\n\ndef polys:\n  def p1: \"ABCDEFGHIKLMNOPQRSTUVWXYZ\";\n  def p2: \"BGWKZQPNDSIOAXEFCLUMTHYVR\";\n  def p3: \"PLAYFIREXMBCDGHKNOQSTUVWZ\";\n  [p1, p2, p2, p3];\n\ndef messages: [\n  \"ATTACKATDAWN\",\n  \"FLEEATONCE\",\n  \"ATTACKATDAWN\",\n  \"The invasion will start on the first of January\"\n  ];\n\ndef task:\n  range(0; messages|length) as $i\n  |  messages[$i]\n  | encrypt(polys[$i]) as $encrypted\n  | ($encrypted | decrypt(polys[$i] )) as $decrypted\n  | \"Message   : \\(.)\",\n    \"Encrypted : \\($encrypted)\",\n    \"Decrypted : \\($decrypted)\"\n    \"\" ;\n\ntask\n"
                },
                {
                    "language": "J",
                    "solution": "ref1=: ~.normalize alpha\nref2=: 'BGWKZQPNDSIOAXEFCLUMTHYVR'\nref3=: 'PLAYFIREXMBCDGHKNOQSTUVWZ'\n\n   ref1 bifid normalize 'attack at dawn'\nDQBDAXDQPDQH\n   ref1 difib ref1 bifid normalize 'attack at dawn'\nATTACKATDAWN\n   ref2 bifid normalize 'flee at once'\nUAEOLWRINS\n   ref2 difib ref2 bifid normalize 'flee at once'\nFLEEATONCE\n   ref2 bifid normalize 'attack at dawn'\nEYFENGIWDILA\n   ref2 difib ref2 bifid normalize 'attack at dawn'\nATTACKATDAWN\n   ref3 bifid normalize 'The invasion will start on the first of January'\nVRSYXSIYTMQVIRSKISLPVLDTCKRTCAIVTMATCEX\n   ref3 difib ref3 bifid normalize 'The invasion will start on the first of January'\nTHEINVASIONWILLSTARTONTHEFIRSTOFIANUARY\n   (_81{.123{.a.)bifid 'The invasion will start on the first of January'\nTgqhpqpqxzpxfqzoKqhxw/O3eWH53BYw`+Be8F1\n   (_81{.123{.a.)difib(_81{.123{.a.)bifid 'The invasion will start on the first of January'\nTheinvasionwillstartonthefirstofJanuary\n"
                }
            ],
            [
                {
                    "language": "AppleScript",
                    "solution": "\"Given example:\nATTACKATDAWN --> DQBDAXDQPDQH --> ATTACKATDAWN\nWikipedia example:\nFLEEATONCE --> UAEOLWRINS --> FLEEATONCE\nA 6 x 6 square allows all 36 letters & digits to be encoded:\nThe invasion will start on the 1st of January --> TTFAEWUAU9WTE3WP1S5KDF0B8M9AH7KHHVLAV --> THEINVASIONWILLSTARTONTHE1STOFJANUARY\"\n"
                },
                {
                    "language": "J",
                    "solution": "alpha=: a.{~65+i.26\nnormalize=: {{ rplc&'JI'(toupper y)([-.-.)alpha }}\nbifid=: {{ m{~_2 (t&#.)\\,|:(t,t=.%:#m)#:m i.y([-.-.)m }}\ndifib=: {{ m{~t#.|:(|.@$$,)(t,t=.%:#m)#:m i.y([-.-.)m }}\n"
                }
            ]
        ]
    },
    {
        "task_name": "Bin-given-limits",
        "task_description": "You are given a list of n ascending, unique numbers which are to form limits\nfor n+1 bins which count how many of a large set of input numbers fall in the\nrange of each bin.\n\n(Assuming zero-based indexing)\n\n    bin[0] counts how many inputs are < limit[0]\n    bin[1] counts how many inputs are >= limit[0] and < limit[1]\n    ..''\n    bin[n-1] counts how many inputs are >= limit[n-2] and < limit[n-1]\n    bin[n] counts how many inputs are >= limit[n-1]\n\n;Task:\nThe task is to create a function that given the ascending limits and a stream/\nlist of numbers, will return the bins; together with another function that\ngiven the same list of limits and the binning will ''print the limit of each bin\ntogether with the count of items that fell in the range''.\n\nAssume the numbers to bin are too large to practically sort.\n\n;Task examples:\nPart 1: Bin using the following limits the given input data\n\n    limits  = [23, 37, 43, 53, 67, 83]\n    data = [95,21,94,12,99,4,70,75,83,93,52,80,57,5,53,86,65,17,92,83,71,61,54,58,47,\n            16, 8, 9,32,84,7,87,46,19,30,37,96,6,98,40,79,97,45,64,60,29,49,36,43,55]\n\nPart 2: Bin using the following limits the given input data\n\n    limits = [14, 18, 249, 312, 389, 392, 513, 591, 634, 720]\n    data = [445,814,519,697,700,130,255,889,481,122,932, 77,323,525,570,219,367,523,442,933,\n            416,589,930,373,202,253,775, 47,731,685,293,126,133,450,545,100,741,583,763,306,\n            655,267,248,477,549,238, 62,678, 98,534,622,907,406,714,184,391,913, 42,560,247,\n            346,860, 56,138,546, 38,985,948, 58,213,799,319,390,634,458,945,733,507,916,123,\n            345,110,720,917,313,845,426,  9,457,628,410,723,354,895,881,953,677,137,397, 97,\n            854,740, 83,216,421, 94,517,479,292,963,376,981,480, 39,257,272,157,  5,316,395,\n            787,942,456,242,759,898,576, 67,298,425,894,435,831,241,989,614,987,770,384,692,\n            698,765,331,487,251,600,879,342,982,527,736,795,585, 40, 54,901,408,359,577,237,\n            605,847,353,968,832,205,838,427,876,959,686,646,835,127,621,892,443,198,988,791,\n            466, 23,707,467, 33,670,921,180,991,396,160,436,717,918,  8,374,101,684,727,749]\n\nShow output here, on this page.\n",
        "solution_pairs": [
            [
                {
                    "language": "Wren",
                    "solution": "import \"./sort\" for Find\nimport \"./fmt\" for Fmt\n\nvar getBins = Fn.new { |limits, data|\n    var n = limits.count\n    var bins = List.filled(n+1, 0)\n    for (d in data) {\n        var res = Find.all(limits, d) // uses binary search\n        var found = res[0]\n        var index = res[2].from\n        if (found) index = index + 1\n        bins[index] = bins[index] + 1\n    }\n    return bins\n}\n\nvar printBins = Fn.new { |limits, bins|\n    for (i in 0..limits.count) {\n        if (i == 0) {\n            Fmt.print(\"           < $3d = $2d\", limits[0], bins[0])\n        } else if (i == limits.count) {\n            Fmt.print(\">= $3d           = $2d\", limits[i-1], bins[i])\n        } else {\n            Fmt.print(\">= $3d and < $3d = $2d\", limits[i-1], limits[i], bins[i])\n        }\n    }\n    System.print()\n}\n\nvar limitsList  = [\n    [23, 37, 43, 53, 67, 83],\n    [14, 18, 249, 312, 389, 392, 513, 591, 634, 720]\n]\n\nvar dataList = [\n    [\n        95,21,94,12,99,4,70,75,83,93,52,80,57, 5,53,86,65,17,92,83,71,61,54,58,47,\n        16, 8, 9,32,84,7,87,46,19,30,37,96, 6,98,40,79,97,45,64,60,29,49,36,43,55\n    ],\n    [\n       445,814,519,697,700,130,255,889,481,122,932, 77,323,525,570,219,367,523,442,933,\n       416,589,930,373,202,253,775, 47,731,685,293,126,133,450,545,100,741,583,763,306,\n       655,267,248,477,549,238, 62,678, 98,534,622,907,406,714,184,391,913, 42,560,247,\n       346,860, 56,138,546, 38,985,948, 58,213,799,319,390,634,458,945,733,507,916,123,\n       345,110,720,917,313,845,426,  9,457,628,410,723,354,895,881,953,677,137,397, 97,\n       854,740, 83,216,421, 94,517,479,292,963,376,981,480, 39,257,272,157,  5,316,395,\n       787,942,456,242,759,898,576, 67,298,425,894,435,831,241,989,614,987,770,384,692,\n       698,765,331,487,251,600,879,342,982,527,736,795,585, 40, 54,901,408,359,577,237,\n       605,847,353,968,832,205,838,427,876,959,686,646,835,127,621,892,443,198,988,791,\n       466, 23,707,467, 33,670,921,180,991,396,160,436,717,918,  8,374,101,684,727,749\n    ]\n]\n\nfor (i in 0...limitsList.count) {\n    System.print(\"Example %(i+1):\\n\")\n    var bins = getBins.call(limitsList[i], dataList[i])\n    printBins.call(limitsList[i], bins)\n}\n"
                },
                {
                    "language": "11l",
                    "solution": "F bisect_right(a, x)\n   V lo = 0\n   V hi = a.len\n   L lo < hi\n      V mid = (lo + hi) I/ 2\n      I x < a[mid]\n         hi = mid\n      E\n         lo = mid + 1\n   R lo\n\nF bin_it(limits, data)\n   \u2018Bin data according to (ascending) limits.\u2019\n   V bins = [0] * (limits.len + 1)\n   L(d) data\n      bins[bisect_right(limits, d)]++\n   R bins\n\nF bin_print(limits, bins)\n   print(\u2018          < #3 := #3\u2019.format(limits[0], bins[0]))\n   L(lo, hi, count) zip(limits, limits[1..], bins[1..])\n      print(\u2018>= #3 .. < #3 := #3\u2019.format(lo, hi, count))\n   print(\u2018>= #3          := #3\u2019.format(limits.last, bins.last))\n\nprint(\"RC FIRST EXAMPLE\\n\")\nV limits = [23, 37, 43, 53, 67, 83]\nV data = [95, 21, 94, 12, 99, 4, 70, 75, 83, 93, 52, 80, 57, 5, 53, 86, 65, 17, 92, 83, 71, 61, 54, 58, 47,\n          16,  8,  9, 32, 84, 7, 87, 46, 19, 30, 37, 96, 6, 98, 40, 79, 97, 45, 64, 60, 29, 49, 36, 43, 55]\nV bins = bin_it(limits, data)\nbin_print(limits, bins)\n\nprint(\"\\nRC SECOND EXAMPLE\\n\")\nlimits = [14, 18, 249, 312, 389, 392, 513, 591, 634, 720]\ndata = [445,814,519,697,700,130,255,889,481,122,932, 77,323,525,570,219,367,523,442,933,\n        416,589,930,373,202,253,775, 47,731,685,293,126,133,450,545,100,741,583,763,306,\n        655,267,248,477,549,238, 62,678, 98,534,622,907,406,714,184,391,913, 42,560,247,\n        346,860, 56,138,546, 38,985,948, 58,213,799,319,390,634,458,945,733,507,916,123,\n        345,110,720,917,313,845,426,  9,457,628,410,723,354,895,881,953,677,137,397, 97,\n        854,740, 83,216,421, 94,517,479,292,963,376,981,480, 39,257,272,157,  5,316,395,\n        787,942,456,242,759,898,576, 67,298,425,894,435,831,241,989,614,987,770,384,692,\n        698,765,331,487,251,600,879,342,982,527,736,795,585, 40, 54,901,408,359,577,237,\n        605,847,353,968,832,205,838,427,876,959,686,646,835,127,621,892,443,198,988,791,\n        466, 23,707,467, 33,670,921,180,991,396,160,436,717,918,  8,374,101,684,727,749]\nbins = bin_it(limits, data)\nbin_print(limits, bins)\n"
                }
            ],
            [
                {
                    "language": "Jq",
                    "solution": "< 14 => 3\n< 18 => 0\n< 249 => 44\n< 312 => 10\n< 389 => 16\n< 392 => 2\n< 513 => 28\n< 591 => 16\n< 634 => 6\n< 720 => 16\n>= 720 => 59\n"
                },
                {
                    "language": "Lua",
                    "solution": "function binner(limits, data)\n  local bins = setmetatable({}, {__index=function() return 0 end})\n  local n, flr = #limits+1, math.floor\n  for _, x in ipairs(data) do\n    local lo, hi = 1, n\n    while lo < hi do\n      local mid = flr((lo + hi) / 2)\n      if not limits[mid] or x < limits[mid] then hi=mid else lo=mid+1 end\n    end\n    bins[lo] = bins[lo] + 1\n  end\n  return bins\nend\n\nfunction printer(limits, bins)\n  for i = 1, #limits+1 do\n    print(string.format(\"[%3s,%3s) : %d\", limits[i-1] or \" -\u221e\", limits[i] or \" +\u221e\", bins[i]))\n  end\nend\n\nprint(\"PART 1:\")\nlimits = {23, 37, 43, 53, 67, 83}\ndata = {95,21,94,12,99,4,70,75,83,93,52,80,57,5,53,86,65,17,92,83,71,61,54,58,47,\n        16, 8, 9,32,84,7,87,46,19,30,37,96,6,98,40,79,97,45,64,60,29,49,36,43,55}\nbins = binner(limits, data)\nprinter(limits, bins)\n\nprint(\"\\nPART 2:\")\nlimits = {14, 18, 249, 312, 389, 392, 513, 591, 634, 720}\ndata = {445,814,519,697,700,130,255,889,481,122,932, 77,323,525,570,219,367,523,442,933,\n        416,589,930,373,202,253,775, 47,731,685,293,126,133,450,545,100,741,583,763,306,\n        655,267,248,477,549,238, 62,678, 98,534,622,907,406,714,184,391,913, 42,560,247,\n        346,860, 56,138,546, 38,985,948, 58,213,799,319,390,634,458,945,733,507,916,123,\n        345,110,720,917,313,845,426,  9,457,628,410,723,354,895,881,953,677,137,397, 97,\n        854,740, 83,216,421, 94,517,479,292,963,376,981,480, 39,257,272,157,  5,316,395,\n        787,942,456,242,759,898,576, 67,298,425,894,435,831,241,989,614,987,770,384,692,\n        698,765,331,487,251,600,879,342,982,527,736,795,585, 40, 54,901,408,359,577,237,\n        605,847,353,968,832,205,838,427,876,959,686,646,835,127,621,892,443,198,988,791,\n        466, 23,707,467, 33,670,921,180,991,396,160,436,717,918,  8,374,101,684,727,749}\nbins = binner(limits, data)\nprinter(limits, bins)\n"
                }
            ],
            [
                {
                    "language": "Factor",
                    "solution": "USING: assocs formatting grouping io kernel math math.parser\nmath.statistics sequences sequences.extras sorting.extras ;\n\n: bin ( data limits -- seq )\n    dup length 1 + [ 0 ] replicate -rot\n    [ bisect-right over [ 1 + ] change-nth ] curry each ;\n\n: .bin ( {lo,hi} n i -- )\n    swap \"%3d members in \" printf zero? \"(\" \"[\" ? write\n    \"%s, %s)\\n\" vprintf ;\n\n: .bins ( data limits -- )\n    dup [ number>string ] map \"-\u221e\" prefix \"\u221e\" suffix 2 clump\n    -rot bin [ .bin ] 2each-index ;\n\n\n\"First example:\" print\n{\n    95 21 94 12 99 4 70 75 83 93 52 80 57 5 53 86 65 17 92 83 71\n    61 54 58 47 16 8 9 32 84 7 87 46 19 30 37 96 6 98 40 79 97\n    45 64 60 29 49 36 43 55\n}\n{ 23 37 43 53 67 83 } .bins nl\n\n\"Second example:\" print\n{\n    445 814 519 697 700 130 255 889 481 122\n    932  77 323 525 570 219 367 523 442 933\n    416 589 930 373 202 253 775  47 731 685\n    293 126 133 450 545 100 741 583 763 306\n    655 267 248 477 549 238  62 678  98 534\n    622 907 406 714 184 391 913  42 560 247\n    346 860  56 138 546  38 985 948  58 213\n    799 319 390 634 458 945 733 507 916 123\n    345 110 720 917 313 845 426   9 457 628\n    410 723 354 895 881 953 677 137 397  97\n    854 740  83 216 421  94 517 479 292 963\n    376 981 480  39 257 272 157   5 316 395\n    787 942 456 242 759 898 576  67 298 425\n    894 435 831 241 989 614 987 770 384 692\n    698 765 331 487 251 600 879 342 982 527\n    736 795 585  40  54 901 408 359 577 237\n    605 847 353 968 832 205 838 427 876 959\n    686 646 835 127 621 892 443 198 988 791\n    466  23 707 467  33 670 921 180 991 396\n    160 436 717 918   8 374 101 684 727 749\n}\n{ 14 18 249 312 389 392 513 591 634 720 } .bins\n"
                },
                {
                    "language": "Ada",
                    "solution": "package binning is\n   type Nums_Array is array (Natural range <>) of Integer;\n   function Is_Sorted (Item : Nums_Array) return Boolean;\n   subtype Limits_Array is Nums_Array with\n        Dynamic_Predicate => Is_Sorted (Limits_Array);\n   function Bins (Limits : Limits_Array; Data : Nums_Array) return Nums_Array;\n   procedure Print (Limits : Limits_Array; Bin_Result : Nums_Array);\nend binning;\n"
                }
            ],
            [
                {
                    "language": "CLU",
                    "solution": "% Bin the given data, return an array of counts.\n% CLU allows arrays to start at any index; the result array\n% will have the same lower bound as the limit array.\n\n% The datatype for the limits and data may be any type\n% that allows the < comparator.\nbin_count = proc [T: type] (limits, data: array[T]) returns (array[int])\n            where T has lt: proctype (T,T) returns (bool)\n    ad = array[T]       % abbreviations for array types\n    ai = array[int]\n\n    lowbin: int := ad$low(limits)\n    bins: ai := ai$fill(lowbin, ad$size(limits)+1, 0)\n\n    for item: T in ad$elements(data) do\n        bin: int := lowbin\n        while bin <= ad$high(limits) do\n            if item < limits[bin] then break end\n            bin := bin + 1\n        end\n        bins[bin] := bins[bin] + 1\n    end\n\n    return(bins)\nend bin_count\n\n% Display the bins and the amount of items in each bin.\n% This imposes the further restriction on the datatype\n% that it allows `unparse' (may be turned into a string).\ndisplay_bins = proc [T: type] (limits, data: array[T])\n               where T has unparse: proctype (T) returns (string),\n                     T has lt: proctype (T,T) returns (bool)\n    ad = array[T]\n    ai = array[int]\n\n    po: stream := stream$primary_output()\n    bins: ai := bin_count[T](limits, data)\n\n    for i: int in int$from_to(ad$low(limits), ad$high(limits)+1) do\n        lo, hi: string\n        if i-1 < ad$low(limits)\n            then lo := \"-inf\"\n            else lo := T$unparse(limits[i-1])\n        end\n        if i > ad$high(limits)\n            then hi := \"inf\"\n            else hi := T$unparse(limits[i])\n        end\n\n        stream$putright(po, lo, 5)\n        stream$puts(po, \" - \")\n        stream$putright(po, hi, 5)\n        stream$puts(po, \" : \")\n        stream$putright(po, int$unparse(bins[i]), 5)\n        stream$putl(po, \"\")\n    end\n\n    stream$putl(po, \"------------------------------------------\\n\")\nend display_bins\n\n% Try both example inputs\nstart_up = proc ()\n    ai = array[int]\n\n    limits1: ai := ai$[23, 37, 43, 53, 67, 83]\n    data1: ai := ai$\n     [95,21,94,12,99,4,70,75,83,93,52,80,57,5,53,86,65,17,92,83,71,61,54,58,47,\n      16, 8, 9,32,84,7,87,46,19,30,37,96,6,98,40,79,97,45,64,60,29,49,36,43,55]\n\n    limits2: ai := ai$[14, 18, 249, 312, 389, 392, 513, 591, 634, 720]\n    data2: ai := ai$\n     [445,814,519,697,700,130,255,889,481,122,932, 77,323,525,570,219,367,523,442,933,\n      416,589,930,373,202,253,775, 47,731,685,293,126,133,450,545,100,741,583,763,306,\n      655,267,248,477,549,238, 62,678, 98,534,622,907,406,714,184,391,913, 42,560,247,\n      346,860, 56,138,546, 38,985,948, 58,213,799,319,390,634,458,945,733,507,916,123,\n      345,110,720,917,313,845,426,  9,457,628,410,723,354,895,881,953,677,137,397, 97,\n      854,740, 83,216,421, 94,517,479,292,963,376,981,480, 39,257,272,157,  5,316,395,\n      787,942,456,242,759,898,576, 67,298,425,894,435,831,241,989,614,987,770,384,692,\n      698,765,331,487,251,600,879,342,982,527,736,795,585, 40, 54,901,408,359,577,237,\n      605,847,353,968,832,205,838,427,876,959,686,646,835,127,621,892,443,198,988,791,\n      466, 23,707,467, 33,670,921,180,991,396,160,436,717,918,  8,374,101,684,727,749]\n\n    display_bins[int](limits1, data1)\n    display_bins[int](limits2, data2)\nend start_up\n"
                },
                {
                    "language": "REXX",
                    "solution": "/*REXX program counts how many numbers of a set that fall in the range of each bin. */\nlims= 23 37 43 53 67 83                      /* <----- 1st set of bin limits & data.*/\ndata= 95 21 94 12 99 4 70 75 83 93 52 80 57 5 53 86 65 17 92 83 71 61 54 58 47,\n      16 8 9 32 84 7 87 46 19 30 37 96 6 98 40 79 97 45 64 60 29 49 36 43 55\ncall limits lims\ncall bins data\ncall show 'the 1st set of bin counts for the specified data:'\nDo 3; say''; End\nlims=  14  18 249 312 389 392 513 591 634 720 /* <-----2nd set of bin limits & data.*/\ndata= 445 814 519 697 700 130 255 889 481 122 932  77 323 525 570 219 367 523 442 933,\n      416 589 930 373 202 253 775  47 731 685 293 126 133 450 545 100 741 583 763 306,\n      655 267 248 477 549 238  62 678  98 534 622 907 406 714 184 391 913  42 560 247,\n      346 860  56 138 546  38 985 948  58 213 799 319 390 634 458 945 733 507 916 123,\n      345 110 720 917 313 845 426   9 457 628 410 723 354 895 881 953 677 137 397  97,\n      854 740  83 216 421  94 517 479 292 963 376 981 480  39 257 272 157   5 316 395,\n      787 942 456 242 759 898 576  67 298 425 894 435 831 241 989 614 987 770 384 692,\n      698 765 331 487 251 600 879 342 982 527 736 795 585  40  54 901 408 359 577 237,\n      605 847 353 968 832 205 838 427 876 959 686 646 835 127 621 892 443 198 988 791,\n      466  23 707 467  33 670 921 180 991 396 160 436 717 918   8 374 101 684 727 749\ncall limits lims\ncall bins data\ncall show 'the 2nd set of bin counts for the specified data:'\nexit 0\n/*------------------------------------------------------------------------------*/\nbins:\n  Parse Arg numbers\n  count.=0\n  Do j=1 To words(numbers)\n    x=word(numbers,j)\n    Do k=1 To bins-1 Until x<limit.k  /* determine which bin is to be used      */\n      End\n    count.k=count.k+1               /* increment count for this bin             */\n    End\n  count_length=0                    /* compute the length of the largest count  */\n  Do k=0 To bins\n    count_length=max(count_length,length(count.k))\n    End\n  Return\n/*------------------------------------------------------------------------------*/\nlimits:\n  Parse Arg limlist\n  limit_length=0\n  bins=words(limlist)+1             /* number of bins                           */\n  limit.=''\n  Do j=1 To bins-1\n    limit.j=word(limlist,j)         /* lower limit of bin j                     */\n    limit_length=max(limit_length,length(limit.j)) /* length of largest limit   */\n    End\n  Return\n/*------------------------------------------------------------------------------*/\nshow:\n  Say arg(1)\n  Say copies('-',51)\n  ll=limit_length\n  do k=1 To bins\n    km1=k-1\n    Select\n      When k=1 Then\n        range='  ' right(''       ,ll) '   <' right(limit.k,ll)\n      When k<bins Then\n        range='>=' right(limit.km1,ll) '.. <' right(limit.k,ll)\n      Otherwise\n        range='>=' right(limit.km1,ll) '    ' right(''     ,ll)\n      End\n    Say '       'range '   count=' right(count.k,count_length)\n    End\n  Return\n"
                }
            ],
            [
                {
                    "language": "Ring",
                    "solution": "limit = [0, 23, 37, 43, 53, 67, 83]\ndata  = [95,21,94,12,99,4,70,75,83,93,52,80,57,5,53,86,65,17,92,83,71,61,54,58,47,\n         16, 8, 9,32,84,7,87,46,19,30,37,96,6,98,40,79,97,45,64,60,29,49,36,43,55]\ndata  = sort(data)\ndn    = list(len(limit))\nsee \"Example 1:\" + nl + nl\nlimits(limit,data,dn)\nsee nl\n\nlimit = [0, 14, 18, 249, 312, 389, 392, 513, 591, 634, 720]\ndata   = [445,814,519,697,700,130,255,889,481,122,932, 77,323,525,570,219,367,523,442,933,\n          416,589,930,373,202,253,775, 47,731,685,293,126,133,450,545,100,741,583,763,306,\n          655,267,248,477,549,238, 62,678, 98,534,622,907,406,714,184,391,913, 42,560,247,\n          346,860, 56,138,546, 38,985,948, 58,213,799,319,390,634,458,945,733,507,916,123,\n          345,110,720,917,313,845,426,  9,457,628,410,723,354,895,881,953,677,137,397, 97,\n          854,740, 83,216,421, 94,517,479,292,963,376,981,480, 39,257,272,157,  5,316,395,\n          787,942,456,242,759,898,576, 67,298,425,894,435,831,241,989,614,987,770,384,692,\n          698,765,331,487,251,600,879,342,982,527,736,795,585, 40, 54,901,408,359,577,237,\n          605,847,353,968,832,205,838,427,876,959,686,646,835,127,621,892,443,198,988,791,\n          466, 23,707,467, 33,670,921,180,991,396,160,436,717,918,  8,374,101,684,727,749]\ndata  = sort(data)\ndn    = list(len(limit))\nsee \"Example 2:\" + nl + nl\nlimits(limit,data,dn)\n\nfunc limits(limit,data,dn)\n     for n = 1 to len(data)\n         for m = 1 to len(limit)-1\n             if data[n] >= limit[m] and data[n] < limit[m+1]\n                dn[m] += 1\n              ok\n         next\n         if data[n] >= limit[len(limit)]\n            dn[len(limit)] += 1\n         ok\n     next\n\n     for n = 1 to len(limit)-1\n        see \">= \" + limit[n] + \" and < \" + limit[n+1] + \" := \" + dn[n] + nl\n     next\n     see \">= \" + limit[n] + \" := \" + dn[n] + nl\n"
                },
                {
                    "language": "Go",
                    "solution": "package main\n\nimport (\n    \"fmt\"\n    \"sort\"\n)\n\nfunc getBins(limits, data []int) []int {\n    n := len(limits)\n    bins := make([]int, n+1)\n    for _, d := range data {\n        index := sort.SearchInts(limits, d) // uses binary search\n        if index < len(limits) && d == limits[index] {\n            index++\n        }\n        bins[index]++\n    }\n    return bins\n}\n\nfunc printBins(limits, bins []int) {\n    n := len(limits)\n    fmt.Printf(\"           < %3d = %2d\\n\", limits[0], bins[0])\n    for i := 1; i < n; i++ {\n        fmt.Printf(\">= %3d and < %3d = %2d\\n\", limits[i-1], limits[i], bins[i])\n    }\n    fmt.Printf(\">= %3d           = %2d\\n\", limits[n-1], bins[n])\n    fmt.Println()\n}\n\nfunc main() {\n    limitsList := [][]int{\n        {23, 37, 43, 53, 67, 83},\n        {14, 18, 249, 312, 389, 392, 513, 591, 634, 720},\n    }\n\n    dataList := [][]int{\n        {\n            95, 21, 94, 12, 99, 4, 70, 75, 83, 93, 52, 80, 57, 5, 53, 86, 65, 17, 92, 83, 71, 61, 54, 58, 47,\n            16,  8,  9, 32, 84, 7, 87, 46, 19, 30, 37, 96, 6, 98, 40, 79, 97, 45, 64, 60, 29, 49, 36, 43, 55,\n        },\n        {\n            445, 814, 519, 697, 700, 130, 255, 889, 481, 122, 932,  77, 323, 525, 570, 219, 367, 523, 442, 933,\n            416, 589, 930, 373, 202, 253, 775,  47, 731, 685, 293, 126, 133, 450, 545, 100, 741, 583, 763, 306,\n            655, 267, 248, 477, 549, 238,  62, 678,  98, 534, 622, 907, 406, 714, 184, 391, 913,  42, 560, 247,\n            346, 860,  56, 138, 546,  38, 985, 948,  58, 213, 799, 319, 390, 634, 458, 945, 733, 507, 916, 123,\n            345, 110, 720, 917, 313, 845, 426,   9, 457, 628, 410, 723, 354, 895, 881, 953, 677, 137, 397,  97,\n            854, 740,  83, 216, 421,  94, 517, 479, 292, 963, 376, 981, 480,  39, 257, 272, 157,   5, 316, 395,\n            787, 942, 456, 242, 759, 898, 576,  67, 298, 425, 894, 435, 831, 241, 989, 614, 987, 770, 384, 692,\n            698, 765, 331, 487, 251, 600, 879, 342, 982, 527, 736, 795, 585,  40,  54, 901, 408, 359, 577, 237,\n            605, 847, 353, 968, 832, 205, 838, 427, 876, 959, 686, 646, 835, 127, 621, 892, 443, 198, 988, 791,\n            466,  23, 707, 467,  33, 670, 921, 180, 991, 396, 160, 436, 717, 918,   8, 374, 101, 684, 727, 749,\n        },\n    }\n\n    for i := 0; i < len(limitsList); i++ {\n        fmt.Println(\"Example\", i+1, \"\\b\\n\")\n        bins := getBins(limitsList[i], dataList[i])\n        printBins(limitsList[i], bins)\n    }\n}\n"
                }
            ]
        ]
    },
    {
        "task_name": "Binary-digits",
        "task_description": ";Task:\nCreate and display the sequence of binary digits for a given &nbsp; [[wp:Natural number|non-negative integer]].\n\n    The decimal value &nbsp;    '''5''' &nbsp; should produce an output of &nbsp;             '''101'''\n    The decimal value &nbsp;   '''50''' &nbsp; should produce an output of &nbsp;          '''110010'''\n    The decimal value &nbsp; '''9000''' &nbsp; should produce an output of &nbsp;  '''10001100101000'''\n\nThe results can be achieved using built-in radix functions within the language &nbsp; (if these are available), &nbsp; or alternatively a user defined function can be used. \n\nThe output produced should consist just of the binary digits of each number followed by a &nbsp; ''newline''. \n\nThere should be no other whitespace, radix or sign markers in the produced output, and [[wp:Leading zero|leading zeros]] should not appear in the results.\n<br><br>\n",
        "solution_pairs": [
            [
                {
                    "language": "Ecstasy",
                    "solution": "module BinaryDigits {\n    @Inject Console console;\n    void run() {\n        Int64[] tests = [0, 1, 5, 50, 9000];\n\n        Int longestInt = tests.map(n -> n.estimateStringLength())\n                              .reduce(0, (max, len) -> max.notLessThan(len));\n        Int longestBin = tests.map(n -> (64-n.leadingZeroCount).notLessThan(1))\n                              .reduce(0, (max, len) -> max.maxOf(len));\n\n        function String(Int64) num = n -> {\n            Int indent = longestInt - n.estimateStringLength();\n            return $\"{' ' * indent}{n}\";\n        };\n\n        function String(Int64) bin = n -> {\n            Int index  = n.leadingZeroCount.minOf(63);\n            Int indent = index - (64 - longestBin);\n            val bits   = n.toBitArray()[index ..< 64];\n            return $\"{' ' * indent}{bits.toString().substring(2)}\";\n        };\n\n        for (Int64 test : tests) {\n            console.print($\"The decimal value {num(test)} should produce an output of {bin(test)}\");\n        }\n    }\n}\n"
                },
                {
                    "language": "TI-83-BASIC",
                    "solution": "PROGRAM:BINARY\n:Disp \"NUMBER TO\"\n:Disp \"CONVERT\"\n:Input \"Str1\"\n:Disp real(25,Str1,10,2)\n"
                }
            ],
            [
                {
                    "language": "MLite",
                    "solution": "fun binary\n\t\t(0, b)\t=\timplode ` map (fn x = if int x then chr (x + 48) else x) b\n\t|\t(n, b)\t=\tbinary (n div 2, n mod 2 :: b)\n\t|\tn\t=\tbinary (n, [])\n;\t\n"
                },
                {
                    "language": "UNIX-Shell",
                    "solution": "bin() {\n    set -- \"${1:-0}\" \"\"\n    while [ 1 -lt \"$1\" ]\n    do\n        set -- $(($1 >> 1)) $(($1 & 1))$2\n    done\n    echo \"$1$2\"\n}\n\necho $(for i in 0 1 2 5 50 9000; do bin $i; done)\n"
                }
            ],
            [
                {
                    "language": "Elixir",
                    "solution": "IO.puts Integer.to_string(5, 2)\n"
                },
                {
                    "language": "Modula-3",
                    "solution": "MODULE Binary EXPORTS Main;\n\nIMPORT IO, Fmt;\n\nVAR num := 10;\n\nBEGIN\n  IO.Put(Fmt.Int(num, 2) & \"\\n\");\n  num := 150;\n  IO.Put(Fmt.Int(num, 2) & \"\\n\");\nEND Binary.\n"
                }
            ],
            [
                {
                    "language": "Whitespace",
                    "solution": "\t\n"
                },
                {
                    "language": "True-BASIC",
                    "solution": "FUNCTION BIN$ (N)\n    LET N = ABS(INT(N))\n    LET B$ = \"\"\n    DO\n       LET I = MOD(N, 2)\n       LET B$ = STR$(I) & B$\n       LET N = INT(N / 2)\n    LOOP WHILE N > 0\n    LET BIN$ = B$\nEND FUNCTION\n\n\nPRINT USING \"####\": 5;\nPRINT \" -> \"; BIN$(5)\nPRINT USING \"####\": 50;\nPRINT \" -> \"; BIN$(50)\nPRINT USING \"####\": 9000;\nPRINT \" -> \"; BIN$(9000)\nEND\n"
                }
            ],
            [
                {
                    "language": "QBasic",
                    "solution": "FUNCTION BIN$ (N)\n    N = ABS(INT(N))\n    B$ = \"\"\n    DO\n        B$ = STR$(N MOD 2) + B$\n        N = INT(N / 2)\n    LOOP WHILE N > 0\n    BIN$ = B$\nEND FUNCTION\n\nfmt$ = \"#### -> &\"\nPRINT USING fmt$; 5; BIN$(5)\nPRINT USING fmt$; 50; BIN$(50)\nPRINT USING fmt$; 9000; BIN$(9000)\n"
                },
                {
                    "language": "Elixir",
                    "solution": "IO.puts Integer.to_string(5, 2)\n"
                }
            ]
        ]
    },
    {
        "task_name": "Binary-search",
        "task_description": "A binary search divides a range of values into halves, and continues to narrow down the field of search until the unknown value is found. It is the classic example of a \"divide and conquer\" algorithm.\n\nAs an analogy, consider the children's game \"[[Guess the number/With feedback|guess a number]].\"  The scorer has a secret number, and will only tell the player if their guessed number is higher than, lower than, or equal to the secret number. The player then uses this information to guess a new number.\n\nAs the player, an optimal strategy for the general case is to start by choosing the range's midpoint as the guess, and then asking whether the guess was higher, lower, or equal to the secret number. If the guess was too high, one would select the point exactly between the range midpoint and the beginning of the range. If the original guess was too low, one would ask about the point exactly between the range midpoint and the end of the range. This process repeats until one has reached the secret number.\n\n\n;Task:\nGiven the starting point of a range, the ending point of a range, and the \"secret value\", implement a binary search through a sorted integer array for a certain number. Implementations can be recursive or iterative (both if you can). Print out whether or not the number was in the array afterwards. If it was, print the index also.\n\nThere are several binary search algorithms commonly seen. They differ by how they treat multiple values equal to the given value, and whether they indicate whether the element was found or not. For completeness we will present pseudocode for all of them.\n\nAll of the following code examples use an \"inclusive\" upper bound (i.e. <code>high = N-1</code> initially). Any of the examples can be converted into an equivalent example using \"exclusive\" upper bound (i.e. <code>high = N</code> initially) by making the following simple changes (which simply increase <code>high</code> by 1):\n* change <code>high = N-1</code> to <code>high = N</code>\n* change <code>high = mid-1</code> to <code>high = mid</code>\n* (for recursive algorithm) change <code>if (high < low)</code> to <code>if (high <= low)</code>\n* (for iterative algorithm) change <code>while (low <= high)</code> to <code>while (low < high)</code>\n\n;Traditional algorithm\nThe algorithms are as follows (from [[wp:Binary search algorithm|Wikipedia]]). The algorithms return the index of some element that equals the given value (if there are multiple such elements, it returns some arbitrary one). It is also possible, when the element is not found, to return the \"insertion point\" for it (the index that the value would have if it were inserted into the array).\n\n'''Recursive Pseudocode''':\n   // initially called with low = 0, high = N-1\n   BinarySearch(A[0..N-1], value, low, high) {\n       // invariants: value > A[i] for all i < low\n                      value < A[i] for all i > high\n       if (high < low)\n           return not_found // value would be inserted at index \"low\"\n       mid = (low + high) / 2\n       if (A[mid] > value)\n           return BinarySearch(A, value, low, mid-1)\n       else if (A[mid] < value)\n           return BinarySearch(A, value, mid+1, high)\n       else\n           return mid\n   }\n\n'''Iterative Pseudocode''':\n   BinarySearch(A[0..N-1], value) {\n       low = 0\n       high = N - 1\n       while (low <= high) {\n           // invariants: value > A[i] for all i < low\n                          value < A[i] for all i > high\n           mid = (low + high) / 2\n           if (A[mid] > value)\n               high = mid - 1\n           else if (A[mid] < value)\n               low = mid + 1\n           else\n               return mid\n       }\n       return not_found // value would be inserted at index \"low\"\n   }\n\n;Leftmost insertion point\nThe following algorithms return the leftmost place where the given element can be correctly inserted (and still maintain the sorted order). This is the lower (inclusive) bound of the range of elements that are equal to the given value (if any). Equivalently, this is the lowest index where the element is greater than or equal to the given value (since if it were any lower, it would violate the ordering), or 1 past the last index if such an element does not exist. This algorithm does not determine if the element is actually found. This algorithm only requires one comparison per level.\n\n'''Recursive Pseudocode''':\n   // initially called with low = 0, high = N - 1\n   BinarySearch_Left(A[0..N-1], value, low, high) {\n       // invariants: value > A[i] for all i < low\n                      value <= A[i] for all i > high\n       if (high < low)\n           return low\n       mid = (low + high) / 2\n       if (A[mid] >= value)\n           return BinarySearch_Left(A, value, low, mid-1)\n       else\n           return BinarySearch_Left(A, value, mid+1, high)\n   }\n\n'''Iterative Pseudocode''':\n   BinarySearch_Left(A[0..N-1], value) {\n       low = 0\n       high = N - 1\n       while (low <= high) {\n           // invariants: value > A[i] for all i < low\n                          value <= A[i] for all i > high\n           mid = (low + high) / 2\n           if (A[mid] >= value)\n               high = mid - 1\n           else\n               low = mid + 1\n       }\n       return low\n   }\n\n;Rightmost insertion point\nThe following algorithms return the rightmost place where the given element can be correctly inserted (and still maintain the sorted order). This is the upper (exclusive) bound of the range of elements that are equal to the given value (if any). Equivalently, this is the lowest index where the element is greater than the given value, or 1 past the last index if such an element does not exist. This algorithm does not determine if the element is actually found. This algorithm only requires one comparison per level. Note that these algorithms are almost exactly the same as the leftmost-insertion-point algorithms, except for how the inequality treats equal values.\n\n'''Recursive Pseudocode''':\n   // initially called with low = 0, high = N - 1\n   BinarySearch_Right(A[0..N-1], value, low, high) {\n       // invariants: value >= A[i] for all i < low\n                      value < A[i] for all i > high\n       if (high < low)\n           return low\n       mid = (low + high) / 2\n       if (A[mid] > value)\n           return BinarySearch_Right(A, value, low, mid-1)\n       else\n           return BinarySearch_Right(A, value, mid+1, high)\n   }\n\n'''Iterative Pseudocode''':\n   BinarySearch_Right(A[0..N-1], value) {\n       low = 0\n       high = N - 1\n       while (low <= high) {\n           // invariants: value >= A[i] for all i < low\n                          value < A[i] for all i > high\n           mid = (low + high) / 2\n           if (A[mid] > value)\n               high = mid - 1\n           else\n               low = mid + 1\n       }\n       return low\n   }\n\n;Extra credit\nMake sure it does not have overflow bugs.\n\nThe line in the pseudo-code above to calculate the mean of two integers:\n<pre>mid = (low + high) / 2</pre>\ncould produce the wrong result in some programming languages when used with a bounded integer type, if the addition causes an overflow. (This can occur if the array size is greater than half the maximum integer value.) If signed integers are used, and <code>low + high</code> overflows, it becomes a negative number, and dividing by 2 will still result in a negative number. Indexing an array with a negative number could produce an out-of-bounds exception, or other undefined behavior. If unsigned integers are used, an overflow will result in losing the largest bit, which will produce the wrong result.\n\nOne way to fix it is to manually add half the range to the low number:\n<pre>mid = low + (high - low) / 2</pre>\nEven though this is mathematically equivalent to the above, it is not susceptible to overflow.\n\nAnother way for signed integers, possibly faster, is the following:\n<pre>mid = (low + high) >>> 1</pre>\nwhere <code> >>> </code> is the logical right shift operator. The reason why this works is that, for signed integers, even though it overflows, when viewed as an unsigned number, the value is still the correct sum. To divide an unsigned number by 2, simply do a logical right shift.\n\n\n;Related task:\n:* [[Guess the number/With Feedback (Player)]]\n\n\n;See also:\n:* [[wp:Binary search algorithm]]\n:* [http://googleresearch.blogspot.com/2006/06/extra-extra-read-all-about-it-nearly.html Extra, Extra - Read All About It: Nearly All Binary Searches and Mergesorts are Broken].\n<br><br>\n",
        "solution_pairs": [
            [
                {
                    "language": "M4",
                    "solution": "define(`notfound',`-1')dnl\ndefine(`midsearch',`ifelse(defn($1[$4]),$2,$4,\n`ifelse(eval(defn($1[$4])>$2),1,`binarysearch($1,$2,$3,decr($4))',`binarysearch($1,$2,incr($4),$5)')')')dnl\ndefine(`binarysearch',`ifelse(eval($4<$3),1,notfound,`midsearch($1,$2,$3,eval(($3+$4)/2),$4)')')dnl\ndnl\ndefine(`setrange',`ifelse(`$3',`',$2,`define($1[$2],$3)`'setrange($1,incr($2),shift(shift(shift($@))))')')dnl\ndefine(`asize',decr(setrange(`a',1,1,3,5,7,11,13,17,19,23,29)))dnl\ndnl\nbinarysearch(`a',5,1,asize)\nbinarysearch(`a',8,1,asize)\n"
                },
                {
                    "language": "MACRO-11",
                    "solution": "        .TITLE  BINRTA\n        .MCALL  .TTYOUT,.PRINT,.EXIT\n        ; TEST CODE\nBINRTA::CLR     R5\n1$:     MOV     R5,R0\n        ADD     #'0,R0\n        .TTYOUT\n        MOV     R5,R0\n        MOV     #DATA,R1\n        MOV     #DATEND,R2\n        JSR     PC,BINSRC\n        BEQ     2$\n        .PRINT  #4$\n        BR      3$\n2$:     .PRINT  #5$\n3$:     INC     R5\n        CMP     R5,#^D10\n        BLT     1$\n        .EXIT\n4$:     .ASCII  / NOT/\n5$:     .ASCIZ  / FOUND/\n        .EVEN\n\n        ; TEST DATA\nDATA:   .WORD   1, 2, 3, 5, 7\nDATEND  =       . + 2\n\n        ; BINARY SEARCH\n        ; INPUT: R0 = VALUE, R1 = LOW PTR, R2 = HIGH PTR\n        ; OUTPUT: ZF SET IF VALUE FOUND; R1 = INSERTION POINT\nBINSRC: BR      3$\n1$:     MOV     R1,R3\n        ADD     R2,R3\n        ROR     R3\n        CMP     (R3),R0\n        BGE     2$\n        ADD     #2,R3\n        MOV     R3,R1\n        BR      3$\n2$:     SUB     #2,R3\n        MOV     R3,R2\n3$:     CMP     R2,R1\n        BGE     1$\n        CMP     (R1),R0\n        RTS     PC\n        .END    BINRTA\n"
                }
            ],
            [
                {
                    "language": "Icon",
                    "solution": "procedure binsearch(A, target)\n    if *A = 0 then fail\n    mid := *A/2 + 1\n    if target > A[mid] then {\n        return mid + binsearch(A[(mid+1):0], target)\n        }\n    else if target < A[mid] then {\n        return binsearch(A[1+:(mid-1)], target)\n        }\n    return mid\nend\n"
                },
                {
                    "language": "UNIX-Shell",
                    "solution": "left=0\nright=$(($size - 1))\nwhile\t[ $left -le $right ] ; do\n\tmid=$((($left + $right) >> 1))\n#\techo \"$left\t$mid(${array[$mid]})\t$right\"\n\tif\t[ $value -eq ${array[$mid]} ] ; then\n\t\techo $mid\n\t\texit\n\telif\t[ $value -lt ${array[$mid]} ]; then\n\t\tright=$(($mid - 1))\n\telse\n\t\tleft=$((mid + 1))\n\tfi\ndone\necho 'ERROR 404 : NOT FOUND'\n"
                }
            ],
            [
                {
                    "language": "Raku",
                    "solution": "sub search (@a, $x --> Int) {\n    binary_search { $x cmp @a[$^i] }, 0, @a.end\n}\n"
                },
                {
                    "language": "FBSL",
                    "solution": "#APPTYPE CONSOLE\n\nDIM va[]\n\nPRINT \"Loading ... \";\nDIM gtc = GetTickCount()\nFOR DIM i = 0 TO 1000000: va[] = i * PI: NEXT\nPRINT \"done in \", GetTickCount() - gtc, \" milliseconds\"\n\ngtc = GetTickCount()\nPRINT 1000000 * PI, \" found at index \", BSearchIter(va, 1000000 * PI), _\n\t\" in \", GetTickCount() - gtc, \" milliseconds\"\n\nPAUSE\n\nFUNCTION BSearchIter(BYVAL array, BYVAL num)\n\tSTATIC low = LBOUND(va), high = UBOUND(va)\n\tWHILE low <= high\n\t\tDIM midp = (high + low) \\ 2\n\t\tIF array[midp] > num THEN\n\t\t\thigh = midp - 1\n\t\tELSEIF array[midp] < num THEN\n\t\t\tlow = midp + 1\n\t\tELSE\n\t\t\tRETURN midp\n\t\tEND IF\n\tWEND\n\tRETURN -1\nEND FUNCTION\n"
                }
            ],
            [
                {
                    "language": "Groovy",
                    "solution": "def a = [] as Set\ndef random = new Random()\nwhile (a.size() < 20) { a << random.nextInt(30) }\ndef source = a.sort()\nsource[0..-2].eachWithIndex { si, i -> assert si < source[i+1] }\n\nprintln \"${source}\"\n1.upto(5) {\n    target = random.nextInt(10) + (it - 2) * 10\n    print \"Trial #${it}. Looking for: ${target}\"\n    def answers = [binSearchR, binSearchI].collect { search ->\n        search(source, target)\n    }\n    assert answers[0] == answers[1]\n    println \"\"\"\n    Answer: ${answers[0]}, : ${source[answers[0].values().iterator().next()]}\"\"\"\n}\n"
                },
                {
                    "language": "D",
                    "solution": "import std.stdio, std.array, std.range, std.traits;\n\n/// Recursive.\nbool binarySearch(R, T)(/*in*/ R data, in T x) pure nothrow @nogc\nif (isRandomAccessRange!R && is(Unqual!T == Unqual!(ElementType!R))) {\n    if (data.empty)\n        return false;\n    immutable i = data.length / 2;\n    immutable mid = data[i];\n    if (mid > x)\n        return data[0 .. i].binarySearch(x);\n    if (mid < x)\n        return data[i + 1 .. $].binarySearch(x);\n    return true;\n}\n\n/// Iterative.\nbool binarySearchIt(R, T)(/*in*/ R data, in T x) pure nothrow @nogc\nif (isRandomAccessRange!R && is(Unqual!T == Unqual!(ElementType!R))) {\n    while (!data.empty) {\n        immutable i = data.length / 2;\n        immutable mid = data[i];\n        if (mid > x)\n            data = data[0 .. i];\n        else if (mid < x)\n            data = data[i + 1 .. $];\n        else\n            return true;\n    }\n    return false;\n}\n\nvoid main() {\n    /*const*/ auto items = [2, 4, 6, 8, 9].assumeSorted;\n    foreach (const x; [1, 8, 10, 9, 5, 2])\n        writefln(\"%2d %5s %5s %5s\", x,\n                 items.binarySearch(x),\n                 items.binarySearchIt(x),\n                 // Standard Binary Search:\n                 !items.equalRange(x).empty);\n}\n"
                }
            ],
            [
                {
                    "language": "Python",
                    "solution": "# findIndexBinary :: (a -> Ordering) -> [a] -> Maybe Int\ndef findIndexBinary(p):\n    def isFound(bounds):\n        (lo, hi) = bounds\n        return lo > hi or 0 == hi\n\n    def half(xs):\n        def choice(lh):\n            (lo, hi) = lh\n            mid = (lo + hi) // 2\n            cmpr = p(xs[mid])\n            return (lo, mid - 1) if cmpr < 0 else (\n                (1 + mid, hi) if cmpr > 0 else (\n                    mid, 0\n                )\n            )\n        return lambda bounds: choice(bounds)\n\n    def go(xs):\n        (lo, hi) = until(isFound)(\n            half(xs)\n        )((0, len(xs) - 1)) if xs else None\n        return None if 0 != hi else lo\n\n    return lambda xs: go(xs)\n\n\n# COMPARISON CONSTRUCTORS ---------------------------------\n\n# compare :: a -> a -> Ordering\ndef compare(a):\n    '''Simple comparison of x and y -> LT|EQ|GT'''\n    return lambda b: -1 if a < b else (1 if a > b else 0)\n\n\n# byKV :: (a -> b) -> a -> a -> Ordering\ndef byKV(f):\n    '''Property accessor function -> target value -> x -> LT|EQ|GT'''\n    def go(v, x):\n        fx = f(x)\n        return -1 if v < fx else 1 if v > fx else 0\n    return lambda v: lambda x: go(v, x)\n\n\n# TESTS ---------------------------------------------------\ndef main():\n\n    # BINARY SEARCH FOR WORD IN AZ-SORTED LIST\n\n    mb1 = findIndexBinary(compare('iota'))(\n        # Sorted AZ\n        ['alpha', 'beta', 'delta', 'epsilon', 'eta', 'gamma', 'iota',\n         'kappa', 'lambda', 'mu', 'theta', 'zeta']\n    )\n\n    print (\n        'Not found' if None is mb1 else (\n            'Word found at index ' + str(mb1)\n        )\n    )\n\n    # BINARY SEARCH FOR WORD OF GIVEN LENGTH (IN WORD-LENGTH SORTED LIST)\n\n    mb2 = findIndexBinary(byKV(len)(7))(\n        # Sorted by rising length\n        ['mu', 'eta', 'beta', 'iota', 'zeta', 'alpha', 'delta', 'gamma',\n         'kappa', 'theta', 'lambda', 'epsilon']\n    )\n\n    print (\n        'Not found' if None is mb2 else (\n            'Word of given length found at index ' + str(mb2)\n        )\n    )\n\n\n# GENERIC -------------------------------------------------\n\n# until :: (a -> Bool) -> (a -> a) -> a -> a\ndef until(p):\n    def go(f, x):\n        v = x\n        while not p(v):\n            v = f(v)\n        return v\n    return lambda f: lambda x: go(f, x)\n\n\nif __name__ == '__main__':\n    main()\n"
                },
                {
                    "language": "Picat",
                    "solution": "go =>\n  A = [2, 4, 6, 8, 9],\n  TestValues = [2,1,8,10,9,5],\n\n  foreach(Value in TestValues)\n    test(binary_search,A, Value)\n  end,\n  test(binary_search,[1,20,3,4], 5),\n  nl.\n\n% Test with binary search predicate Search\ntest(Search,A,Value) =>\n  Ret = apply(Search,A,Value),\n  printf(\"A: %w Value:%d Ret: %d: \", A, Value, Ret),\n  if Ret == -1 then\n    println(\"The array is not sorted.\")\n  elseif Ret == 0 then\n    printf(\"The value %d is not in the array.\\n\", Value)\n  else\n    printf(\"The value %d is found at position %d.\\n\", Value, Ret)\n  end.\n\nbinary_search(A, Value) = V =>\n  V1 = 0,\n  % we want a sorted array\n  if not sort(A) == A then\n    V1 := -1\n  else\n    Low = 1,\n    High = A.length,\n    Mid = 1,\n    Found = 0,\n    while (Found == 0, Low <= High)\n       Mid := (Low + High) // 2,\n       if A[Mid] > Value then\n         High := Mid - 1\n       elseif A[Mid] < Value then\n         Low := Mid + 1\n       else\n         V1 := Mid,\n         Found := 1\n      end\n    end\n  end,\n  V = V1.\n"
                }
            ]
        ]
    },
    {
        "task_name": "Binary-strings",
        "task_description": "Many languages have powerful and useful ('''binary safe''') [[wp:String (computer science)|string]] [[wp:Comparison of programming languages (string functions)|manipulation functions]], while others don't, making it harder for these languages to accomplish some tasks.\n\nThis task is about creating functions to handle ''binary'' strings (strings made of arbitrary bytes, i.e. ''byte strings'' according to Wikipedia) for those languages that don't have built-in support for them. \n\nIf your language of choice does have this built-in support, show a possible alternative implementation for the ''functions'' or ''abilities'' already provided by the language.\n\nIn particular the functions you need to create are:\n* String creation and destruction (when needed and if there's no [[garbage collection]] or similar mechanism)\n* String assignment\n* String comparison\n* String cloning and copying\n* Check if a string is empty\n* Append a byte to a string\n* Extract a substring from a string\n* Replace every occurrence of a byte (or a string) in a string with another string\n* Join strings\n\n<br>\nPossible contexts of use: compression algorithms (like [[LZW compression]]), L-systems (manipulation of symbols), many more.\n<br><br>\n",
        "solution_pairs": [
            [
                {
                    "language": "8086-Assembly",
                    "solution": ";this code assumes that both DS and ES point to the correct segments.\ncld\nmov si,offset TestMessage\nmov di,offset EmptyRam\nmov cx,5  ;length of the source string, you'll need to either know this\n          ;ahead of time or calculate it.\nrep movsb\nret\n\n;there is no buffer overflow protection built into these functions so be careful!\nTestMessage byte \"Hello\"\nEmptyRam byte 0,0,0,0,0\n"
                },
                {
                    "language": "Go",
                    "solution": "package main\n\nimport (\n    \"bytes\"\n    \"fmt\"\n)\n\n// Strings in Go allow arbitrary bytes.  They are implemented basically as\n// immutable byte slices and syntactic sugar.  This program shows functions\n// required by the task on byte slices, thus it mostly highlights what\n// happens behind the syntactic sugar.  The program does not attempt to\n// reproduce the immutability property of strings, as that does not seem\n// to be the intent of the task.\n\nfunc main() {\n    // Task point: String creation and destruction.\n    // Strings are most often constructed from literals as in s := \"binary\"\n    // With byte slices,\n    b := []byte{'b', 'i', 'n', 'a', 'r', 'y'}\n    fmt.Println(b) // output shows numeric form of bytes.\n    // Go is garbage collected.  There are no destruction operations.\n\n    // Task point: String assignment.\n    // t = s assigns strings.  Since strings are immutable, it is irrelevant\n    // whether the string is copied or not.\n    // With byte slices, the same works,\n    var c []byte\n    c = b\n    fmt.Println(c)\n\n    // Task point: String comparison.\n    // operators <, <=, ==, >=, and > work directly on strings comparing them\n    // by lexicographic order.\n    // With byte slices, there are standard library functions, bytes.Equal\n    // and bytes.Compare.\n    fmt.Println(bytes.Equal(b, c)) // prints true\n\n    // Task point: String cloning and copying.\n    // The immutable property of Go strings makes cloning and copying\n    // meaningless for strings.\n    // With byte slices though, it is relevant.  The assignment c = b shown\n    // above does a reference copy, leaving both c and b based on the same\n    // underlying data.  To clone or copy the underlying data,\n    d := make([]byte, len(b)) // allocate new space\n    copy(d, b)                // copy the data\n    // The data can be manipulated independently now:\n    d[1] = 'a'\n    d[4] = 'n'\n    fmt.Println(string(b)) // convert to string for readable output\n    fmt.Println(string(d))\n\n    // Task point: Check if a string is empty.\n    // Most typical for strings is s == \"\", but len(s) == 0 works too.\n    // For byte slices, \"\" does not work, len(b) == 0 is correct.\n    fmt.Println(len(b) == 0)\n\n    // Task point: Append a byte to a string.\n    // The language does not provide a way to do this directly with strings.\n    // Instead, the byte must be converted to a one-byte string first, as in,\n    // s += string('z')\n    // For byte slices, the language provides the append function,\n    z := append(b, 'z')\n    fmt.Printf(\"%s\\n\", z) // another way to get readable output\n\n    // Task point: Extract a substring from a string.\n    // Slicing syntax is the for both strings and slices.\n    sub := b[1:3]\n    fmt.Println(string(sub))\n\n    // Task point: Replace every occurrence of a byte (or a string)\n    // in a string with another string.\n    // Go supports this with similar library functions for strings and\n    // byte slices.  Strings:  t = strings.Replace(s, \"n\", \"m\", -1).\n    // The byte slice equivalent returns a modified copy, leaving the\n    // original byte slice untouched,\n    f := bytes.Replace(d, []byte{'n'}, []byte{'m'}, -1)\n    fmt.Printf(\"%s -> %s\\n\", d, f)\n\n    // Task point: Join strings.\n    // Using slicing syntax again, with strings,\n    // rem := s[:1] + s[3:] leaves rem == \"bary\".\n    // Only the concatenation of the parts is different with byte slices,\n    rem := append(append([]byte{}, b[:1]...), b[3:]...)\n    fmt.Println(string(rem))\n}\n"
                }
            ],
            [
                {
                    "language": "Python",
                    "solution": "v1 = \"hello\"\nv2 = \"world\"\nmsg = v1 + \" \" + v2\n"
                },
                {
                    "language": "PARI-GP",
                    "solution": "cmp_str(u,v)=u==v\ncopy_str(v)=v \\\\ Creates a copy, not a pointer\nappend_str(v,n)=concat(v,n)\nreplace_str(source, n, replacement)=my(v=[]);for(i=1,#source,v=concat(v,if(source[i]==n,replacement,source[i]))); v\n\nu=[72, 101, 108, 108, 111, 44, 32, 119, 111, 114, 108, 100];\nv=[];\ncmp_str(u,v)\nw=copy_str(v)\n#w==0\nappend_str(u,33)\nu[8..12]\nreplace_str(u,108,[121])\nconcat(v,w)\n"
                }
            ],
            [
                {
                    "language": "Go",
                    "solution": "package main\n\nimport (\n    \"bytes\"\n    \"fmt\"\n)\n\n// Strings in Go allow arbitrary bytes.  They are implemented basically as\n// immutable byte slices and syntactic sugar.  This program shows functions\n// required by the task on byte slices, thus it mostly highlights what\n// happens behind the syntactic sugar.  The program does not attempt to\n// reproduce the immutability property of strings, as that does not seem\n// to be the intent of the task.\n\nfunc main() {\n    // Task point: String creation and destruction.\n    // Strings are most often constructed from literals as in s := \"binary\"\n    // With byte slices,\n    b := []byte{'b', 'i', 'n', 'a', 'r', 'y'}\n    fmt.Println(b) // output shows numeric form of bytes.\n    // Go is garbage collected.  There are no destruction operations.\n\n    // Task point: String assignment.\n    // t = s assigns strings.  Since strings are immutable, it is irrelevant\n    // whether the string is copied or not.\n    // With byte slices, the same works,\n    var c []byte\n    c = b\n    fmt.Println(c)\n\n    // Task point: String comparison.\n    // operators <, <=, ==, >=, and > work directly on strings comparing them\n    // by lexicographic order.\n    // With byte slices, there are standard library functions, bytes.Equal\n    // and bytes.Compare.\n    fmt.Println(bytes.Equal(b, c)) // prints true\n\n    // Task point: String cloning and copying.\n    // The immutable property of Go strings makes cloning and copying\n    // meaningless for strings.\n    // With byte slices though, it is relevant.  The assignment c = b shown\n    // above does a reference copy, leaving both c and b based on the same\n    // underlying data.  To clone or copy the underlying data,\n    d := make([]byte, len(b)) // allocate new space\n    copy(d, b)                // copy the data\n    // The data can be manipulated independently now:\n    d[1] = 'a'\n    d[4] = 'n'\n    fmt.Println(string(b)) // convert to string for readable output\n    fmt.Println(string(d))\n\n    // Task point: Check if a string is empty.\n    // Most typical for strings is s == \"\", but len(s) == 0 works too.\n    // For byte slices, \"\" does not work, len(b) == 0 is correct.\n    fmt.Println(len(b) == 0)\n\n    // Task point: Append a byte to a string.\n    // The language does not provide a way to do this directly with strings.\n    // Instead, the byte must be converted to a one-byte string first, as in,\n    // s += string('z')\n    // For byte slices, the language provides the append function,\n    z := append(b, 'z')\n    fmt.Printf(\"%s\\n\", z) // another way to get readable output\n\n    // Task point: Extract a substring from a string.\n    // Slicing syntax is the for both strings and slices.\n    sub := b[1:3]\n    fmt.Println(string(sub))\n\n    // Task point: Replace every occurrence of a byte (or a string)\n    // in a string with another string.\n    // Go supports this with similar library functions for strings and\n    // byte slices.  Strings:  t = strings.Replace(s, \"n\", \"m\", -1).\n    // The byte slice equivalent returns a modified copy, leaving the\n    // original byte slice untouched,\n    f := bytes.Replace(d, []byte{'n'}, []byte{'m'}, -1)\n    fmt.Printf(\"%s -> %s\\n\", d, f)\n\n    // Task point: Join strings.\n    // Using slicing syntax again, with strings,\n    // rem := s[:1] + s[3:] leaves rem == \"bary\".\n    // Only the concatenation of the parts is different with byte slices,\n    rem := append(append([]byte{}, b[:1]...), b[3:]...)\n    fmt.Println(string(rem))\n}\n"
                },
                {
                    "language": "Common-Lisp",
                    "solution": "\"string\"\n(coerce '(#\\s #\\t #\\r #\\i #\\n #\\g) 'string)\n"
                }
            ],
            [
                {
                    "language": "Run-BASIC",
                    "solution": "' Create string\ns$ = \"Hello, world\"\n\n' String destruction\ns$ = \"\"\n\n' String comparison\nIf s$ = \"Hello, world\" then print \"Equal String\"\n\n' Copying string\na$ = s$\n\n' Check If empty\nIf s$ = \"\" then print \"String is MT\"\n\n' Append a byte\ns$ = s$ + Chr$(65)\n\n' Extract a substring\na$ = Mid$(s$, 1, 5)   ' bytes 1 -> 5\n\n'substitute string \"world\" with \"universe\"\na$ = \"Hello, world\"\nfor i = 1 to len(a$)\n    if mid$(a$,i,5)=\"world\" then\n        a$=left$(a$,i-1)+\"universe\"+mid$(a$,i+5)\n    end if\nnext\nprint a$\n\n'join strings\ns$ = \"See \" + \"you \" + \"later.\"\nprint s$\n"
                },
                {
                    "language": "OCaml",
                    "solution": "# String.copy str ;;\n- : string = \"Some text\"\n"
                }
            ],
            [
                {
                    "language": "Pascal",
                    "solution": "const\n  greeting = 'Hello';\nvar\n  s1: string;\n  s2: ansistring;\n  s3: pchar;\nbegin\n{ Assignments }\n  s1 := 'Mister Presiden';  (* typo is on purpose. See below! *)\n{ Comparisons }\n  if s2 > 'a' then\n    writeln ('The first letter of ', s1, ' is later than a');\n{ Cloning and copying }\n  s2 := greeting;\n{ Check if a string is empty }\n  if s1 = '' then\n    writeln('This string is empty!');\n{ Append a byte to a string }\n  s1 := s1 + 't';\n{ Extract a substring from a string }\n  s3 := copy(S2, 2, 4);  (* s3 receives ello *)\n{ String replacement }  (* the unit StrUtils of the FreePascal rtl has AnsiReplaceStr *)\n  s1 := AnsiReplaceStr('Thees ees a text weeth typos', 'ee', 'i');\n{ Join strings}\n  s3 := greeting + ' and how are you, ' + s1 + '?';\nend.\n"
                },
                {
                    "language": "BBC-BASIC",
                    "solution": "      A$ = CHR$(0) + CHR$(1) + CHR$(254) + CHR$(255) : REM assignment\n      B$ = A$                                        : REM clone / copy\n      IF A$ = B$ THEN PRINT \"Strings are equal\"      : REM comparison\n      IF A$ = \"\" THEN PRINT \"String is empty\"        : REM Check if empty\n      A$ += CHR$(128)                                : REM Append a byte\n      S$ = MID$(A$, S%, L%)                          : REM Extract a substring\n      C$ = A$ + B$                                   : REM Join strings\n\n      REM To replace every occurrence of a byte:\n      old$ = CHR$(1)\n      new$ = CHR$(5)\n      REPEAT\n        I% = INSTR(A$, old$)\n        IF I% MID$(A$, I%, 1) = new$\n      UNTIL I% = 0\n"
                }
            ]
        ]
    },
    {
        "task_name": "Bioinformatics-base-count",
        "task_description": "Given this string representing ordered DNA bases:\n<pre>\nCGTAAAAAATTACAACGTCCTTTGGCTATCTCTTAAACTCCTGCTAAATG\nCTCGTGCTTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTG\nAGGACAAAGGTCAAGATGGAGCGCATCGAACGCAATAAGGATCATTTGAT\nGGGACGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTCTT\nCGATTCTGCTTATAACACTATGTTCTTATGAAATGGATGTTCTGAGTTGG\nTCAGTCCCAATGTGCGGGGTTTCTTTTAGTACGTCGGGAGTGGTATTATA\nTTTAATTTTTCTATATAGCGATCTGTATTTAAGCAATTCATTTAGGTTAT\nCGCCGCGATGCTCGGTTCGGACCGCCAAGCATCTGGCTCCACTGCTAGTG\nTCCTAAATTTGAATGGCAAACACAAATAAGATTTAGCAATTCGTGTAGAC\nGACCGGGGACTTGCATGATGGGAGCAGCTTTGTTAAACTACGAACGTAAT\n</pre>\n\n\n;Task:\n:* &nbsp; \"Pretty print\" the sequence followed by a summary of the counts of each of the bases: &nbsp; ('''A''', '''C''', '''G''', and '''T''') &nbsp; in the sequence \n:* &nbsp; print the total count of each base in the string.\n\n\n{{Template:Strings}}\n<br><br>\n",
        "solution_pairs": [
            [
                {
                    "language": "Java",
                    "solution": "void printBaseCount(String string) throws IOException {\n    BufferedReader reader = new BufferedReader(new StringReader(string));\n    int index = 0;\n    String sequence;\n    int A = 0, C = 0, G = 0, T = 0;\n    int a, c, g, t;\n    while ((sequence = reader.readLine()) != null) {\n        System.out.printf(\"%d %s \", index++, sequence);\n        a = c = g = t = 0;\n        for (char base : sequence.toCharArray()) {\n            switch (base) {\n                case 'A' -> {\n                    A++;\n                    a++;\n                }\n                case 'C' -> {\n                    C++;\n                    c++;\n                }\n                case 'G' -> {\n                    G++;\n                    g++;\n                }\n                case 'T' -> {\n                    T++;\n                    t++;\n                }\n            }\n        }\n        System.out.printf(\"[A %2d, C %2d, G %2d, T %2d]%n\", a, c, g, t);\n    }\n    reader.close();\n    int total = A + C + G + T;\n    System.out.printf(\"%nTotal of %d bases%n\", total);\n    System.out.printf(\"A %3d (%.2f%%)%n\", A, ((double) A / total) * 100);\n    System.out.printf(\"C %3d (%.2f%%)%n\", C, ((double) C / total) * 100);\n    System.out.printf(\"G %3d (%.2f%%)%n\", G, ((double) G / total) * 100);\n    System.out.printf(\"T %3d (%.2f%%)%n\", T, ((double) T / total) * 100);\n}\n"
                },
                {
                    "language": "Ada",
                    "solution": "with Ada.Text_Io;\n\nprocedure Base_Count is\n\n   type Sequence is new String;\n   Test : constant Sequence :=\n     \"CGTAAAAAATTACAACGTCCTTTGGCTATCTCTTAAACTCCTGCTAAATG\" &\n     \"CTCGTGCTTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTG\" &\n     \"AGGACAAAGGTCAAGATGGAGCGCATCGAACGCAATAAGGATCATTTGAT\" &\n     \"GGGACGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTCTT\" &\n     \"CGATTCTGCTTATAACACTATGTTCTTATGAAATGGATGTTCTGAGTTGG\" &\n     \"TCAGTCCCAATGTGCGGGGTTTCTTTTAGTACGTCGGGAGTGGTATTATA\" &\n     \"TTTAATTTTTCTATATAGCGATCTGTATTTAAGCAATTCATTTAGGTTAT\" &\n     \"CGCCGCGATGCTCGGTTCGGACCGCCAAGCATCTGGCTCCACTGCTAGTG\" &\n     \"TCCTAAATTTGAATGGCAAACACAAATAAGATTTAGCAATTCGTGTAGAC\" &\n     \"GACCGGGGACTTGCATGATGGGAGCAGCTTTGTTAAACTACGAACGTAAT\";\n\n   Line_Width : constant := 70;\n\n   procedure Put (Seq : Sequence) is\n      use Ada.Text_Io;\n      package Position_Io is new Ada.Text_Io.Integer_Io (Natural);\n      First : Natural := Seq'First;\n      Last  : Natural;\n   begin\n      loop\n         Last := Natural'Min (Seq'Last, First + Line_Width - 1);\n         Position_Io.Put (First, Width => 3);\n         Put (String'(\"..\"));\n         Position_Io.Put (Last, Width => 3);\n         Put (String'(\"  \"));\n         Put (String (Seq (First .. Last)));\n         New_Line;\n         exit when Last = Seq'Last;\n         First := First + Line_Width;\n      end loop;\n   end Put;\n\n   procedure Count (Seq : Sequence) is\n      use Ada.Text_Io;\n      A_Count, C_Count : Natural := 0;\n      G_Count, T_Count : Natural := 0;\n   begin\n      for B of Seq loop\n         case B is\n            when 'A' =>  A_Count := A_Count + 1;\n            when 'C' =>  C_Count := C_Count + 1;\n            when 'G' =>  G_Count := G_Count + 1;\n            when 'T' =>  T_Count := T_Count + 1;\n            when others =>\n               raise Constraint_Error;\n         end case;\n      end loop;\n      Put_Line (\"A: \" & A_Count'Image);\n      Put_Line (\"C: \" & C_Count'Image);\n      Put_Line (\"G: \" & G_Count'Image);\n      Put_Line (\"T: \" & T_Count'Image);\n      Put_Line (\"Total: \" & Seq'Length'Image);\n   end Count;\n\nbegin\n   Put (Test);\n   Count (Test);\nend Base_Count;\n"
                }
            ],
            [
                {
                    "language": "Java",
                    "solution": "void printBaseCount(String string) throws IOException {\n    BufferedReader reader = new BufferedReader(new StringReader(string));\n    int index = 0;\n    String sequence;\n    int A = 0, C = 0, G = 0, T = 0;\n    int a, c, g, t;\n    while ((sequence = reader.readLine()) != null) {\n        System.out.printf(\"%d %s \", index++, sequence);\n        a = c = g = t = 0;\n        for (char base : sequence.toCharArray()) {\n            switch (base) {\n                case 'A' -> {\n                    A++;\n                    a++;\n                }\n                case 'C' -> {\n                    C++;\n                    c++;\n                }\n                case 'G' -> {\n                    G++;\n                    g++;\n                }\n                case 'T' -> {\n                    T++;\n                    t++;\n                }\n            }\n        }\n        System.out.printf(\"[A %2d, C %2d, G %2d, T %2d]%n\", a, c, g, t);\n    }\n    reader.close();\n    int total = A + C + G + T;\n    System.out.printf(\"%nTotal of %d bases%n\", total);\n    System.out.printf(\"A %3d (%.2f%%)%n\", A, ((double) A / total) * 100);\n    System.out.printf(\"C %3d (%.2f%%)%n\", C, ((double) C / total) * 100);\n    System.out.printf(\"G %3d (%.2f%%)%n\", G, ((double) G / total) * 100);\n    System.out.printf(\"T %3d (%.2f%%)%n\", T, ((double) T / total) * 100);\n}\n"
                },
                {
                    "language": "Forth",
                    "solution": "( Gforth 0.7.3 )\n\n: dnacode s\" CGTAAAAAATTACAACGTCCTTTGGCTATCTCTTAAACTCCTGCTAAATGCTCGTGCTTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTGAGGACAAAGGTCAAGATGGAGCGCATCGAACGCAATAAGGATCATTTGATGGGACGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTCTTCGATTCTGCTTATAACACTATGTTCTTATGAAATGGATGTTCTGAGTTGGTCAGTCCCAATGTGCGGGGTTTCTTTTAGTACGTCGGGAGTGGTATTATATTTAATTTTTCTATATAGCGATCTGTATTTAAGCAATTCATTTAGGTTATCGCCGCGATGCTCGGTTCGGACCGCCAAGCATCTGGCTCCACTGCTAGTGTCCTAAATTTGAATGGCAAACACAAATAAGATTTAGCAATTCGTGTAGACGACCGGGGACTTGCATGATGGGAGCAGCTTTGTTAAACTACGAACGTAAT\" ;\n\nvariable #A \\ Gforth initialises variables to 0\nvariable #C\nvariable #G\nvariable #T\nvariable #ch\n50 constant pplength\n\n: basecount ( adr u -- )\n    .\" Sequence:\"\n    swap dup rot + swap ?do  \\ count while pretty-printing\n        #ch @ pplength mod 0= if cr #ch @ 10 .r 2 spaces then\n        i c@ dup emit\n        dup 'A = if drop #A @ 1+ #A ! else\n        dup 'C = if drop #C @ 1+ #C ! else\n        dup 'G = if drop #G @ 1+ #G ! else\n        dup 'T = if drop #T @ 1+ #T ! else drop then then then then\n        #ch @ 1+ #ch !\n    loop\n    cr cr .\" Base counts:\"\n    cr 4 spaces 'A emit ': emit #A @ 5 .r\n    cr 4 spaces 'C emit ': emit #C @ 5 .r\n    cr 4 spaces 'G emit ': emit #G @ 5 .r\n    cr 4 spaces 'T emit ': emit #T @ 5 .r\n    cr .\"  ----------\"\n    cr .\"   Sum:\"  #ch @ 5 .r\n    cr .\"  ==========\" cr cr\n;\n\n( demo run: )\n\ndnacode basecount\n"
                }
            ],
            [
                {
                    "language": "REXX",
                    "solution": "/*REXX program finds the number of each base in a DNA  string          */\n/*                                         (along with a total).       */\nParse Arg dna .\nIf dna==''|dna==',' Then\n  dna='cgtaaaaaattacaacgtcctttggctatctcttaaactcctgctaaatg',\n      'ctcgtgctttccaattatgtaagcgttccgagacggggtggtcgattctg',\n      'aggacaaaggtcaagatggagcgcatcgaacgcaataaggatcatttgat',\n      'gggacgtttcgtcgacaaagtcttgtttcgagagtaacggctaccgtctt',\n      'cgattctgcttataacactatgttcttatgaaatggatgttctgagttgg',\n      'tcagtcccaatgtgcggggtttcttttagtacgtcgggagtggtattata',\n      'tttaatttttctatatagcgatctgtatttaagcaattcatttaggttat',\n      'cgccgcgatgctcggttcggaccgccaagcatctggctccactgctagtg',\n      'tcctaaatttgaatggcaaacacaaataagatttagcaattcgtgtagac',\n      'gaccggggacttgcatgatgggagcagctttgttaaactacgaacgtaat'\ndna=translate(space(dna,0))          /* elide blanks from DNA; uppercas*/\nSay '--------length of the DNA string: ' length(dna)\ncount.=0                          /* initialize the count for all bases*/\nw=1                               /* the maximum width of a base count */\nnames=''                          /* list of all names                 */\nDo j=1 To length(dna)             /* traipse through the  DNA  string  */\n  name=substr(dna,j,1)            /* obtain a base name from the DNA   */\n  If pos(name,names)==0 Then\n    names=names||name             /* if not found, add it to the list  */\n  count.name=count.name+1         /* bump the count of this base.      */\n  w=max(w,length(count.name))     /* compute the maximum number width  */\n  End\nSay\nDo k=0 To 255\n  z=d2c(k)                        /* traipse through all possibilities */\n  If pos(z,names)>0 Then Do\n    Say '     base ' z ' has a basecount of: ' right(count.z,w)\n    count.tot=count.tot+count.z   /* add to a grand total to verify    */\n    End\n  End\nSay\nSay '--------total for all basecounts:' right(count.tot,w+1)\n"
                },
                {
                    "language": "Ada",
                    "solution": "with Ada.Text_Io;\n\nprocedure Base_Count is\n\n   type Sequence is new String;\n   Test : constant Sequence :=\n     \"CGTAAAAAATTACAACGTCCTTTGGCTATCTCTTAAACTCCTGCTAAATG\" &\n     \"CTCGTGCTTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTG\" &\n     \"AGGACAAAGGTCAAGATGGAGCGCATCGAACGCAATAAGGATCATTTGAT\" &\n     \"GGGACGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTCTT\" &\n     \"CGATTCTGCTTATAACACTATGTTCTTATGAAATGGATGTTCTGAGTTGG\" &\n     \"TCAGTCCCAATGTGCGGGGTTTCTTTTAGTACGTCGGGAGTGGTATTATA\" &\n     \"TTTAATTTTTCTATATAGCGATCTGTATTTAAGCAATTCATTTAGGTTAT\" &\n     \"CGCCGCGATGCTCGGTTCGGACCGCCAAGCATCTGGCTCCACTGCTAGTG\" &\n     \"TCCTAAATTTGAATGGCAAACACAAATAAGATTTAGCAATTCGTGTAGAC\" &\n     \"GACCGGGGACTTGCATGATGGGAGCAGCTTTGTTAAACTACGAACGTAAT\";\n\n   Line_Width : constant := 70;\n\n   procedure Put (Seq : Sequence) is\n      use Ada.Text_Io;\n      package Position_Io is new Ada.Text_Io.Integer_Io (Natural);\n      First : Natural := Seq'First;\n      Last  : Natural;\n   begin\n      loop\n         Last := Natural'Min (Seq'Last, First + Line_Width - 1);\n         Position_Io.Put (First, Width => 3);\n         Put (String'(\"..\"));\n         Position_Io.Put (Last, Width => 3);\n         Put (String'(\"  \"));\n         Put (String (Seq (First .. Last)));\n         New_Line;\n         exit when Last = Seq'Last;\n         First := First + Line_Width;\n      end loop;\n   end Put;\n\n   procedure Count (Seq : Sequence) is\n      use Ada.Text_Io;\n      A_Count, C_Count : Natural := 0;\n      G_Count, T_Count : Natural := 0;\n   begin\n      for B of Seq loop\n         case B is\n            when 'A' =>  A_Count := A_Count + 1;\n            when 'C' =>  C_Count := C_Count + 1;\n            when 'G' =>  G_Count := G_Count + 1;\n            when 'T' =>  T_Count := T_Count + 1;\n            when others =>\n               raise Constraint_Error;\n         end case;\n      end loop;\n      Put_Line (\"A: \" & A_Count'Image);\n      Put_Line (\"C: \" & C_Count'Image);\n      Put_Line (\"G: \" & G_Count'Image);\n      Put_Line (\"T: \" & T_Count'Image);\n      Put_Line (\"Total: \" & Seq'Length'Image);\n   end Count;\n\nbegin\n   Put (Test);\n   Count (Test);\nend Base_Count;\n"
                }
            ],
            [
                {
                    "language": "EasyLang",
                    "solution": "len d[] 26\npos = 1\nnumfmt 0 4\nrepeat\n   s$ = input\n   until s$ = \"\"\n   for c$ in strchars s$\n      if pos mod 40 = 1\n         write pos & \":\"\n      .\n      if pos mod 4 = 1\n         write \" \"\n      .\n      write c$\n      if pos mod 40 = 0\n         print \"\"\n      .\n      pos += 1\n      c = strcode c$\n      d[c - 64] += 1\n   .\n.\nprint \"\"\nfor i in [ 1 3 7 20 ]\n   write strchar (64 + i) & \": \"\n   print d[i]\n.\nprint \"Total: \" & d[1] + d[3] + d[7] + d[20]\ninput_data\nCGTAAAAAATTACAACGTCCTTTGGCTATCTCTTAAACTCCTGCTAAATG\nCTCGTGCTTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTG\nAGGACAAAGGTCAAGATGGAGCGCATCGAACGCAATAAGGATCATTTGAT\nGGGACGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTCTT\nCGATTCTGCTTATAACACTATGTTCTTATGAAATGGATGTTCTGAGTTGG\nTCAGTCCCAATGTGCGGGGTTTCTTTTAGTACGTCGGGAGTGGTATTATA\nTTTAATTTTTCTATATAGCGATCTGTATTTAAGCAATTCATTTAGGTTAT\nCGCCGCGATGCTCGGTTCGGACCGCCAAGCATCTGGCTCCACTGCTAGTG\nTCCTAAATTTGAATGGCAAACACAAATAAGATTTAGCAATTCGTGTAGAC\nGACCGGGGACTTGCATGATGGGAGCAGCTTTGTTAAACTACGAACGTAAT\n"
                },
                {
                    "language": "Jq",
                    "solution": "def lpad($len; $fill): tostring | ($len - length) as $l | ($fill * $l)[:$l] + .;\n\n# \"bow\" = bag of words, i.e. a JSON object with counts\n# Input: a bow or null\n# Output: augmented bow\ndef bow(stream):\n  reduce stream as $word (.; .[($word|tostring)] += 1);\n\n# The main function ignores its input in favor of `stream`:\ndef report(stream; $cols):\n\n  # input: a string, possibly longer than $cols\n  def pp_sequence($start):\n  range(0; length / $cols) as $i\n    | \"\\($start + ($i*$cols) | lpad(5; \" \")): \" +  .[ $i * $cols : ($i+1) * $cols] ;\n\n  # input: a bow\n  def pp_counts:\n    \"BASE COUNTS:\",\n     (to_entries | sort[] | \"    \\(.key):  \\(.value | lpad(6;\" \"))\"),\n     \"Total: \\( [.[]] | add | lpad(7;\" \"))\" ;\n\n  # state: {bow, emit, pending, start}\n  foreach (stream,null) as $line ({start: - $cols};\n    .start += $cols\n    | if $line == null\n      then .emit = .pending\n      else .bow |= bow(range(0; $line|length) | $line[.:.+1])\n      | (($line|length) + (.pending|length) ) as $len\n      | if $len >= $cols\n        then (.pending + $line) as $new\n        | .emit = $new[:$cols]\n        | .pending = $new[$cols:]\n        else .pending = $line\n        end\n      end;\n    (select(.emit|length > 0) | .start as $start | .emit | pp_sequence($start)),\n    (select($line == null) | \"\", (.bow|pp_counts) ) )\n    ;\n\n# To illustrate reformatting:\nreport(inputs; 33)\n"
                }
            ],
            [
                {
                    "language": "Ring",
                    "solution": "dna = \"\" +\n      \"CGTAAAAAATTACAACGTCCTTTGGCTATCTCTTAAACTCCTGCTAAATG\" +\n      \"CTCGTGCTTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTG\" +\n      \"AGGACAAAGGTCAAGATGGAGCGCATCGAACGCAATAAGGATCATTTGAT\" +\n      \"GGGACGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTCTT\" +\n      \"CGATTCTGCTTATAACACTATGTTCTTATGAAATGGATGTTCTGAGTTGG\" +\n      \"TCAGTCCCAATGTGCGGGGTTTCTTTTAGTACGTCGGGAGTGGTATTATA\" +\n      \"TTTAATTTTTCTATATAGCGATCTGTATTTAAGCAATTCATTTAGGTTAT\" +\n      \"CGCCGCGATGCTCGGTTCGGACCGCCAAGCATCTGGCTCCACTGCTAGTG\" +\n      \"TCCTAAATTTGAATGGCAAACACAAATAAGATTTAGCAATTCGTGTAGAC\" +\n      \"GACCGGGGACTTGCATGATGGGAGCAGCTTTGTTAAACTACGAACGTAAT\"\n\ndnaBase = [:A=0, :C=0, :G=0, :T=0]\nlenDna = len(dna)\nfor n = 1 to lenDna\n    dnaStr = substr(dna,n,1)\n    switch dnaStr\n           on \"A\"\n              strA = dnaBase[\"A\"]\n              strA++\n              dnaBase[\"A\"] = strA\n           on \"C\"\n              strC = dnaBase[\"C\"]\n              strC++\n              dnaBase[\"C\"] = strC\n           on \"G\"\n              strG = dnaBase[\"G\"]\n              strG++\n              dnaBase[\"G\"] = strG\n           on \"T\"\n              strT = dnaBase[\"T\"]\n              strT++\n              dnaBase[\"T\"] = strT\n     off\nnext\n? \"A : \" + dnaBase[\"A\"]\n? \"T : \" + dnaBase[\"T\"]\n? \"C : \" + dnaBase[\"C\"]\n? \"G : \" + dnaBase[\"G\"]\n"
                },
                {
                    "language": "Swift",
                    "solution": "import Foundation\n\nlet dna = \"\"\"\n          CGTAAAAAATTACAACGTCCTTTGGCTATCTCTTAAACTCCTGCTAAATG\n          CTCGTGCTTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTG\n          AGGACAAAGGTCAAGATGGAGCGCATCGAACGCAATAAGGATCATTTGAT\n          GGGACGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTCTT\n          CGATTCTGCTTATAACACTATGTTCTTATGAAATGGATGTTCTGAGTTGG\n          TCAGTCCCAATGTGCGGGGTTTCTTTTAGTACGTCGGGAGTGGTATTATA\n          TTTAATTTTTCTATATAGCGATCTGTATTTAAGCAATTCATTTAGGTTAT\n          CGCCGCGATGCTCGGTTCGGACCGCCAAGCATCTGGCTCCACTGCTAGTG\n          TCCTAAATTTGAATGGCAAACACAAATAAGATTTAGCAATTCGTGTAGAC\n          GACCGGGGACTTGCATGATGGGAGCAGCTTTGTTAAACTACGAACGTAAT\n          \"\"\"\n\nprint(\"input:\\n\\(dna)\\n\")\n\nlet counts =\n  dna.replacingOccurrences(of: \"\\n\", with: \"\").reduce(into: [:], { $0[$1, default: 0] += 1 })\n\nprint(\"Counts: \\(counts)\")\nprint(\"Total: \\(counts.values.reduce(0, +))\")\n"
                }
            ]
        ]
    }
]